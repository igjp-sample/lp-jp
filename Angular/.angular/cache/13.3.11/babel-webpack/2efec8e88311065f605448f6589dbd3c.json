{"ast":null,"code":"import * as i1 from '@angular/animations';\nimport { style, animate, animation, keyframes, useAnimation, trigger, transition } from '@angular/animations';\nimport * as i0 from '@angular/core';\nimport { Injectable, Directive, Input, HostListener, NgModule, isDevMode, PLATFORM_ID, Inject, EventEmitter, ElementRef, Optional, Output, HostBinding, InjectionToken, Component, ViewContainerRef, ViewChild, ContentChildren, forwardRef, ContentChild, Self, SecurityContext, TemplateRef, Pipe, LOCALE_ID, QueryList, ViewChildren, Host, ChangeDetectionStrategy, inject, SkipSelf, SimpleChange, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';\nimport * as i12 from '@angular/forms';\nimport { NgModel, FormControlName, NG_VALUE_ACCESSOR, NG_VALIDATORS, CheckboxRequiredValidator, FormsModule, NgControl, ReactiveFormsModule } from '@angular/forms';\nimport * as i4 from '@angular/common';\nimport { isPlatformBrowser, formatDate as formatDate$1, CurrencyPipe, formatPercent, formatNumber, getLocaleCurrencyCode, DatePipe, DOCUMENT, CommonModule, FormatWidth, getLocaleDateFormat, getLocaleNumberFormat, NumberFormatStyle, getCurrencySymbol } from '@angular/common';\nimport { Observable, Subject, fromEvent, interval, animationFrameScheduler, noop, merge, Subscription, timer, pipe } from 'rxjs';\nimport { takeUntil, filter, first as first$1, throttleTime, take, throttle, debounce, tap, switchMap, skipLast, map, debounceTime, shareReplay, takeWhile, delay, pluck } from 'rxjs/operators';\nimport mergeWith from 'lodash.mergewith';\nimport { __awaiter, __decorate, __param } from 'tslib';\nimport * as JSZip from 'jszip';\nimport * as i1$1 from '@angular/platform-browser';\nimport { HammerGestureConfig, HAMMER_GESTURE_CONFIG, ɵgetDOM } from '@angular/platform-browser';\nimport * as i2 from '@angular/common/http';\nimport { addRow, addChild, pinLeft, unpinLeft, jumpDown, jumpUp, caseSensitive, editor } from '@igniteui/material-icons-extended';\nimport 'igniteui-trial-watermark';\nimport { v4 } from 'uuid';\nconst _c0 = [[[\"igx-drop-down-item\"]]];\nconst _c1 = [\"igx-drop-down-item\"];\nconst _c2 = [[[\"igx-prefix\"], [\"\", \"igxPrefix\", \"\"]], \"*\", [[\"igx-suffix\"], [\"\", \"igxSuffix\", \"\"]], [[\"igx-divider\"]]];\nconst _c3 = [\"igx-prefix, [igxPrefix]\", \"*\", \"igx-suffix, [igxSuffix]\", \"igx-divider\"];\nconst _c4 = [\"display_container\"];\n\nfunction DisplayContainerComponent_ng_template_0_Template(rf, ctx) {}\n\nconst _c5 = [\"horizontal_container\"];\nconst _c6 = [\"container\"];\nconst _c7 = [\"scrollContainer\"];\n\nfunction IgxDropDownComponent_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵprojection(1);\n    i0.ɵɵelementContainerEnd();\n  }\n}\n\nconst _c8 = [\"*\"];\nconst _c9 = [\"noLigature\"];\nconst _c10 = [\"explicitLigature\"];\nconst _c11 = [\"svgImage\"];\n\nfunction IgxIconComponent_ng_template_0_Template(rf, ctx) {}\n\nfunction IgxIconComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0);\n  }\n}\n\nfunction IgxIconComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 4);\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"innerHTML\", ctx_r5.getSvg, i0.ɵɵsanitizeHtml);\n  }\n}\n\nfunction IgxIconComponent_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_div_0_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 14);\n    i0.ɵɵtemplate(1, IgxInputGroupComponent_div_0_ng_container_1_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r22 = i0.ɵɵreference(25);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r22);\n  }\n}\n\nfunction IgxInputGroupComponent_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 16);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 1);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 2);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 3);\n  }\n}\n\nconst _c12 = function (a0) {\n  return {\n    \"igx-input-group__upload-button\": a0\n  };\n};\n\nfunction IgxInputGroupComponent_ng_template_10_igx_prefix_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r27 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-prefix\", 18)(1, \"button\", 19);\n    i0.ɵɵlistener(\"click\", function IgxInputGroupComponent_ng_template_10_igx_prefix_0_Template_button_click_1_listener() {\n      i0.ɵɵrestoreView(_r27);\n      const ctx_r26 = i0.ɵɵnextContext(2);\n      return ctx_r26.uploadButtonHandler();\n    });\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r25 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r25.displayDensity)(\"disabled\", ctx_r25.disabled)(\"ngClass\", i0.ɵɵpureFunction1(4, _c12, ctx_r25.isTypeLine));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r25.resourceStrings.igx_input_upload_button, \" \");\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxInputGroupComponent_ng_template_10_igx_prefix_0_Template, 3, 6, \"igx-prefix\", 17);\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r9.isFileType);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_12_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 21)(1, \"span\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r28 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"title\", ctx_r28.fileNames);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r28.fileNames);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_12_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxInputGroupComponent_ng_template_12_div_0_Template, 3, 2, \"div\", 20);\n  }\n\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r11.isFileType);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_14_igx_suffix_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r31 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-suffix\", 23);\n    i0.ɵɵlistener(\"click\", function IgxInputGroupComponent_ng_template_14_igx_suffix_0_Template_igx_suffix_click_0_listener() {\n      i0.ɵɵrestoreView(_r31);\n      const ctx_r30 = i0.ɵɵnextContext(2);\n      return ctx_r30.clearValueHandler();\n    })(\"keydown.Enter\", function IgxInputGroupComponent_ng_template_14_igx_suffix_0_Template_igx_suffix_keydown_Enter_0_listener() {\n      i0.ɵɵrestoreView(_r31);\n      const ctx_r32 = i0.ɵɵnextContext(2);\n      return ctx_r32.clearValueHandler();\n    });\n    i0.ɵɵelementStart(1, \"igx-icon\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r29 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r29.resourceStrings.igx_input_clear_button);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_14_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxInputGroupComponent_ng_template_14_igx_suffix_0_Template, 3, 1, \"igx-suffix\", 22);\n  }\n\n  if (rf & 2) {\n    const ctx_r13 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r13.isFileType && ctx_r13.isFilled);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_16_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 4);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_18_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_18_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_18_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_18_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_18_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_18_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_18_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_18_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 24);\n    i0.ɵɵtemplate(1, IgxInputGroupComponent_ng_template_18_ng_container_1_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(2, IgxInputGroupComponent_ng_template_18_ng_container_2_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementStart(3, \"div\", 25);\n    i0.ɵɵtemplate(4, IgxInputGroupComponent_ng_template_18_ng_container_4_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(5, IgxInputGroupComponent_ng_template_18_ng_container_5_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(6, IgxInputGroupComponent_ng_template_18_ng_container_6_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(7, IgxInputGroupComponent_ng_template_18_ng_container_7_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(8, IgxInputGroupComponent_ng_template_18_ng_container_8_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r6 = i0.ɵɵreference(9);\n\n    const _r8 = i0.ɵɵreference(11);\n\n    const _r2 = i0.ɵɵreference(5);\n\n    const _r4 = i0.ɵɵreference(7);\n\n    const _r10 = i0.ɵɵreference(13);\n\n    const _r12 = i0.ɵɵreference(15);\n\n    const _r14 = i0.ɵɵreference(17);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r6);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r8);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r10);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r12);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r14);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_20_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_20_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_20_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_20_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_20_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_20_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_20_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_20_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxInputGroupComponent_ng_template_20_ng_container_0_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementStart(1, \"div\", 24);\n    i0.ɵɵtemplate(2, IgxInputGroupComponent_ng_template_20_ng_container_2_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(3, IgxInputGroupComponent_ng_template_20_ng_container_3_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementStart(4, \"div\", 25);\n    i0.ɵɵtemplate(5, IgxInputGroupComponent_ng_template_20_ng_container_5_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(6, IgxInputGroupComponent_ng_template_20_ng_container_6_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(7, IgxInputGroupComponent_ng_template_20_ng_container_7_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(8, IgxInputGroupComponent_ng_template_20_ng_container_8_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r2 = i0.ɵɵreference(5);\n\n    const _r6 = i0.ɵɵreference(9);\n\n    const _r8 = i0.ɵɵreference(11);\n\n    const _r4 = i0.ɵɵreference(7);\n\n    const _r10 = i0.ɵɵreference(13);\n\n    const _r12 = i0.ɵɵreference(15);\n\n    const _r14 = i0.ɵɵreference(17);\n\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r6);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r8);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r10);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r12);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r14);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_22_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_22_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_22_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_22_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_22_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_22_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_22_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_22_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxInputGroupComponent_ng_template_22_ng_container_0_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementStart(1, \"div\", 24);\n    i0.ɵɵtemplate(2, IgxInputGroupComponent_ng_template_22_ng_container_2_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(3, IgxInputGroupComponent_ng_template_22_ng_container_3_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(4, IgxInputGroupComponent_ng_template_22_ng_container_4_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(5, IgxInputGroupComponent_ng_template_22_ng_container_5_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(6, IgxInputGroupComponent_ng_template_22_ng_container_6_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(7, IgxInputGroupComponent_ng_template_22_ng_container_7_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r2 = i0.ɵɵreference(5);\n\n    const _r6 = i0.ɵɵreference(9);\n\n    const _r8 = i0.ɵɵreference(11);\n\n    const _r4 = i0.ɵɵreference(7);\n\n    const _r10 = i0.ɵɵreference(13);\n\n    const _r12 = i0.ɵɵreference(15);\n\n    const _r14 = i0.ɵɵreference(17);\n\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r6);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r8);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r10);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r12);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r14);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_24_ng_container_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_24_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxInputGroupComponent_ng_template_24_ng_container_1_ng_container_1_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n\n    const _r20 = i0.ɵɵreference(23);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r20);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_24_ng_container_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_24_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxInputGroupComponent_ng_template_24_ng_container_2_ng_container_1_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n\n    const _r18 = i0.ɵɵreference(21);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r18);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_24_ng_container_3_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_24_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxInputGroupComponent_ng_template_24_ng_container_3_ng_container_1_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n\n    const _r18 = i0.ɵɵreference(21);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r18);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_24_ng_container_4_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_24_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxInputGroupComponent_ng_template_24_ng_container_4_ng_container_1_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n\n    const _r16 = i0.ɵɵreference(19);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r16);\n  }\n}\n\nfunction IgxInputGroupComponent_ng_template_24_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0, 26);\n    i0.ɵɵtemplate(1, IgxInputGroupComponent_ng_template_24_ng_container_1_Template, 2, 1, \"ng-container\", 27);\n    i0.ɵɵtemplate(2, IgxInputGroupComponent_ng_template_24_ng_container_2_Template, 2, 1, \"ng-container\", 27);\n    i0.ɵɵtemplate(3, IgxInputGroupComponent_ng_template_24_ng_container_3_Template, 2, 1, \"ng-container\", 27);\n    i0.ɵɵtemplate(4, IgxInputGroupComponent_ng_template_24_ng_container_4_Template, 2, 1, \"ng-container\", 28);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r23 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngSwitch\", ctx_r23.theme);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", \"bootstrap\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", \"fluent\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", \"indigo-design\");\n  }\n}\n\nconst _c13 = [[[\"igx-hint\"], [\"\", \"igxHint\", \"\"]], [[\"\", \"igxLabel\", \"\"]], [[\"\", \"igxInput\", \"\"]], [[\"igx-prefix\"], [\"\", \"igxPrefix\", \"\"]], [[\"igx-suffix\"], [\"\", \"igxSuffix\", \"\"]]];\nconst _c14 = [\"igx-hint, [igxHint]\", \"[igxLabel]\", \"[igxInput]\", \"igx-prefix, [igxPrefix]\", \"igx-suffix, [igxSuffix]\"];\nconst _c15 = [\"radio\"];\nconst _c16 = [\"nativeLabel\"];\nconst _c17 = [\"placeholderLabel\"];\nconst _c18 = [\"menuItemTemplate\"];\n\nfunction IgxGridActionButtonComponent_ng_container_0_igx_icon_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\", 4);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"family\", ctx_r3.iconSet)(\"name\", ctx_r3.iconName);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r3.iconName);\n  }\n}\n\nfunction IgxGridActionButtonComponent_ng_container_0_igx_icon_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r4.iconName);\n  }\n}\n\nfunction IgxGridActionButtonComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"button\", 2);\n    i0.ɵɵlistener(\"click\", function IgxGridActionButtonComponent_ng_container_0_Template_button_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return ctx_r5.handleClick($event);\n    })(\"mousedown\", function IgxGridActionButtonComponent_ng_container_0_Template_button_mousedown_1_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return ctx_r7.preventEvent($event);\n    });\n    i0.ɵɵtemplate(2, IgxGridActionButtonComponent_ng_container_0_igx_icon_2_Template, 2, 3, \"igx-icon\", 3);\n    i0.ɵɵtemplate(3, IgxGridActionButtonComponent_ng_container_0_igx_icon_3_Template, 2, 1, \"igx-icon\", 0);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"title\", ctx_r0.labelText);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.iconSet);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.iconSet);\n  }\n}\n\nfunction IgxGridActionButtonComponent_ng_template_1_ng_container_0_igx_icon_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\", 4);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r10 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"family\", ctx_r10.iconSet)(\"name\", ctx_r10.iconName);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r10.iconName);\n  }\n}\n\nfunction IgxGridActionButtonComponent_ng_template_1_ng_container_0_igx_icon_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r11.iconName);\n  }\n}\n\nfunction IgxGridActionButtonComponent_ng_template_1_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 5, 6);\n    i0.ɵɵtemplate(3, IgxGridActionButtonComponent_ng_template_1_ng_container_0_igx_icon_3_Template, 2, 3, \"igx-icon\", 3);\n    i0.ɵɵtemplate(4, IgxGridActionButtonComponent_ng_template_1_ng_container_0_igx_icon_4_Template, 2, 1, \"igx-icon\", 0);\n    i0.ɵɵelementStart(5, \"label\", 7);\n    i0.ɵɵtext(6);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"className\", ctx_r8.containerClass);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r8.iconSet);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r8.iconSet);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r8.labelText);\n  }\n}\n\nfunction IgxGridActionButtonComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxGridActionButtonComponent_ng_template_1_ng_container_0_Template, 7, 4, \"ng-container\", 0);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.asMenuItem);\n  }\n}\n\nconst _c19 = [\"checkbox\"];\nconst _c20 = [\"label\"];\nconst _c21 = [\"igxDirRef\"];\nconst _c22 = [\"cell\"];\n\nfunction IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-grid-action-button\", 5);\n    i0.ɵɵlistener(\"actionClick\", function IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_1_Template_igx_grid_action_button_actionClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext(2);\n      return ctx_r5.startEdit($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"asMenuItem\", ctx_r1.asMenuItems)(\"labelText\", ctx_r1.grid.resourceStrings.igx_grid_actions_edit_label);\n  }\n}\n\nfunction IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-grid-action-button\", 6);\n    i0.ɵɵlistener(\"actionClick\", function IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_2_Template_igx_grid_action_button_actionClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext(2);\n      return ctx_r7.addRowHandler($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"asMenuItem\", ctx_r2.asMenuItems)(\"labelText\", ctx_r2.grid.resourceStrings.igx_grid_actions_add_label);\n  }\n}\n\nfunction IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-grid-action-button\", 7);\n    i0.ɵɵlistener(\"actionClick\", function IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_3_Template_igx_grid_action_button_actionClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r9 = i0.ɵɵnextContext(2);\n      return ctx_r9.addRowHandler($event, true);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"asMenuItem\", ctx_r3.asMenuItems)(\"labelText\", ctx_r3.grid.resourceStrings.igx_grid_actions_add_child_label);\n  }\n}\n\nfunction IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-grid-action-button\", 8);\n    i0.ɵɵlistener(\"actionClick\", function IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_4_Template_igx_grid_action_button_actionClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r11 = i0.ɵɵnextContext(2);\n      return ctx_r11.deleteRow($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"asMenuItem\", ctx_r4.asMenuItems)(\"labelText\", ctx_r4.grid.resourceStrings.igx_grid_actions_delete_label);\n  }\n}\n\nfunction IgxGridEditingActionsComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_1_Template, 1, 2, \"igx-grid-action-button\", 1);\n    i0.ɵɵtemplate(2, IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_2_Template, 1, 2, \"igx-grid-action-button\", 2);\n    i0.ɵɵtemplate(3, IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_3_Template, 1, 2, \"igx-grid-action-button\", 3);\n    i0.ɵɵtemplate(4, IgxGridEditingActionsComponent_ng_container_0_igx_grid_action_button_4_Template, 1, 2, \"igx-grid-action-button\", 4);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.disabled);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.addRow && ctx_r0.isRootRow);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.addChild && ctx_r0.hasChildren);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.disabled);\n  }\n}\n\nfunction IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-grid-action-button\", 5);\n    i0.ɵɵlistener(\"actionClick\", function IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_1_Template_igx_grid_action_button_actionClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext(2);\n      return ctx_r5.scrollToRow($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"asMenuItem\", ctx_r1.asMenuItems)(\"labelText\", ctx_r1.grid.resourceStrings.igx_grid_actions_jumpDown_label);\n  }\n}\n\nfunction IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-grid-action-button\", 6);\n    i0.ɵɵlistener(\"actionClick\", function IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_2_Template_igx_grid_action_button_actionClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext(2);\n      return ctx_r7.scrollToRow($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"asMenuItem\", ctx_r2.asMenuItems)(\"labelText\", ctx_r2.grid.resourceStrings.igx_grid_actions_jumpUp_label);\n  }\n}\n\nfunction IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-grid-action-button\", 7);\n    i0.ɵɵlistener(\"actionClick\", function IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_3_Template_igx_grid_action_button_actionClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r9 = i0.ɵɵnextContext(2);\n      return ctx_r9.pin($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"asMenuItem\", ctx_r3.asMenuItems)(\"labelText\", ctx_r3.grid.resourceStrings.igx_grid_actions_pin_label);\n  }\n}\n\nfunction IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-grid-action-button\", 8);\n    i0.ɵɵlistener(\"actionClick\", function IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_4_Template_igx_grid_action_button_actionClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r11 = i0.ɵɵnextContext(2);\n      return ctx_r11.unpin($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"asMenuItem\", ctx_r4.asMenuItems)(\"labelText\", ctx_r4.grid.resourceStrings.igx_grid_actions_unpin_label);\n  }\n}\n\nfunction IgxGridPinningActionsComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_1_Template, 1, 2, \"igx-grid-action-button\", 1);\n    i0.ɵɵtemplate(2, IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_2_Template, 1, 2, \"igx-grid-action-button\", 2);\n    i0.ɵɵtemplate(3, IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_3_Template, 1, 2, \"igx-grid-action-button\", 3);\n    i0.ɵɵtemplate(4, IgxGridPinningActionsComponent_ng_container_0_igx_grid_action_button_4_Template, 1, 2, \"igx-grid-action-button\", 4);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.inPinnedArea && ctx_r0.pinnedTop);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.inPinnedArea && !ctx_r0.pinnedTop);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.pinned);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.pinned);\n  }\n}\n\nconst _c23 = [\"dropdown\"];\n\nfunction IgxActionStripComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"button\", 5);\n    i0.ɵɵlistener(\"click\", function IgxActionStripComponent_ng_container_2_Template_button_click_1_listener($event) {\n      return $event.stopPropagation();\n    });\n    i0.ɵɵelementStart(2, \"igx-icon\");\n    i0.ɵɵtext(3, \"more_vert\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n\n    const _r1 = i0.ɵɵreference(4);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"igxToggleAction\", _r1)(\"overlaySettings\", ctx_r0.menuOverlaySettings)(\"title\", ctx_r0.resourceStrings.igx_action_strip_button_more_title)(\"igxDropDownItemNavigation\", _r1);\n  }\n}\n\nfunction IgxActionStripComponent_igx_drop_down_item_5_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nconst _c24 = function (a0) {\n  return {\n    $implicit: a0\n  };\n};\n\nfunction IgxActionStripComponent_igx_drop_down_item_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-drop-down-item\", 6)(1, \"div\", 7);\n    i0.ɵɵtemplate(2, IgxActionStripComponent_igx_drop_down_item_5_ng_container_2_Template, 1, 0, \"ng-container\", 8);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const item_r4 = ctx.$implicit;\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", item_r4.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c24, item_r4));\n  }\n}\n\nconst _c25 = [\"defaultTemplate\"];\nconst _c26 = [\"imageTemplate\"];\nconst _c27 = [\"initialsTemplate\"];\nconst _c28 = [\"iconTemplate\"];\n\nfunction IgxAvatarComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0);\n  }\n}\n\nfunction IgxAvatarComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 5, 6);\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"background-image\", ctx_r3.getSrcUrl());\n  }\n}\n\nfunction IgxAvatarComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r5.initials.substring(0, 2));\n  }\n}\n\nfunction IgxAvatarComponent_ng_template_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r7.icon);\n  }\n}\n\nfunction IgxAvatarComponent_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxExpansionPanelHeaderComponent_ng_content_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 3, [\"*ngIf\", \"iconTemplate\"]);\n  }\n}\n\nfunction IgxExpansionPanelHeaderComponent_igx_icon_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.panel.collapsed ? \"expand_more\" : \"expand_less\", \" \");\n  }\n}\n\nconst _c29 = [[[\"igx-expansion-panel-title\"]], [[\"igx-expansion-panel-description\"]], \"*\", [[\"igx-expansion-panel-icon\"]]];\nconst _c30 = [\"igx-expansion-panel-title\", \"igx-expansion-panel-description\", \"*\", \"igx-expansion-panel-icon\"];\n\nfunction IgxExpansionPanelComponent_ng_content_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 1, [\"*ngIf\", \"!collapsed\"]);\n  }\n}\n\nconst _c31 = [[[\"igx-expansion-panel-header\"]], [[\"igx-expansion-panel-body\"]]];\nconst _c32 = [\"igx-expansion-panel-header\", \"igx-expansion-panel-body\"];\nconst _c33 = [[[\"igx-expansion-panel\"]]];\nconst _c34 = [\"igx-expansion-panel\"];\n\nfunction IgxBadgeComponent_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 2);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r0.value);\n  }\n}\n\nfunction IgxBadgeComponent_igx_icon_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.icon);\n  }\n}\n\nconst _c35 = [\"expansionPanel\"];\n\nfunction IgxBannerComponent_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 9);\n    i0.ɵɵprojection(1, 1);\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxBannerComponent_ng_container_10_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"button\", 10);\n    i0.ɵɵlistener(\"click\", function IgxBannerComponent_ng_container_10_Template_button_click_1_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r4 = i0.ɵɵnextContext();\n      return ctx_r4.close();\n    });\n    i0.ɵɵtext(2, \" Dismiss \");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n}\n\nfunction IgxBannerComponent_ng_container_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵprojection(1, 2);\n    i0.ɵɵelementContainerEnd();\n  }\n}\n\nconst _c36 = [\"*\", [[\"igx-icon\"]], [[\"igx-banner-actions\"]]];\nconst _c37 = [\"*\", \"igx-icon\", \"igx-banner-actions\"];\n\nfunction IgxButtonGroupComponent_button_1_igx_icon_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const button_r1 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(button_r1.icon);\n  }\n}\n\nfunction IgxButtonGroupComponent_button_1_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 5);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const button_r1 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(button_r1.label);\n  }\n}\n\nfunction IgxButtonGroupComponent_button_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"button\", 2)(1, \"span\");\n    i0.ɵɵtemplate(2, IgxButtonGroupComponent_button_1_igx_icon_2_Template, 2, 1, \"igx-icon\", 3);\n    i0.ɵɵtemplate(3, IgxButtonGroupComponent_button_1_span_3_Template, 2, 1, \"span\", 4);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const button_r1 = ctx.$implicit;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"displayDensity\", ctx_r0.displayDensity)(\"selected\", button_r1.selected)(\"disabled\", ctx_r0.disabled || button_r1.disabled)(\"igxButtonColor\", button_r1.color)(\"igxButtonBackground\", button_r1.bgcolor)(\"igxLabel\", button_r1.label)(\"igxRipple\", button_r1.ripple);\n    i0.ɵɵattribute(\"data-togglable\", button_r1.togglable);\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassMapInterpolate1(\"igx-button-group__item-content \", ctx_r0.itemContentCssClass, \"\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", button_r1.icon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", button_r1.label);\n  }\n}\n\nconst _c38 = [\"yearsBtn\"];\n\nfunction IgxMonthsViewComponent_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 3);\n    i0.ɵɵlistener(\"monthSelection\", function IgxMonthsViewComponent_span_2_Template_span_monthSelection_0_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r3 = i0.ɵɵnextContext();\n      return ctx_r3.selectMonth($event);\n    });\n    i0.ɵɵpipe(1, \"date\");\n    i0.ɵɵtext(2);\n    i0.ɵɵpipe(3, \"titlecase\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const month_r1 = ctx.$implicit;\n    const i_r2 = ctx.index;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"igxCalendarMonth\", month_r1)(\"date\", ctx_r0.date)(\"index\", i_r2);\n    i0.ɵɵattribute(\"aria-label\", i0.ɵɵpipeBind2(1, 6, month_r1, \"LLLL\"))(\"tabindex\", ctx_r0.activeMonth === month_r1.getMonth() ? 0 : -1);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", i0.ɵɵpipeBind1(3, 9, ctx_r0.formattedMonth(month_r1)), \" \");\n  }\n}\n\nfunction IgxYearsViewComponent_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 3);\n    i0.ɵɵlistener(\"yearSelection\", function IgxYearsViewComponent_span_2_Template_span_yearSelection_0_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return ctx_r2.selectYear($event);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const year_r1 = ctx.$implicit;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"igxCalendarYear\", year_r1)(\"date\", ctx_r0.date);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.formattedYear(year_r1), \" \");\n  }\n}\n\nfunction IgxDaysViewComponent_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 4)(1, \"span\");\n    i0.ɵɵtext(2, \"Wk\");\n    i0.ɵɵelementEnd()();\n  }\n}\n\nfunction IgxDaysViewComponent_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 5);\n    i0.ɵɵtext(1);\n    i0.ɵɵpipe(2, \"titlecase\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const dayName_r3 = ctx.$implicit;\n    i0.ɵɵattribute(\"aria-label\", dayName_r3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", i0.ɵɵpipeBind1(2, 2, dayName_r3), \" \");\n  }\n}\n\nfunction IgxDaysViewComponent_div_3_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 8)(1, \"span\", 9);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const week_r4 = i0.ɵɵnextContext().$implicit;\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r7.getWeekNumber(week_r4[0].date), \" \");\n  }\n}\n\nfunction IgxDaysViewComponent_div_3_igx_day_item_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-day-item\", 10);\n    i0.ɵɵlistener(\"focus\", function IgxDaysViewComponent_div_3_igx_day_item_2_Template_igx_day_item_focus_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r12);\n      const day_r10 = restoredCtx.$implicit;\n      const ctx_r11 = i0.ɵɵnextContext(2);\n      return ctx_r11.activeDate = day_r10.date.toLocaleDateString();\n    })(\"dateSelection\", function IgxDaysViewComponent_div_3_igx_day_item_2_Template_igx_day_item_dateSelection_0_listener($event) {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r13 = i0.ɵɵnextContext(2);\n      return ctx_r13.selectDay($event);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const day_r10 = ctx.$implicit;\n    const ctx_r8 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"date\", day_r10)(\"selection\", ctx_r8.selection)(\"selected\", ctx_r8.isSelected(day_r10))(\"isLastInRange\", ctx_r8.isLastInRange(day_r10))(\"isFirstInRange\", ctx_r8.isFirstInRange(day_r10))(\"isWithinRange\", ctx_r8.isWithinRange(day_r10.date, true))(\"disabledDates\", ctx_r8.disabledDates)(\"specialDates\", ctx_r8.specialDates)(\"outOfRangeDates\", ctx_r8.outOfRangeDates)(\"hideOutsideDays\", ctx_r8.hideOutsideDays);\n    i0.ɵɵattribute(\"aria-selected\", ctx_r8.isSelected(day_r10))(\"aria-disabled\", ctx_r8.isDateDisabled(day_r10.date))(\"aria-label\", ctx_r8.isFirstInRange(day_r10) ? day_r10.date.toDateString() + \", \" + ctx_r8.resourceStrings.igx_calendar_range_start : ctx_r8.isLastInRange(day_r10) ? day_r10.date.toDateString() + \", \" + ctx_r8.resourceStrings.igx_calendar_range_end : day_r10.date.toDateString())(\"tabindex\", ctx_r8.tabIndex(day_r10));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r8.formattedDate(day_r10.date), \" \");\n  }\n}\n\nfunction IgxDaysViewComponent_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 0);\n    i0.ɵɵtemplate(1, IgxDaysViewComponent_div_3_div_1_Template, 3, 1, \"div\", 6);\n    i0.ɵɵtemplate(2, IgxDaysViewComponent_div_3_igx_day_item_2_Template, 2, 15, \"igx-day-item\", 7);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const week_r4 = ctx.$implicit;\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.showWeekNumbers);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", week_r4)(\"ngForTrackBy\", ctx_r2.dateTracker);\n  }\n}\n\nconst _c39 = [\"months\"];\nconst _c40 = [\"decade\"];\nconst _c41 = [\"days\"];\nconst _c42 = [\"prevMonthBtn\"];\nconst _c43 = [\"nextMonthBtn\"];\nconst _c44 = [\"monthsBtn\"];\n\nfunction IgxCalendarComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"span\");\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\"\", ctx_r1.getFormattedDate().weekday, \",\\xA0\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r1.getFormattedDate().monthday);\n  }\n}\n\nfunction IgxCalendarComponent_ng_template_2_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 10);\n    i0.ɵɵtext(1);\n    i0.ɵɵpipe(2, \"date\");\n    i0.ɵɵpipe(3, \"date\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const obj_r10 = i0.ɵɵnextContext().$implicit;\n    const ctx_r11 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r11.monthsViewNumber > 1 ? ctx_r11.resourceStrings.igx_calendar_first_picker_of.replace(\"{0}\", ctx_r11.monthsViewNumber.toString()) + \" \" + i0.ɵɵpipeBind2(2, 1, ctx_r11.getViewDate(obj_r10.index), \"LLLL yyyy\") : ctx_r11.resourceStrings.igx_calendar_selected_month_is + i0.ɵɵpipeBind2(3, 4, ctx_r11.getViewDate(obj_r10.index), \"LLLL yyyy\"), \" \");\n  }\n}\n\nfunction IgxCalendarComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r16 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵtemplate(0, IgxCalendarComponent_ng_template_2_span_0_Template, 4, 7, \"span\", 6);\n    i0.ɵɵelementStart(1, \"span\", 7, 8);\n    i0.ɵɵlistener(\"keydown\", function IgxCalendarComponent_ng_template_2_Template_span_keydown_1_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r16);\n      const obj_r10 = restoredCtx.$implicit;\n      const ctx_r15 = i0.ɵɵnextContext();\n      return ctx_r15.onActiveViewYearKB(ctx_r15.getViewDate(obj_r10.index), $event, obj_r10.index);\n    })(\"click\", function IgxCalendarComponent_ng_template_2_Template_span_click_1_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r16);\n      const obj_r10 = restoredCtx.$implicit;\n      const ctx_r17 = i0.ɵɵnextContext();\n      return ctx_r17.onActiveViewYear(ctx_r17.getViewDate(obj_r10.index), obj_r10.index);\n    });\n    i0.ɵɵpipe(3, \"date\");\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"span\", 7, 9);\n    i0.ɵɵlistener(\"keydown\", function IgxCalendarComponent_ng_template_2_Template_span_keydown_5_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r16);\n      const obj_r10 = restoredCtx.$implicit;\n      const ctx_r18 = i0.ɵɵnextContext();\n      return ctx_r18.onActiveViewDecadeKB($event, ctx_r18.getViewDate(obj_r10.index), obj_r10.index);\n    })(\"click\", function IgxCalendarComponent_ng_template_2_Template_span_click_5_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r16);\n      const obj_r10 = restoredCtx.$implicit;\n      const ctx_r19 = i0.ɵɵnextContext();\n      return ctx_r19.onActiveViewDecade(ctx_r19.getViewDate(obj_r10.index), obj_r10.index);\n    });\n    i0.ɵɵpipe(7, \"date\");\n    i0.ɵɵtext(8);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const obj_r10 = ctx.$implicit;\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.monthsViewNumber < 2 || obj_r10.index < 1);\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"aria-label\", i0.ɵɵpipeBind2(3, 5, ctx_r3.getViewDate(obj_r10.index), \"LLLL\") + \" \" + ctx_r3.resourceStrings.igx_calendar_select_month);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r3.formattedMonth(ctx_r3.getViewDate(obj_r10.index)), \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"aria-label\", i0.ɵɵpipeBind2(7, 8, ctx_r3.getViewDate(obj_r10.index), \"yyyy\") + \" \" + ctx_r3.resourceStrings.igx_calendar_select_year);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r3.formattedYear(ctx_r3.getViewDate(obj_r10.index)), \" \");\n  }\n}\n\nfunction IgxCalendarComponent_header_4_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxCalendarComponent_header_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"header\", 11)(1, \"h5\", 12);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"h2\", 13);\n    i0.ɵɵtemplate(4, IgxCalendarComponent_header_4_ng_container_4_Template, 1, 0, \"ng-container\", 14);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n\n    const _r0 = i0.ɵɵreference(1);\n\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r4.formattedYear(ctx_r4.headerDate), \" \");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r4.headerTemplate ? ctx_r4.headerTemplate : _r0)(\"ngTemplateOutletContext\", ctx_r4.headerContext);\n  }\n}\n\nfunction IgxCalendarComponent_div_5_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r21 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r21.monthsViewNumber && ctx_r21.monthsViewNumber > 1 ? ctx_r21.resourceStrings.igx_calendar_multi_selection.replace(\"{0}\", ctx_r21.monthsViewNumber.toString()) : ctx_r21.resourceStrings.igx_calendar_singular_multi_selection, \" \");\n  }\n}\n\nfunction IgxCalendarComponent_div_5_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r22 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r22.monthsViewNumber && ctx_r22.monthsViewNumber > 1 ? ctx_r22.resourceStrings.igx_calendar_range_selection.replace(\"{0}\", ctx_r22.monthsViewNumber.toString()) : ctx_r22.resourceStrings.igx_calendar_singular_range_selection, \" \");\n  }\n}\n\nfunction IgxCalendarComponent_div_5_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r23 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r23.monthsViewNumber && ctx_r23.monthsViewNumber > 1 ? ctx_r23.resourceStrings.igx_calendar_single_selection.replace(\"{0}\", ctx_r23.monthsViewNumber.toString()) : ctx_r23.resourceStrings.igx_calendar_singular_single_selection, \" \");\n  }\n}\n\nfunction IgxCalendarComponent_div_5_div_11_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxCalendarComponent_div_5_div_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 27);\n    i0.ɵɵpipe(1, \"IgxGetViewDate\");\n    i0.ɵɵtemplate(2, IgxCalendarComponent_div_5_div_11_ng_container_2_Template, 1, 0, \"ng-container\", 14);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const i_r29 = ctx.index;\n    const ctx_r25 = i0.ɵɵnextContext(2);\n\n    const _r2 = i0.ɵɵreference(3);\n\n    i0.ɵɵstyleProp(\"width\", 100 / ctx_r25.monthsViewNumber, \"%\");\n    i0.ɵɵattribute(\"data-month\", i0.ɵɵpipeBind3(1, 5, i_r29, ctx_r25.viewDate, false));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r25.subheaderTemplate ? ctx_r25.subheaderTemplate : _r2)(\"ngTemplateOutletContext\", ctx_r25.getContext(i_r29));\n  }\n}\n\nfunction IgxCalendarComponent_div_5_igx_days_view_19_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r35 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-days-view\", 28, 29);\n    i0.ɵɵlistener(\"activeDateChange\", function IgxCalendarComponent_div_5_igx_days_view_19_Template_igx_days_view_activeDateChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r35);\n      const ctx_r34 = i0.ɵɵnextContext(2);\n      return ctx_r34.activeDate = $event;\n    })(\"viewChanging\", function IgxCalendarComponent_div_5_igx_days_view_19_Template_igx_days_view_viewChanging_0_listener($event) {\n      i0.ɵɵrestoreView(_r35);\n      const ctx_r36 = i0.ɵɵnextContext(2);\n      return ctx_r36.viewChanging($event);\n    })(\"dateSelection\", function IgxCalendarComponent_div_5_igx_days_view_19_Template_igx_days_view_dateSelection_0_listener($event) {\n      i0.ɵɵrestoreView(_r35);\n      const ctx_r37 = i0.ɵɵnextContext(2);\n      return ctx_r37.childClicked($event);\n    })(\"monthsViewBlur\", function IgxCalendarComponent_div_5_igx_days_view_19_Template_igx_days_view_monthsViewBlur_0_listener() {\n      i0.ɵɵrestoreView(_r35);\n      const ctx_r38 = i0.ɵɵnextContext(2);\n      return ctx_r38.resetActiveDate();\n    });\n    i0.ɵɵpipe(2, \"IgxGetViewDate\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const i_r32 = ctx.index;\n    const ctx_r27 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"changeDaysView\", true)(\"selection\", ctx_r27.selection)(\"locale\", ctx_r27.locale)(\"value\", ctx_r27.value)(\"activeDate\", ctx_r27.activeDate)(\"viewDate\", i0.ɵɵpipeBind2(2, 13, i_r32, ctx_r27.viewDate))(\"weekStart\", ctx_r27.weekStart)(\"formatOptions\", ctx_r27.formatOptions)(\"formatViews\", ctx_r27.formatViews)(\"disabledDates\", ctx_r27.disabledDates)(\"specialDates\", ctx_r27.specialDates)(\"hideOutsideDays\", ctx_r27.hideOutsideDays)(\"showWeekNumbers\", ctx_r27.showWeekNumbers);\n  }\n}\n\nconst _c45 = function (a0) {\n  return {\n    \"min-width.%\": a0\n  };\n};\n\nfunction IgxCalendarComponent_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r40 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 15);\n    i0.ɵɵlistener(\"@animateView.done\", function IgxCalendarComponent_div_5_Template_div_animation_animateView_done_0_listener($event) {\n      i0.ɵɵrestoreView(_r40);\n      const ctx_r39 = i0.ɵɵnextContext();\n      return ctx_r39.viewRendered($event);\n    })(\"swiperight\", function IgxCalendarComponent_div_5_Template_div_swiperight_0_listener() {\n      i0.ɵɵrestoreView(_r40);\n      const ctx_r41 = i0.ɵɵnextContext();\n      return ctx_r41.previousMonth();\n    })(\"swipeleft\", function IgxCalendarComponent_div_5_Template_div_swipeleft_0_listener() {\n      i0.ɵɵrestoreView(_r40);\n      const ctx_r42 = i0.ɵɵnextContext();\n      return ctx_r42.nextMonth();\n    })(\"pointerdown\", function IgxCalendarComponent_div_5_Template_div_pointerdown_0_listener() {\n      i0.ɵɵrestoreView(_r40);\n      const ctx_r43 = i0.ɵɵnextContext();\n      return ctx_r43.suppressBlur();\n    });\n    i0.ɵɵelementStart(1, \"section\", 16)(2, \"span\", 17);\n    i0.ɵɵtemplate(3, IgxCalendarComponent_div_5_ng_container_3_Template, 2, 1, \"ng-container\", 18);\n    i0.ɵɵtemplate(4, IgxCalendarComponent_div_5_ng_container_4_Template, 2, 1, \"ng-container\", 18);\n    i0.ɵɵtemplate(5, IgxCalendarComponent_div_5_ng_container_5_Template, 2, 1, \"ng-container\", 18);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(6, \"div\", 19, 20);\n    i0.ɵɵpipe(8, \"date\");\n    i0.ɵɵelementStart(9, \"igx-icon\", 21);\n    i0.ɵɵtext(10, \"keyboard_arrow_left\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵtemplate(11, IgxCalendarComponent_div_5_div_11_Template, 3, 9, \"div\", 22);\n    i0.ɵɵpipe(12, \"IgxMonthViewSlots\");\n    i0.ɵɵelementStart(13, \"div\", 23, 24);\n    i0.ɵɵpipe(15, \"date\");\n    i0.ɵɵelementStart(16, \"igx-icon\", 21);\n    i0.ɵɵtext(17, \"keyboard_arrow_right\");\n    i0.ɵɵelementEnd()()();\n    i0.ɵɵelementStart(18, \"section\", 25);\n    i0.ɵɵlistener(\"@animateChange.done\", function IgxCalendarComponent_div_5_Template_section_animation_animateChange_done_18_listener($event) {\n      i0.ɵɵrestoreView(_r40);\n      const ctx_r44 = i0.ɵɵnextContext();\n      return ctx_r44.animationDone($event);\n    });\n    i0.ɵɵtemplate(19, IgxCalendarComponent_div_5_igx_days_view_19_Template, 3, 16, \"igx-days-view\", 26);\n    i0.ɵɵpipe(20, \"IgxMonthViewSlots\");\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"@animateView\", ctx_r5.activeView);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.selection === \"multi\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.selection === \"range\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.selection === \"single\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"startScroll\", ctx_r5.startPrevMonthScroll)(\"stopScroll\", ctx_r5.stopMonthScroll)(\"ngStyle\", i0.ɵɵpureFunction1(25, _c45, 100 / (ctx_r5.monthsViewNumber * 7)));\n    i0.ɵɵattribute(\"aria-label\", ctx_r5.resourceStrings.igx_calendar_previous_month + \", \" + i0.ɵɵpipeBind2(8, 15, ctx_r5.getPrevMonth(ctx_r5.viewDate), \"LLLL\"));\n    i0.ɵɵadvance(5);\n    i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBind1(12, 18, ctx_r5.monthsViewNumber));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"startScroll\", ctx_r5.startNextMonthScroll)(\"stopScroll\", ctx_r5.stopMonthScroll)(\"ngStyle\", i0.ɵɵpureFunction1(27, _c45, 100 / (ctx_r5.monthsViewNumber * 7)));\n    i0.ɵɵattribute(\"aria-label\", ctx_r5.resourceStrings.igx_calendar_next_month + \", \" + i0.ɵɵpipeBind2(15, 20, ctx_r5.getNextMonth(ctx_r5.viewDate, ctx_r5.monthsViewNumber), \"LLLL\"));\n    i0.ɵɵadvance(5);\n    i0.ɵɵproperty(\"@animateChange\", ctx_r5.animationAction);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBind1(20, 23, ctx_r5.monthsViewNumber));\n  }\n}\n\nfunction IgxCalendarComponent_igx_months_view_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r47 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-months-view\", 30, 31);\n    i0.ɵɵlistener(\"@animateView.done\", function IgxCalendarComponent_igx_months_view_6_Template_igx_months_view_animation_animateView_done_0_listener($event) {\n      i0.ɵɵrestoreView(_r47);\n      const ctx_r46 = i0.ɵɵnextContext();\n      return ctx_r46.viewRendered($event);\n    })(\"selected\", function IgxCalendarComponent_igx_months_view_6_Template_igx_months_view_selected_0_listener($event) {\n      i0.ɵɵrestoreView(_r47);\n      const ctx_r48 = i0.ɵɵnextContext();\n      return ctx_r48.changeMonth($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"@animateView\", ctx_r6.activeView)(\"date\", ctx_r6.viewDate)(\"locale\", ctx_r6.locale)(\"formatView\", ctx_r6.formatViews.month)(\"monthFormat\", ctx_r6.formatOptions.month);\n  }\n}\n\nfunction IgxCalendarComponent_igx_years_view_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r51 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-years-view\", 32, 33);\n    i0.ɵɵlistener(\"@animateView.done\", function IgxCalendarComponent_igx_years_view_7_Template_igx_years_view_animation_animateView_done_0_listener($event) {\n      i0.ɵɵrestoreView(_r51);\n      const ctx_r50 = i0.ɵɵnextContext();\n      return ctx_r50.viewRendered($event);\n    })(\"selected\", function IgxCalendarComponent_igx_years_view_7_Template_igx_years_view_selected_0_listener($event) {\n      i0.ɵɵrestoreView(_r51);\n      const ctx_r52 = i0.ɵɵnextContext();\n      return ctx_r52.changeYear($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"@animateView\", ctx_r7.activeView)(\"date\", ctx_r7.viewDate)(\"locale\", ctx_r7.locale)(\"formatView\", ctx_r7.formatViews.year)(\"yearFormat\", ctx_r7.formatOptions.year);\n  }\n}\n\nconst _c46 = function () {\n  return {\n    \"min-width.%\": 25,\n    \"left\": 0\n  };\n};\n\nconst _c47 = function () {\n  return {\n    \"min-width.%\": 25,\n    \"right\": 0\n  };\n};\n\nfunction IgxMonthPickerComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 2);\n    i0.ɵɵlistener(\"@animateView.done\", function IgxMonthPickerComponent_div_0_Template_div_animation_animateView_done_0_listener($event) {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r4 = i0.ɵɵnextContext();\n      return ctx_r4.viewRendered($event);\n    })(\"swiperight\", function IgxMonthPickerComponent_div_0_Template_div_swiperight_0_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.previousYear();\n    })(\"swipeleft\", function IgxMonthPickerComponent_div_0_Template_div_swipeleft_0_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return ctx_r7.nextYear();\n    });\n    i0.ɵɵelementStart(1, \"div\", 3)(2, \"div\", 4);\n    i0.ɵɵlistener(\"click\", function IgxMonthPickerComponent_div_0_Template_div_click_2_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.previousYear();\n    })(\"keydown\", function IgxMonthPickerComponent_div_0_Template_div_keydown_2_listener($event) {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return ctx_r9.changeYearKB($event, false);\n    });\n    i0.ɵɵelementStart(3, \"igx-icon\");\n    i0.ɵɵtext(4, \"keyboard_arrow_left\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(5, \"div\")(6, \"span\", 5, 6);\n    i0.ɵɵlistener(\"keydown\", function IgxMonthPickerComponent_div_0_Template_span_keydown_6_listener($event) {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return ctx_r10.activeViewDecadeKB($event);\n    })(\"click\", function IgxMonthPickerComponent_div_0_Template_span_click_6_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return ctx_r11.activeViewDecade();\n    });\n    i0.ɵɵtext(8);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(9, \"div\", 7);\n    i0.ɵɵlistener(\"click\", function IgxMonthPickerComponent_div_0_Template_div_click_9_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r12 = i0.ɵɵnextContext();\n      return ctx_r12.nextYear();\n    })(\"keydown\", function IgxMonthPickerComponent_div_0_Template_div_keydown_9_listener($event) {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r13 = i0.ɵɵnextContext();\n      return ctx_r13.changeYearKB($event);\n    });\n    i0.ɵɵelementStart(10, \"igx-icon\");\n    i0.ɵɵtext(11, \"keyboard_arrow_right\");\n    i0.ɵɵelementEnd()()();\n    i0.ɵɵelementStart(12, \"igx-months-view\", 8, 9);\n    i0.ɵɵlistener(\"@animateChange.done\", function IgxMonthPickerComponent_div_0_Template_igx_months_view_animation_animateChange_done_12_listener($event) {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r14 = i0.ɵɵnextContext();\n      return ctx_r14.animationDone($event);\n    })(\"@animateView.done\", function IgxMonthPickerComponent_div_0_Template_igx_months_view_animation_animateView_done_12_listener($event) {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r15 = i0.ɵɵnextContext();\n      return ctx_r15.viewRendered($event);\n    })(\"selected\", function IgxMonthPickerComponent_div_0_Template_igx_months_view_selected_12_listener($event) {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r16 = i0.ɵɵnextContext();\n      return ctx_r16.selectMonth($event);\n    });\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"@animateView\", ctx_r0.activeView);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction0(13, _c46));\n    i0.ɵɵattribute(\"aria-label\", \"Previous Year \" + ctx_r0.getPreviousYear());\n    i0.ɵɵadvance(3);\n    i0.ɵɵstyleProp(\"width\", 100, \"%\");\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.formattedYear(ctx_r0.viewDate), \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction0(14, _c47));\n    i0.ɵɵattribute(\"aria-label\", \"Next Year \" + ctx_r0.getNextYear());\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"@animateChange\", ctx_r0.yearAction)(\"date\", ctx_r0.viewDate)(\"locale\", ctx_r0.locale)(\"formatView\", ctx_r0.formatViews.month)(\"monthFormat\", ctx_r0.formatOptions.month);\n  }\n}\n\nfunction IgxMonthPickerComponent_igx_years_view_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r19 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-years-view\", 10, 11);\n    i0.ɵɵlistener(\"@animateView.done\", function IgxMonthPickerComponent_igx_years_view_1_Template_igx_years_view_animation_animateView_done_0_listener($event) {\n      i0.ɵɵrestoreView(_r19);\n      const ctx_r18 = i0.ɵɵnextContext();\n      return ctx_r18.viewRendered($event);\n    })(\"selected\", function IgxMonthPickerComponent_igx_years_view_1_Template_igx_years_view_selected_0_listener($event) {\n      i0.ɵɵrestoreView(_r19);\n      const ctx_r20 = i0.ɵɵnextContext();\n      return ctx_r20.selectYear($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"@animateView\", ctx_r1.activeView)(\"date\", ctx_r1.viewDate)(\"locale\", ctx_r1.locale)(\"formatView\", ctx_r1.formatViews.year)(\"yearFormat\", ctx_r1.formatOptions.year);\n  }\n}\n\nconst _c48 = [[[\"igx-avatar\"], [\"igx-card-media\"], [\"\", \"igxCardThumbnail\", \"\"]], [[\"\", \"igxCardHeaderTitle\", \"\"], [\"\", \"igxCardHeaderSubtitle\", \"\"], [\"\", 8, \"igx-card-header__title\"], [\"\", 8, \"igx-card-header__subtitle\"]], \"*\"];\nconst _c49 = [\"igx-avatar, igx-card-media, [igxCardThumbnail]\", \"\\n        [igxCardHeaderTitle],\\n        [igxCardHeaderSubtitle],\\n        .igx-card-header__title,\\n        .igx-card-header__subtitle\", \"*\"];\nconst _c50 = [[[\"igx-icon\"], [\"\", \"igxButton\", \"icon\"]], [[\"\", \"igxButton\", \"\"]], \"*\"];\nconst _c51 = [\"igx-icon, [igxButton='icon']\", \"[igxButton]\", \"*\"];\nconst _c52 = [\"defaultIndicator\"];\nconst _c53 = [\"defaultNextButton\"];\nconst _c54 = [\"defaultPrevButton\"];\n\nfunction IgxCarouselComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 7);\n  }\n\n  if (rf & 2) {\n    const slide_r10 = ctx.$implicit;\n    i0.ɵɵclassProp(\"igx-nav-dot--active\", slide_r10.active);\n  }\n}\n\nfunction IgxCarouselComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 8)(1, \"igx-icon\");\n    i0.ɵɵtext(2, \"arrow_forward\");\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const disabled_r11 = ctx.$implicit;\n    i0.ɵɵclassProp(\"igx-nav-arrow--disabled\", disabled_r11);\n  }\n}\n\nfunction IgxCarouselComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 8)(1, \"igx-icon\");\n    i0.ɵɵtext(2, \"arrow_back\");\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const disabled_r12 = ctx.$implicit;\n    i0.ɵɵclassProp(\"igx-nav-arrow--disabled\", disabled_r12);\n  }\n}\n\nfunction IgxCarouselComponent_div_6_div_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxCarouselComponent_div_6_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r17 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 11);\n    i0.ɵɵlistener(\"click\", function IgxCarouselComponent_div_6_div_1_Template_div_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r17);\n      const slide_r14 = restoredCtx.$implicit;\n      const ctx_r16 = i0.ɵɵnextContext(2);\n      return ctx_r16.select(slide_r14);\n    });\n    i0.ɵɵtemplate(1, IgxCarouselComponent_div_6_div_1_ng_container_1_Template, 1, 0, \"ng-container\", 12);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const slide_r14 = ctx.$implicit;\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"id\", \"tab-\" + slide_r14.index + \"-\" + ctx_r13.total);\n    i0.ɵɵattribute(\"role\", \"tab\")(\"aria-label\", ctx_r13.resourceStrings.igx_carousel_slide + \" \" + (slide_r14.index + 1) + \" \" + ctx_r13.resourceStrings.igx_carousel_of + \" \" + ctx_r13.total)(\"aria-controls\", \"panel-\" + slide_r14.index)(\"aria-selected\", slide_r14.active);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r13.getIndicatorTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(7, _c24, slide_r14));\n  }\n}\n\nfunction IgxCarouselComponent_div_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 9);\n    i0.ɵɵtemplate(1, IgxCarouselComponent_div_6_div_1_Template, 2, 9, \"div\", 10);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r6.indicatorsOrientationClass);\n    i0.ɵɵattribute(\"role\", \"tablist\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r6.slides);\n  }\n}\n\nfunction IgxCarouselComponent_div_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 9)(1, \"span\", 13);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r7.indicatorsOrientationClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"id\", ctx_r7.labelId);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r7.getCarouselLabel);\n  }\n}\n\nfunction IgxCarouselComponent_div_10_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxCarouselComponent_div_10_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r20 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 14);\n    i0.ɵɵlistener(\"keydown.enter\", function IgxCarouselComponent_div_10_Template_div_keydown_enter_0_listener() {\n      i0.ɵɵrestoreView(_r20);\n      const ctx_r19 = i0.ɵɵnextContext();\n      return ctx_r19.prev();\n    })(\"click\", function IgxCarouselComponent_div_10_Template_div_click_0_listener() {\n      i0.ɵɵrestoreView(_r20);\n      const ctx_r21 = i0.ɵɵnextContext();\n      return ctx_r21.prev();\n    });\n    i0.ɵɵtemplate(1, IgxCarouselComponent_div_10_ng_container_1_Template, 1, 0, \"ng-container\", 12);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"aria-label\", ctx_r8.resourceStrings.igx_carousel_previous_slide);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r8.getPrevButtonTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(3, _c24, ctx_r8.prevButtonDisabled));\n  }\n}\n\nfunction IgxCarouselComponent_div_11_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxCarouselComponent_div_11_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r24 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 15);\n    i0.ɵɵlistener(\"keydown.enter\", function IgxCarouselComponent_div_11_Template_div_keydown_enter_0_listener() {\n      i0.ɵɵrestoreView(_r24);\n      const ctx_r23 = i0.ɵɵnextContext();\n      return ctx_r23.next();\n    })(\"click\", function IgxCarouselComponent_div_11_Template_div_click_0_listener() {\n      i0.ɵɵrestoreView(_r24);\n      const ctx_r25 = i0.ɵɵnextContext();\n      return ctx_r25.next();\n    });\n    i0.ɵɵtemplate(1, IgxCarouselComponent_div_11_ng_container_1_Template, 1, 0, \"ng-container\", 12);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"aria-label\", ctx_r9.resourceStrings.igx_carousel_next_slide);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r9.getNextButtonTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(3, _c24, ctx_r9.nextButtonDisabled));\n  }\n}\n\nconst _c55 = [\"chipArea\"];\nconst _c56 = [\"selectContainer\"];\nconst _c57 = [\"defaultRemoveIcon\"];\nconst _c58 = [\"defaultSelectIcon\"];\n\nfunction IgxChipComponent_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxChipComponent_div_9_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxChipComponent_div_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 9);\n    i0.ɵɵlistener(\"keydown\", function IgxChipComponent_div_9_Template_div_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return ctx_r9.onRemoveBtnKeyDown($event);\n    })(\"pointerdown\", function IgxChipComponent_div_9_Template_div_pointerdown_0_listener($event) {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return ctx_r11.onRemoveMouseDown($event);\n    })(\"mousedown\", function IgxChipComponent_div_9_Template_div_mousedown_0_listener($event) {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r12 = i0.ɵɵnextContext();\n      return ctx_r12.onRemoveMouseDown($event);\n    })(\"click\", function IgxChipComponent_div_9_Template_div_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r13 = i0.ɵɵnextContext();\n      return ctx_r13.onRemoveClick($event);\n    })(\"touchmove\", function IgxChipComponent_div_9_Template_div_touchmove_0_listener() {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r14 = i0.ɵɵnextContext();\n      return ctx_r14.onRemoveTouchMove();\n    })(\"touchend\", function IgxChipComponent_div_9_Template_div_touchend_0_listener($event) {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r15 = i0.ɵɵnextContext();\n      return ctx_r15.onRemoveTouchEnd($event);\n    });\n    i0.ɵɵtemplate(1, IgxChipComponent_div_9_ng_container_1_Template, 1, 0, \"ng-container\", 4);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"tabIndex\", ctx_r3.tabIndex);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r3.removeButtonTemplate);\n  }\n}\n\nfunction IgxChipComponent_ng_template_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1, \"done\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"aria-label\", ctx_r5.resourceStrings.igx_chip_select);\n  }\n}\n\nfunction IgxChipComponent_ng_template_12_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1, \"cancel\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"aria-label\", ctx_r7.resourceStrings.igx_chip_remove);\n  }\n}\n\nconst _c59 = [[[\"igx-prefix\"], [\"\", \"igxPrefix\", \"\"]], \"*\", [[\"igx-suffix\"], [\"\", \"igxSuffix\", \"\"]]];\n\nconst _c60 = function (a0) {\n  return {\n    chip: a0\n  };\n};\n\nconst _c61 = [\"igx-prefix,[igxPrefix]\", \"*\", \"igx-suffix,[igxSuffix]\"];\n\nfunction IgxComboItemComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-checkbox\", 2);\n    i0.ɵɵlistener(\"click\", function IgxComboItemComponent_ng_container_0_Template_igx_checkbox_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r2);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return ctx_r1.disableCheck($event);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"checked\", ctx_r0.selected)(\"readonly\", true)(\"disableRipple\", true)(\"disableTransitions\", ctx_r0.disableTransitions)(\"tabindex\", -1);\n  }\n}\n\nconst _c62 = [\"inputGroup\"];\nconst _c63 = [\"comboInput\"];\nconst _c64 = [\"searchInput\"];\nconst _c65 = [\"dropdownItemContainer\"];\nconst _c66 = [\"primitive\"];\nconst _c67 = [\"complex\"];\n\nfunction IgxComboDropDownComponent_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵprojection(1);\n    i0.ɵɵelementContainerEnd();\n  }\n}\n\nfunction IgxComboComponent_igx_suffix_12_ng_container_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxComboComponent_igx_suffix_12_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxComboComponent_igx_suffix_12_ng_container_1_ng_container_1_Template, 1, 0, \"ng-container\", 14);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r22 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r22.clearIconTemplate);\n  }\n}\n\nfunction IgxComboComponent_igx_suffix_12_igx_icon_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1, \" clear \");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxComboComponent_igx_suffix_12_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r26 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-suffix\", 24);\n    i0.ɵɵlistener(\"click\", function IgxComboComponent_igx_suffix_12_Template_igx_suffix_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r26);\n      const ctx_r25 = i0.ɵɵnextContext();\n      return ctx_r25.handleClearItems($event);\n    });\n    i0.ɵɵtemplate(1, IgxComboComponent_igx_suffix_12_ng_container_1_Template, 2, 1, \"ng-container\", 10);\n    i0.ɵɵtemplate(2, IgxComboComponent_igx_suffix_12_igx_icon_2_Template, 2, 0, \"igx-icon\", 10);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.clearIconTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r2.clearIconTemplate);\n  }\n}\n\nfunction IgxComboComponent_ng_container_14_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxComboComponent_ng_container_14_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxComboComponent_ng_container_14_ng_container_1_Template, 1, 0, \"ng-container\", 25);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r3.toggleIconTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c24, ctx_r3.collapsed));\n  }\n}\n\nfunction IgxComboComponent_igx_icon_15_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r4.dropdown.collapsed ? \"arrow_drop_down\" : \"arrow_drop_up\", \" \");\n  }\n}\n\nfunction IgxComboComponent_igx_input_group_18_igx_suffix_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r31 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-suffix\")(1, \"igx-icon\", 29);\n    i0.ɵɵlistener(\"click\", function IgxComboComponent_igx_input_group_18_igx_suffix_3_Template_igx_icon_click_1_listener() {\n      i0.ɵɵrestoreView(_r31);\n      const ctx_r30 = i0.ɵɵnextContext(2);\n      return ctx_r30.toggleCaseSensitive();\n    });\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r29 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"active\", ctx_r29.filteringOptions.caseSensitive);\n  }\n}\n\nfunction IgxComboComponent_igx_input_group_18_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r33 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-input-group\", 26)(1, \"input\", 27, 28);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxComboComponent_igx_input_group_18_Template_input_ngModelChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r32 = i0.ɵɵnextContext();\n      return ctx_r32.searchValue = $event;\n    })(\"ngModelChange\", function IgxComboComponent_igx_input_group_18_Template_input_ngModelChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r34 = i0.ɵɵnextContext();\n      return ctx_r34.handleInputChange($event);\n    })(\"keyup\", function IgxComboComponent_igx_input_group_18_Template_input_keyup_1_listener($event) {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r35 = i0.ɵɵnextContext();\n      return ctx_r35.handleKeyUp($event);\n    })(\"keydown\", function IgxComboComponent_igx_input_group_18_Template_input_keydown_1_listener($event) {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r36 = i0.ɵɵnextContext();\n      return ctx_r36.handleKeyDown($event);\n    })(\"focus\", function IgxComboComponent_igx_input_group_18_Template_input_focus_1_listener($event) {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r37 = i0.ɵɵnextContext();\n      return ctx_r37.dropdown.onBlur($event);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, IgxComboComponent_igx_input_group_18_igx_suffix_3_Template, 2, 1, \"igx-suffix\", 10);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"displayDensity\", ctx_r6.displayDensity);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngModel\", ctx_r6.searchValue);\n    i0.ɵɵattribute(\"placeholder\", ctx_r6.searchPlaceholder)(\"aria-owns\", ctx_r6.dropdown.id)(\"aria-labelledby\", ctx_r6.ariaLabelledBy);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.showSearchCaseIcon);\n  }\n}\n\nfunction IgxComboComponent_ng_container_19_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxComboComponent_igx_combo_item_22_ng_container_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nconst _c68 = function (a0, a1, a2, a3, a4) {\n  return {\n    $implicit: a0,\n    data: a1,\n    valueKey: a2,\n    groupKey: a3,\n    displayKey: a4\n  };\n};\n\nfunction IgxComboComponent_igx_combo_item_22_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxComboComponent_igx_combo_item_22_ng_container_1_ng_container_1_Template, 1, 0, \"ng-container\", 25);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const item_r38 = i0.ɵɵnextContext().$implicit;\n    const ctx_r40 = i0.ɵɵnextContext();\n\n    const _r20 = i0.ɵɵreference(36);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r40.headerItemTemplate ? ctx_r40.headerItemTemplate : _r20)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction5(2, _c68, item_r38, ctx_r40.data, ctx_r40.valueKey, ctx_r40.groupKey, ctx_r40.displayKey));\n  }\n}\n\nfunction IgxComboComponent_igx_combo_item_22_ng_container_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0, null, 31);\n  }\n}\n\nconst _c69 = function (a0, a1, a2, a3) {\n  return {\n    $implicit: a0,\n    data: a1,\n    valueKey: a2,\n    displayKey: a3\n  };\n};\n\nfunction IgxComboComponent_igx_combo_item_22_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxComboComponent_igx_combo_item_22_ng_container_2_ng_container_1_Template, 2, 0, \"ng-container\", 25);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const item_r38 = i0.ɵɵnextContext().$implicit;\n    const ctx_r41 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r41.template)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction4(2, _c69, item_r38, ctx_r41.data, ctx_r41.valueKey, ctx_r41.displayKey));\n  }\n}\n\nfunction IgxComboComponent_igx_combo_item_22_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-combo-item\", 30);\n    i0.ɵɵtemplate(1, IgxComboComponent_igx_combo_item_22_ng_container_1_Template, 2, 8, \"ng-container\", 10);\n    i0.ɵɵtemplate(2, IgxComboComponent_igx_combo_item_22_ng_container_2_Template, 2, 7, \"ng-container\", 10);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r38 = ctx.$implicit;\n    const rowIndex_r39 = ctx.index;\n    const ctx_r9 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"itemHeight\", ctx_r9.itemHeight)(\"value\", item_r38)(\"isHeader\", item_r38.isHeader)(\"index\", rowIndex_r39);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", item_r38.isHeader);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !item_r38.isHeader);\n  }\n}\n\nfunction IgxComboComponent_div_25_div_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxComboComponent_div_25_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 35);\n    i0.ɵɵtemplate(1, IgxComboComponent_div_25_div_1_ng_container_1_Template, 1, 0, \"ng-container\", 14);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r47 = i0.ɵɵnextContext(2);\n\n    const _r16 = i0.ɵɵreference(32);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r47.emptyTemplate ? ctx_r47.emptyTemplate : _r16);\n  }\n}\n\nfunction IgxComboComponent_div_25_igx_combo_add_item_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxComboComponent_div_25_igx_combo_add_item_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-combo-add-item\", 36);\n    i0.ɵɵtemplate(1, IgxComboComponent_div_25_igx_combo_add_item_2_ng_container_1_Template, 1, 0, \"ng-container\", 14);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r48 = i0.ɵɵnextContext(2);\n\n    const _r18 = i0.ɵɵreference(34);\n\n    i0.ɵɵproperty(\"itemHeight\", ctx_r48.itemHeight)(\"tabindex\", ctx_r48.dropdown.collapsed ? -1 : ctx_r48.customValueFlag ? 1 : -1)(\"index\", ctx_r48.virtualScrollContainer.igxForOf.length);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r48.addItemTemplate ? ctx_r48.addItemTemplate : _r18);\n  }\n}\n\nfunction IgxComboComponent_div_25_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 32);\n    i0.ɵɵtemplate(1, IgxComboComponent_div_25_div_1_Template, 2, 1, \"div\", 33);\n    i0.ɵɵtemplate(2, IgxComboComponent_div_25_igx_combo_add_item_2_Template, 2, 4, \"igx-combo-add-item\", 34);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r10 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r10.filteredData.length === 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r10.isAddButtonVisible());\n  }\n}\n\nfunction IgxComboComponent_ng_container_26_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxComboComponent_ng_template_27_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const display_r51 = ctx.$implicit;\n    const key_r53 = ctx.displayKey;\n    i0.ɵɵtextInterpolate1(\" \", display_r51[key_r53], \"\\n\");\n  }\n}\n\nfunction IgxComboComponent_ng_template_29_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const display_r54 = ctx.$implicit;\n    i0.ɵɵtextInterpolate1(\" \", display_r54, \"\\n\");\n  }\n}\n\nfunction IgxComboComponent_ng_template_31_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1, \"The list is empty\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxComboComponent_ng_template_33_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"button\", 37);\n    i0.ɵɵtext(1, \"Add item\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxComboComponent_ng_template_35_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const item_r56 = ctx.$implicit;\n    const key_r57 = ctx.valueKey;\n    i0.ɵɵtextInterpolate1(\" \", item_r56[key_r57], \"\\n\");\n  }\n}\n\nconst _c70 = [[[\"\", \"igxLabel\", \"\"]], [[\"igx-prefix\"]], [[\"igx-hint\"], [\"\", \"igxHint\", \"\"]], [[\"igx-suffix\"]]];\n\nconst _c71 = function (a0, a1, a2, a3, a4) {\n  return [a0, a1, a2, a3, a4];\n};\n\nconst _c72 = [\"[igxLabel]\", \"igx-prefix\", \"igx-hint, [igxHint]\", \"igx-suffix\"];\n\nfunction IgxSimpleComboComponent_igx_suffix_12_ng_container_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxSimpleComboComponent_igx_suffix_12_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxSimpleComboComponent_igx_suffix_12_ng_container_1_ng_container_1_Template, 1, 0, \"ng-container\", 14);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r22 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r22.clearIconTemplate);\n  }\n}\n\nfunction IgxSimpleComboComponent_igx_suffix_12_igx_icon_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1, \" clear \");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxSimpleComboComponent_igx_suffix_12_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r26 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-suffix\", 24);\n    i0.ɵɵlistener(\"click\", function IgxSimpleComboComponent_igx_suffix_12_Template_igx_suffix_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r26);\n      const ctx_r25 = i0.ɵɵnextContext();\n      return ctx_r25.handleClear($event);\n    });\n    i0.ɵɵtemplate(1, IgxSimpleComboComponent_igx_suffix_12_ng_container_1_Template, 2, 1, \"ng-container\", 9);\n    i0.ɵɵtemplate(2, IgxSimpleComboComponent_igx_suffix_12_igx_icon_2_Template, 2, 0, \"igx-icon\", 9);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.clearIconTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r2.clearIconTemplate);\n  }\n}\n\nfunction IgxSimpleComboComponent_igx_suffix_13_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r28 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-suffix\")(1, \"igx-icon\", 25);\n    i0.ɵɵlistener(\"click\", function IgxSimpleComboComponent_igx_suffix_13_Template_igx_icon_click_1_listener() {\n      i0.ɵɵrestoreView(_r28);\n      const ctx_r27 = i0.ɵɵnextContext();\n      return ctx_r27.toggleCaseSensitive();\n    });\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"active\", ctx_r3.filteringOptions.caseSensitive);\n  }\n}\n\nfunction IgxSimpleComboComponent_ng_container_15_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxSimpleComboComponent_ng_container_15_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxSimpleComboComponent_ng_container_15_ng_container_1_Template, 1, 0, \"ng-container\", 26);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r4.toggleIconTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c24, ctx_r4.collapsed));\n  }\n}\n\nfunction IgxSimpleComboComponent_igx_icon_16_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r31 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-icon\", 27);\n    i0.ɵɵlistener(\"click\", function IgxSimpleComboComponent_igx_icon_16_Template_igx_icon_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r31);\n      const ctx_r30 = i0.ɵɵnextContext();\n      return ctx_r30.onClick($event);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r5.dropdown.collapsed ? \"arrow_drop_down\" : \"arrow_drop_up\", \" \");\n  }\n}\n\nfunction IgxSimpleComboComponent_ng_container_19_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxSimpleComboComponent_igx_combo_item_22_ng_container_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxSimpleComboComponent_igx_combo_item_22_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxSimpleComboComponent_igx_combo_item_22_ng_container_1_ng_container_1_Template, 1, 0, \"ng-container\", 26);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const item_r32 = i0.ɵɵnextContext().$implicit;\n    const ctx_r34 = i0.ɵɵnextContext();\n\n    const _r20 = i0.ɵɵreference(37);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r34.headerItemTemplate ? ctx_r34.headerItemTemplate : _r20)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction5(2, _c68, item_r32, ctx_r34.data, ctx_r34.valueKey, ctx_r34.groupKey, ctx_r34.displayKey));\n  }\n}\n\nfunction IgxSimpleComboComponent_igx_combo_item_22_ng_container_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0, null, 29);\n  }\n}\n\nfunction IgxSimpleComboComponent_igx_combo_item_22_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxSimpleComboComponent_igx_combo_item_22_ng_container_2_ng_container_1_Template, 2, 0, \"ng-container\", 26);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const item_r32 = i0.ɵɵnextContext().$implicit;\n    const ctx_r35 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r35.template)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction4(2, _c69, item_r32, ctx_r35.data, ctx_r35.valueKey, ctx_r35.displayKey));\n  }\n}\n\nfunction IgxSimpleComboComponent_igx_combo_item_22_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r42 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-combo-item\", 28);\n    i0.ɵɵlistener(\"click\", function IgxSimpleComboComponent_igx_combo_item_22_Template_igx_combo_item_click_0_listener() {\n      i0.ɵɵrestoreView(_r42);\n      const ctx_r41 = i0.ɵɵnextContext();\n      return ctx_r41.handleItemClick();\n    });\n    i0.ɵɵtemplate(1, IgxSimpleComboComponent_igx_combo_item_22_ng_container_1_Template, 2, 8, \"ng-container\", 9);\n    i0.ɵɵtemplate(2, IgxSimpleComboComponent_igx_combo_item_22_ng_container_2_Template, 2, 7, \"ng-container\", 9);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r32 = ctx.$implicit;\n    const rowIndex_r33 = ctx.index;\n    const ctx_r9 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"singleMode\", true)(\"itemHeight\", ctx_r9.itemHeight)(\"value\", item_r32)(\"isHeader\", item_r32.isHeader)(\"index\", rowIndex_r33);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", item_r32.isHeader);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !item_r32.isHeader);\n  }\n}\n\nfunction IgxSimpleComboComponent_div_26_div_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxSimpleComboComponent_div_26_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 33);\n    i0.ɵɵtemplate(1, IgxSimpleComboComponent_div_26_div_1_ng_container_1_Template, 1, 0, \"ng-container\", 14);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r43 = i0.ɵɵnextContext(2);\n\n    const _r16 = i0.ɵɵreference(33);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r43.emptyTemplate ? ctx_r43.emptyTemplate : _r16);\n  }\n}\n\nfunction IgxSimpleComboComponent_div_26_igx_combo_add_item_2_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxSimpleComboComponent_div_26_igx_combo_add_item_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-combo-add-item\", 34, 35);\n    i0.ɵɵtemplate(2, IgxSimpleComboComponent_div_26_igx_combo_add_item_2_ng_container_2_Template, 1, 0, \"ng-container\", 14);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r44 = i0.ɵɵnextContext(2);\n\n    const _r18 = i0.ɵɵreference(35);\n\n    i0.ɵɵproperty(\"itemHeight\", ctx_r44.itemHeight)(\"tabindex\", ctx_r44.dropdown.collapsed ? -1 : ctx_r44.customValueFlag ? 1 : -1)(\"index\", ctx_r44.virtualScrollContainer.igxForOf.length);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r44.addItemTemplate ? ctx_r44.addItemTemplate : _r18);\n  }\n}\n\nfunction IgxSimpleComboComponent_div_26_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 30);\n    i0.ɵɵtemplate(1, IgxSimpleComboComponent_div_26_div_1_Template, 2, 1, \"div\", 31);\n    i0.ɵɵtemplate(2, IgxSimpleComboComponent_div_26_igx_combo_add_item_2_Template, 3, 4, \"igx-combo-add-item\", 32);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r10 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r10.filteredData.length === 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r10.isAddButtonVisible());\n  }\n}\n\nfunction IgxSimpleComboComponent_ng_container_27_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxSimpleComboComponent_ng_template_28_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const display_r48 = ctx.$implicit;\n    const key_r50 = ctx.displayKey;\n    i0.ɵɵtextInterpolate1(\" \", display_r48[key_r50], \"\\n\");\n  }\n}\n\nfunction IgxSimpleComboComponent_ng_template_30_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const display_r51 = ctx.$implicit;\n    i0.ɵɵtextInterpolate1(\" \", display_r51, \"\\n\");\n  }\n}\n\nfunction IgxSimpleComboComponent_ng_template_32_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1, \"The list is empty\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxSimpleComboComponent_ng_template_34_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"button\", 36);\n    i0.ɵɵtext(1, \"Add item\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxSimpleComboComponent_ng_template_36_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const item_r53 = ctx.$implicit;\n    const key_r54 = ctx.valueKey;\n    i0.ɵɵtextInterpolate1(\" \", item_r53[key_r54], \"\\n\");\n  }\n}\n\nconst _c73 = function (a0, a1, a2, a3) {\n  return [a0, a1, a2, a3, true];\n};\n\nfunction IgxCalendarContainerComponent_ng_template_0_div_0_button_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 5, 6);\n    i0.ɵɵlistener(\"click\", function IgxCalendarContainerComponent_ng_template_0_div_0_button_1_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext(3);\n      return ctx_r7.calendarClose.emit({\n        owner: ctx_r7\n      });\n    });\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r4.closeButtonLabel, \" \");\n  }\n}\n\nfunction IgxCalendarContainerComponent_ng_template_0_div_0_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r11 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 5, 7);\n    i0.ɵɵlistener(\"click\", function IgxCalendarContainerComponent_ng_template_0_div_0_button_2_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r11);\n      const ctx_r10 = i0.ɵɵnextContext(3);\n      return ctx_r10.todaySelection.emit({\n        owner: ctx_r10\n      });\n    });\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r5.todayButtonLabel, \" \");\n  }\n}\n\nfunction IgxCalendarContainerComponent_ng_template_0_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 3);\n    i0.ɵɵtemplate(1, IgxCalendarContainerComponent_ng_template_0_div_0_button_1_Template, 3, 1, \"button\", 4);\n    i0.ɵɵtemplate(2, IgxCalendarContainerComponent_ng_template_0_div_0_button_2_Template, 3, 1, \"button\", 4);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.closeButtonLabel);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.todayButtonLabel);\n  }\n}\n\nfunction IgxCalendarContainerComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxCalendarContainerComponent_ng_template_0_div_0_Template, 3, 2, \"div\", 2);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.closeButtonLabel || ctx_r1.todayButtonLabel);\n  }\n}\n\nfunction IgxCalendarContainerComponent_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDatePickerComponent_igx_prefix_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-prefix\", 7);\n    i0.ɵɵlistener(\"click\", function IgxDatePickerComponent_igx_prefix_1_Template_igx_prefix_click_0_listener() {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return ctx_r2.toggle();\n    });\n    i0.ɵɵelementStart(1, \"igx-icon\", 8);\n    i0.ɵɵtext(2, \"today\");\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"title\", ctx_r0.value ? ctx_r0.pickerResourceStrings.igx_date_picker_change_date : ctx_r0.pickerResourceStrings.igx_date_picker_choose_date);\n  }\n}\n\nfunction IgxDatePickerComponent_igx_suffix_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-suffix\", 7);\n    i0.ɵɵlistener(\"click\", function IgxDatePickerComponent_igx_suffix_3_Template_igx_suffix_click_0_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r4 = i0.ɵɵnextContext();\n      return ctx_r4.clear();\n    });\n    i0.ɵɵelementStart(1, \"igx-icon\");\n    i0.ɵɵtext(2, \"clear\");\n    i0.ɵɵelementEnd()();\n  }\n}\n\nconst _c74 = [[[\"\", \"igxLabel\", \"\"]], [[\"igx-prefix\"], [\"\", \"igxPrefix\", \"\"]], [[\"igx-suffix\"], [\"\", \"igxSuffix\", \"\"]], [[\"igx-hint\"], [\"\", \"igxHint\", \"\"]]];\nconst _c75 = [\"[igxLabel]\", \"igx-prefix,[igxPrefix]\", \"igx-suffix,[igxSuffix]\", \"igx-hint,[igxHint]\"];\n\nfunction IgxDialogComponent_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 9);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"id\", ctx_r2.titleId);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r2.title, \" \");\n  }\n}\n\nfunction IgxDialogComponent_ng_content_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngIf\", \"!title\"]);\n  }\n}\n\nfunction IgxDialogComponent_span_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 10);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r4.message);\n  }\n}\n\nfunction IgxDialogComponent_ng_content_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 1, [\"*ngIf\", \"!message\"]);\n  }\n}\n\nfunction IgxDialogComponent_div_9_button_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r11 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 13);\n    i0.ɵɵlistener(\"click\", function IgxDialogComponent_div_9_button_1_Template_button_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r11);\n      const ctx_r10 = i0.ɵɵnextContext(2);\n      return ctx_r10.onInternalLeftButtonSelect($event);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext(2);\n    i0.ɵɵpropertyInterpolate(\"igxButtonColor\", ctx_r8.leftButtonColor);\n    i0.ɵɵpropertyInterpolate(\"igxButtonBackground\", ctx_r8.leftButtonBackgroundColor);\n    i0.ɵɵpropertyInterpolate(\"igxRipple\", ctx_r8.leftButtonRipple);\n    i0.ɵɵproperty(\"igxFocus\", ctx_r8.isOpen)(\"igxButton\", ctx_r8.leftButtonType);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r8.leftButtonLabel, \" \");\n  }\n}\n\nfunction IgxDialogComponent_div_9_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 13);\n    i0.ɵɵlistener(\"click\", function IgxDialogComponent_div_9_button_2_Template_button_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r13);\n      const ctx_r12 = i0.ɵɵnextContext(2);\n      return ctx_r12.onInternalRightButtonSelect($event);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵpropertyInterpolate(\"igxButtonColor\", ctx_r9.rightButtonColor);\n    i0.ɵɵpropertyInterpolate(\"igxButtonBackground\", ctx_r9.rightButtonBackgroundColor);\n    i0.ɵɵpropertyInterpolate(\"igxRipple\", ctx_r9.rightButtonRipple);\n    i0.ɵɵproperty(\"igxFocus\", ctx_r9.isOpen)(\"igxButton\", ctx_r9.rightButtonType);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r9.rightButtonLabel, \" \");\n  }\n}\n\nfunction IgxDialogComponent_div_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 11);\n    i0.ɵɵtemplate(1, IgxDialogComponent_div_9_button_1_Template, 2, 6, \"button\", 12);\n    i0.ɵɵtemplate(2, IgxDialogComponent_div_9_button_2_Template, 2, 6, \"button\", 12);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.leftButtonLabel);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.rightButtonLabel);\n  }\n}\n\nfunction IgxDialogComponent_ng_content_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 2, [\"*ngIf\", \"!leftButtonLabel && !rightButtonLabel\"]);\n  }\n}\n\nconst _c76 = [[[\"igx-dialog-title\"], [\"\", \"igxDialogTitle\", \"\"]], \"*\", [[\"igx-dialog-actions\"], [\"\", \"igxDialogActions\", \"\"]]];\nconst _c77 = [\"igx-dialog-title,[igxDialogTitle]\", \"*\", \"igx-dialog-actions,[igxDialogActions]\"];\n\nfunction IgxExcelStyleClearFiltersComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 1);\n    i0.ɵɵlistener(\"keydown\", function IgxExcelStyleClearFiltersComponent_div_0_Template_div_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r2);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return ctx_r1.onClearFilterKeyDown($event);\n    })(\"click\", function IgxExcelStyleClearFiltersComponent_div_0_Template_div_click_0_listener() {\n      i0.ɵɵrestoreView(_r2);\n      const ctx_r3 = i0.ɵɵnextContext();\n      return ctx_r3.clearFilter();\n    });\n    i0.ɵɵelementStart(1, \"span\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"igx-icon\");\n    i0.ɵɵtext(4, \"clear\");\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r0.clearFilterClass());\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r0.esf.grid.resourceStrings.igx_grid_excel_filter_clear);\n  }\n}\n\nconst _c78 = [\"input\"];\n\nfunction IgxSelectComponent_ng_container_11_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxSelectComponent_ng_container_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxSelectComponent_ng_container_11_ng_container_1_Template, 1, 0, \"ng-container\", 14);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r2.toggleIconTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c24, ctx_r2.collapsed));\n  }\n}\n\nfunction IgxSelectComponent_igx_icon_12_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r3.collapsed ? \"arrow_drop_down\" : \"arrow_drop_up\");\n  }\n}\n\nfunction IgxSelectComponent_div_16_ng_content_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 5, [\"*ngTemplateOutlet\", \"headerTemplate\"]);\n  }\n}\n\nfunction IgxSelectComponent_div_16_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 15);\n    i0.ɵɵtemplate(1, IgxSelectComponent_div_16_ng_content_1_Template, 1, 0, \"ng-content\", 16);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r4.headerTemplate);\n  }\n}\n\nfunction IgxSelectComponent_div_20_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxSelectComponent_div_20_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 17);\n    i0.ɵɵtemplate(1, IgxSelectComponent_div_20_ng_container_1_Template, 1, 0, \"ng-container\", 16);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r6.footerTemplate);\n  }\n}\n\nconst _c79 = [[[\"\", \"igxLabel\", \"\"]], [[\"igx-prefix\"], [\"\", \"igxPrefix\", \"\"]], [[\"igx-suffix\"], [\"\", \"igxSuffix\", \"\"]], [[\"igx-hint\"], [\"\", \"igxHint\", \"\"]], [[\"igx-select-item\"], [\"igx-select-item-group\"]], \"*\"];\nconst _c80 = [\"[igxLabel]\", \"igx-prefix,[igxPrefix]\", \"igx-suffix,[igxSuffix]\", \"igx-hint, [igxHint]\", \"igx-select-item, igx-select-item-group\", \"*\"];\nconst _c81 = [\"overlayOutlet\"];\nconst _c82 = [\"dropdownConditions\"];\nconst _c83 = [\"logicOperatorButtonGroup\"];\nconst _c84 = [\"inputValues\"];\n\nfunction IgxExcelStyleDefaultExpressionComponent_igx_icon_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-icon\", 13);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"name\", ctx_r1.getIconName());\n  }\n}\n\nfunction IgxExcelStyleDefaultExpressionComponent_igx_icon_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1, \"filter_list\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxExcelStyleDefaultExpressionComponent_igx_select_item_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-select-item\", 14)(1, \"div\", 15);\n    i0.ɵɵelement(2, \"igx-icon\", 13);\n    i0.ɵɵelementStart(3, \"span\", 16);\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const condition_r9 = ctx.$implicit;\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"value\", condition_r9)(\"text\", ctx_r3.getConditionFriendlyName(condition_r9))(\"selected\", ctx_r3.isConditionSelected(condition_r9));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"name\", ctx_r3.getCondition(condition_r9).iconName);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r3.translateCondition(condition_r9));\n  }\n}\n\nfunction IgxExcelStyleDefaultExpressionComponent_button_10_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r11 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 17);\n    i0.ɵɵlistener(\"click\", function IgxExcelStyleDefaultExpressionComponent_button_10_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r11);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return ctx_r10.onRemoveButtonClick();\n    });\n    i0.ɵɵelementStart(1, \"igx-icon\");\n    i0.ɵɵtext(2, \"cancel\");\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"displayDensity\", ctx_r6.displayDensity);\n  }\n}\n\nfunction IgxExcelStyleDefaultExpressionComponent_igx_buttongroup_11_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r16 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-buttongroup\", 18, 19)(2, \"span\", 20, 21);\n    i0.ɵɵlistener(\"keydown\", function IgxExcelStyleDefaultExpressionComponent_igx_buttongroup_11_Template_span_keydown_2_listener($event) {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r15 = i0.ɵɵnextContext();\n      return ctx_r15.onLogicOperatorKeyDown($event, 0);\n    })(\"click\", function IgxExcelStyleDefaultExpressionComponent_igx_buttongroup_11_Template_span_click_2_listener($event) {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r17 = i0.ɵɵnextContext();\n      return ctx_r17.onLogicOperatorButtonClicked($event, 0);\n    });\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"span\", 20, 22);\n    i0.ɵɵlistener(\"keydown\", function IgxExcelStyleDefaultExpressionComponent_igx_buttongroup_11_Template_span_keydown_5_listener($event) {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r18 = i0.ɵɵnextContext();\n      return ctx_r18.onLogicOperatorKeyDown($event, 1);\n    })(\"click\", function IgxExcelStyleDefaultExpressionComponent_igx_buttongroup_11_Template_span_click_5_listener($event) {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r19 = i0.ɵɵnextContext();\n      return ctx_r19.onLogicOperatorButtonClicked($event, 1);\n    });\n    i0.ɵɵtext(7);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"multiSelection\", false);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r7.displayDensity)(\"selected\", ctx_r7.expressionUI.afterOperator === 0);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r7.grid.resourceStrings.igx_grid_filter_operator_and, \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r7.displayDensity)(\"selected\", ctx_r7.expressionUI.afterOperator === 1);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r7.grid.resourceStrings.igx_grid_filter_operator_or, \" \");\n  }\n}\n\nconst _c85 = [\"hourList\"];\nconst _c86 = [\"minuteList\"];\nconst _c87 = [\"secondsList\"];\nconst _c88 = [\"ampmList\"];\n\nfunction IgxTimePickerComponent_igx_prefix_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-prefix\", 15);\n    i0.ɵɵlistener(\"click\", function IgxTimePickerComponent_igx_prefix_2_Template_igx_prefix_click_0_listener() {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return ctx_r11.toggle();\n    });\n    i0.ɵɵelementStart(1, \"igx-icon\", 16);\n    i0.ɵɵtext(2, \"access_time\");\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"title\", ctx_r0.value ? ctx_r0.resourceStrings.igx_time_picker_change_time : ctx_r0.resourceStrings.igx_time_picker_choose_time);\n  }\n}\n\nfunction IgxTimePickerComponent_igx_suffix_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r14 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-suffix\", 15);\n    i0.ɵɵlistener(\"click\", function IgxTimePickerComponent_igx_suffix_7_Template_igx_suffix_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r14);\n      const ctx_r13 = i0.ɵɵnextContext();\n      ctx_r13.clear();\n      return $event.stopPropagation();\n    });\n    i0.ɵɵelementStart(1, \"igx-icon\");\n    i0.ɵɵtext(2, \"clear\");\n    i0.ɵɵelementEnd()();\n  }\n}\n\nfunction IgxTimePickerComponent_ng_template_12_div_0_button_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r19 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 20);\n    i0.ɵɵlistener(\"click\", function IgxTimePickerComponent_ng_template_12_div_0_button_1_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r19);\n      const ctx_r18 = i0.ɵɵnextContext(3);\n      return ctx_r18.cancelButtonClick();\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r16.cancelButtonLabel, \" \");\n  }\n}\n\nfunction IgxTimePickerComponent_ng_template_12_div_0_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r21 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 20);\n    i0.ɵɵlistener(\"click\", function IgxTimePickerComponent_ng_template_12_div_0_button_2_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r21);\n      const ctx_r20 = i0.ɵɵnextContext(3);\n      return ctx_r20.okButtonClick();\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r17 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r17.okButtonLabel, \" \");\n  }\n}\n\nfunction IgxTimePickerComponent_ng_template_12_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 18);\n    i0.ɵɵtemplate(1, IgxTimePickerComponent_ng_template_12_div_0_button_1_Template, 2, 1, \"button\", 19);\n    i0.ɵɵtemplate(2, IgxTimePickerComponent_ng_template_12_div_0_button_2_Template, 2, 1, \"button\", 19);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r15 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r15.cancelButtonLabel);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r15.okButtonLabel);\n  }\n}\n\nfunction IgxTimePickerComponent_ng_template_12_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxTimePickerComponent_ng_template_12_div_0_Template, 3, 2, \"div\", 17);\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.cancelButtonLabel || ctx_r3.okButtonLabel);\n  }\n}\n\nfunction IgxTimePickerComponent_div_16_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 21)(1, \"h2\", 22)(2, \"span\");\n    i0.ɵɵtext(3);\n    i0.ɵɵpipe(4, \"timeFormatPipe\");\n    i0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(4, 1, ctx_r5.selectedDate));\n  }\n}\n\nfunction IgxTimePickerComponent_div_19_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 26, 27);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const hour_r24 = ctx.$implicit;\n\n    const _r25 = i0.ɵɵreference(1);\n\n    i0.ɵɵproperty(\"igxTimeItem\", hour_r24);\n    i0.ɵɵattribute(\"role\", _r25.isSelectedTime ? \"spinbutton\" : null)(\"aria-valuenow\", _r25.isSelectedTime ? _r25.hourValue : null)(\"aria-valuemin\", _r25.isSelectedTime ? _r25.minValue : null)(\"aria-valuemax\", _r25.isSelectedTime ? _r25.maxValue : null);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(hour_r24);\n  }\n}\n\nconst _c89 = function (a0, a2, a3, a4) {\n  return [a0, \"hour\", a2, a3, a4];\n};\n\nfunction IgxTimePickerComponent_div_19_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 23, 24);\n    i0.ɵɵtemplate(2, IgxTimePickerComponent_div_19_span_2_Template, 3, 6, \"span\", 25);\n    i0.ɵɵpipe(3, \"timeItemPipe\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"igxItemList\", \"hourList\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBindV(3, 2, i0.ɵɵpureFunction4(8, _c89, ctx_r6.hourItems, ctx_r6.selectedDate, ctx_r6.minDropdownValue, ctx_r6.maxDropdownValue)));\n  }\n}\n\nfunction IgxTimePickerComponent_div_20_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 30, 27);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const minute_r28 = ctx.$implicit;\n\n    const _r29 = i0.ɵɵreference(1);\n\n    i0.ɵɵproperty(\"igxTimeItem\", minute_r28);\n    i0.ɵɵattribute(\"role\", _r29.isSelectedTime ? \"spinbutton\" : null)(\"aria-valuenow\", _r29.isSelectedTime ? minute_r28 : null)(\"aria-valuemin\", _r29.isSelectedTime ? _r29.minValue : null)(\"aria-valuemax\", _r29.isSelectedTime ? _r29.maxValue : null);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(minute_r28);\n  }\n}\n\nconst _c90 = function (a0, a2, a3, a4) {\n  return [a0, \"minutes\", a2, a3, a4];\n};\n\nfunction IgxTimePickerComponent_div_20_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 23, 28);\n    i0.ɵɵtemplate(2, IgxTimePickerComponent_div_20_span_2_Template, 3, 6, \"span\", 29);\n    i0.ɵɵpipe(3, \"timeItemPipe\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"igxItemList\", \"minuteList\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBindV(3, 2, i0.ɵɵpureFunction4(8, _c90, ctx_r7.minuteItems, ctx_r7.selectedDate, ctx_r7.minDropdownValue, ctx_r7.maxDropdownValue)));\n  }\n}\n\nfunction IgxTimePickerComponent_div_21_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 33, 27);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const seconds_r32 = ctx.$implicit;\n\n    const _r33 = i0.ɵɵreference(1);\n\n    i0.ɵɵproperty(\"igxTimeItem\", seconds_r32);\n    i0.ɵɵattribute(\"role\", _r33.isSelectedTime ? \"spinbutton\" : null)(\"aria-valuenow\", _r33.isSelectedTime ? seconds_r32 : null)(\"aria-valuemin\", _r33.isSelectedTime ? _r33.minValue : null)(\"aria-valuemax\", _r33.isSelectedTime ? _r33.maxValue : null);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(seconds_r32);\n  }\n}\n\nconst _c91 = function (a0, a2, a3, a4) {\n  return [a0, \"seconds\", a2, a3, a4];\n};\n\nfunction IgxTimePickerComponent_div_21_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 23, 31);\n    i0.ɵɵtemplate(2, IgxTimePickerComponent_div_21_span_2_Template, 3, 6, \"span\", 32);\n    i0.ɵɵpipe(3, \"timeItemPipe\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"igxItemList\", \"secondsList\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBindV(3, 2, i0.ɵɵpureFunction4(8, _c91, ctx_r8.secondsItems, ctx_r8.selectedDate, ctx_r8.minDropdownValue, ctx_r8.maxDropdownValue)));\n  }\n}\n\nfunction IgxTimePickerComponent_div_22_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 36, 27);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ampm_r36 = ctx.$implicit;\n\n    const _r37 = i0.ɵɵreference(1);\n\n    i0.ɵɵproperty(\"igxTimeItem\", ampm_r36);\n    i0.ɵɵattribute(\"role\", _r37.isSelectedTime ? \"spinbutton\" : null)(\"aria-valuenow\", _r37.isSelectedTime ? ampm_r36 : null)(\"aria-valuemin\", _r37.isSelectedTime ? _r37.minValue : null)(\"aria-valuemax\", _r37.isSelectedTime ? _r37.maxValue : null);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ampm_r36);\n  }\n}\n\nconst _c92 = function (a0, a2, a3, a4) {\n  return [a0, \"ampm\", a2, a3, a4];\n};\n\nfunction IgxTimePickerComponent_div_22_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 23, 34);\n    i0.ɵɵtemplate(2, IgxTimePickerComponent_div_22_span_2_Template, 3, 6, \"span\", 35);\n    i0.ɵɵpipe(3, \"timeItemPipe\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"igxItemList\", \"ampmList\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBindV(3, 2, i0.ɵɵpureFunction4(8, _c92, ctx_r9.ampmItems, ctx_r9.selectedDate, ctx_r9.minDropdownValue, ctx_r9.maxDropdownValue)));\n  }\n}\n\nfunction IgxTimePickerComponent_ng_container_23_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nconst _c93 = function (a0, a1) {\n  return {\n    \"igx-time-picker--dropdown\": a0,\n    \"igx-time-picker--vertical\": a1\n  };\n};\n\nconst _c94 = [\"picker\"];\n\nfunction IgxExcelStyleDateExpressionComponent_igx_icon_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-icon\", 12);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"name\", ctx_r1.getIconName());\n  }\n}\n\nfunction IgxExcelStyleDateExpressionComponent_igx_icon_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1, \"filter_list\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxExcelStyleDateExpressionComponent_igx_select_item_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-select-item\", 13);\n    i0.ɵɵelement(1, \"igx-icon\", 12);\n    i0.ɵɵelementStart(2, \"span\");\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const condition_r10 = ctx.$implicit;\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"value\", condition_r10)(\"text\", ctx_r3.getConditionFriendlyName(condition_r10))(\"selected\", ctx_r3.isConditionSelected(condition_r10));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"name\", ctx_r3.getCondition(condition_r10).iconName);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r3.translateCondition(condition_r10));\n  }\n}\n\nfunction IgxExcelStyleDateExpressionComponent_igx_date_picker_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-date-picker\", 14, 15);\n    i0.ɵɵlistener(\"valueChange\", function IgxExcelStyleDateExpressionComponent_igx_date_picker_6_Template_igx_date_picker_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r13);\n      const ctx_r12 = i0.ɵɵnextContext();\n      return ctx_r12.expressionUI.expression.searchVal = $event;\n    })(\"click\", function IgxExcelStyleDateExpressionComponent_igx_date_picker_6_Template_igx_date_picker_click_0_listener() {\n      i0.ɵɵrestoreView(_r13);\n\n      const _r11 = i0.ɵɵreference(1);\n\n      return _r11.open();\n    });\n    i0.ɵɵelement(2, \"igx-picker-toggle\")(3, \"igx-picker-clear\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"value\", ctx_r4.expressionUI.expression.searchVal)(\"locale\", ctx_r4.grid.locale)(\"outlet\", ctx_r4.grid.outlet)(\"displayDensity\", ctx_r4.displayDensity)(\"readOnly\", true)(\"placeholder\", ctx_r4.inputDatePlaceholder)(\"displayFormat\", ctx_r4.column.pipeArgs.format)(\"formatter\", ctx_r4.column.formatter)(\"disabled\", ctx_r4.expressionUI.expression.condition && ctx_r4.expressionUI.expression.condition.isUnary);\n  }\n}\n\nfunction IgxExcelStyleDateExpressionComponent_igx_time_picker_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r17 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-time-picker\", 16, 15);\n    i0.ɵɵlistener(\"valueChange\", function IgxExcelStyleDateExpressionComponent_igx_time_picker_7_Template_igx_time_picker_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r17);\n      const ctx_r16 = i0.ɵɵnextContext();\n      return ctx_r16.expressionUI.expression.searchVal = $event;\n    })(\"click\", function IgxExcelStyleDateExpressionComponent_igx_time_picker_7_Template_igx_time_picker_click_0_listener() {\n      i0.ɵɵrestoreView(_r17);\n\n      const _r15 = i0.ɵɵreference(1);\n\n      return _r15.open();\n    });\n    i0.ɵɵelement(2, \"igx-picker-toggle\")(3, \"igx-picker-clear\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"inputFormat\", ctx_r5.column.defaultTimeFormat)(\"value\", ctx_r5.expressionUI.expression.searchVal)(\"locale\", ctx_r5.grid.locale)(\"outlet\", ctx_r5.grid.outlet)(\"displayDensity\", ctx_r5.displayDensity)(\"readOnly\", true)(\"placeholder\", ctx_r5.inputTimePlaceholder)(\"displayFormat\", ctx_r5.column.pipeArgs.format)(\"formatter\", ctx_r5.column.formatter)(\"disabled\", ctx_r5.expressionUI.expression.condition && ctx_r5.expressionUI.expression.condition.isUnary);\n  }\n}\n\nfunction IgxExcelStyleDateExpressionComponent_igx_input_group_8_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r23 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-input-group\", 17, 18)(3, \"input\", 19, 20);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxExcelStyleDateExpressionComponent_igx_input_group_8_Template_input_ngModelChange_3_listener($event) {\n      i0.ɵɵrestoreView(_r23);\n      const ctx_r22 = i0.ɵɵnextContext();\n      return ctx_r22.expressionUI.expression.searchVal = $event;\n    });\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"displayDensity\", ctx_r6.displayDensity);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"placeholder\", ctx_r6.inputDatePlaceholder)(\"igxDateTimeEditor\", ctx_r6.column.defaultDateTimeFormat)(\"ngModel\", ctx_r6.expressionUI.expression.searchVal)(\"disabled\", ctx_r6.expressionUI.expression.condition && ctx_r6.expressionUI.expression.condition.isUnary);\n  }\n}\n\nfunction IgxExcelStyleDateExpressionComponent_button_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r25 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 21);\n    i0.ɵɵlistener(\"click\", function IgxExcelStyleDateExpressionComponent_button_9_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r25);\n      const ctx_r24 = i0.ɵɵnextContext();\n      return ctx_r24.onRemoveButtonClick();\n    });\n    i0.ɵɵelementStart(1, \"igx-icon\");\n    i0.ɵɵtext(2, \"cancel\");\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"displayDensity\", ctx_r7.displayDensity);\n  }\n}\n\nfunction IgxExcelStyleDateExpressionComponent_igx_buttongroup_10_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r30 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-buttongroup\", 22, 23)(2, \"span\", 24, 25);\n    i0.ɵɵlistener(\"keydown\", function IgxExcelStyleDateExpressionComponent_igx_buttongroup_10_Template_span_keydown_2_listener($event) {\n      i0.ɵɵrestoreView(_r30);\n      const ctx_r29 = i0.ɵɵnextContext();\n      return ctx_r29.onLogicOperatorKeyDown($event, 0);\n    })(\"click\", function IgxExcelStyleDateExpressionComponent_igx_buttongroup_10_Template_span_click_2_listener($event) {\n      i0.ɵɵrestoreView(_r30);\n      const ctx_r31 = i0.ɵɵnextContext();\n      return ctx_r31.onLogicOperatorButtonClicked($event, 0);\n    });\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"span\", 24, 26);\n    i0.ɵɵlistener(\"keydown\", function IgxExcelStyleDateExpressionComponent_igx_buttongroup_10_Template_span_keydown_5_listener($event) {\n      i0.ɵɵrestoreView(_r30);\n      const ctx_r32 = i0.ɵɵnextContext();\n      return ctx_r32.onLogicOperatorKeyDown($event, 1);\n    })(\"click\", function IgxExcelStyleDateExpressionComponent_igx_buttongroup_10_Template_span_click_5_listener($event) {\n      i0.ɵɵrestoreView(_r30);\n      const ctx_r33 = i0.ɵɵnextContext();\n      return ctx_r33.onLogicOperatorButtonClicked($event, 1);\n    });\n    i0.ɵɵtext(7);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"multiSelection\", false);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r8.displayDensity)(\"selected\", ctx_r8.expressionUI.afterOperator === 0);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r8.grid.resourceStrings.igx_grid_filter_operator_and, \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r8.displayDensity)(\"selected\", ctx_r8.expressionUI.afterOperator === 1);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r8.grid.resourceStrings.igx_grid_filter_operator_or, \" \");\n  }\n}\n\nconst _c95 = [\"toggle\"];\nconst _c96 = [\"defaultExpressionTemplate\"];\nconst _c97 = [\"dateExpressionTemplate\"];\nconst _c98 = [\"expressionsContainer\"];\n\nfunction IgxExcelStyleCustomDialogComponent_ng_container_7_igx_excel_style_date_expression_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-excel-style-date-expression\", 15);\n    i0.ɵɵlistener(\"expressionRemoved\", function IgxExcelStyleCustomDialogComponent_ng_container_7_igx_excel_style_date_expression_1_Template_igx_excel_style_date_expression_expressionRemoved_0_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext(2);\n      return ctx_r6.onExpressionRemoved($event);\n    })(\"logicOperatorChanged\", function IgxExcelStyleCustomDialogComponent_ng_container_7_igx_excel_style_date_expression_1_Template_igx_excel_style_date_expression_logicOperatorChanged_0_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r8 = i0.ɵɵnextContext(2);\n      return ctx_r8.onLogicOperatorChanged($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const expression_r5 = ctx.$implicit;\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"expressionUI\", expression_r5)(\"column\", ctx_r4.column)(\"grid\", ctx_r4.grid)(\"displayDensity\", ctx_r4.displayDensity)(\"expressionsList\", ctx_r4.expressionsList);\n  }\n}\n\nfunction IgxExcelStyleCustomDialogComponent_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxExcelStyleCustomDialogComponent_ng_container_7_igx_excel_style_date_expression_1_Template, 1, 5, \"igx-excel-style-date-expression\", 14);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r2.expressionsList);\n  }\n}\n\nfunction IgxExcelStyleCustomDialogComponent_ng_container_8_igx_excel_style_default_expression_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-excel-style-default-expression\", 15);\n    i0.ɵɵlistener(\"expressionRemoved\", function IgxExcelStyleCustomDialogComponent_ng_container_8_igx_excel_style_default_expression_1_Template_igx_excel_style_default_expression_expressionRemoved_0_listener($event) {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r11 = i0.ɵɵnextContext(2);\n      return ctx_r11.onExpressionRemoved($event);\n    })(\"logicOperatorChanged\", function IgxExcelStyleCustomDialogComponent_ng_container_8_igx_excel_style_default_expression_1_Template_igx_excel_style_default_expression_logicOperatorChanged_0_listener($event) {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r13 = i0.ɵɵnextContext(2);\n      return ctx_r13.onLogicOperatorChanged($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const expression_r10 = ctx.$implicit;\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"expressionUI\", expression_r10)(\"column\", ctx_r9.column)(\"grid\", ctx_r9.grid)(\"displayDensity\", ctx_r9.displayDensity)(\"expressionsList\", ctx_r9.expressionsList);\n  }\n}\n\nfunction IgxExcelStyleCustomDialogComponent_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxExcelStyleCustomDialogComponent_ng_container_8_igx_excel_style_default_expression_1_Template, 1, 5, \"igx-excel-style-default-expression\", 14);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r3.expressionsList);\n  }\n}\n\nconst _c99 = function (a0, a1) {\n  return {\n    \"igx-excel-filter__secondary--cosy\": a0,\n    \"igx-excel-filter__secondary--compact\": a1\n  };\n};\n\nconst _c100 = [\"customDialog\"];\nconst _c101 = [\"subMenu\"];\n\nfunction IgxExcelStyleConditionalFilterComponent_ng_container_0_igx_drop_down_item_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-drop-down-item\", 7)(1, \"div\", 8);\n    i0.ɵɵelement(2, \"igx-icon\", 9);\n    i0.ɵɵelementStart(3, \"span\", 10);\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const condition_r5 = ctx.$implicit;\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"value\", condition_r5);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"name\", ctx_r2.getCondition(condition_r5).iconName);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r2.translateCondition(condition_r5));\n  }\n}\n\nfunction IgxExcelStyleConditionalFilterComponent_ng_container_0_igx_drop_down_item_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-drop-down-item\")(1, \"div\", 8)(2, \"igx-icon\");\n    i0.ɵɵtext(3, \"filter_list\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"span\", 10);\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(5);\n    i0.ɵɵtextInterpolate(ctx_r3.esf.grid.resourceStrings.igx_grid_excel_custom_filter);\n  }\n}\n\nfunction IgxExcelStyleConditionalFilterComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 1);\n    i0.ɵɵlistener(\"keydown\", function IgxExcelStyleConditionalFilterComponent_ng_container_0_Template_div_keydown_1_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.onTextFilterKeyDown($event);\n    })(\"click\", function IgxExcelStyleConditionalFilterComponent_ng_container_0_Template_div_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.onTextFilterClick($event);\n    });\n    i0.ɵɵelementStart(2, \"span\");\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"igx-icon\");\n    i0.ɵɵtext(5, \"keyboard_arrow_right\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(6, \"igx-drop-down\", 2, 3);\n    i0.ɵɵlistener(\"selectionChanging\", function IgxExcelStyleConditionalFilterComponent_ng_container_0_Template_igx_drop_down_selectionChanging_6_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return ctx_r9.onSubMenuSelection($event);\n    })(\"closed\", function IgxExcelStyleConditionalFilterComponent_ng_container_0_Template_igx_drop_down_closed_6_listener() {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return ctx_r10.onSubMenuClosed();\n    });\n    i0.ɵɵelementStart(8, \"div\");\n    i0.ɵɵtemplate(9, IgxExcelStyleConditionalFilterComponent_ng_container_0_igx_drop_down_item_9_Template, 5, 3, \"igx-drop-down-item\", 4);\n    i0.ɵɵtemplate(10, IgxExcelStyleConditionalFilterComponent_ng_container_0_igx_drop_down_item_10_Template, 6, 1, \"igx-drop-down-item\", 0);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelement(11, \"igx-excel-style-custom-dialog\", 5, 6);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const _r1 = i0.ɵɵreference(7);\n\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"igxDropDownItemNavigation\", _r1);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r0.subMenuText);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"maxHeight\", \"397px\")(\"displayDensity\", ctx_r0.esf.grid.displayDensity)(\"allowItemsFocus\", true);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.conditions);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.showCustomFilterItem());\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"column\", ctx_r0.esf.column)(\"filteringService\", ctx_r0.esf.grid.filteringService)(\"overlayComponentId\", ctx_r0.esf.overlayComponentId)(\"displayDensity\", ctx_r0.esf.grid.displayDensity);\n  }\n}\n\nfunction IgxExcelStyleHeaderComponent_header_0_button_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 5);\n    i0.ɵɵlistener(\"click\", function IgxExcelStyleHeaderComponent_header_0_button_4_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r4 = i0.ɵɵnextContext(2);\n      return ctx_r4.esf.onSelect();\n    });\n    i0.ɵɵelementStart(1, \"igx-icon\");\n    i0.ɵɵtext(2, \"done\");\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", ctx_r1.esf.column.selected ? \"igx-excel-filter__actions-selected\" : \"igx-excel-filter__actions-select\");\n    i0.ɵɵattribute(\"aria-label\", ctx_r1.esf.column.selected ? ctx_r1.esf.grid.resourceStrings.igx_grid_excel_deselect : ctx_r1.esf.grid.resourceStrings.igx_grid_excel_select);\n  }\n}\n\nfunction IgxExcelStyleHeaderComponent_header_0_button_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 6);\n    i0.ɵɵlistener(\"click\", function IgxExcelStyleHeaderComponent_header_0_button_5_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext(2);\n      return ctx_r6.esf.onPin();\n    });\n    i0.ɵɵelement(1, \"igx-icon\", 7);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵattribute(\"aria-label\", ctx_r2.esf.column.pinned ? ctx_r2.esf.grid.resourceStrings.igx_grid_excel_unpin : ctx_r2.esf.grid.resourceStrings.igx_grid_excel_pin);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"name\", ctx_r2.esf.column.pinned ? \"unpin-left\" : \"pin-left\");\n  }\n}\n\nfunction IgxExcelStyleHeaderComponent_header_0_button_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 6);\n    i0.ɵɵlistener(\"click\", function IgxExcelStyleHeaderComponent_header_0_button_6_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r8 = i0.ɵɵnextContext(2);\n      return ctx_r8.esf.onHideToggle();\n    });\n    i0.ɵɵelementStart(1, \"igx-icon\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵattribute(\"aria-label\", ctx_r3.esf.column.hidden ? ctx_r3.esf.grid.resourceStrings.igx_grid_excel_show : ctx_r3.esf.grid.resourceStrings.igx_grid_excel_hide);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r3.esf.column.hidden ? \"visibility\" : \"visibility_off\");\n  }\n}\n\nfunction IgxExcelStyleHeaderComponent_header_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"header\", 1)(1, \"h4\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"div\", 2);\n    i0.ɵɵtemplate(4, IgxExcelStyleHeaderComponent_header_0_button_4_Template, 3, 2, \"button\", 3);\n    i0.ɵɵtemplate(5, IgxExcelStyleHeaderComponent_header_0_button_5_Template, 2, 2, \"button\", 4);\n    i0.ɵɵtemplate(6, IgxExcelStyleHeaderComponent_header_0_button_6_Template, 3, 2, \"button\", 4);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r0.esf.column.header || ctx_r0.esf.column.field);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.showSelecting);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.showPinning);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.showHiding);\n  }\n}\n\nfunction IgxExcelStyleHidingComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 1);\n    i0.ɵɵlistener(\"click\", function IgxExcelStyleHidingComponent_div_0_Template_div_click_0_listener() {\n      i0.ɵɵrestoreView(_r2);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return ctx_r1.esf.onHideToggle();\n    });\n    i0.ɵɵelementStart(1, \"span\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"igx-icon\");\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r0.esf.column.hidden ? ctx_r0.esf.grid.resourceStrings.igx_grid_excel_show : ctx_r0.esf.grid.resourceStrings.igx_grid_excel_hide);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r0.esf.column.hidden ? \"visibility\" : \"visibility_off\");\n  }\n}\n\nfunction IgxExcelStyleMovingComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"header\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"igx-buttongroup\", 1)(4, \"button\", 2);\n    i0.ɵɵlistener(\"click\", function IgxExcelStyleMovingComponent_ng_container_0_Template_button_click_4_listener() {\n      i0.ɵɵrestoreView(_r2);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return ctx_r1.onMoveButtonClicked(0);\n    });\n    i0.ɵɵelementStart(5, \"igx-icon\");\n    i0.ɵɵtext(6, \"arrow_back\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(7, \"span\");\n    i0.ɵɵtext(8);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(9, \"button\", 2);\n    i0.ɵɵlistener(\"click\", function IgxExcelStyleMovingComponent_ng_container_0_Template_button_click_9_listener() {\n      i0.ɵɵrestoreView(_r2);\n      const ctx_r3 = i0.ɵɵnextContext();\n      return ctx_r3.onMoveButtonClicked(1);\n    });\n    i0.ɵɵelementStart(10, \"span\");\n    i0.ɵɵtext(11);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(12, \"igx-icon\");\n    i0.ɵɵtext(13, \"arrow_forwards\");\n    i0.ɵɵelementEnd()()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.esf.grid.resourceStrings.igx_grid_excel_filter_moving_header, \"\\n\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"multiSelection\", false);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r0.esf.grid.displayDensity)(\"disabled\", ctx_r0.canNotMoveLeft);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.esf.grid.displayDensity === \"compact\" ? ctx_r0.esf.grid.resourceStrings.igx_grid_excel_filter_moving_left_short : ctx_r0.esf.grid.resourceStrings.igx_grid_excel_filter_moving_left, \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r0.esf.grid.displayDensity)(\"disabled\", ctx_r0.canNotMoveRight);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.esf.grid.displayDensity === \"compact\" ? ctx_r0.esf.grid.resourceStrings.igx_grid_excel_filter_moving_right_short : ctx_r0.esf.grid.resourceStrings.igx_grid_excel_filter_moving_right, \" \");\n  }\n}\n\nfunction IgxExcelStylePinningComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 1);\n    i0.ɵɵlistener(\"click\", function IgxExcelStylePinningComponent_div_0_Template_div_click_0_listener() {\n      i0.ɵɵrestoreView(_r2);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return ctx_r1.esf.onPin();\n    });\n    i0.ɵɵelementStart(1, \"span\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(3, \"igx-icon\", 2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r0.esf.column.pinned ? \"igx-excel-filter__actions-unpin\" : \"igx-excel-filter__actions-pin\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r0.esf.column.pinned ? ctx_r0.esf.grid.resourceStrings.igx_grid_excel_unpin : ctx_r0.esf.grid.resourceStrings.igx_grid_excel_pin);\n    i0.ɵɵadvance(1);\n    i0.ɵɵpropertyInterpolate(\"name\", ctx_r0.esf.column.pinned ? \"unpin-left\" : \"pin-left\");\n  }\n}\n\nconst _c102 = [\"leftPanningTmpl\"];\nconst _c103 = [\"rightPanningTmpl\"];\n\nfunction IgxListItemComponent_div_0_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxListItemComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 7, 8);\n    i0.ɵɵtemplate(2, IgxListItemComponent_div_0_ng_container_2_Template, 1, 0, \"ng-container\", 9);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"width\", ctx_r0.element.offsetWidth, \"px\")(\"height\", ctx_r0.element.offsetHeight, \"px\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.list.listItemLeftPanningTemplate.template)(\"ngTemplateOutletContext\", ctx_r0.context);\n  }\n}\n\nfunction IgxListItemComponent_div_1_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxListItemComponent_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 10, 11);\n    i0.ɵɵtemplate(2, IgxListItemComponent_div_1_ng_container_2_Template, 1, 0, \"ng-container\", 9);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"width\", ctx_r1.element.offsetWidth, \"px\")(\"height\", ctx_r1.element.offsetHeight, \"px\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.list.listItemRightPanningTemplate.template)(\"ngTemplateOutletContext\", ctx_r1.context);\n  }\n}\n\nfunction IgxListItemComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0);\n  }\n}\n\nfunction IgxListItemComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 12);\n    i0.ɵɵprojection(1, 1);\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxListItemComponent_ng_template_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 13);\n    i0.ɵɵprojection(1, 2);\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxListItemComponent_ng_template_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 14);\n    i0.ɵɵprojection(1, 3);\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxListItemComponent_ng_container_10_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxListItemComponent_ng_container_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxListItemComponent_ng_container_10_ng_container_1_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r2 = i0.ɵɵreference(3);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r2);\n  }\n}\n\nfunction IgxListItemComponent_ng_container_11_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxListItemComponent_ng_container_11_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxListItemComponent_ng_container_11_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxListItemComponent_ng_container_11_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxListItemComponent_ng_container_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 16);\n    i0.ɵɵtemplate(2, IgxListItemComponent_ng_container_11_ng_container_2_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(3, IgxListItemComponent_ng_container_11_ng_container_3_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(4, IgxListItemComponent_ng_container_11_ng_container_4_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(5, IgxListItemComponent_ng_container_11_ng_container_5_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r4 = i0.ɵɵreference(5);\n\n    const _r6 = i0.ɵɵreference(7);\n\n    const _r8 = i0.ɵɵreference(9);\n\n    const _r2 = i0.ɵɵreference(3);\n\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r6);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r8);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r2);\n  }\n}\n\nconst _c104 = [\"*\", [[\"\", \"igxListThumbnail\", \"\"], [\"igx-list__item-thumbnail\"], [\"igx-avatar\"]], [[\"\", \"igxListLine\", \"\"], [\"\", 8, \"igx-list__item-lines\"], [\"\", \"igxListLineTitle\", \"\"], [\"\", \"igxListLineSubTitle\", \"\"], [\"\", 8, \"igx-list__item-line-title\"], [\"\", 8, \"igx-list__item-line-subtitle\"]], [[\"\", \"igxListAction\", \"\"], [\"\", 8, \"igx-list__item-actions\"]]];\nconst _c105 = [\"*\", \"[igxListThumbnail], igx-list__item-thumbnail, igx-avatar\", \"[igxListLine], .igx-list__item-lines, [igxListLineTitle], [igxListLineSubTitle], .igx-list__item-line-title, .igx-list__item-line-subtitle\", \"[igxListAction], .igx-list__item-actions\"];\nconst _c106 = [\"defaultEmptyList\"];\nconst _c107 = [\"defaultDataLoading\"];\n\nfunction IgxListComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"article\", 3);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.resourceStrings.igx_list_no_items, \" \");\n  }\n}\n\nfunction IgxListComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"article\", 3);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r3.resourceStrings.igx_list_loading, \" \");\n  }\n}\n\nfunction IgxListComponent_ng_container_5_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxListComponent_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxListComponent_ng_container_5_ng_container_1_Template, 1, 0, \"ng-container\", 4);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r4.template)(\"ngTemplateOutletContext\", ctx_r4.context);\n  }\n}\n\nconst _c108 = [\"indicator\"];\n\nconst _c109 = function (a0, a1, a2, a3, a4) {\n  return {\n    \"igx-linear-bar__value--start\": a0,\n    \"igx-linear-bar__value--center\": a1,\n    \"igx-linear-bar__value--end\": a2,\n    \"igx-linear-bar__value--top\": a3,\n    \"igx-linear-bar__value--hidden\": a4\n  };\n};\n\nconst _c110 = [\"circle\"];\n\nfunction IgxCircularProgressBarComponent__svg_text_5__svg_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxCircularProgressBarComponent__svg_text_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"text\", 9);\n    i0.ɵɵtemplate(1, IgxCircularProgressBarComponent__svg_text_5__svg_ng_container_1_Template, 1, 0, \"ng-container\", 6);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n\n    const _r4 = i0.ɵɵreference(9);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r2.textTemplate ? ctx_r2.textTemplate.template : _r4)(\"ngTemplateOutletContext\", ctx_r2.context);\n  }\n}\n\nfunction IgxCircularProgressBarComponent__svg_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxCircularProgressBarComponent__svg_ng_template_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"tspan\", 10);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r5.textContent ? ctx_r5.textContent : ctx_r5.valueInPercent + \"%\", \" \");\n  }\n}\n\nfunction IgxCircularProgressBarComponent__svg_ng_template_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"linearGradient\", 11);\n    i0.ɵɵelement(1, \"stop\", 12)(2, \"stop\", 13);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"id\", ctx_r7.gradientId);\n  }\n}\n\nconst _c111 = [\"ghostTemplate\"];\nconst _c112 = [\"childrenContainer\"];\n\nfunction IgxTreeNodeComponent_ng_template_0_0_ng_template_0_Template(rf, ctx) {}\n\nfunction IgxTreeNodeComponent_ng_template_0_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxTreeNodeComponent_ng_template_0_0_ng_template_0_Template, 0, 0, \"ng-template\");\n  }\n}\n\nfunction IgxTreeNodeComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxTreeNodeComponent_ng_template_0_0_Template, 1, 0, null, 1);\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r8 = i0.ɵɵreference(9);\n\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r8);\n  }\n}\n\nfunction IgxTreeNodeComponent_2_ng_template_0_Template(rf, ctx) {}\n\nfunction IgxTreeNodeComponent_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxTreeNodeComponent_2_ng_template_0_Template, 0, 0, \"ng-template\");\n  }\n}\n\nfunction IgxTreeNodeComponent_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 7, 8);\n    i0.ɵɵprojection(2);\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxTreeNodeComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"aria-label\", ctx_r5.expanded ? ctx_r5.resourceStrings.igx_collapse : ctx_r5.resourceStrings.igx_expand);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r5.expanded ? \"keyboard_arrow_down\" : \"keyboard_arrow_right\", \" \");\n  }\n}\n\nfunction IgxTreeNodeComponent_ng_template_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-checkbox\", 9);\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"checked\", ctx_r7.selected)(\"readonly\", true)(\"indeterminate\", ctx_r7.indeterminate)(\"tabindex\", -1);\n  }\n}\n\nfunction IgxTreeNodeComponent_ng_template_8_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 19);\n  }\n}\n\nfunction IgxTreeNodeComponent_ng_template_8_span_4_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nconst _c113 = function (a0) {\n  return {\n    \"igx-tree-node__toggle-button--hidden\": a0\n  };\n};\n\nfunction IgxTreeNodeComponent_ng_template_8_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r25 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 20);\n    i0.ɵɵlistener(\"click\", function IgxTreeNodeComponent_ng_template_8_span_4_Template_span_click_0_listener() {\n      i0.ɵɵrestoreView(_r25);\n      const ctx_r24 = i0.ɵɵnextContext(2);\n      return ctx_r24.indicatorClick();\n    });\n    i0.ɵɵtemplate(1, IgxTreeNodeComponent_ng_template_8_span_4_ng_container_1_Template, 1, 0, \"ng-container\", 21);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r18 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(3, _c113, !(ctx_r18._children == null ? null : ctx_r18._children.length)));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r18.expandIndicatorTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(5, _c24, ctx_r18.expanded));\n  }\n}\n\nfunction IgxTreeNodeComponent_ng_template_8_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 22);\n    i0.ɵɵelement(1, \"igx-circular-bar\", 23);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"animate\", false)(\"indeterminate\", true)(\"textVisibility\", false);\n  }\n}\n\nfunction IgxTreeNodeComponent_ng_template_8_div_6_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxTreeNodeComponent_ng_template_8_div_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r29 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 24);\n    i0.ɵɵlistener(\"pointerdown\", function IgxTreeNodeComponent_ng_template_8_div_6_Template_div_pointerdown_0_listener($event) {\n      return $event.preventDefault();\n    })(\"click\", function IgxTreeNodeComponent_ng_template_8_div_6_Template_div_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r28 = i0.ɵɵnextContext(2);\n      return ctx_r28.onSelectorClick($event);\n    });\n    i0.ɵɵtemplate(1, IgxTreeNodeComponent_ng_template_8_div_6_ng_container_1_Template, 1, 0, \"ng-container\", 1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n\n    const _r6 = i0.ɵɵreference(7);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r6);\n  }\n}\n\nfunction IgxTreeNodeComponent_ng_template_8_span_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 19);\n  }\n}\n\nconst _c114 = function (a0, a1, a2, a3, a4, a5) {\n  return {\n    \"igx-tree-node__wrapper--cosy\": a0,\n    \"igx-tree-node__wrapper--compact\": a1,\n    \"igx-tree-node__wrapper--selected\": a2,\n    \"igx-tree-node__wrapper--active\": a3,\n    \"igx-tree-node__wrapper--focused\": a4,\n    \"igx-tree-node__wrapper--disabled\": a5\n  };\n};\n\nconst _c115 = function () {\n  return [];\n};\n\nfunction IgxTreeNodeComponent_ng_template_8_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r32 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 10, 11);\n    i0.ɵɵlistener(\"pointerdown\", function IgxTreeNodeComponent_ng_template_8_Template_div_pointerdown_0_listener($event) {\n      i0.ɵɵrestoreView(_r32);\n      const ctx_r31 = i0.ɵɵnextContext();\n      return ctx_r31.onPointerDown($event);\n    })(\"focus\", function IgxTreeNodeComponent_ng_template_8_Template_div_focus_0_listener() {\n      i0.ɵɵrestoreView(_r32);\n      const ctx_r33 = i0.ɵɵnextContext();\n      return ctx_r33.handleFocus();\n    })(\"blur\", function IgxTreeNodeComponent_ng_template_8_Template_div_blur_0_listener() {\n      i0.ɵɵrestoreView(_r32);\n      const ctx_r34 = i0.ɵɵnextContext();\n      return ctx_r34.clearFocus();\n    });\n    i0.ɵɵelementStart(2, \"div\", 12);\n    i0.ɵɵtemplate(3, IgxTreeNodeComponent_ng_template_8_span_3_Template, 1, 0, \"span\", 13);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(4, IgxTreeNodeComponent_ng_template_8_span_4_Template, 2, 7, \"span\", 14);\n    i0.ɵɵtemplate(5, IgxTreeNodeComponent_ng_template_8_span_5_Template, 2, 3, \"span\", 15);\n    i0.ɵɵtemplate(6, IgxTreeNodeComponent_ng_template_8_div_6_Template, 2, 1, \"div\", 16);\n    i0.ɵɵelementStart(7, \"div\", 17);\n    i0.ɵɵprojection(8, 1);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(9, \"div\", 18);\n    i0.ɵɵtemplate(10, IgxTreeNodeComponent_ng_template_8_span_10_Template, 1, 0, \"span\", 13);\n    i0.ɵɵelement(11, \"div\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"tabIndex\", ctx_r9.tabIndex)(\"ngClass\", i0.ɵɵpureFunction6(8, _c114, ctx_r9.isCosy, ctx_r9.isCompact, ctx_r9.selected, ctx_r9.active, ctx_r9.focused, ctx_r9.disabled));\n    i0.ɵɵattribute(\"role\", ctx_r9.role);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpureFunction0(15, _c115).constructor(ctx_r9.level));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r9.loading);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r9.loading);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r9.showSelectors);\n    i0.ɵɵadvance(4);\n    i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpureFunction0(16, _c115).constructor(ctx_r9.level));\n  }\n}\n\nfunction IgxTreeNodeComponent_ng_template_10_1_ng_template_0_Template(rf, ctx) {}\n\nfunction IgxTreeNodeComponent_ng_template_10_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxTreeNodeComponent_ng_template_10_1_ng_template_0_Template, 0, 0, \"ng-template\");\n  }\n}\n\nfunction IgxTreeNodeComponent_ng_template_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 25);\n    i0.ɵɵtemplate(1, IgxTreeNodeComponent_ng_template_10_1_Template, 1, 0, null, 1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r8 = i0.ɵɵreference(9);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r8);\n  }\n}\n\nconst _c116 = [[[\"igx-tree-node\"]], \"*\"];\nconst _c117 = [\"igx-tree-node\", \"*\"];\nconst _c118 = [[[\"igx-tree-node\"]]];\nconst _c119 = [\"igx-tree-node\"];\nconst _c120 = [\"list\"];\nconst _c121 = [\"selectAllCheckbox\"];\nconst _c122 = [\"addToCurrentFilterCheckbox\"];\nconst _c123 = [\"tree\"];\nconst _c124 = [\"defaultExcelStyleLoadingValuesTemplate\"];\n\nfunction IgxExcelStyleSearchComponent_igx_icon_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-icon\", 14);\n    i0.ɵɵlistener(\"click\", function IgxExcelStyleSearchComponent_igx_icon_5_Template_igx_icon_click_0_listener() {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.clearInput();\n    });\n    i0.ɵɵtext(1, \" clear \");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_igx_list_6_igx_list_item_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r16 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-list-item\")(1, \"igx-checkbox\", 21);\n    i0.ɵɵlistener(\"change\", function IgxExcelStyleSearchComponent_igx_list_6_igx_list_item_3_Template_igx_checkbox_change_1_listener($event) {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r15 = i0.ɵɵnextContext(2);\n      return ctx_r15.onCheckboxChange($event);\n    });\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const item_r14 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"value\", item_r14)(\"tabindex\", -1)(\"checked\", item_r14 == null ? null : item_r14.isSelected)(\"disableRipple\", true)(\"indeterminate\", item_r14 == null ? null : item_r14.indeterminate)(\"disableTransitions\", true);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", item_r14.label, \" \");\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_igx_list_6_ng_template_4_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_igx_list_6_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 22);\n    i0.ɵɵtemplate(1, IgxExcelStyleSearchComponent_igx_list_6_ng_template_4_ng_container_1_Template, 1, 0, \"ng-container\", 23);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r12.valuesLoadingTemplate);\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_igx_list_6_ng_template_5_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_igx_list_6_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxExcelStyleSearchComponent_igx_list_6_ng_template_5_ng_container_0_Template, 1, 0, \"ng-container\", 23);\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n\n    const _r4 = i0.ɵɵreference(9);\n\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r4);\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_igx_list_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-list\", 15, 16)(2, \"div\", 17);\n    i0.ɵɵtemplate(3, IgxExcelStyleSearchComponent_igx_list_6_igx_list_item_3_Template, 3, 7, \"igx-list-item\", 18);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(4, IgxExcelStyleSearchComponent_igx_list_6_ng_template_4_Template, 2, 1, \"ng-template\", 19);\n    i0.ɵɵtemplate(5, IgxExcelStyleSearchComponent_igx_list_6_ng_template_5_Template, 1, 1, \"ng-template\", 20);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"displayDensity\", ctx_r2.esf.displayDensity)(\"isLoading\", ctx_r2.isLoading);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"igxForOf\", ctx_r2.displayedListData)(\"igxForScrollOrientation\", \"vertical\")(\"igxForContainerSize\", ctx_r2.containerSize)(\"igxForItemSize\", ctx_r2.itemSize);\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_div_7_div_1_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 31)(1, \"igx-checkbox\", 35, 36);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r25 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"value\", ctx_r25.addToCurrentFilterItem)(\"checked\", ctx_r25.addToCurrentFilterItem.isSelected)(\"disableRipple\", true)(\"disableTransitions\", true);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r25.addToCurrentFilterItem.label, \" \");\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_div_7_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r28 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 30)(1, \"div\", 31)(2, \"igx-checkbox\", 32, 33);\n    i0.ɵɵlistener(\"change\", function IgxExcelStyleSearchComponent_div_7_div_1_Template_igx_checkbox_change_2_listener($event) {\n      i0.ɵɵrestoreView(_r28);\n      const ctx_r27 = i0.ɵɵnextContext(2);\n      return ctx_r27.onSelectAllCheckboxChange($event);\n    });\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵtemplate(5, IgxExcelStyleSearchComponent_div_7_div_1_div_5_Template, 4, 5, \"div\", 34);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r19 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"value\", ctx_r19.selectAllItem)(\"checked\", ctx_r19.selectAllItem == null ? null : ctx_r19.selectAllItem.isSelected)(\"disableRipple\", true)(\"indeterminate\", ctx_r19.selectAllItem == null ? null : ctx_r19.selectAllItem.indeterminate)(\"disableTransitions\", true);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r19.selectAllItem.label, \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r19.searchValue);\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_div_7_igx_tree_node_4_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-tree-node\", 37)(1, \"div\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const childLevel9_r47 = ctx.$implicit;\n    i0.ɵɵproperty(\"data\", childLevel9_r47)(\"selected\", childLevel9_r47.isSelected);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(childLevel9_r47.label);\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_div_7_igx_tree_node_4_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-tree-node\", 37)(1, \"div\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, IgxExcelStyleSearchComponent_div_7_igx_tree_node_4_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_Template, 3, 3, \"igx-tree-node\", 28);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const childLevel8_r45 = ctx.$implicit;\n    i0.ɵɵproperty(\"data\", childLevel8_r45)(\"selected\", childLevel8_r45.isSelected);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(childLevel8_r45.label);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", childLevel8_r45.children);\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_div_7_igx_tree_node_4_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-tree-node\", 37)(1, \"div\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, IgxExcelStyleSearchComponent_div_7_igx_tree_node_4_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_Template, 4, 4, \"igx-tree-node\", 28);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const childLevel7_r43 = ctx.$implicit;\n    i0.ɵɵproperty(\"data\", childLevel7_r43)(\"selected\", childLevel7_r43.isSelected);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(childLevel7_r43.label);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", childLevel7_r43.children);\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_div_7_igx_tree_node_4_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-tree-node\", 37)(1, \"div\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, IgxExcelStyleSearchComponent_div_7_igx_tree_node_4_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_Template, 4, 4, \"igx-tree-node\", 28);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const childLevel6_r41 = ctx.$implicit;\n    i0.ɵɵproperty(\"data\", childLevel6_r41)(\"selected\", childLevel6_r41.isSelected);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(childLevel6_r41.label);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", childLevel6_r41.children);\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_div_7_igx_tree_node_4_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-tree-node\", 37)(1, \"div\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, IgxExcelStyleSearchComponent_div_7_igx_tree_node_4_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_Template, 4, 4, \"igx-tree-node\", 28);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const childLevel5_r39 = ctx.$implicit;\n    i0.ɵɵproperty(\"data\", childLevel5_r39)(\"selected\", childLevel5_r39.isSelected);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(childLevel5_r39.label);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", childLevel5_r39.children);\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_div_7_igx_tree_node_4_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-tree-node\", 37)(1, \"div\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, IgxExcelStyleSearchComponent_div_7_igx_tree_node_4_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_Template, 4, 4, \"igx-tree-node\", 28);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const childLevel4_r37 = ctx.$implicit;\n    i0.ɵɵproperty(\"data\", childLevel4_r37)(\"selected\", childLevel4_r37.isSelected);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(childLevel4_r37.label);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", childLevel4_r37.children);\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_div_7_igx_tree_node_4_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-tree-node\", 37)(1, \"div\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, IgxExcelStyleSearchComponent_div_7_igx_tree_node_4_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_Template, 4, 4, \"igx-tree-node\", 28);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const childLevel3_r35 = ctx.$implicit;\n    i0.ɵɵproperty(\"data\", childLevel3_r35)(\"selected\", childLevel3_r35.isSelected);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(childLevel3_r35.label);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", childLevel3_r35.children);\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_div_7_igx_tree_node_4_igx_tree_node_3_igx_tree_node_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-tree-node\", 37)(1, \"div\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, IgxExcelStyleSearchComponent_div_7_igx_tree_node_4_igx_tree_node_3_igx_tree_node_3_igx_tree_node_3_Template, 4, 4, \"igx-tree-node\", 28);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const childLevel2_r33 = ctx.$implicit;\n    i0.ɵɵproperty(\"data\", childLevel2_r33)(\"selected\", childLevel2_r33.isSelected);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(childLevel2_r33.label);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", childLevel2_r33.children);\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_div_7_igx_tree_node_4_igx_tree_node_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-tree-node\", 37)(1, \"div\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, IgxExcelStyleSearchComponent_div_7_igx_tree_node_4_igx_tree_node_3_igx_tree_node_3_Template, 4, 4, \"igx-tree-node\", 28);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const childLevel1_r31 = ctx.$implicit;\n    i0.ɵɵproperty(\"data\", childLevel1_r31)(\"selected\", childLevel1_r31.isSelected);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(childLevel1_r31.label);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", childLevel1_r31.children);\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_div_7_igx_tree_node_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-tree-node\", 37)(1, \"div\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, IgxExcelStyleSearchComponent_div_7_igx_tree_node_4_igx_tree_node_3_Template, 4, 4, \"igx-tree-node\", 28);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r29 = ctx.$implicit;\n    i0.ɵɵproperty(\"data\", item_r29)(\"selected\", item_r29.isSelected);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(item_r29.label);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", item_r29.children);\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_div_7_ng_template_5_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_div_7_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 22);\n    i0.ɵɵtemplate(1, IgxExcelStyleSearchComponent_div_7_ng_template_5_ng_container_1_Template, 1, 0, \"ng-container\", 23);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r22 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r22.valuesLoadingTemplate);\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_div_7_ng_template_6_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_div_7_ng_template_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxExcelStyleSearchComponent_div_7_ng_template_6_ng_container_0_Template, 1, 0, \"ng-container\", 23);\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n\n    const _r4 = i0.ɵɵreference(9);\n\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r4);\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_div_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r51 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 24);\n    i0.ɵɵtemplate(1, IgxExcelStyleSearchComponent_div_7_div_1_Template, 6, 7, \"div\", 25);\n    i0.ɵɵelementStart(2, \"igx-tree\", 26, 27);\n    i0.ɵɵlistener(\"nodeSelection\", function IgxExcelStyleSearchComponent_div_7_Template_igx_tree_nodeSelection_2_listener($event) {\n      i0.ɵɵrestoreView(_r51);\n      const ctx_r50 = i0.ɵɵnextContext();\n      return ctx_r50.onNodeSelectionChange($event);\n    });\n    i0.ɵɵtemplate(4, IgxExcelStyleSearchComponent_div_7_igx_tree_node_4_Template, 4, 4, \"igx-tree-node\", 28);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(5, IgxExcelStyleSearchComponent_div_7_ng_template_5_Template, 2, 1, \"ng-template\", 19);\n    i0.ɵɵtemplate(6, IgxExcelStyleSearchComponent_div_7_ng_template_6_Template, 1, 1, \"ng-template\", 29);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r3.isTreeEmpty());\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r3.esf.displayDensity);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r3.displayedListData);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.isTreeEmpty());\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_ng_template_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 38);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r5.esf.grid == null ? null : ctx_r5.esf.grid.resourceStrings.igx_grid_excel_no_matches, \" \");\n  }\n}\n\nfunction IgxExcelStyleSearchComponent_ng_template_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-circular-bar\", 39);\n  }\n\n  if (rf & 2) {\n    i0.ɵɵproperty(\"indeterminate\", true);\n  }\n}\n\nfunction IgxExcelStyleSelectingComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 1);\n    i0.ɵɵlistener(\"click\", function IgxExcelStyleSelectingComponent_div_0_Template_div_click_0_listener() {\n      i0.ɵɵrestoreView(_r2);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return ctx_r1.esf.onSelect();\n    });\n    i0.ɵɵelementStart(1, \"span\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"igx-icon\");\n    i0.ɵɵtext(4, \"done\");\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r0.esf.column.selected ? \"igx-excel-filter__actions-selected\" : \"igx-excel-filter__actions-select\");\n    i0.ɵɵattribute(\"aria-pressed\", ctx_r0.esf.column.selected);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r0.esf.grid.resourceStrings.igx_grid_excel_select);\n  }\n}\n\nconst _c125 = [\"sortButtonGroup\"];\n\nfunction IgxExcelStyleSortingComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"header\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"igx-buttongroup\", 1, 2)(5, \"button\", 3);\n    i0.ɵɵlistener(\"click\", function IgxExcelStyleSortingComponent_ng_container_0_Template_button_click_5_listener() {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return ctx_r2.onSortButtonClicked(1);\n    });\n    i0.ɵɵelementStart(6, \"igx-icon\");\n    i0.ɵɵtext(7, \"arrow_upwards\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(8, \"span\");\n    i0.ɵɵtext(9);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(10, \"button\", 3);\n    i0.ɵɵlistener(\"click\", function IgxExcelStyleSortingComponent_ng_container_0_Template_button_click_10_listener() {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r4 = i0.ɵɵnextContext();\n      return ctx_r4.onSortButtonClicked(2);\n    });\n    i0.ɵɵelementStart(11, \"igx-icon\");\n    i0.ɵɵtext(12, \"arrow_downwards\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(13, \"span\");\n    i0.ɵɵtext(14);\n    i0.ɵɵelementEnd()()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.esf.grid.resourceStrings.igx_grid_excel_filter_sorting_header, \"\\n\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"multiSelection\", false);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r0.esf.grid.displayDensity);\n    i0.ɵɵattribute(\"data-togglable\", true);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.esf.grid.displayDensity === \"compact\" ? ctx_r0.esf.grid.resourceStrings.igx_grid_excel_filter_sorting_asc_short : ctx_r0.esf.grid.resourceStrings.igx_grid_excel_filter_sorting_asc, \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r0.esf.grid.displayDensity);\n    i0.ɵɵattribute(\"data-togglable\", true);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.esf.grid.displayDensity === \"compact\" ? ctx_r0.esf.grid.resourceStrings.igx_grid_excel_filter_sorting_desc_short : ctx_r0.esf.grid.resourceStrings.igx_grid_excel_filter_sorting_desc, \" \");\n  }\n}\n\nconst _c126 = [\"mainDropdown\"];\nconst _c127 = [\"defaultExcelColumnOperations\"];\nconst _c128 = [\"defaultExcelFilterOperations\"];\n\nfunction IgxGridExcelStyleFilteringComponent_ng_template_0_igx_excel_style_sorting_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-excel-style-sorting\");\n  }\n}\n\nfunction IgxGridExcelStyleFilteringComponent_ng_template_0_igx_excel_style_moving_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-excel-style-moving\");\n  }\n}\n\nfunction IgxGridExcelStyleFilteringComponent_ng_template_0_igx_excel_style_pinning_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-excel-style-pinning\");\n  }\n}\n\nfunction IgxGridExcelStyleFilteringComponent_ng_template_0_igx_excel_style_hiding_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-excel-style-hiding\");\n  }\n}\n\nfunction IgxGridExcelStyleFilteringComponent_ng_template_0_igx_excel_style_selecting_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-excel-style-selecting\");\n  }\n}\n\nfunction IgxGridExcelStyleFilteringComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-excel-style-header\", 5);\n    i0.ɵɵtemplate(1, IgxGridExcelStyleFilteringComponent_ng_template_0_igx_excel_style_sorting_1_Template, 1, 0, \"igx-excel-style-sorting\", 6);\n    i0.ɵɵtemplate(2, IgxGridExcelStyleFilteringComponent_ng_template_0_igx_excel_style_moving_2_Template, 1, 0, \"igx-excel-style-moving\", 6);\n    i0.ɵɵtemplate(3, IgxGridExcelStyleFilteringComponent_ng_template_0_igx_excel_style_pinning_3_Template, 1, 0, \"igx-excel-style-pinning\", 6);\n    i0.ɵɵtemplate(4, IgxGridExcelStyleFilteringComponent_ng_template_0_igx_excel_style_hiding_4_Template, 1, 0, \"igx-excel-style-hiding\", 6);\n    i0.ɵɵtemplate(5, IgxGridExcelStyleFilteringComponent_ng_template_0_igx_excel_style_selecting_5_Template, 1, 0, \"igx-excel-style-selecting\", 6);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"showHiding\", ctx_r1.displayDensity !== \"comfortable\" && !(ctx_r1.column == null ? null : ctx_r1.column.disableHiding))(\"showPinning\", ctx_r1.displayDensity !== \"comfortable\" && !(ctx_r1.column == null ? null : ctx_r1.column.disablePinning))(\"showSelecting\", ctx_r1.displayDensity !== \"comfortable\" && ctx_r1.columnSelectable());\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.column == null ? null : ctx_r1.column.sortable);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.grid == null ? null : ctx_r1.grid.moving);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !(ctx_r1.column == null ? null : ctx_r1.column.disablePinning) && ctx_r1.displayDensity === \"comfortable\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !(ctx_r1.column == null ? null : ctx_r1.column.disableHiding) && ctx_r1.displayDensity === \"comfortable\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.columnSelectable() && ctx_r1.displayDensity === \"comfortable\");\n  }\n}\n\nfunction IgxGridExcelStyleFilteringComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-excel-style-clear-filters\")(1, \"igx-excel-style-conditional-filter\")(2, \"igx-excel-style-search\");\n  }\n}\n\nfunction IgxGridExcelStyleFilteringComponent_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵprojection(1);\n    i0.ɵɵelementContainerEnd();\n  }\n}\n\nfunction IgxGridExcelStyleFilteringComponent_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵprojection(1, 1);\n    i0.ɵɵelementContainerEnd();\n  }\n}\n\nconst _c129 = [[[\"igx-excel-style-column-operations\"], [\"\", \"igxExcelStyleColumnOperations\", \"\"]], [[\"igx-excel-style-filter-operations\"], [\"\", \"igxExcelStyleFilterOperations\", \"\"]]];\n\nconst _c130 = function (a0, a1) {\n  return {\n    \"igx-excel-filter__menu--cosy\": a0,\n    \"igx-excel-filter__menu--compact\": a1\n  };\n};\n\nconst _c131 = [\"igx-excel-style-column-operations,[igxExcelStyleColumnOperations]\", \"igx-excel-style-filter-operations,[igxExcelStyleFilterOperations]\"];\nconst _c132 = [[[\"igx-select-item\"]]];\nconst _c133 = [\"igx-select-item\"];\n\nfunction IgxGridToolbarAdvancedFilteringComponent_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.grid == null ? null : ctx_r1.grid.resourceStrings.igx_grid_toolbar_advanced_filtering_button_label);\n  }\n}\n\nfunction IgxGridToolbarComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 2);\n  }\n}\n\nfunction IgxGridToolbarComponent_igx_grid_toolbar_actions_5_igx_grid_toolbar_advanced_filtering_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-grid-toolbar-advanced-filtering\");\n  }\n}\n\nfunction IgxGridToolbarComponent_igx_grid_toolbar_actions_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-grid-toolbar-actions\");\n    i0.ɵɵtemplate(1, IgxGridToolbarComponent_igx_grid_toolbar_actions_5_igx_grid_toolbar_advanced_filtering_1_Template, 1, 0, \"igx-grid-toolbar-advanced-filtering\", 2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.grid.allowAdvancedFiltering);\n  }\n}\n\nfunction IgxGridToolbarComponent_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridToolbarComponent_div_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 5);\n    i0.ɵɵelement(1, \"igx-linear-bar\", 6);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"indeterminate\", true);\n  }\n}\n\nconst _c134 = [[[\"\", \"igxGridToolbarTitle\", \"\"], [\"igx-grid-toolbar-title\"]], \"*\", [[\"\", \"igxGridToolbarActions\", \"\"], [\"igx-grid-toolbar-actions\"]]];\nconst _c135 = [\"[igxGridToolbarTitle],igx-grid-toolbar-title\", \"*\", \"[igxGridToolbarActions],igx-grid-toolbar-actions\"];\n\nfunction IgxSummaryCellComponent_ng_container_0_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxSummaryCellComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxSummaryCellComponent_ng_container_0_ng_container_1_Template, 1, 0, \"ng-container\", 2);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n\n    const _r1 = i0.ɵɵreference(2);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.summaryTemplate ? ctx_r0.summaryTemplate : _r1)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c24, ctx_r0.summaryResults));\n  }\n}\n\nfunction IgxSummaryCellComponent_ng_template_1_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 4)(2, \"span\", 5);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"span\", 6);\n    i0.ɵɵtext(5);\n    i0.ɵɵpipe(6, \"summaryFormatter\");\n    i0.ɵɵpipe(7, \"number\");\n    i0.ɵɵpipe(8, \"date\");\n    i0.ɵɵpipe(9, \"currency\");\n    i0.ɵɵpipe(10, \"percent\");\n    i0.ɵɵpipe(11, \"number\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const summary_r5 = ctx.$implicit;\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"height\", ctx_r4.itemHeight, \"px\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"title\", summary_r5.label);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r4.translateSummary(summary_r5));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"title\", summary_r5.summaryResult);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r4.summaryFormatter ? i0.ɵɵpipeBind3(6, 6, summary_r5, ctx_r4.column.summaries, ctx_r4.summaryFormatter) : ctx_r4.isNumberColumn() && summary_r5.defaultFormatting ? i0.ɵɵpipeBind3(7, 10, summary_r5.summaryResult, ctx_r4.column.pipeArgs.digitsInfo, ctx_r4.grid.locale) : ctx_r4.isDateKindColumn() && summary_r5.defaultFormatting ? i0.ɵɵpipeBind4(8, 14, summary_r5.summaryResult, ctx_r4.column.pipeArgs.format, ctx_r4.column.pipeArgs.timezone, ctx_r4.grid.locale) : ctx_r4.isCurrencyColumn() && summary_r5.defaultFormatting ? i0.ɵɵpipeBindV(9, 19, i0.ɵɵpureFunction5(33, _c71, summary_r5.summaryResult, ctx_r4.currencyCode, ctx_r4.column.pipeArgs.display, ctx_r4.column.pipeArgs.digitsInfo, ctx_r4.grid.locale)) : ctx_r4.isPercentColumn() && summary_r5.defaultFormatting ? i0.ɵɵpipeBind3(10, 25, summary_r5.summaryResult, ctx_r4.column.pipeArgs.digitsInfo, ctx_r4.grid.locale) : summary_r5.key === \"count\" ? i0.ɵɵpipeBind3(11, 29, summary_r5.summaryResult, undefined, ctx_r4.grid.locale) : summary_r5.summaryResult, \" \");\n  }\n}\n\nfunction IgxSummaryCellComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxSummaryCellComponent_ng_template_1_ng_container_0_Template, 12, 39, \"ng-container\", 3);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngForOf\", ctx_r2.summaryResults);\n  }\n}\n\nfunction IgxSummaryRowComponent_ng_container_0_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 4);\n    i0.ɵɵlistener(\"pointerdown\", function IgxSummaryRowComponent_ng_container_0_ng_container_1_Template_div_pointerdown_1_listener($event) {\n      return $event.preventDefault();\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"min-width\", ctx_r3.grid.summariesMargin, \"px\")(\"flex-basis\", ctx_r3.grid.summariesMargin, \"px\");\n  }\n}\n\nfunction IgxSummaryRowComponent_ng_container_0_ng_container_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxSummaryRowComponent_ng_container_0_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxSummaryRowComponent_ng_container_0_ng_container_2_ng_container_1_Template, 1, 0, \"ng-container\", 5);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext(2);\n\n    const _r1 = i0.ɵɵreference(2);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r1)(\"ngTemplateOutletContext\", ctx_r4.getContext(ctx_r4));\n  }\n}\n\nfunction IgxSummaryRowComponent_ng_container_0_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-grid-summary-cell\", 6);\n    i0.ɵɵpipe(1, \"igxStringReplace\");\n  }\n\n  if (rf & 2) {\n    const col_r10 = ctx.$implicit;\n    const ctx_r6 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"max-height\", ctx_r6.minHeight, \"px\")(\"min-height\", ctx_r6.minHeight, \"px\")(\"min-width\", col_r10.getCellWidth())(\"max-width\", col_r10.getCellWidth())(\"flex-basis\", col_r10.getCellWidth());\n    i0.ɵɵclassProp(\"igx-grid-summary--cosy\", ctx_r6.grid.displayDensity === \"cosy\")(\"igx-grid-summary--compact\", ctx_r6.grid.displayDensity === \"compact\")(\"igx-grid-summary--empty\", !col_r10.hasSummary)(\"igx-grid-summary--pinned-last\", col_r10.isLastPinned);\n    i0.ɵɵproperty(\"column\", col_r10)(\"rowIndex\", ctx_r6.index)(\"firstCellIndentation\", ctx_r6.firstCellIndentation)(\"summaryResults\", ctx_r6.getColumnSummaries(col_r10.field))(\"summaryTemplate\", col_r10.summaryTemplate)(\"hasSummary\", col_r10.hasSummary)(\"density\", ctx_r6.grid.displayDensity)(\"summaryFormatter\", col_r10.summaryFormatter)(\"active\", ctx_r6.isCellActive(col_r10.visibleIndex));\n    i0.ɵɵattribute(\"aria-describedby\", i0.ɵɵpipeBind3(1, 28, ctx_r6.gridID + \"_\" + col_r10.field, \".\", \"_\"));\n  }\n}\n\nfunction IgxSummaryRowComponent_ng_container_0_ng_container_6_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxSummaryRowComponent_ng_container_0_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxSummaryRowComponent_ng_container_0_ng_container_6_ng_container_1_Template, 1, 0, \"ng-container\", 5);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext(2);\n\n    const _r1 = i0.ɵɵreference(2);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r1)(\"ngTemplateOutletContext\", ctx_r7.getContext(ctx_r7));\n  }\n}\n\nfunction IgxSummaryRowComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxSummaryRowComponent_ng_container_0_ng_container_1_Template, 2, 4, \"ng-container\", 0);\n    i0.ɵɵtemplate(2, IgxSummaryRowComponent_ng_container_0_ng_container_2_Template, 2, 2, \"ng-container\", 0);\n    i0.ɵɵtemplate(3, IgxSummaryRowComponent_ng_container_0_ng_template_3_Template, 2, 32, \"ng-template\", 2, 3, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵpipe(5, \"igxNotGrouped\");\n    i0.ɵɵtemplate(6, IgxSummaryRowComponent_ng_container_0_ng_container_6_Template, 2, 2, \"ng-container\", 0);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.grid.summariesMargin);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.pinnedColumns.length > 0 && ctx_r0.grid.isPinningToStart);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"igxGridForOf\", i0.ɵɵpipeBind1(5, 9, ctx_r0.unpinnedColumns))(\"igxForScrollContainer\", ctx_r0.grid.parentVirtDir)(\"igxForScrollOrientation\", \"horizontal\")(\"igxForContainerSize\", ctx_r0.grid.unpinnedWidth)(\"igxForTrackBy\", ctx_r0.grid.trackColumnChanges)(\"igxForSizePropName\", \"calcPixelWidth\");\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.pinnedColumns.length > 0 && !ctx_r0.grid.isPinningToStart);\n  }\n}\n\nfunction IgxSummaryRowComponent_ng_template_1_igx_grid_summary_cell_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-grid-summary-cell\", 8);\n    i0.ɵɵpipe(1, \"igxStringReplace\");\n  }\n\n  if (rf & 2) {\n    const col_r15 = ctx.$implicit;\n    const ctx_r14 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"max-height\", ctx_r14.minHeight, \"px\")(\"min-height\", ctx_r14.minHeight, \"px\")(\"min-width\", col_r15.getCellWidth())(\"max-width\", col_r15.getCellWidth())(\"flex-basis\", col_r15.getCellWidth())(\"left\", col_r15.rightPinnedOffset);\n    i0.ɵɵclassProp(\"igx-grid-summary--cosy\", ctx_r14.grid.displayDensity === \"cosy\")(\"igx-grid-summary--compact\", ctx_r14.grid.displayDensity === \"compact\")(\"igx-grid-summary--empty\", !col_r15.hasSummary)(\"igx-grid-summary--pinned-first\", col_r15.isFirstPinned)(\"igx-grid-summary--pinned-last\", col_r15.isLastPinned);\n    i0.ɵɵproperty(\"column\", col_r15)(\"firstCellIndentation\", ctx_r14.firstCellIndentation)(\"rowIndex\", ctx_r14.index)(\"summaryResults\", ctx_r14.getColumnSummaries(col_r15.field))(\"summaryTemplate\", col_r15.summaryTemplate)(\"hasSummary\", col_r15.hasSummary)(\"density\", ctx_r14.grid.displayDensity)(\"active\", ctx_r14.isCellActive(col_r15.visibleIndex));\n    i0.ɵɵattribute(\"aria-describedby\", i0.ɵɵpipeBind3(1, 31, ctx_r14.gridID + \"_\" + col_r15.field, \".\", \"_\"));\n  }\n}\n\nfunction IgxSummaryRowComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxSummaryRowComponent_ng_template_1_igx_grid_summary_cell_0_Template, 2, 35, \"igx-grid-summary-cell\", 7);\n    i0.ɵɵpipe(1, \"igxNotGrouped\");\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBind1(1, 1, ctx_r2.pinnedColumns));\n  }\n}\n\nconst _c136 = [\"columnSelect\"];\nconst _c137 = [\"conditionSelect\"];\nconst _c138 = [\"searchValueInput\"];\nconst _c139 = [\"addRootAndGroupButton\"];\nconst _c140 = [\"addConditionButton\"];\nconst _c141 = [\"editingInputsContainer\"];\nconst _c142 = [\"addModeContainer\"];\nconst _c143 = [\"currentGroupButtonsContainer\"];\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_container_13_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"button\", 23, 24);\n    i0.ɵɵlistener(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_13_Template_button_click_1_listener() {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r14 = i0.ɵɵnextContext(2);\n      return ctx_r14.addAndGroup();\n    });\n    i0.ɵɵelementStart(3, \"igx-icon\");\n    i0.ɵɵtext(4, \"add\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"span\");\n    i0.ɵɵtext(6);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(7, \"button\", 23);\n    i0.ɵɵlistener(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_13_Template_button_click_7_listener() {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r16 = i0.ɵɵnextContext(2);\n      return ctx_r16.addOrGroup();\n    });\n    i0.ɵɵelementStart(8, \"igx-icon\");\n    i0.ɵɵtext(9, \"add\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(10, \"span\");\n    i0.ɵɵtext(11);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(12, \"div\", 25)(13, \"h6\", 26);\n    i0.ɵɵtext(14);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r3.displayDensity);\n    i0.ɵɵadvance(5);\n    i0.ɵɵtextInterpolate(ctx_r3.grid.resourceStrings.igx_grid_advanced_filter_and_group);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r3.displayDensity);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate(ctx_r3.grid.resourceStrings.igx_grid_advanced_filter_or_group);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r3.grid.resourceStrings.igx_grid_advanced_filter_initial_text, \" \");\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_template_14_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r21 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 27, 28);\n    i0.ɵɵlistener(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_14_Template_button_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r21);\n      const expressionItem_r17 = restoredCtx.$implicit;\n      const afterExpression_r18 = restoredCtx.afterExpression;\n      const ctx_r20 = i0.ɵɵnextContext(2);\n      return ctx_r20.addCondition(expressionItem_r17, afterExpression_r18);\n    });\n    i0.ɵɵelementStart(2, \"igx-icon\");\n    i0.ɵɵtext(3, \"add\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"span\");\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(6, \"button\", 27);\n    i0.ɵɵlistener(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_14_Template_button_click_6_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r21);\n      const expressionItem_r17 = restoredCtx.$implicit;\n      const afterExpression_r18 = restoredCtx.afterExpression;\n      const ctx_r22 = i0.ɵɵnextContext(2);\n      return ctx_r22.addAndGroup(expressionItem_r17, afterExpression_r18);\n    });\n    i0.ɵɵelementStart(7, \"igx-icon\");\n    i0.ɵɵtext(8, \"add\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(9, \"span\");\n    i0.ɵɵtext(10);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(11, \"button\", 27);\n    i0.ɵɵlistener(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_14_Template_button_click_11_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r21);\n      const expressionItem_r17 = restoredCtx.$implicit;\n      const afterExpression_r18 = restoredCtx.afterExpression;\n      const ctx_r23 = i0.ɵɵnextContext(2);\n      return ctx_r23.addOrGroup(expressionItem_r17, afterExpression_r18);\n    });\n    i0.ɵɵelementStart(12, \"igx-icon\");\n    i0.ɵɵtext(13, \"add\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(14, \"span\");\n    i0.ɵɵtext(15);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r5.displayDensity)(\"disabled\", ctx_r5.hasEditedExpression);\n    i0.ɵɵadvance(5);\n    i0.ɵɵtextInterpolate(ctx_r5.grid.resourceStrings.igx_grid_advanced_filter_add_condition);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r5.displayDensity)(\"disabled\", ctx_r5.hasEditedExpression);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate(ctx_r5.grid.resourceStrings.igx_grid_advanced_filter_and_group);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r5.displayDensity)(\"disabled\", ctx_r5.hasEditedExpression);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate(ctx_r5.grid.resourceStrings.igx_grid_advanced_filter_or_group);\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_span_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 39);\n    i0.ɵɵtext(1);\n    i0.ɵɵpipe(2, \"columnFormatter\");\n    i0.ɵɵpipe(3, \"date\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const expressionItem_r24 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r28 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r28.isDate(expressionItem_r24.expression.searchVal) ? ctx_r28.getFormatter(expressionItem_r24.expression.fieldName) ? i0.ɵɵpipeBind3(2, 1, expressionItem_r24.expression.searchVal, ctx_r28.getFormatter(expressionItem_r24.expression.fieldName), undefined) : i0.ɵɵpipeBind4(3, 5, expressionItem_r24.expression.searchVal, ctx_r28.getFormat(expressionItem_r24.expression.fieldName), undefined, ctx_r28.grid.locale) : expressionItem_r24.expression.searchVal, \" \");\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_9_igx_icon_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r33 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-icon\", 41);\n    i0.ɵɵlistener(\"keydown\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_9_igx_icon_3_Template_igx_icon_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r32 = i0.ɵɵnextContext(5);\n      return ctx_r32.invokeClick($event);\n    })(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_9_igx_icon_3_Template_igx_icon_click_0_listener() {\n      i0.ɵɵrestoreView(_r33);\n      const expressionItem_r24 = i0.ɵɵnextContext(3).$implicit;\n      const ctx_r34 = i0.ɵɵnextContext(2);\n      return ctx_r34.enterExpressionAdd(expressionItem_r24);\n    });\n    i0.ɵɵtext(1, \" add \");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r37 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 40)(1, \"igx-icon\", 41);\n    i0.ɵɵlistener(\"keydown\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_9_Template_igx_icon_keydown_1_listener($event) {\n      i0.ɵɵrestoreView(_r37);\n      const ctx_r36 = i0.ɵɵnextContext(4);\n      return ctx_r36.invokeClick($event);\n    })(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_9_Template_igx_icon_click_1_listener() {\n      i0.ɵɵrestoreView(_r37);\n      const expressionItem_r24 = i0.ɵɵnextContext(2).$implicit;\n      const ctx_r38 = i0.ɵɵnextContext(2);\n      return ctx_r38.enterExpressionEdit(expressionItem_r24);\n    });\n    i0.ɵɵtext(2, \" edit \");\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_9_igx_icon_3_Template, 2, 0, \"igx-icon\", 42);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const expressionItem_r24 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r29 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", !expressionItem_r24.inAddMode && (expressionItem_r24.parent !== ctx_r29.currentGroup || expressionItem_r24 !== ctx_r29.currentGroup.children[ctx_r29.currentGroup.children.length - 1]));\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r43 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 32);\n    i0.ɵɵlistener(\"mouseenter\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template_div_mouseenter_0_listener() {\n      i0.ɵɵrestoreView(_r43);\n      const expressionItem_r24 = i0.ɵɵnextContext().$implicit;\n      return expressionItem_r24.hovered = true;\n    })(\"mouseleave\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template_div_mouseleave_0_listener() {\n      i0.ɵɵrestoreView(_r43);\n      const expressionItem_r24 = i0.ɵɵnextContext().$implicit;\n      return expressionItem_r24.hovered = false;\n    });\n    i0.ɵɵelementStart(1, \"igx-chip\", 33);\n    i0.ɵɵlistener(\"keydown\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template_igx_chip_keydown_1_listener($event) {\n      i0.ɵɵrestoreView(_r43);\n      const ctx_r46 = i0.ɵɵnextContext(3);\n      return ctx_r46.invokeClick($event);\n    })(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template_igx_chip_click_1_listener() {\n      i0.ɵɵrestoreView(_r43);\n      const expressionItem_r24 = i0.ɵɵnextContext().$implicit;\n      const ctx_r47 = i0.ɵɵnextContext(2);\n      return ctx_r47.onChipClick(expressionItem_r24);\n    })(\"dblclick\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template_igx_chip_dblclick_1_listener() {\n      i0.ɵɵrestoreView(_r43);\n      const expressionItem_r24 = i0.ɵɵnextContext().$implicit;\n      const ctx_r49 = i0.ɵɵnextContext(2);\n      return ctx_r49.onChipDblClick(expressionItem_r24);\n    })(\"remove\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template_igx_chip_remove_1_listener() {\n      i0.ɵɵrestoreView(_r43);\n      const expressionItem_r24 = i0.ɵɵnextContext().$implicit;\n      const ctx_r51 = i0.ɵɵnextContext(2);\n      return ctx_r51.onChipRemove(expressionItem_r24);\n    })(\"selectedChanged\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template_igx_chip_selectedChanged_1_listener() {\n      i0.ɵɵrestoreView(_r43);\n      const ctx_r53 = i0.ɵɵnextContext(3);\n      return ctx_r53.onChipSelectionEnd();\n    });\n    i0.ɵɵelementStart(2, \"span\", 34);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"igx-prefix\");\n    i0.ɵɵelement(5, \"igx-icon\", 35);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(6, \"span\", 36);\n    i0.ɵɵtext(7);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(8, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_span_8_Template, 4, 10, \"span\", 37);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(9, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_9_Template, 4, 1, \"div\", 38);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const expressionItem_r24 = i0.ɵɵnextContext().$implicit;\n    const ctx_r25 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"data\", expressionItem_r24)(\"displayDensity\", ctx_r25.displayDensity === \"compact\" ? \"cosy\" : ctx_r25.displayDensity)(\"removable\", true)(\"selected\", expressionItem_r24.selected);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(expressionItem_r24.columnHeader || expressionItem_r24.expression.fieldName);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"name\", expressionItem_r24.expression.condition.iconName);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r25.getConditionFriendlyName(expressionItem_r24.expression.condition.name), \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !expressionItem_r24.expression.condition.isUnary);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", expressionItem_r24.selected && ctx_r25.selectedExpressions.length === 1 || expressionItem_r24.hovered);\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_select_item_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-select-item\", 58);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const column_r65 = ctx.$implicit;\n    i0.ɵɵproperty(\"value\", column_r65);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", column_r65.header || column_r65.field, \" \");\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_prefix_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-prefix\");\n    i0.ɵɵelement(1, \"igx-icon\", 35);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r58 = i0.ɵɵreference(6);\n\n    const ctx_r59 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"name\", ctx_r59.selectedColumn.filters.condition(_r58.value).iconName);\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_select_item_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-select-item\", 59)(1, \"div\", 60);\n    i0.ɵɵelement(2, \"igx-icon\", 35);\n    i0.ɵɵelementStart(3, \"span\", 61);\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const condition_r66 = ctx.$implicit;\n    const ctx_r60 = i0.ɵɵnextContext(4);\n    i0.ɵɵproperty(\"value\", condition_r66)(\"text\", ctx_r60.getConditionFriendlyName(condition_r66));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"name\", ctx_r60.selectedColumn.filters.condition(condition_r66).iconName);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r60.getConditionFriendlyName(condition_r66));\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_input_group_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r69 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-input-group\", 62)(1, \"input\", 63, 64);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_input_group_9_Template_input_ngModelChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r69);\n      const ctx_r68 = i0.ɵɵnextContext(4);\n      return ctx_r68.searchValue = $event;\n    });\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r61 = i0.ɵɵnextContext(4);\n    i0.ɵɵproperty(\"displayDensity\", \"compact\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"disabled\", !ctx_r61.selectedColumn || !ctx_r61.selectedCondition || ctx_r61.selectedColumn && ctx_r61.selectedColumn.filters.condition(ctx_r61.selectedCondition).isUnary)(\"type\", ctx_r61.selectedColumn && ctx_r61.selectedColumn.dataType === \"number\" ? \"number\" : \"text\")(\"placeholder\", ctx_r61.grid.resourceStrings.igx_grid_advanced_filter_value_placeholder)(\"ngModel\", ctx_r61.searchValue);\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_date_picker_10_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r72 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-date-picker\", 65, 66);\n    i0.ɵɵlistener(\"valueChange\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_date_picker_10_Template_igx_date_picker_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r72);\n      const ctx_r71 = i0.ɵɵnextContext(4);\n      return ctx_r71.searchValue = $event;\n    })(\"keydown\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_date_picker_10_Template_igx_date_picker_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r72);\n      const ctx_r73 = i0.ɵɵnextContext(4);\n      return ctx_r73.openPicker($event);\n    })(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_date_picker_10_Template_igx_date_picker_click_0_listener() {\n      i0.ɵɵrestoreView(_r72);\n\n      const _r70 = i0.ɵɵreference(1);\n\n      return _r70.open();\n    });\n    i0.ɵɵelement(2, \"igx-picker-toggle\")(3, \"igx-picker-clear\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r62 = i0.ɵɵnextContext(4);\n    i0.ɵɵproperty(\"value\", ctx_r62.searchValue)(\"formatter\", ctx_r62.selectedColumn.formatter)(\"displayFormat\", ctx_r62.selectedColumn.pipeArgs.format)(\"readOnly\", true)(\"displayDensity\", \"compact\")(\"locale\", ctx_r62.grid.locale)(\"outlet\", ctx_r62.grid.outlet)(\"displayFormat\", ctx_r62.selectedColumn.pipeArgs.format)(\"placeholder\", ctx_r62.grid.resourceStrings.igx_grid_filter_row_date_placeholder)(\"disabled\", !ctx_r62.selectedColumn || !ctx_r62.selectedCondition || ctx_r62.selectedColumn && ctx_r62.selectedColumn.filters.condition(ctx_r62.selectedCondition).isUnary);\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_time_picker_11_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r77 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-time-picker\", 67, 66);\n    i0.ɵɵlistener(\"valueChange\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_time_picker_11_Template_igx_time_picker_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r77);\n      const ctx_r76 = i0.ɵɵnextContext(4);\n      return ctx_r76.searchValue = $event;\n    })(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_time_picker_11_Template_igx_time_picker_click_0_listener() {\n      i0.ɵɵrestoreView(_r77);\n\n      const _r75 = i0.ɵɵreference(1);\n\n      return _r75.open();\n    })(\"keydown\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_time_picker_11_Template_igx_time_picker_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r77);\n      const ctx_r79 = i0.ɵɵnextContext(4);\n      return ctx_r79.openPicker($event);\n    });\n    i0.ɵɵelement(2, \"igx-picker-toggle\")(3, \"igx-picker-clear\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r63 = i0.ɵɵnextContext(4);\n    i0.ɵɵproperty(\"inputFormat\", ctx_r63.selectedColumn.defaultTimeFormat)(\"value\", ctx_r63.searchValue)(\"formatter\", ctx_r63.selectedColumn.formatter)(\"locale\", ctx_r63.grid.locale)(\"outlet\", ctx_r63.grid.outlet)(\"displayDensity\", \"compact\")(\"placeholder\", ctx_r63.grid.resourceStrings.igx_grid_filter_row_time_placeholder)(\"readOnly\", true)(\"disabled\", !ctx_r63.selectedColumn || !ctx_r63.selectedCondition || ctx_r63.selectedColumn && ctx_r63.selectedColumn.filters.condition(ctx_r63.selectedCondition).isUnary);\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_input_group_12_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r83 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-input-group\", 68, 69)(2, \"input\", 70, 71);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_input_group_12_Template_input_ngModelChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r83);\n      const ctx_r82 = i0.ɵɵnextContext(4);\n      return ctx_r82.searchValue = $event;\n    });\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r64 = i0.ɵɵnextContext(4);\n    i0.ɵɵproperty(\"displayDensity\", \"compact\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"placeholder\", ctx_r64.grid.resourceStrings.igx_grid_filter_row_date_placeholder)(\"igxDateTimeEditor\", ctx_r64.selectedColumn.defaultDateTimeFormat)(\"ngModel\", ctx_r64.searchValue)(\"disabled\", !ctx_r64.selectedColumn || !ctx_r64.selectedCondition || ctx_r64.selectedColumn && ctx_r64.selectedColumn.filters.condition(ctx_r64.selectedCondition).isUnary);\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r85 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 43, 44)(2, \"igx-select\", 45, 46);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_Template_igx_select_ngModelChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r85);\n      const ctx_r84 = i0.ɵɵnextContext(3);\n      return ctx_r84.selectedColumn = $event;\n    });\n    i0.ɵɵtemplate(4, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_select_item_4_Template, 2, 2, \"igx-select-item\", 47);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"igx-select\", 48, 49);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_Template_igx_select_ngModelChange_5_listener($event) {\n      i0.ɵɵrestoreView(_r85);\n      const ctx_r86 = i0.ɵɵnextContext(3);\n      return ctx_r86.selectedCondition = $event;\n    });\n    i0.ɵɵtemplate(7, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_prefix_7_Template, 2, 1, \"igx-prefix\", 11);\n    i0.ɵɵtemplate(8, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_select_item_8_Template, 5, 4, \"igx-select-item\", 50);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(9, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_input_group_9_Template, 3, 5, \"igx-input-group\", 51);\n    i0.ɵɵtemplate(10, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_date_picker_10_Template, 4, 10, \"igx-date-picker\", 52);\n    i0.ɵɵtemplate(11, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_time_picker_11_Template, 4, 9, \"igx-time-picker\", 53);\n    i0.ɵɵtemplate(12, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_input_group_12_Template, 4, 5, \"igx-input-group\", 54);\n    i0.ɵɵelementStart(13, \"div\", 55)(14, \"button\", 56);\n    i0.ɵɵlistener(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_Template_button_click_14_listener() {\n      i0.ɵɵrestoreView(_r85);\n      const ctx_r87 = i0.ɵɵnextContext(3);\n      return ctx_r87.commitOperandEdit();\n    });\n    i0.ɵɵelementStart(15, \"igx-icon\");\n    i0.ɵɵtext(16, \"check\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(17, \"button\", 57);\n    i0.ɵɵlistener(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_Template_button_click_17_listener() {\n      i0.ɵɵrestoreView(_r85);\n      const ctx_r88 = i0.ɵɵnextContext(3);\n      return ctx_r88.cancelOperandEdit();\n    });\n    i0.ɵɵelementStart(18, \"igx-icon\");\n    i0.ɵɵtext(19, \"close\");\n    i0.ɵɵelementEnd()()()();\n  }\n\n  if (rf & 2) {\n    const _r58 = i0.ɵɵreference(6);\n\n    const ctx_r26 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"displayDensity\", \"compact\")(\"overlaySettings\", ctx_r26.columnSelectOverlaySettings)(\"placeholder\", ctx_r26.grid.resourceStrings.igx_grid_advanced_filter_column_placeholder)(\"ngModel\", ctx_r26.selectedColumn);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r26.filterableColumns);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", \"compact\")(\"overlaySettings\", ctx_r26.conditionSelectOverlaySettings)(\"placeholder\", ctx_r26.grid.resourceStrings.igx_grid_filter_condition_placeholder)(\"ngModel\", ctx_r26.selectedCondition)(\"disabled\", !ctx_r26.selectedColumn);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r26.selectedColumn && _r58.value && ctx_r26.selectedColumn.filters.condition(_r58.value));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r26.getConditionList());\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r26.selectedColumn || ctx_r26.selectedColumn.dataType !== \"date\" && ctx_r26.selectedColumn.dataType !== \"time\" && ctx_r26.selectedColumn.dataType !== \"dateTime\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r26.selectedColumn && ctx_r26.selectedColumn.dataType === \"date\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r26.selectedColumn && ctx_r26.selectedColumn.dataType === \"time\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r26.selectedColumn && ctx_r26.selectedColumn.dataType === \"dateTime\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r26.displayDensity)(\"disabled\", !ctx_r26.operandCanBeCommitted());\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r26.displayDensity);\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_2_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r92 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 72, 73);\n    i0.ɵɵtemplate(2, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_2_ng_container_2_Template, 1, 0, \"ng-container\", 74);\n    i0.ɵɵelementStart(3, \"button\", 57);\n    i0.ɵɵlistener(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_2_Template_button_click_3_listener() {\n      i0.ɵɵrestoreView(_r92);\n      const ctx_r91 = i0.ɵɵnextContext(3);\n      return ctx_r91.cancelOperandAdd();\n    });\n    i0.ɵɵelementStart(4, \"igx-icon\");\n    i0.ɵɵtext(5, \"close\");\n    i0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const expressionItem_r24 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵnextContext();\n\n    const _r4 = i0.ɵɵreference(15);\n\n    const ctx_r27 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r4)(\"ngTemplateOutletContext\", ctx_r27.context(expressionItem_r24.parent, expressionItem_r24));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r27.displayDensity);\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template, 10, 9, \"div\", 29);\n    i0.ɵɵtemplate(1, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_Template, 20, 19, \"div\", 30);\n    i0.ɵɵtemplate(2, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_2_Template, 6, 3, \"div\", 31);\n  }\n\n  if (rf & 2) {\n    const expressionItem_r24 = ctx.$implicit;\n    i0.ɵɵproperty(\"ngIf\", !expressionItem_r24.inEditMode);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", expressionItem_r24.inEditMode);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", expressionItem_r24.inAddMode);\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_ng_container_3_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_ng_container_3_ng_container_1_Template, 1, 0, \"ng-container\", 74);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const expr_r97 = ctx.$implicit;\n    i0.ɵɵnextContext(2);\n\n    const _r8 = i0.ɵɵreference(19);\n\n    const _r6 = i0.ɵɵreference(17);\n\n    const ctx_r95 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r95.isExpressionGroup(expr_r97) ? _r8 : _r6)(\"ngTemplateOutletContext\", ctx_r95.context(expr_r97));\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_div_4_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_div_4_button_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r104 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 27);\n    i0.ɵɵlistener(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_div_4_button_3_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r104);\n      const expressionItem_r94 = i0.ɵɵnextContext(2).$implicit;\n      const ctx_r102 = i0.ɵɵnextContext(2);\n      return ctx_r102.endGroup(expressionItem_r94);\n    });\n    i0.ɵɵelementStart(1, \"span\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const expressionItem_r94 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r101 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r101.displayDensity)(\"disabled\", ctx_r101.hasEditedExpression || expressionItem_r94.children.length < 2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r101.grid.resourceStrings.igx_grid_advanced_filter_end_group);\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 72, 79);\n    i0.ɵɵtemplate(2, IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_div_4_ng_container_2_Template, 1, 0, \"ng-container\", 74);\n    i0.ɵɵtemplate(3, IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_div_4_button_3_Template, 3, 3, \"button\", 80);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const expressionItem_r94 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵnextContext();\n\n    const _r4 = i0.ɵɵreference(15);\n\n    const ctx_r96 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r4)(\"ngTemplateOutletContext\", ctx_r96.context(expressionItem_r94));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", expressionItem_r94 !== ctx_r96.rootGroup);\n  }\n}\n\nconst _c144 = function (a0, a1, a2) {\n  return {\n    \"igx-filter-tree__line--and\": a0,\n    \"igx-filter-tree__line--or\": a1,\n    \"igx-filter-tree__line--selected\": a2\n  };\n};\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r108 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 75)(1, \"div\", 76);\n    i0.ɵɵlistener(\"keydown\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_Template_div_keydown_1_listener($event) {\n      i0.ɵɵrestoreView(_r108);\n      const ctx_r107 = i0.ɵɵnextContext(2);\n      return ctx_r107.invokeClick($event);\n    })(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_Template_div_click_1_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r108);\n      const expressionItem_r94 = restoredCtx.$implicit;\n      const ctx_r109 = i0.ɵɵnextContext(2);\n      return ctx_r109.onGroupClick(expressionItem_r94);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"div\", 77);\n    i0.ɵɵtemplate(3, IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_ng_container_3_Template, 2, 2, \"ng-container\", 78);\n    i0.ɵɵtemplate(4, IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_div_4_Template, 4, 3, \"div\", 31);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const expressionItem_r94 = ctx.$implicit;\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction3(3, _c144, expressionItem_r94.operator === 0, expressionItem_r94.operator === 1, expressionItem_r94.selected));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", expressionItem_r94.children);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r9.currentGroup === expressionItem_r94);\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_container_20_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_container_20_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxAdvancedFilteringDialogComponent_article_0_ng_container_20_ng_container_1_Template, 1, 0, \"ng-container\", 74);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r8 = i0.ɵɵreference(19);\n\n    const ctx_r10 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r8)(\"ngTemplateOutletContext\", ctx_r10.context(ctx_r10.rootGroup));\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_container_25_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r112 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-buttongroup\", 81);\n    i0.ɵɵlistener(\"selected\", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_25_Template_igx_buttongroup_selected_1_listener($event) {\n      i0.ɵɵrestoreView(_r112);\n      const ctx_r111 = i0.ɵɵnextContext(2);\n      return ctx_r111.selectFilteringLogic($event);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"button\", 27);\n    i0.ɵɵlistener(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_25_Template_button_click_2_listener() {\n      i0.ɵɵrestoreView(_r112);\n      const ctx_r113 = i0.ɵɵnextContext(2);\n      return ctx_r113.ungroup();\n    });\n    i0.ɵɵelement(3, \"igx-icon\", 82);\n    i0.ɵɵelementStart(4, \"span\");\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(6, \"button\", 83);\n    i0.ɵɵlistener(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_25_Template_button_click_6_listener() {\n      i0.ɵɵrestoreView(_r112);\n      const ctx_r114 = i0.ɵɵnextContext(2);\n      return ctx_r114.deleteGroup();\n    });\n    i0.ɵɵelementStart(7, \"igx-icon\");\n    i0.ɵɵtext(8, \"delete\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(9, \"span\");\n    i0.ɵɵtext(10);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r11.displayDensity)(\"multiSelection\", false)(\"values\", ctx_r11.filteringLogics);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r11.displayDensity)(\"disabled\", !ctx_r11.contextualGroup.parent);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate(ctx_r11.grid.resourceStrings.igx_grid_advanced_filter_ungroup);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r11.displayDensity);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate(ctx_r11.grid.resourceStrings.igx_grid_advanced_filter_delete);\n  }\n}\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_ng_container_26_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r116 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"button\", 23);\n    i0.ɵɵlistener(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_26_Template_button_click_1_listener() {\n      i0.ɵɵrestoreView(_r116);\n      const ctx_r115 = i0.ɵɵnextContext(2);\n      return ctx_r115.createAndGroup();\n    });\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"button\", 23);\n    i0.ɵɵlistener(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_26_Template_button_click_3_listener() {\n      i0.ɵɵrestoreView(_r116);\n      const ctx_r117 = i0.ɵɵnextContext(2);\n      return ctx_r117.createOrGroup();\n    });\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"button\", 83);\n    i0.ɵɵlistener(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_26_Template_button_click_5_listener() {\n      i0.ɵɵrestoreView(_r116);\n      const ctx_r118 = i0.ɵɵnextContext(2);\n      return ctx_r118.deleteFilters();\n    });\n    i0.ɵɵtext(6);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r12.displayDensity);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r12.grid.resourceStrings.igx_grid_advanced_filter_create_and_group, \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r12.displayDensity);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r12.grid.resourceStrings.igx_grid_advanced_filter_create_or_group, \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r12.displayDensity);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r12.grid.resourceStrings.igx_grid_advanced_filter_delete_filters, \" \");\n  }\n}\n\nconst _c145 = function (a0, a1, a2) {\n  return {\n    \"igx-advanced-filter--cosy\": a0,\n    \"igx-advanced-filter--compact\": a1,\n    \"igx-advanced-filter--inline\": a2\n  };\n};\n\nconst _c146 = function (a0, a1) {\n  return {\n    \"igx-filter-contextual-menu--cosy\": a0,\n    \"igx-filter-contextual-menu--compact\": a1\n  };\n};\n\nfunction IgxAdvancedFilteringDialogComponent_article_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r120 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"article\", 3);\n    i0.ɵɵlistener(\"dragStart\", function IgxAdvancedFilteringDialogComponent_article_0_Template_article_dragStart_0_listener($event) {\n      i0.ɵɵrestoreView(_r120);\n      const ctx_r119 = i0.ɵɵnextContext();\n      return ctx_r119.dragStart($event);\n    })(\"dragEnd\", function IgxAdvancedFilteringDialogComponent_article_0_Template_article_dragEnd_0_listener() {\n      i0.ɵɵrestoreView(_r120);\n      const ctx_r121 = i0.ɵɵnextContext();\n      return ctx_r121.dragEnd();\n    })(\"dragMove\", function IgxAdvancedFilteringDialogComponent_article_0_Template_article_dragMove_0_listener($event) {\n      i0.ɵɵrestoreView(_r120);\n      const ctx_r122 = i0.ɵɵnextContext();\n      return ctx_r122.onDragMove($event);\n    })(\"keydown\", function IgxAdvancedFilteringDialogComponent_article_0_Template_article_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r120);\n      const ctx_r123 = i0.ɵɵnextContext();\n      return ctx_r123.onKeyDown($event);\n    });\n    i0.ɵɵelementStart(1, \"header\", 4)(2, \"h4\", 5);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"div\", 6)(5, \"div\", 7)(6, \"span\");\n    i0.ɵɵtext(7);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(8, \"div\", 8)(9, \"span\");\n    i0.ɵɵtext(10);\n    i0.ɵɵelementEnd()()()();\n    i0.ɵɵelementStart(11, \"article\", 9, 10);\n    i0.ɵɵlistener(\"scroll\", function IgxAdvancedFilteringDialogComponent_article_0_Template_article_scroll_11_listener() {\n      i0.ɵɵrestoreView(_r120);\n      const ctx_r124 = i0.ɵɵnextContext();\n      return ctx_r124.onExpressionsScrolled();\n    });\n    i0.ɵɵtemplate(13, IgxAdvancedFilteringDialogComponent_article_0_ng_container_13_Template, 15, 5, \"ng-container\", 11);\n    i0.ɵɵtemplate(14, IgxAdvancedFilteringDialogComponent_article_0_ng_template_14_Template, 16, 9, \"ng-template\", null, 12, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵtemplate(16, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_Template, 3, 3, \"ng-template\", null, 13, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵtemplate(18, IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_Template, 5, 7, \"ng-template\", null, 14, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵtemplate(20, IgxAdvancedFilteringDialogComponent_article_0_ng_container_20_Template, 2, 2, \"ng-container\", 11);\n    i0.ɵɵelementStart(21, \"div\", 15);\n    i0.ɵɵlistener(\"keydown\", function IgxAdvancedFilteringDialogComponent_article_0_Template_div_keydown_21_listener($event) {\n      i0.ɵɵrestoreView(_r120);\n      const ctx_r125 = i0.ɵɵnextContext();\n      return ctx_r125.onKeyDown($event);\n    })(\"closed\", function IgxAdvancedFilteringDialogComponent_article_0_Template_div_closed_21_listener() {\n      i0.ɵɵrestoreView(_r120);\n      const ctx_r126 = i0.ɵɵnextContext();\n      return ctx_r126.contextMenuClosed();\n    });\n    i0.ɵɵelementStart(22, \"button\", 16);\n    i0.ɵɵlistener(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_Template_button_click_22_listener() {\n      i0.ɵɵrestoreView(_r120);\n      const ctx_r127 = i0.ɵɵnextContext();\n      return ctx_r127.clearSelection();\n    });\n    i0.ɵɵelementStart(23, \"igx-icon\");\n    i0.ɵɵtext(24, \"close\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵtemplate(25, IgxAdvancedFilteringDialogComponent_article_0_ng_container_25_Template, 11, 8, \"ng-container\", 11);\n    i0.ɵɵtemplate(26, IgxAdvancedFilteringDialogComponent_article_0_ng_container_26_Template, 7, 6, \"ng-container\", 11);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(27, \"footer\", 17)(28, \"div\", 18)(29, \"button\", 19);\n    i0.ɵɵlistener(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_Template_button_click_29_listener($event) {\n      i0.ɵɵrestoreView(_r120);\n      const ctx_r128 = i0.ɵɵnextContext();\n      return ctx_r128.onClearButtonClick($event);\n    });\n    i0.ɵɵtext(30);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(31, \"div\", 20)(32, \"button\", 19);\n    i0.ɵɵlistener(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_Template_button_click_32_listener() {\n      i0.ɵɵrestoreView(_r120);\n      const ctx_r129 = i0.ɵɵnextContext();\n      return ctx_r129.cancelChanges();\n    });\n    i0.ɵɵtext(33);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(34, \"div\", 21)(35, \"button\", 22);\n    i0.ɵɵlistener(\"click\", function IgxAdvancedFilteringDialogComponent_article_0_Template_button_click_35_listener($event) {\n      i0.ɵɵrestoreView(_r120);\n      const ctx_r130 = i0.ɵɵnextContext();\n      return ctx_r130.onApplyButtonClick($event);\n    });\n    i0.ɵɵtext(36);\n    i0.ɵɵelementEnd()()()();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ghost\", false)(\"dragTolerance\", 0)(\"ngClass\", i0.ɵɵpureFunction3(17, _c145, ctx_r0.grid.displayDensity === \"cosy\", ctx_r0.grid.displayDensity === \"compact\", ctx_r0.inline));\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.grid.resourceStrings.igx_grid_advanced_filter_title, \" \");\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate(ctx_r0.grid.resourceStrings.igx_grid_advanced_filter_and_label);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate(ctx_r0.grid.resourceStrings.igx_grid_advanced_filter_or_label);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.rootGroup);\n    i0.ɵɵadvance(7);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.rootGroup);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(21, _c146, ctx_r0.displayDensity === \"cosy\", ctx_r0.displayDensity === \"compact\"));\n    i0.ɵɵadvance(4);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.contextualGroup);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r0.contextualGroup);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r0.displayDensity);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.grid.resourceStrings.igx_grid_excel_custom_dialog_clear, \" \");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r0.displayDensity);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.grid.resourceStrings.igx_grid_excel_cancel, \" \");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r0.displayDensity);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.grid.resourceStrings.igx_grid_excel_apply, \" \");\n  }\n}\n\nfunction IgxSnackbarComponent_button_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 2);\n    i0.ɵɵlistener(\"click\", function IgxSnackbarComponent_button_3_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r2);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return ctx_r1.triggerAction();\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.actionText, \"\\n\");\n  }\n}\n\nfunction IgxPaginatorComponent_igx_page_size_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-page-size\");\n  }\n}\n\nfunction IgxPaginatorComponent_igx_page_nav_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-page-nav\");\n  }\n}\n\nconst _c147 = [[[\"\", \"igxPaginatorContent\", \"\"], [\"igx-paginator-content\"]]];\nconst _c148 = [\"[igxPaginatorContent],igx-paginator-content\"];\n\nfunction IgxPageSizeSelectorComponent_igx_select_item_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-select-item\", 5);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const val_r1 = ctx.$implicit;\n    i0.ɵɵproperty(\"value\", val_r1);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", val_r1, \" \");\n  }\n}\n\nconst _c149 = [\"defaultFilterUI\"];\nconst _c150 = [\"defaultDateUI\"];\nconst _c151 = [\"defaultTimeUI\"];\nconst _c152 = [\"defaultDateTimeUI\"];\nconst _c153 = [\"inputGroupConditions\"];\nconst _c154 = [\"chipsArea\"];\nconst _c155 = [\"inputGroupPrefix\"];\nconst _c156 = [\"operand\"];\nconst _c157 = [\"closeButton\"];\nconst _c158 = [\"operators\"];\n\nfunction IgxGridFilteringRowComponent_igx_drop_down_item_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-drop-down-item\", 19)(1, \"div\", 20);\n    i0.ɵɵelement(2, \"igx-icon\", 21);\n    i0.ɵɵelementStart(3, \"span\", 22);\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const condition_r18 = ctx.$implicit;\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"value\", condition_r18)(\"selected\", ctx_r1.isConditionSelected(condition_r18));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"name\", ctx_r1.getCondition(condition_r18).iconName);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r1.translateCondition(condition_r18));\n  }\n}\n\nfunction IgxGridFilteringRowComponent_ng_template_3_igx_suffix_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r24 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-suffix\")(1, \"igx-icon\", 30);\n    i0.ɵɵlistener(\"keydown\", function IgxGridFilteringRowComponent_ng_template_3_igx_suffix_7_Template_igx_icon_keydown_1_listener($event) {\n      i0.ɵɵrestoreView(_r24);\n      const ctx_r23 = i0.ɵɵnextContext(2);\n      return ctx_r23.onCommitKeyDown($event);\n    })(\"click\", function IgxGridFilteringRowComponent_ng_template_3_igx_suffix_7_Template_igx_icon_click_1_listener() {\n      i0.ɵɵrestoreView(_r24);\n      const ctx_r25 = i0.ɵɵnextContext(2);\n      return ctx_r25.onCommitClick();\n    });\n    i0.ɵɵtext(2, \"done\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"igx-icon\", 30);\n    i0.ɵɵlistener(\"keydown\", function IgxGridFilteringRowComponent_ng_template_3_igx_suffix_7_Template_igx_icon_keydown_3_listener($event) {\n      i0.ɵɵrestoreView(_r24);\n      const ctx_r26 = i0.ɵɵnextContext(2);\n      return ctx_r26.onClearKeyDown($event);\n    })(\"click\", function IgxGridFilteringRowComponent_ng_template_3_igx_suffix_7_Template_igx_icon_click_3_listener() {\n      i0.ɵɵrestoreView(_r24);\n      const ctx_r27 = i0.ɵɵnextContext(2);\n      return ctx_r27.onClearClick();\n    });\n    i0.ɵɵtext(4, \"clear\");\n    i0.ɵɵelementEnd()();\n  }\n}\n\nfunction IgxGridFilteringRowComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r29 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-input-group\", 23, 24);\n    i0.ɵɵlistener(\"focusout\", function IgxGridFilteringRowComponent_ng_template_3_Template_igx_input_group_focusout_0_listener() {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r28 = i0.ɵɵnextContext();\n      return ctx_r28.onInputGroupFocusout();\n    });\n    i0.ɵɵelementStart(2, \"igx-prefix\", 25, 26);\n    i0.ɵɵlistener(\"click\", function IgxGridFilteringRowComponent_ng_template_3_Template_igx_prefix_click_2_listener($event) {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r30 = i0.ɵɵnextContext();\n      return ctx_r30.inputGroupPrefixClick($event);\n    })(\"keydown\", function IgxGridFilteringRowComponent_ng_template_3_Template_igx_prefix_keydown_2_listener($event) {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r31 = i0.ɵɵnextContext();\n      return ctx_r31.onPrefixKeyDown($event);\n    });\n    i0.ɵɵelement(4, \"igx-icon\", 21);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"input\", 27, 28);\n    i0.ɵɵlistener(\"input\", function IgxGridFilteringRowComponent_ng_template_3_Template_input_input_5_listener($event) {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r32 = i0.ɵɵnextContext();\n      return ctx_r32.onInput($event);\n    })(\"click\", function IgxGridFilteringRowComponent_ng_template_3_Template_input_click_5_listener() {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r33 = i0.ɵɵnextContext();\n      return ctx_r33.onInputClick();\n    })(\"compositionstart\", function IgxGridFilteringRowComponent_ng_template_3_Template_input_compositionstart_5_listener() {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r34 = i0.ɵɵnextContext();\n      return ctx_r34.onCompositionStart();\n    })(\"compositionend\", function IgxGridFilteringRowComponent_ng_template_3_Template_input_compositionend_5_listener() {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r35 = i0.ɵɵnextContext();\n      return ctx_r35.onCompositionEnd();\n    })(\"keydown\", function IgxGridFilteringRowComponent_ng_template_3_Template_input_keydown_5_listener($event) {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r36 = i0.ɵɵnextContext();\n      return ctx_r36.onInputKeyDown($event);\n    })(\"keyup\", function IgxGridFilteringRowComponent_ng_template_3_Template_input_keyup_5_listener() {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r37 = i0.ɵɵnextContext();\n      return ctx_r37.onInputKeyUp();\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(7, IgxGridFilteringRowComponent_ng_template_3_igx_suffix_7_Template, 5, 0, \"igx-suffix\", 29);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n\n    const _r0 = i0.ɵɵreference(1);\n\n    i0.ɵɵproperty(\"displayDensity\", ctx_r3.displayDensity);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"igxDropDownItemNavigation\", _r0);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"name\", ctx_r3.getIconName());\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"placeholder\", ctx_r3.placeholder)(\"value\", ctx_r3.value)(\"type\", ctx_r3.type)(\"readonly\", ctx_r3.isUnaryCondition);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.value || ctx_r3.value === 0);\n  }\n}\n\nfunction IgxGridFilteringRowComponent_ng_template_5_igx_suffix_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r42 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-suffix\")(1, \"igx-icon\", 30);\n    i0.ɵɵlistener(\"keydown\", function IgxGridFilteringRowComponent_ng_template_5_igx_suffix_5_Template_igx_icon_keydown_1_listener($event) {\n      i0.ɵɵrestoreView(_r42);\n      const ctx_r41 = i0.ɵɵnextContext(2);\n      return ctx_r41.onCommitKeyDown($event);\n    })(\"click\", function IgxGridFilteringRowComponent_ng_template_5_igx_suffix_5_Template_igx_icon_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r42);\n      const ctx_r43 = i0.ɵɵnextContext(2);\n      return ctx_r43.onCommitClick($event);\n    });\n    i0.ɵɵtext(2, \"done\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"igx-icon\", 30);\n    i0.ɵɵlistener(\"keydown\", function IgxGridFilteringRowComponent_ng_template_5_igx_suffix_5_Template_igx_icon_keydown_3_listener($event) {\n      i0.ɵɵrestoreView(_r42);\n      const ctx_r44 = i0.ɵɵnextContext(2);\n      return ctx_r44.onClearKeyDown($event);\n    })(\"click\", function IgxGridFilteringRowComponent_ng_template_5_igx_suffix_5_Template_igx_icon_click_3_listener($event) {\n      i0.ɵɵrestoreView(_r42);\n      const ctx_r45 = i0.ɵɵnextContext(2);\n      return ctx_r45.clearInput($event);\n    });\n    i0.ɵɵtext(4, \"clear\");\n    i0.ɵɵelementEnd()();\n  }\n}\n\nfunction IgxGridFilteringRowComponent_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r47 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-date-picker\", 31, 32);\n    i0.ɵɵlistener(\"valueChange\", function IgxGridFilteringRowComponent_ng_template_5_Template_igx_date_picker_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r47);\n      const ctx_r46 = i0.ɵɵnextContext();\n      return ctx_r46.value = $event;\n    })(\"click\", function IgxGridFilteringRowComponent_ng_template_5_Template_igx_date_picker_click_0_listener() {\n      i0.ɵɵrestoreView(_r47);\n\n      const _r38 = i0.ɵɵreference(1);\n\n      const ctx_r48 = i0.ɵɵnextContext();\n      return ctx_r48.expression.condition.isUnary ? null : _r38.open();\n    })(\"keydown\", function IgxGridFilteringRowComponent_ng_template_5_Template_igx_date_picker_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r47);\n      const ctx_r49 = i0.ɵɵnextContext();\n      return ctx_r49.onInputKeyDown($event);\n    })(\"focusout\", function IgxGridFilteringRowComponent_ng_template_5_Template_igx_date_picker_focusout_0_listener() {\n      i0.ɵɵrestoreView(_r47);\n      const ctx_r50 = i0.ɵɵnextContext();\n      return ctx_r50.onInputGroupFocusout();\n    })(\"closed\", function IgxGridFilteringRowComponent_ng_template_5_Template_igx_date_picker_closed_0_listener() {\n      i0.ɵɵrestoreView(_r47);\n      const ctx_r51 = i0.ɵɵnextContext();\n      return ctx_r51.focusEditElement();\n    });\n    i0.ɵɵelementStart(2, \"igx-prefix\", 25, 26);\n    i0.ɵɵlistener(\"click\", function IgxGridFilteringRowComponent_ng_template_5_Template_igx_prefix_click_2_listener($event) {\n      i0.ɵɵrestoreView(_r47);\n      const ctx_r52 = i0.ɵɵnextContext();\n      return ctx_r52.inputGroupPrefixClick($event);\n    })(\"keydown\", function IgxGridFilteringRowComponent_ng_template_5_Template_igx_prefix_keydown_2_listener($event) {\n      i0.ɵɵrestoreView(_r47);\n      const ctx_r53 = i0.ɵɵnextContext();\n      return ctx_r53.onPrefixKeyDown($event);\n    });\n    i0.ɵɵelement(4, \"igx-icon\", 21);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(5, IgxGridFilteringRowComponent_ng_template_5_igx_suffix_5_Template, 5, 0, \"igx-suffix\", 29);\n    i0.ɵɵelement(6, \"igx-picker-toggle\")(7, \"igx-picker-clear\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n\n    const _r0 = i0.ɵɵreference(1);\n\n    i0.ɵɵproperty(\"value\", ctx_r5.value)(\"readOnly\", true)(\"outlet\", ctx_r5.filteringService.grid.outlet)(\"locale\", ctx_r5.filteringService.grid.locale)(\"displayFormat\", ctx_r5.column.pipeArgs.format)(\"formatter\", ctx_r5.column.formatter)(\"placeholder\", ctx_r5.placeholder)(\"displayDensity\", ctx_r5.displayDensity);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"igxDropDownItemNavigation\", _r0);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"name\", ctx_r5.expression.condition.iconName);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.value);\n  }\n}\n\nfunction IgxGridFilteringRowComponent_ng_template_7_igx_suffix_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r58 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-suffix\")(1, \"igx-icon\", 30);\n    i0.ɵɵlistener(\"keydown\", function IgxGridFilteringRowComponent_ng_template_7_igx_suffix_5_Template_igx_icon_keydown_1_listener($event) {\n      i0.ɵɵrestoreView(_r58);\n      const ctx_r57 = i0.ɵɵnextContext(2);\n      return ctx_r57.onCommitKeyDown($event);\n    })(\"click\", function IgxGridFilteringRowComponent_ng_template_7_igx_suffix_5_Template_igx_icon_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r58);\n      const ctx_r59 = i0.ɵɵnextContext(2);\n      return ctx_r59.onCommitClick($event);\n    });\n    i0.ɵɵtext(2, \"done\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"igx-icon\", 30);\n    i0.ɵɵlistener(\"keydown\", function IgxGridFilteringRowComponent_ng_template_7_igx_suffix_5_Template_igx_icon_keydown_3_listener($event) {\n      i0.ɵɵrestoreView(_r58);\n      const ctx_r60 = i0.ɵɵnextContext(2);\n      return ctx_r60.onClearKeyDown($event);\n    })(\"click\", function IgxGridFilteringRowComponent_ng_template_7_igx_suffix_5_Template_igx_icon_click_3_listener($event) {\n      i0.ɵɵrestoreView(_r58);\n      const ctx_r61 = i0.ɵɵnextContext(2);\n      return ctx_r61.clearInput($event);\n    });\n    i0.ɵɵtext(4, \"clear\");\n    i0.ɵɵelementEnd()();\n  }\n}\n\nfunction IgxGridFilteringRowComponent_ng_template_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r63 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-time-picker\", 33, 32);\n    i0.ɵɵlistener(\"valueChange\", function IgxGridFilteringRowComponent_ng_template_7_Template_igx_time_picker_valueChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r63);\n      const ctx_r62 = i0.ɵɵnextContext();\n      return ctx_r62.value = $event;\n    })(\"closed\", function IgxGridFilteringRowComponent_ng_template_7_Template_igx_time_picker_closed_0_listener() {\n      i0.ɵɵrestoreView(_r63);\n      const ctx_r64 = i0.ɵɵnextContext();\n      return ctx_r64.focusEditElement();\n    })(\"focusout\", function IgxGridFilteringRowComponent_ng_template_7_Template_igx_time_picker_focusout_0_listener() {\n      i0.ɵɵrestoreView(_r63);\n      const ctx_r65 = i0.ɵɵnextContext();\n      return ctx_r65.onInputGroupFocusout();\n    })(\"keydown\", function IgxGridFilteringRowComponent_ng_template_7_Template_igx_time_picker_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r63);\n      const ctx_r66 = i0.ɵɵnextContext();\n      return ctx_r66.onInputKeyDown($event);\n    })(\"click\", function IgxGridFilteringRowComponent_ng_template_7_Template_igx_time_picker_click_0_listener() {\n      i0.ɵɵrestoreView(_r63);\n\n      const _r54 = i0.ɵɵreference(1);\n\n      const ctx_r67 = i0.ɵɵnextContext();\n      return ctx_r67.expression.condition.isUnary ? null : _r54.open();\n    });\n    i0.ɵɵelementStart(2, \"igx-prefix\", 25, 26);\n    i0.ɵɵlistener(\"click\", function IgxGridFilteringRowComponent_ng_template_7_Template_igx_prefix_click_2_listener($event) {\n      i0.ɵɵrestoreView(_r63);\n      const ctx_r68 = i0.ɵɵnextContext();\n      return ctx_r68.inputGroupPrefixClick($event);\n    })(\"keydown\", function IgxGridFilteringRowComponent_ng_template_7_Template_igx_prefix_keydown_2_listener($event) {\n      i0.ɵɵrestoreView(_r63);\n      const ctx_r69 = i0.ɵɵnextContext();\n      return ctx_r69.onPrefixKeyDown($event);\n    });\n    i0.ɵɵelement(4, \"igx-icon\", 21);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(5, IgxGridFilteringRowComponent_ng_template_7_igx_suffix_5_Template, 5, 0, \"igx-suffix\", 29);\n    i0.ɵɵelement(6, \"igx-picker-toggle\")(7, \"igx-picker-clear\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n\n    const _r0 = i0.ɵɵreference(1);\n\n    i0.ɵɵproperty(\"value\", ctx_r7.value)(\"inputFormat\", ctx_r7.column.defaultTimeFormat)(\"locale\", ctx_r7.filteringService.grid.locale)(\"formatter\", ctx_r7.column.formatter)(\"outlet\", ctx_r7.filteringService.grid.outlet)(\"displayDensity\", ctx_r7.displayDensity)(\"readOnly\", true)(\"placeholder\", ctx_r7.placeholder);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"igxDropDownItemNavigation\", _r0);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"name\", ctx_r7.expression.condition.iconName);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.value);\n  }\n}\n\nfunction IgxGridFilteringRowComponent_ng_template_9_igx_suffix_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r75 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-suffix\")(1, \"igx-icon\", 30);\n    i0.ɵɵlistener(\"keydown\", function IgxGridFilteringRowComponent_ng_template_9_igx_suffix_7_Template_igx_icon_keydown_1_listener($event) {\n      i0.ɵɵrestoreView(_r75);\n      const ctx_r74 = i0.ɵɵnextContext(2);\n      return ctx_r74.onCommitKeyDown($event);\n    })(\"click\", function IgxGridFilteringRowComponent_ng_template_9_igx_suffix_7_Template_igx_icon_click_1_listener() {\n      i0.ɵɵrestoreView(_r75);\n      const ctx_r76 = i0.ɵɵnextContext(2);\n      return ctx_r76.onCommitClick();\n    });\n    i0.ɵɵtext(2, \"done\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"igx-icon\", 30);\n    i0.ɵɵlistener(\"keydown\", function IgxGridFilteringRowComponent_ng_template_9_igx_suffix_7_Template_igx_icon_keydown_3_listener($event) {\n      i0.ɵɵrestoreView(_r75);\n      const ctx_r77 = i0.ɵɵnextContext(2);\n      return ctx_r77.onClearKeyDown($event);\n    })(\"click\", function IgxGridFilteringRowComponent_ng_template_9_igx_suffix_7_Template_igx_icon_click_3_listener() {\n      i0.ɵɵrestoreView(_r75);\n      const ctx_r78 = i0.ɵɵnextContext(2);\n      return ctx_r78.onClearClick();\n    });\n    i0.ɵɵtext(4, \"clear\");\n    i0.ɵɵelementEnd()();\n  }\n}\n\nfunction IgxGridFilteringRowComponent_ng_template_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r80 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-input-group\", 23, 24);\n    i0.ɵɵlistener(\"focusout\", function IgxGridFilteringRowComponent_ng_template_9_Template_igx_input_group_focusout_0_listener() {\n      i0.ɵɵrestoreView(_r80);\n      const ctx_r79 = i0.ɵɵnextContext();\n      return ctx_r79.onInputGroupFocusout();\n    });\n    i0.ɵɵelementStart(2, \"igx-prefix\", 25, 26);\n    i0.ɵɵlistener(\"click\", function IgxGridFilteringRowComponent_ng_template_9_Template_igx_prefix_click_2_listener($event) {\n      i0.ɵɵrestoreView(_r80);\n      const ctx_r81 = i0.ɵɵnextContext();\n      return ctx_r81.inputGroupPrefixClick($event);\n    })(\"keydown\", function IgxGridFilteringRowComponent_ng_template_9_Template_igx_prefix_keydown_2_listener($event) {\n      i0.ɵɵrestoreView(_r80);\n      const ctx_r82 = i0.ɵɵnextContext();\n      return ctx_r82.onPrefixKeyDown($event);\n    });\n    i0.ɵɵelement(4, \"igx-icon\", 21);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"input\", 34, 28);\n    i0.ɵɵlistener(\"valueChange\", function IgxGridFilteringRowComponent_ng_template_9_Template_input_valueChange_5_listener($event) {\n      i0.ɵɵrestoreView(_r80);\n      const ctx_r83 = i0.ɵɵnextContext();\n      return ctx_r83.onInput($event);\n    })(\"click\", function IgxGridFilteringRowComponent_ng_template_9_Template_input_click_5_listener() {\n      i0.ɵɵrestoreView(_r80);\n      const ctx_r84 = i0.ɵɵnextContext();\n      return ctx_r84.onInputClick();\n    })(\"keydown\", function IgxGridFilteringRowComponent_ng_template_9_Template_input_keydown_5_listener($event) {\n      i0.ɵɵrestoreView(_r80);\n      const ctx_r85 = i0.ɵɵnextContext();\n      return ctx_r85.onInputKeyDown($event);\n    })(\"keyup\", function IgxGridFilteringRowComponent_ng_template_9_Template_input_keyup_5_listener() {\n      i0.ɵɵrestoreView(_r80);\n      const ctx_r86 = i0.ɵɵnextContext();\n      return ctx_r86.onInputKeyUp();\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(7, IgxGridFilteringRowComponent_ng_template_9_igx_suffix_7_Template, 5, 0, \"igx-suffix\", 29);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext();\n\n    const _r0 = i0.ɵɵreference(1);\n\n    i0.ɵɵproperty(\"displayDensity\", ctx_r9.displayDensity);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"igxDropDownItemNavigation\", _r0);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"name\", ctx_r9.getIconName());\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"placeholder\", ctx_r9.placeholder)(\"igxDateTimeEditor\", ctx_r9.column.defaultDateTimeFormat)(\"value\", ctx_r9.value)(\"readonly\", ctx_r9.isUnaryCondition);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r9.value || ctx_r9.value === 0);\n  }\n}\n\nfunction IgxGridFilteringRowComponent_ng_container_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridFilteringRowComponent_button_12_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r88 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 35);\n    i0.ɵɵlistener(\"keydown\", function IgxGridFilteringRowComponent_button_12_Template_button_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r88);\n      const ctx_r87 = i0.ɵɵnextContext();\n      return ctx_r87.onLeftArrowKeyDown($event);\n    })(\"click\", function IgxGridFilteringRowComponent_button_12_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r88);\n      const ctx_r89 = i0.ɵɵnextContext();\n      return ctx_r89.scrollChipsOnArrowPress(\"left\");\n    });\n    i0.ɵɵelementStart(1, \"igx-icon\");\n    i0.ɵɵtext(2, \"navigate_before\");\n    i0.ɵɵelementEnd()();\n  }\n}\n\nfunction IgxGridFilteringRowComponent_ng_container_18_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r98 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 41)(1, \"button\", 42);\n    i0.ɵɵlistener(\"click\", function IgxGridFilteringRowComponent_ng_container_18_span_6_Template_button_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r98);\n      const i_r91 = i0.ɵɵnextContext().index;\n      const ctx_r96 = i0.ɵɵnextContext();\n      return ctx_r96.toggleOperatorsDropDown($event, i_r91);\n    });\n    i0.ɵɵelementStart(2, \"igx-icon\");\n    i0.ɵɵtext(3, \"expand_more\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"span\");\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(6, \"igx-drop-down\", 43, 44);\n    i0.ɵɵlistener(\"selectionChanging\", function IgxGridFilteringRowComponent_ng_container_18_span_6_Template_igx_drop_down_selectionChanging_6_listener($event) {\n      i0.ɵɵrestoreView(_r98);\n      const item_r90 = i0.ɵɵnextContext().$implicit;\n      const ctx_r99 = i0.ɵɵnextContext();\n      return ctx_r99.onLogicOperatorChanged($event, item_r90);\n    });\n    i0.ɵɵelementStart(8, \"igx-drop-down-item\", 19);\n    i0.ɵɵtext(9);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(10, \"igx-drop-down-item\", 19);\n    i0.ɵɵtext(11);\n    i0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const _r95 = i0.ɵɵreference(7);\n\n    const item_r90 = i0.ɵɵnextContext().$implicit;\n    const ctx_r94 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"igxDropDownItemNavigation\", _r95)(\"displayDensity\", ctx_r94.column.grid.displayDensity);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate(ctx_r94.filteringService.getOperatorAsString(item_r90.afterOperator));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r94.column.grid.displayDensity);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"value\", 0)(\"selected\", item_r90.afterOperator === 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r94.filteringService.grid.resourceStrings.igx_grid_filter_operator_and);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"value\", 1)(\"selected\", item_r90.afterOperator === 1);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r94.filteringService.grid.resourceStrings.igx_grid_filter_operator_or);\n  }\n}\n\nfunction IgxGridFilteringRowComponent_ng_container_18_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r103 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0, 36);\n    i0.ɵɵelementStart(1, \"igx-chip\", 37, 38);\n    i0.ɵɵlistener(\"pointerdown\", function IgxGridFilteringRowComponent_ng_container_18_Template_igx_chip_pointerdown_1_listener($event) {\n      i0.ɵɵrestoreView(_r103);\n\n      const _r93 = i0.ɵɵreference(2);\n\n      const ctx_r102 = i0.ɵɵnextContext();\n      return ctx_r102.onChipPointerdown($event, _r93);\n    })(\"click\", function IgxGridFilteringRowComponent_ng_container_18_Template_igx_chip_click_1_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r103);\n      const item_r90 = restoredCtx.$implicit;\n      const ctx_r104 = i0.ɵɵnextContext();\n      return ctx_r104.onChipClick($event, item_r90);\n    })(\"keydown\", function IgxGridFilteringRowComponent_ng_container_18_Template_igx_chip_keydown_1_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r103);\n      const item_r90 = restoredCtx.$implicit;\n      const ctx_r105 = i0.ɵɵnextContext();\n      return ctx_r105.onChipKeyDown($event, item_r90);\n    })(\"remove\", function IgxGridFilteringRowComponent_ng_container_18_Template_igx_chip_remove_1_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r103);\n      const item_r90 = restoredCtx.$implicit;\n      const ctx_r106 = i0.ɵɵnextContext();\n      return ctx_r106.onChipRemoved($event, item_r90);\n    });\n    i0.ɵɵelement(3, \"igx-icon\", 39);\n    i0.ɵɵelementStart(4, \"span\");\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵtemplate(6, IgxGridFilteringRowComponent_ng_container_18_span_6_Template, 12, 10, \"span\", 40);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const item_r90 = ctx.$implicit;\n    const last_r92 = ctx.last;\n    const ctx_r14 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"selectable\", false)(\"selected\", item_r90.isSelected)(\"displayDensity\", ctx_r14.displayDensity)(\"removable\", true);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"name\", item_r90.expression.condition.iconName);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r14.filteringService.getChipLabel(item_r90.expression));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !last_r92);\n  }\n}\n\nfunction IgxGridFilteringRowComponent_button_19_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r108 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 45);\n    i0.ɵɵlistener(\"click\", function IgxGridFilteringRowComponent_button_19_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r108);\n      const ctx_r107 = i0.ɵɵnextContext();\n      return ctx_r107.scrollChipsOnArrowPress(\"right\");\n    });\n    i0.ɵɵelementStart(1, \"igx-icon\");\n    i0.ɵɵtext(2, \"navigate_next\");\n    i0.ɵɵelementEnd()();\n  }\n}\n\nconst _c159 = [\"defaultESFHeaderIconTemplate\"];\nconst _c160 = [\"defaultSortHeaderIconTemplate\"];\n\nfunction IgxGridHeaderComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 6);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"title\", ctx_r1.title);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.column.header || ctx_r1.column.field);\n  }\n}\n\nfunction IgxGridHeaderComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1, \"more_vert\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxGridHeaderComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r5.sortDirection < 2 ? \"arrow_upward\" : \"arrow_downward\");\n  }\n}\n\nfunction IgxGridHeaderComponent_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridHeaderComponent_ng_container_8_ng_container_2_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridHeaderComponent_ng_container_8_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 8);\n    i0.ɵɵlistener(\"click\", function IgxGridHeaderComponent_ng_container_8_ng_container_2_Template_div_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r11 = i0.ɵɵnextContext(2);\n      return ctx_r11.onSortingIconClick($event);\n    })(\"pointerdown\", function IgxGridHeaderComponent_ng_container_8_ng_container_2_Template_div_pointerdown_1_listener($event) {\n      return $event.stopPropagation();\n    });\n    i0.ɵɵpipe(2, \"sortingIndex\");\n    i0.ɵɵtemplate(3, IgxGridHeaderComponent_ng_container_8_ng_container_2_ng_container_3_Template, 1, 0, \"ng-container\", 4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"data-sortIndex\", i0.ɵɵpipeBind2(2, 4, ctx_r8.column.field, ctx_r8.grid.sortingExpressions))(\"draggable\", false);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r8.sortIconTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(7, _c24, ctx_r8));\n  }\n}\n\nfunction IgxGridHeaderComponent_ng_container_8_ng_container_3_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridHeaderComponent_ng_container_8_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r16 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 9);\n    i0.ɵɵlistener(\"click\", function IgxGridHeaderComponent_ng_container_8_ng_container_3_Template_div_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r15 = i0.ɵɵnextContext(2);\n      return ctx_r15.onFilteringIconClick($event);\n    })(\"pointerdown\", function IgxGridHeaderComponent_ng_container_8_ng_container_3_Template_div_pointerdown_1_listener($event) {\n      return $event.stopPropagation();\n    });\n    i0.ɵɵtemplate(2, IgxGridHeaderComponent_ng_container_8_ng_container_3_ng_container_2_Template, 1, 0, \"ng-container\", 4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", ctx_r9.filterIconClassName);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r9.esfIconTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(3, _c24, ctx_r9));\n  }\n}\n\nfunction IgxGridHeaderComponent_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 7);\n    i0.ɵɵtemplate(2, IgxGridHeaderComponent_ng_container_8_ng_container_2_Template, 4, 9, \"ng-container\", 5);\n    i0.ɵɵtemplate(3, IgxGridHeaderComponent_ng_container_8_ng_container_3_Template, 3, 5, \"ng-container\", 5);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.sortable);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.grid.allowFiltering && ctx_r7.column.filterable && ctx_r7.grid.filterMode === \"excelStyleFilter\");\n  }\n}\n\nconst _c161 = function (a0, a1) {\n  return {\n    $implicit: a0,\n    column: a1\n  };\n};\n\nconst _c162 = [\"emptyFilter\"];\nconst _c163 = [\"defaultFilter\"];\nconst _c164 = [\"complexFilter\"];\nconst _c165 = [\"moreIcon\"];\nconst _c166 = [\"ghostChip\"];\nconst _c167 = [\"complexChip\"];\n\nfunction IgxGridFilteringCellComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-chips-area\", 4)(1, \"igx-chip\", 5, 6);\n    i0.ɵɵlistener(\"click\", function IgxGridFilteringCellComponent_ng_template_0_Template_igx_chip_click_1_listener() {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.onChipClicked();\n    });\n    i0.ɵɵelementStart(3, \"igx-icon\", 7);\n    i0.ɵɵtext(4, \"filter_list\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"span\");\n    i0.ɵɵtext(6);\n    i0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"draggable\", false);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r1.displayDensity)(\"tabIndex\", -1);\n    i0.ɵɵattribute(\"draggable\", false);\n    i0.ɵɵadvance(2);\n    i0.ɵɵattribute(\"draggable\", false);\n    i0.ɵɵadvance(2);\n    i0.ɵɵattribute(\"draggable\", false);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.filteringService.grid.resourceStrings.igx_grid_filter);\n  }\n}\n\nfunction IgxGridFilteringCellComponent_ng_template_2_ng_container_2_igx_chip_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r21 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-chip\", 15);\n    i0.ɵɵlistener(\"click\", function IgxGridFilteringCellComponent_ng_template_2_ng_container_2_igx_chip_1_Template_igx_chip_click_0_listener() {\n      i0.ɵɵrestoreView(_r21);\n      const item_r13 = i0.ɵɵnextContext().$implicit;\n      const ctx_r19 = i0.ɵɵnextContext(2);\n      return ctx_r19.onChipClicked(item_r13.expression);\n    })(\"remove\", function IgxGridFilteringCellComponent_ng_template_2_ng_container_2_igx_chip_1_Template_igx_chip_remove_0_listener($event) {\n      i0.ɵɵrestoreView(_r21);\n      const item_r13 = i0.ɵɵnextContext().$implicit;\n      const ctx_r22 = i0.ɵɵnextContext(2);\n      return ctx_r22.onChipRemoved($event, item_r13);\n    });\n    i0.ɵɵelement(1, \"igx-icon\", 16);\n    i0.ɵɵelementStart(2, \"span\", null, 17);\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const item_r13 = i0.ɵɵnextContext().$implicit;\n    const ctx_r16 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"removable\", true)(\"tabIndex\", -1)(\"displayDensity\", ctx_r16.displayDensity);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"name\", item_r13.expression.condition.iconName);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r16.filteringService.getChipLabel(item_r13.expression), \" \");\n  }\n}\n\nfunction IgxGridFilteringCellComponent_ng_template_2_ng_container_2_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 18);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r13 = i0.ɵɵnextContext().$implicit;\n    const ctx_r17 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r17.filteringService.getOperatorAsString(item_r13.afterOperator));\n  }\n}\n\nfunction IgxGridFilteringCellComponent_ng_template_2_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxGridFilteringCellComponent_ng_template_2_ng_container_2_igx_chip_1_Template, 5, 5, \"igx-chip\", 13);\n    i0.ɵɵtemplate(2, IgxGridFilteringCellComponent_ng_template_2_ng_container_2_span_2_Template, 2, 1, \"span\", 14);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const last_r14 = ctx.last;\n    const index_r15 = ctx.index;\n    const ctx_r11 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r11.isChipVisible(index_r15));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !last_r14 && ctx_r11.isChipVisible(index_r15 + 1));\n  }\n}\n\nfunction IgxGridFilteringCellComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r27 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-chips-area\", 4, 8);\n    i0.ɵɵtemplate(2, IgxGridFilteringCellComponent_ng_template_2_ng_container_2_Template, 3, 2, \"ng-container\", 9);\n    i0.ɵɵelementStart(3, \"div\", 10, 11);\n    i0.ɵɵlistener(\"click\", function IgxGridFilteringCellComponent_ng_template_2_Template_div_click_3_listener() {\n      i0.ɵɵrestoreView(_r27);\n      const ctx_r26 = i0.ɵɵnextContext();\n      return ctx_r26.onChipClicked();\n    });\n    i0.ɵɵelementStart(5, \"igx-icon\");\n    i0.ɵɵtext(6, \"filter_list\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(7, \"igx-badge\", 12);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r3.expressionsList);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", ctx_r3.filteringIndicatorClass());\n    i0.ɵɵadvance(4);\n    i0.ɵɵproperty(\"value\", ctx_r3.moreFiltersCount);\n  }\n}\n\nfunction IgxGridFilteringCellComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r30 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-chip\", 19, 20);\n    i0.ɵɵlistener(\"remove\", function IgxGridFilteringCellComponent_ng_template_4_Template_igx_chip_remove_0_listener() {\n      i0.ɵɵrestoreView(_r30);\n      const ctx_r29 = i0.ɵɵnextContext();\n      return ctx_r29.clearFiltering();\n    });\n    i0.ɵɵelementStart(2, \"igx-icon\", 7);\n    i0.ɵɵtext(3, \"filter_list\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"span\");\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"removable\", true)(\"displayDensity\", ctx_r5.displayDensity)(\"tabIndex\", -1);\n    i0.ɵɵadvance(5);\n    i0.ɵɵtextInterpolate(ctx_r5.filteringService.grid.resourceStrings.igx_grid_complex_filter);\n  }\n}\n\nfunction IgxGridFilteringCellComponent_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridHeaderGroupComponent_ng_container_0_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 7);\n  }\n}\n\nfunction IgxGridHeaderGroupComponent_ng_container_0_ng_container_3_igx_grid_header_group_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-grid-header-group\", 9);\n    i0.ɵɵpipe(1, \"igxHeaderGroupStyle\");\n  }\n\n  if (rf & 2) {\n    const child_r10 = i0.ɵɵnextContext().$implicit;\n    const ctx_r11 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", child_r10.headerGroupClasses)(\"ngStyle\", i0.ɵɵpipeBind3(1, 7, child_r10.headerGroupStyles, child_r10, ctx_r11.grid.pipeTrigger))(\"column\", child_r10)(\"igxColumnMovingDrag\", child_r10)(\"ghostHost\", ctx_r11.grid.outlet.nativeElement)(\"igxColumnMovingDrop\", child_r10);\n    i0.ɵɵattribute(\"droppable\", true);\n  }\n}\n\nfunction IgxGridHeaderGroupComponent_ng_container_0_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxGridHeaderGroupComponent_ng_container_0_ng_container_3_igx_grid_header_group_1_Template, 2, 11, \"igx-grid-header-group\", 8);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const child_r10 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !child_r10.hidden);\n  }\n}\n\nfunction IgxGridHeaderGroupComponent_ng_container_0_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 10);\n  }\n}\n\nconst _c168 = function (a0, a1) {\n  return {\n    \"igx-grid-th--pinned-last\": a0,\n    \"igx-grid-th--pinned-first\": a1\n  };\n};\n\nconst _c169 = function (a0, a1) {\n  return {\n    \"grid-template-rows\": a0,\n    \"grid-template-columns\": a1\n  };\n};\n\nfunction IgxGridHeaderGroupComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxGridHeaderGroupComponent_ng_container_0_span_1_Template, 1, 0, \"span\", 3);\n    i0.ɵɵelementStart(2, \"div\", 4);\n    i0.ɵɵtemplate(3, IgxGridHeaderGroupComponent_ng_container_0_ng_container_3_Template, 2, 1, \"ng-container\", 5);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(4, IgxGridHeaderGroupComponent_ng_container_0_span_4_Template, 1, 0, \"span\", 6);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.grid.moving);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(5, _c168, ctx_r0.hasLastPinnedChildColumn, ctx_r0.hasFirstPinnedChildColumn))(\"ngStyle\", i0.ɵɵpureFunction2(8, _c169, ctx_r0.column.getGridTemplate(true), ctx_r0.column.getGridTemplate(false)));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.column.children);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.grid.moving);\n  }\n}\n\nfunction IgxGridHeaderGroupComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 11);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"title\", ctx_r2.title);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r2.column.header);\n  }\n}\n\nfunction IgxGridHeaderGroupComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"draggable\", false);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r4.column.expanded ? \"expand_more\" : \"chevron_right\", \" \");\n  }\n}\n\nfunction IgxGridHeaderGroupComponent_ng_container_5_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 7);\n  }\n}\n\nfunction IgxGridHeaderGroupComponent_ng_container_5_ng_container_3_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridHeaderGroupComponent_ng_container_5_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r20 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 15);\n    i0.ɵɵlistener(\"click\", function IgxGridHeaderGroupComponent_ng_container_5_ng_container_3_Template_div_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r20);\n      const ctx_r19 = i0.ɵɵnextContext(2);\n      return ctx_r19.toggleExpandState($event);\n    });\n    i0.ɵɵtemplate(2, IgxGridHeaderGroupComponent_ng_container_5_ng_container_3_ng_container_2_Template, 1, 0, \"ng-container\", 13);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r14 = i0.ɵɵnextContext(2);\n\n    const _r3 = i0.ɵɵreference(4);\n\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r14.column.collapsibleIndicatorTemplate ? ctx_r14.column.collapsibleIndicatorTemplate : _r3)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(2, _c161, ctx_r14.column, ctx_r14.column));\n  }\n}\n\nfunction IgxGridHeaderGroupComponent_ng_container_5_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridHeaderGroupComponent_ng_container_5_div_5_ng_container_1_igx_grid_header_group_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-grid-header-group\", 18);\n    i0.ɵɵpipe(1, \"igxHeaderGroupWidth\");\n    i0.ɵɵpipe(2, \"igxHeaderGroupWidth\");\n    i0.ɵɵpipe(3, \"igxHeaderGroupStyle\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const child_r22 = i0.ɵɵnextContext().$implicit;\n    const ctx_r23 = i0.ɵɵnextContext(3);\n    i0.ɵɵstyleProp(\"min-width\", i0.ɵɵpipeBind3(1, 7, child_r22.calcWidth, ctx_r23.grid.defaultHeaderGroupMinWidth, ctx_r23.grid.hasColumnLayouts))(\"flex-basis\", i0.ɵɵpipeBind3(2, 11, child_r22.calcWidth, ctx_r23.grid.defaultHeaderGroupMinWidth, ctx_r23.grid.hasColumnLayouts));\n    i0.ɵɵproperty(\"ngClass\", child_r22.headerGroupClasses)(\"ngStyle\", i0.ɵɵpipeBind3(3, 15, child_r22.headerGroupStyles, child_r22, ctx_r23.grid.pipeTrigger))(\"column\", child_r22);\n  }\n}\n\nfunction IgxGridHeaderGroupComponent_ng_container_5_div_5_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxGridHeaderGroupComponent_ng_container_5_div_5_ng_container_1_igx_grid_header_group_1_Template, 4, 19, \"igx-grid-header-group\", 17);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const child_r22 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !child_r22.hidden);\n  }\n}\n\nfunction IgxGridHeaderGroupComponent_ng_container_5_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 16);\n    i0.ɵɵtemplate(1, IgxGridHeaderGroupComponent_ng_container_5_div_5_ng_container_1_Template, 2, 1, \"ng-container\", 5);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r16.column.children);\n  }\n}\n\nfunction IgxGridHeaderGroupComponent_ng_container_5_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 10);\n  }\n}\n\nconst _c170 = function (a0, a1, a2, a3, a4, a5) {\n  return {\n    \"igx-grid-th--pinned-last\": a0,\n    \"igx-grid-th--pinned-first\": a1,\n    \"igx-grid-th--collapsible\": a2,\n    \"igx-grid-th--selectable\": a3,\n    \"igx-grid-th--selected\": a4,\n    \"igx-grid-th--active\": a5\n  };\n};\n\nfunction IgxGridHeaderGroupComponent_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r26 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxGridHeaderGroupComponent_ng_container_5_span_1_Template, 1, 0, \"span\", 3);\n    i0.ɵɵelementStart(2, \"div\", 12);\n    i0.ɵɵlistener(\"pointerdown\", function IgxGridHeaderGroupComponent_ng_container_5_Template_div_pointerdown_2_listener($event) {\n      i0.ɵɵrestoreView(_r26);\n      const ctx_r25 = i0.ɵɵnextContext();\n      return ctx_r25.pointerdown($event);\n    })(\"click\", function IgxGridHeaderGroupComponent_ng_container_5_Template_div_click_2_listener($event) {\n      i0.ɵɵrestoreView(_r26);\n      const ctx_r27 = i0.ɵɵnextContext();\n      return ctx_r27.groupClicked($event);\n    })(\"pointerenter\", function IgxGridHeaderGroupComponent_ng_container_5_Template_div_pointerenter_2_listener() {\n      i0.ɵɵrestoreView(_r26);\n      const ctx_r28 = i0.ɵɵnextContext();\n      return ctx_r28.onPinterEnter();\n    })(\"pointerleave\", function IgxGridHeaderGroupComponent_ng_container_5_Template_div_pointerleave_2_listener() {\n      i0.ɵɵrestoreView(_r26);\n      const ctx_r29 = i0.ɵɵnextContext();\n      return ctx_r29.onPointerLeave();\n    });\n    i0.ɵɵtemplate(3, IgxGridHeaderGroupComponent_ng_container_5_ng_container_3_Template, 3, 5, \"ng-container\", 0);\n    i0.ɵɵtemplate(4, IgxGridHeaderGroupComponent_ng_container_5_ng_container_4_Template, 1, 0, \"ng-container\", 13);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(5, IgxGridHeaderGroupComponent_ng_container_5_div_5_Template, 2, 1, \"div\", 14);\n    i0.ɵɵtemplate(6, IgxGridHeaderGroupComponent_ng_container_5_span_6_Template, 1, 0, \"span\", 6);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n\n    const _r1 = i0.ɵɵreference(2);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.grid.moving);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction6(14, _c170, ctx_r5.hasLastPinnedChildColumn, ctx_r5.hasFirstPinnedChildColumn, ctx_r5.column.collapsible, ctx_r5.selectable, ctx_r5.selected, ctx_r5.activeGroup))(\"igxColumnMovingDrag\", ctx_r5.column)(\"ghostHost\", ctx_r5.grid.outlet.nativeElement)(\"igxColumnMovingDrop\", ctx_r5.column);\n    i0.ɵɵattribute(\"aria-label\", ctx_r5.column.header || ctx_r5.column.field)(\"aria-expanded\", ctx_r5.column.expanded)(\"aria-selected\", ctx_r5.column.selected)(\"droppable\", true);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.column.collapsible);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r5.column.headerTemplate ? ctx_r5.column.headerTemplate : _r1)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(21, _c161, ctx_r5.column, ctx_r5.column));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r5.grid.isPivot);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.grid.moving);\n  }\n}\n\nfunction IgxGridHeaderGroupComponent_ng_container_6_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 7);\n  }\n}\n\nfunction IgxGridHeaderGroupComponent_ng_container_6_igx_grid_filtering_cell_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-grid-filtering-cell\", 22);\n  }\n\n  if (rf & 2) {\n    const ctx_r31 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"column\", ctx_r31.column);\n    i0.ɵɵattribute(\"draggable\", false);\n  }\n}\n\nfunction IgxGridHeaderGroupComponent_ng_container_6_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 23);\n  }\n\n  if (rf & 2) {\n    const ctx_r32 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"cursor\", ctx_r32.colResizingService.resizeCursor);\n    i0.ɵɵproperty(\"igxResizeHandle\", ctx_r32.column);\n    i0.ɵɵattribute(\"draggable\", false);\n  }\n}\n\nfunction IgxGridHeaderGroupComponent_ng_container_6_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 10);\n  }\n}\n\nfunction IgxGridHeaderGroupComponent_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r35 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxGridHeaderGroupComponent_ng_container_6_span_1_Template, 1, 0, \"span\", 3);\n    i0.ɵɵelementStart(2, \"igx-grid-header\", 19);\n    i0.ɵɵlistener(\"pointerdown\", function IgxGridHeaderGroupComponent_ng_container_6_Template_igx_grid_header_pointerdown_2_listener() {\n      i0.ɵɵrestoreView(_r35);\n      const ctx_r34 = i0.ɵɵnextContext();\n      return ctx_r34.activate();\n    });\n    i0.ɵɵpipe(3, \"igxHeaderGroupStyle\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(4, IgxGridHeaderGroupComponent_ng_container_6_igx_grid_filtering_cell_4_Template, 1, 2, \"igx-grid-filtering-cell\", 20);\n    i0.ɵɵtemplate(5, IgxGridHeaderGroupComponent_ng_container_6_span_5_Template, 1, 4, \"span\", 21);\n    i0.ɵɵtemplate(6, IgxGridHeaderGroupComponent_ng_container_6_span_6_Template, 1, 0, \"span\", 6);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.grid.moving);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"id\", ctx_r6.grid.id + \"_\" + ctx_r6.column.field)(\"ngClass\", ctx_r6.column.headerClasses)(\"ngStyle\", i0.ɵɵpipeBind3(3, 13, ctx_r6.column.headerStyles, ctx_r6.column, ctx_r6.grid.pipeTrigger))(\"igxColumnMovingDrag\", ctx_r6.column)(\"ghostHost\", ctx_r6.grid.outlet.nativeElement)(\"igxColumnMovingDrop\", ctx_r6.column)(\"column\", ctx_r6.column)(\"density\", ctx_r6.grid.displayDensity);\n    i0.ɵɵattribute(\"droppable\", true);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.grid.allowFiltering && ctx_r6.grid.filterMode === \"quickFilter\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r6.column.columnGroup && ctx_r6.column.resizable);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.grid.moving);\n  }\n}\n\nconst _c171 = [\"headerVirtualContainer\"];\nconst _c172 = [\"headerDragContainer\"];\nconst _c173 = [\"headerSelectorContainer\"];\nconst _c174 = [\"headerGroupContainer\"];\nconst _c175 = [\"headSelectorBaseTemplate\"];\nconst _c176 = [\"headerHierarchyExpander\"];\n\nfunction IgxGridHeaderRowComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"span\", 8);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"left\", ctx_r0.grid.pinnedWidth, \"px\");\n    i0.ɵɵproperty(\"igxColumnMovingDrop\", ctx_r0.headerContainer);\n  }\n}\n\nfunction IgxGridHeaderRowComponent_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"span\", 9);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"left\", ctx_r1.grid.pinnedWidth, \"px\");\n    i0.ɵɵproperty(\"igxColumnMovingDrop\", ctx_r1.headerContainer);\n  }\n}\n\nfunction IgxGridHeaderRowComponent_ng_container_4_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridHeaderRowComponent_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 10, 11);\n    i0.ɵɵlistener(\"pointerdown\", function IgxGridHeaderRowComponent_ng_container_4_Template_div_pointerdown_1_listener($event) {\n      return $event.preventDefault();\n    });\n    i0.ɵɵelementStart(3, \"div\", 12);\n    i0.ɵɵtemplate(4, IgxGridHeaderRowComponent_ng_container_4_ng_container_4_Template, 1, 0, \"ng-container\", 13);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"igx-grid__drag-indicator--header\", !ctx_r2.grid.isRowSelectable);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r2.grid.dragIndicatorIconTemplate || ctx_r2.grid.dragIndicatorIconBase);\n  }\n}\n\nfunction IgxGridHeaderRowComponent_ng_container_5_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0, null, 17);\n  }\n}\n\nfunction IgxGridHeaderRowComponent_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r21 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 14, 15);\n    i0.ɵɵlistener(\"click\", function IgxGridHeaderRowComponent_ng_container_5_Template_div_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r21);\n      const ctx_r20 = i0.ɵɵnextContext();\n      return ctx_r20.headerRowSelection($event);\n    })(\"pointerdown\", function IgxGridHeaderRowComponent_ng_container_5_Template_div_pointerdown_1_listener($event) {\n      return $event.preventDefault();\n    });\n    i0.ɵɵtemplate(3, IgxGridHeaderRowComponent_ng_container_5_ng_container_3_Template, 2, 0, \"ng-container\", 16);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n\n    const _r12 = i0.ɵɵreference(17);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"igx-grid__cbx-selection--push\", ctx_r3.grid.filteringService.isFilterRowVisible);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r3.grid.headSelectorTemplate || _r12)(\"ngTemplateOutletContext\", ctx_r3.rowSelectorsContext);\n  }\n}\n\nfunction IgxGridHeaderRowComponent_ng_container_6_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nconst _c177 = function (a0, a1, a2) {\n  return {\n    \"igx-grid__hierarchical-expander igx-grid__hierarchical-expander--header igx-grid__tr-action\": a0,\n    \"igx-grid__hierarchical-expander--push\": a1,\n    \"igx-grid__hierarchical-expander--no-border\": a2\n  };\n};\n\nfunction IgxGridHeaderRowComponent_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r26 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 18, 19);\n    i0.ɵɵlistener(\"click\", function IgxGridHeaderRowComponent_ng_container_6_Template_div_click_1_listener() {\n      i0.ɵɵrestoreView(_r26);\n      const ctx_r25 = i0.ɵɵnextContext();\n      return ctx_r25.grid.toggleAll();\n    })(\"pointerdown\", function IgxGridHeaderRowComponent_ng_container_6_Template_div_pointerdown_1_listener($event) {\n      return $event.preventDefault();\n    });\n    i0.ɵɵtemplate(3, IgxGridHeaderRowComponent_ng_container_6_ng_container_3_Template, 1, 0, \"ng-container\", 16);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"hidden\", !ctx_r4.grid.hasExpandableChildren || !ctx_r4.grid.hasVisibleColumns)(\"ngClass\", i0.ɵɵpureFunction3(4, _c177, ctx_r4.grid.hasExpandableChildren, ctx_r4.grid.filteringService.isFilterRowVisible, ctx_r4.grid.isRowSelectable || ctx_r4.grid.rowDraggable));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r4.grid.iconTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(8, _c24, ctx_r4.grid));\n  }\n}\n\nfunction IgxGridHeaderRowComponent_ng_container_7_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridHeaderRowComponent_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r31 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 20, 21);\n    i0.ɵɵlistener(\"click\", function IgxGridHeaderRowComponent_ng_container_7_Template_div_click_1_listener() {\n      i0.ɵɵrestoreView(_r31);\n      const ctx_r30 = i0.ɵɵnextContext();\n      return ctx_r30.grid.toggleAllGroupRows();\n    })(\"pointerdown\", function IgxGridHeaderRowComponent_ng_container_7_Template_div_pointerdown_1_listener($event) {\n      return $event.preventDefault();\n    });\n    i0.ɵɵtemplate(3, IgxGridHeaderRowComponent_ng_container_7_ng_container_3_Template, 1, 0, \"ng-container\", 13);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassMap(ctx_r5.indentationCSSClasses);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r5.grid.iconTemplate);\n  }\n}\n\nfunction IgxGridHeaderRowComponent_ng_container_8_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-grid-header-group\", 23);\n    i0.ɵɵpipe(2, \"igxHeaderGroupWidth\");\n    i0.ɵɵpipe(3, \"igxHeaderGroupWidth\");\n    i0.ɵɵpipe(4, \"igxHeaderGroupStyle\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const column_r34 = ctx.$implicit;\n    const ctx_r33 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"min-width\", i0.ɵɵpipeBind3(2, 7, column_r34.calcWidth, ctx_r33.grid.defaultHeaderGroupMinWidth, ctx_r33.hasMRL))(\"flex-basis\", i0.ɵɵpipeBind3(3, 11, column_r34.calcWidth, ctx_r33.grid.defaultHeaderGroupMinWidth, ctx_r33.hasMRL));\n    i0.ɵɵproperty(\"ngClass\", column_r34.headerGroupClasses)(\"ngStyle\", i0.ɵɵpipeBind3(4, 15, column_r34.headerGroupStyles, column_r34, ctx_r33.grid.pipeTrigger))(\"column\", column_r34);\n  }\n}\n\nfunction IgxGridHeaderRowComponent_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxGridHeaderRowComponent_ng_container_8_ng_container_1_Template, 5, 19, \"ng-container\", 22);\n    i0.ɵɵpipe(2, \"igxTopLevel\");\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBind1(2, 1, ctx_r6.pinnedColumnCollection));\n  }\n}\n\nfunction IgxGridHeaderRowComponent_ng_template_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-grid-header-group\", 23);\n    i0.ɵɵpipe(1, \"igxHeaderGroupWidth\");\n    i0.ɵɵpipe(2, \"igxHeaderGroupWidth\");\n    i0.ɵɵpipe(3, \"igxHeaderGroupStyle\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const column_r35 = ctx.$implicit;\n    const ctx_r8 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"min-width\", i0.ɵɵpipeBind3(1, 7, column_r35.calcWidth, ctx_r8.grid.defaultHeaderGroupMinWidth, ctx_r8.hasMRL))(\"flex-basis\", i0.ɵɵpipeBind3(2, 11, column_r35.calcWidth, ctx_r8.grid.defaultHeaderGroupMinWidth, ctx_r8.hasMRL));\n    i0.ɵɵproperty(\"ngClass\", column_r35.headerGroupClasses)(\"ngStyle\", i0.ɵɵpipeBind3(3, 15, column_r35.headerGroupStyles, column_r35, ctx_r8.grid.pipeTrigger))(\"column\", column_r35);\n  }\n}\n\nfunction IgxGridHeaderRowComponent_ng_container_12_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-grid-header-group\", 23);\n    i0.ɵɵpipe(2, \"igxHeaderGroupWidth\");\n    i0.ɵɵpipe(3, \"igxHeaderGroupWidth\");\n    i0.ɵɵpipe(4, \"igxHeaderGroupStyle\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const column_r37 = ctx.$implicit;\n    const ctx_r36 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"min-width\", i0.ɵɵpipeBind3(2, 9, column_r37.calcWidth, ctx_r36.grid.defaultHeaderGroupMinWidth, ctx_r36.hasMRL))(\"flex-basis\", i0.ɵɵpipeBind3(3, 13, column_r37.calcWidth, ctx_r36.grid.defaultHeaderGroupMinWidth, ctx_r36.hasMRL))(\"left\", column_r37.rightPinnedOffset);\n    i0.ɵɵproperty(\"ngClass\", column_r37.headerGroupClasses)(\"ngStyle\", i0.ɵɵpipeBind3(4, 17, column_r37.headerGroupStyles, column_r37, ctx_r36.grid.pipeTrigger))(\"column\", column_r37);\n  }\n}\n\nfunction IgxGridHeaderRowComponent_ng_container_12_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxGridHeaderRowComponent_ng_container_12_ng_container_1_Template, 5, 21, \"ng-container\", 22);\n    i0.ɵɵpipe(2, \"igxTopLevel\");\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBind1(2, 1, ctx_r9.pinnedColumnCollection));\n  }\n}\n\nfunction IgxGridHeaderRowComponent_ng_container_13_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"igx-grid-filtering-row\", 24, 25);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r10 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"width\", ctx_r10.width, \"px\");\n    i0.ɵɵproperty(\"column\", ctx_r10.grid.filteringService.filteredColumn);\n  }\n}\n\nfunction IgxGridHeaderRowComponent_ng_container_14_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"span\", 26);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"igxColumnMovingDrop\", ctx_r11.headerContainer);\n  }\n}\n\nconst _c178 = function (a0) {\n  return {\n    \"visibility\": a0\n  };\n};\n\nfunction IgxGridHeaderRowComponent_ng_template_16_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 27);\n    i0.ɵɵelement(1, \"igx-checkbox\", 28, 29);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const context_r39 = ctx.$implicit;\n    const ctx_r13 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"tabindex\", -1)(\"readonly\", true)(\"checked\", context_r39.selectedCount > 0 && context_r39.totalCount === context_r39.selectedCount)(\"disableRipple\", true)(\"ngStyle\", i0.ɵɵpureFunction1(7, _c178, ctx_r13.grid.isMultiRowSelectionEnabled ? \"visible\" : \"hidden\"))(\"indeterminate\", context_r39.selectedCount > 0 && context_r39.selectedCount !== context_r39.totalCount)(\"aria-label\", ctx_r13.grid.headSelectorBaseAriaLabel);\n  }\n}\n\nfunction IgxGridGroupByAreaComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-chip\", 5);\n    i0.ɵɵlistener(\"keyDown\", function IgxGridGroupByAreaComponent_ng_container_1_Template_igx_chip_keyDown_1_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.handleKeyDown($event.owner.id, $event.originalEvent);\n    })(\"remove\", function IgxGridGroupByAreaComponent_ng_container_1_Template_igx_chip_remove_1_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.clearGrouping($event.owner.id);\n    })(\"chipClick\", function IgxGridGroupByAreaComponent_ng_container_1_Template_igx_chip_chipClick_1_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r7);\n      const expression_r4 = restoredCtx.$implicit;\n      const ctx_r9 = i0.ɵɵnextContext();\n      return ctx_r9.handleClick(expression_r4.fieldName);\n    });\n    i0.ɵɵpipe(2, \"igxGroupByMeta\");\n    i0.ɵɵpipe(3, \"igxGroupByMeta\");\n    i0.ɵɵpipe(4, \"igxGroupByMeta\");\n    i0.ɵɵpipe(5, \"igxGroupByMeta\");\n    i0.ɵɵelementStart(6, \"span\");\n    i0.ɵɵtext(7);\n    i0.ɵɵpipe(8, \"igxGroupByMeta\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(9, \"igx-icon\", 6);\n    i0.ɵɵtext(10);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(11, \"span\", 7)(12, \"igx-icon\", 8);\n    i0.ɵɵtext(13, \"arrow_forward\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const expression_r4 = ctx.$implicit;\n    const last_r5 = ctx.last;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"id\", expression_r4.fieldName)(\"title\", i0.ɵɵpipeBind2(2, 9, expression_r4.fieldName, ctx_r0.grid).title)(\"displayDensity\", ctx_r0.grid.displayDensity)(\"removable\", i0.ɵɵpipeBind2(3, 12, expression_r4.fieldName, ctx_r0.grid).groupable)(\"draggable\", i0.ɵɵpipeBind2(4, 15, expression_r4.fieldName, ctx_r0.grid).groupable)(\"disabled\", !i0.ɵɵpipeBind2(5, 18, expression_r4.fieldName, ctx_r0.grid).groupable);\n    i0.ɵɵadvance(6);\n    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind2(8, 21, expression_r4.fieldName, ctx_r0.grid).title);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate(expression_r4.dir === 1 ? \"arrow_upward\" : \"arrow_downward\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"hidden\", last_r5 && !ctx_r0.dropAreaVisible);\n  }\n}\n\nfunction IgxGridGroupByAreaComponent_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridGroupByAreaComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\", 9);\n    i0.ɵɵtext(1, \"group_work\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"span\", 10);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate(ctx_r3.dropAreaMessage);\n  }\n}\n\nconst _c179 = [\"loadingOverlay\"];\nconst _c180 = [\"igxLoadingOverlayOutlet\"];\nconst _c181 = [\"emptyFilteredGrid\"];\nconst _c182 = [\"defaultEmptyGrid\"];\nconst _c183 = [\"defaultLoadingGrid\"];\nconst _c184 = [\"verticalScrollContainer\"];\nconst _c185 = [\"verticalScrollHolder\"];\nconst _c186 = [\"scr\"];\nconst _c187 = [\"footer\"];\nconst _c188 = [\"tbody\"];\nconst _c189 = [\"pinContainer\"];\nconst _c190 = [\"tfoot\"];\nconst _c191 = [\"igxRowEditingOverlayOutlet\"];\nconst _c192 = [\"dragIndicatorIconBase\"];\nconst _c193 = [\"rowEditingOverlay\"];\nconst _c194 = [\"igxFilteringOverlayOutlet\"];\nconst _c195 = [\"defaultExpandedTemplate\"];\nconst _c196 = [\"defaultCollapsedTemplate\"];\nconst _c197 = [\"defaultESFHeaderIcon\"];\nconst _c198 = [\"defaultRowEditTemplate\"];\nconst _c199 = [\"summaryRow\"];\nconst _c200 = [\"row\"];\nconst _c201 = [\"pinnedRow\"];\nconst _c202 = [\"groupContent\"];\nconst _c203 = [\"defaultGroupByExpandedTemplate\"];\nconst _c204 = [\"defaultGroupByCollapsedTemplate\"];\n\nfunction IgxGridGroupByRowComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 10)(2, \"igx-icon\");\n    i0.ɵɵtext(3, \"drag_indicator\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵadvance(2);\n    i0.ɵɵstyleProp(\"visibility\", \"hidden\");\n  }\n}\n\nfunction IgxGridGroupByRowComponent_ng_container_3_2_ng_template_0_Template(rf, ctx) {}\n\nfunction IgxGridGroupByRowComponent_ng_container_3_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxGridGroupByRowComponent_ng_container_3_2_ng_template_0_Template, 0, 0, \"ng-template\", null, 12, i0.ɵɵtemplateRefExtractor);\n  }\n}\n\nconst _c205 = function (a0, a1, a2) {\n  return {\n    selectedCount: a0,\n    totalCount: a1,\n    groupRow: a2\n  };\n};\n\nfunction IgxGridGroupByRowComponent_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r19 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 11);\n    i0.ɵɵlistener(\"pointerdown\", function IgxGridGroupByRowComponent_ng_container_3_Template_div_pointerdown_1_listener($event) {\n      return $event.preventDefault();\n    })(\"click\", function IgxGridGroupByRowComponent_ng_container_3_Template_div_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r19);\n      const ctx_r18 = i0.ɵɵnextContext();\n      return ctx_r18.onGroupSelectorClick($event);\n    });\n    i0.ɵɵtemplate(2, IgxGridGroupByRowComponent_ng_container_3_2_Template, 2, 0, null, 3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n\n    const _r12 = i0.ɵɵreference(16);\n\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r2.grid.groupByRowSelectorTemplate ? ctx_r2.grid.groupByRowSelectorTemplate : _r12)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(6, _c24, i0.ɵɵpureFunction3(2, _c205, ctx_r2.selectedRowsInTheGroup.length, ctx_r2.groupRow.records.length, ctx_r2.groupRow)));\n  }\n}\n\nfunction IgxGridGroupByRowComponent_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridGroupByRowComponent_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridGroupByRowComponent_ng_template_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1, \"expand_more\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxGridGroupByRowComponent_ng_template_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1, \"chevron_right\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxGridGroupByRowComponent_ng_template_13_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 19);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r20 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r20.groupRow.value);\n  }\n}\n\nfunction IgxGridGroupByRowComponent_ng_template_13_ng_template_6_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 19);\n    i0.ɵɵtext(2);\n    i0.ɵɵpipe(3, \"number\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r23 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(3, 1, ctx_r23.groupRow.value));\n  }\n}\n\nfunction IgxGridGroupByRowComponent_ng_template_13_ng_template_6_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"span\", 19);\n    i0.ɵɵtext(2);\n    i0.ɵɵpipe(3, \"date\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r24 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(3, 1, ctx_r24.groupRow.value));\n  }\n}\n\nfunction IgxGridGroupByRowComponent_ng_template_13_ng_template_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxGridGroupByRowComponent_ng_template_13_ng_template_6_ng_container_0_Template, 4, 3, \"ng-container\", 1);\n    i0.ɵɵtemplate(1, IgxGridGroupByRowComponent_ng_template_13_ng_template_6_ng_container_1_Template, 4, 3, \"ng-container\", 1);\n  }\n\n  if (rf & 2) {\n    const ctx_r22 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r22.dataType === \"number\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r22.dataType === \"date\");\n  }\n}\n\nfunction IgxGridGroupByRowComponent_ng_template_13_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 13)(1, \"igx-icon\", 14);\n    i0.ɵɵtext(2, \"group_work\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"span\", 15);\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(5, IgxGridGroupByRowComponent_ng_template_13_ng_container_5_Template, 3, 1, \"ng-container\", 16);\n    i0.ɵɵtemplate(6, IgxGridGroupByRowComponent_ng_template_13_ng_template_6_Template, 2, 2, \"ng-template\", null, 17, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelement(8, \"igx-badge\", 18);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const _r21 = i0.ɵɵreference(7);\n\n    const ctx_r11 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r11.groupRow.column && ctx_r11.groupRow.column.header ? ctx_r11.groupRow.column.header : ctx_r11.groupRow.expression ? ctx_r11.groupRow.expression.fieldName : \"\", \": \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r11.dataType === \"boolean\" || ctx_r11.dataType === \"string\")(\"ngIfElse\", _r21);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"value\", ctx_r11.groupRow.records ? ctx_r11.groupRow.records.length : 0);\n  }\n}\n\nfunction IgxGridGroupByRowComponent_ng_template_15_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 20);\n    i0.ɵɵelement(1, \"igx-checkbox\", 21, 22);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r13 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"tabindex\", -1)(\"readonly\", true)(\"checked\", ctx_r13.areAllRowsInTheGroupSelected)(\"disableRipple\", true)(\"indeterminate\", ctx_r13.groupByRowCheckboxIndeterminateState)(\"disabled\", ctx_r13.grid.rowSelection === \"single\")(\"aria-label\", ctx_r13.groupByRowSelectorBaseAriaLabel);\n  }\n}\n\nconst _c206 = [\"defaultCell\"];\nconst _c207 = [\"defaultPinnedIndicator\"];\nconst _c208 = [\"inlineEditor\"];\nconst _c209 = [\"addRowCell\"];\n\nfunction IgxGridCellComponent_ng_template_0_igx_chip_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-chip\", 6);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r10 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"disabled\", true)(\"displayDensity\", \"compact\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r10.grid.resourceStrings.igx_grid_pinned_row_indicator);\n  }\n}\n\nfunction IgxGridCellComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxGridCellComponent_ng_template_0_igx_chip_0_Template, 2, 3, \"igx-chip\", 5);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.displayPinnedChip);\n  }\n}\n\nfunction IgxGridCellComponent_ng_template_2_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 9);\n    i0.ɵɵpipe(1, \"columnFormatter\");\n    i0.ɵɵpipe(2, \"number\");\n    i0.ɵɵpipe(3, \"date\");\n    i0.ɵɵpipe(4, \"currency\");\n    i0.ɵɵpipe(5, \"percent\");\n    i0.ɵɵtext(6);\n    i0.ɵɵpipe(7, \"columnFormatter\");\n    i0.ɵɵpipe(8, \"number\");\n    i0.ɵɵpipe(9, \"date\");\n    i0.ɵɵpipe(10, \"currency\");\n    i0.ɵɵpipe(11, \"percent\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"cssClass\", ctx_r11.highlightClass)(\"activeCssClass\", ctx_r11.activeHighlightClass)(\"groupName\", ctx_r11.gridID)(\"value\", ctx_r11.formatter ? i0.ɵɵpipeBind3(1, 9, ctx_r11.value, ctx_r11.formatter, ctx_r11.rowData) : ctx_r11.column.dataType === \"number\" ? i0.ɵɵpipeBind3(2, 13, ctx_r11.value, ctx_r11.column.pipeArgs.digitsInfo, ctx_r11.grid.locale) : ctx_r11.column.dataType === \"date\" || ctx_r11.column.dataType === \"time\" || ctx_r11.column.dataType === \"dateTime\" ? i0.ɵɵpipeBind4(3, 17, ctx_r11.value, ctx_r11.column.pipeArgs.format, ctx_r11.column.pipeArgs.timezone, ctx_r11.grid.locale) : ctx_r11.column.dataType === \"currency\" ? i0.ɵɵpipeBindV(4, 22, i0.ɵɵpureFunction5(55, _c71, ctx_r11.value, ctx_r11.currencyCode, ctx_r11.column.pipeArgs.display, ctx_r11.column.pipeArgs.digitsInfo, ctx_r11.grid.locale)) : ctx_r11.column.dataType === \"percent\" ? i0.ɵɵpipeBind3(5, 28, ctx_r11.value, ctx_r11.column.pipeArgs.digitsInfo, ctx_r11.grid.locale) : ctx_r11.value)(\"row\", ctx_r11.rowData)(\"column\", ctx_r11.column.field)(\"containerClass\", \"igx-grid__td-text\")(\"metadata\", ctx_r11.searchMetadata);\n    i0.ɵɵadvance(6);\n    i0.ɵɵtextInterpolate(ctx_r11.formatter ? i0.ɵɵpipeBind3(7, 32, ctx_r11.value, ctx_r11.formatter, ctx_r11.rowData) : ctx_r11.column.dataType === \"number\" ? i0.ɵɵpipeBind3(8, 36, ctx_r11.value, ctx_r11.column.pipeArgs.digitsInfo, ctx_r11.grid.locale) : ctx_r11.column.dataType === \"date\" || ctx_r11.column.dataType === \"time\" || ctx_r11.column.dataType === \"dateTime\" ? i0.ɵɵpipeBind4(9, 40, ctx_r11.value, ctx_r11.column.pipeArgs.format, ctx_r11.column.pipeArgs.timezone, ctx_r11.grid.locale) : ctx_r11.column.dataType === \"currency\" ? i0.ɵɵpipeBindV(10, 45, i0.ɵɵpureFunction5(61, _c71, ctx_r11.value, ctx_r11.currencyCode, ctx_r11.column.pipeArgs.display, ctx_r11.column.pipeArgs.digitsInfo, ctx_r11.grid.locale)) : ctx_r11.column.dataType === \"percent\" ? i0.ɵɵpipeBind3(11, 51, ctx_r11.value, ctx_r11.column.pipeArgs.digitsInfo, ctx_r11.grid.locale) : ctx_r11.value);\n  }\n}\n\nconst _c210 = function (a0, a1) {\n  return {\n    \"igx-icon--success\": a0,\n    \"igx-icon--error\": a1\n  };\n};\n\nfunction IgxGridCellComponent_ng_template_2_igx_icon_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\", 10);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(2, _c210, ctx_r12.value, !ctx_r12.value));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r12.value ? \"check\" : \"close\");\n  }\n}\n\nfunction IgxGridCellComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxGridCellComponent_ng_template_2_div_0_Template, 12, 67, \"div\", 7);\n    i0.ɵɵtemplate(1, IgxGridCellComponent_ng_template_2_igx_icon_1_Template, 2, 5, \"igx-icon\", 8);\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.column.dataType !== \"boolean\" || ctx_r3.column.dataType === \"boolean\" && ctx_r3.formatter);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.column.dataType === \"boolean\" && !ctx_r3.formatter);\n  }\n}\n\nfunction IgxGridCellComponent_ng_template_4_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 9);\n    i0.ɵɵpipe(1, \"columnFormatter\");\n    i0.ɵɵpipe(2, \"number\");\n    i0.ɵɵpipe(3, \"date\");\n    i0.ɵɵpipe(4, \"currency\");\n    i0.ɵɵpipe(5, \"percent\");\n    i0.ɵɵtext(6);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r14 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"cssClass\", ctx_r14.highlightClass)(\"activeCssClass\", ctx_r14.activeHighlightClass)(\"groupName\", ctx_r14.gridID)(\"value\", ctx_r14.formatter ? i0.ɵɵpipeBind3(1, 9, ctx_r14.value, ctx_r14.formatter, ctx_r14.rowData) : ctx_r14.column.dataType === \"number\" ? i0.ɵɵpipeBind3(2, 13, ctx_r14.value, ctx_r14.column.pipeArgs.digitsInfo, ctx_r14.grid.locale) : ctx_r14.column.dataType === \"date\" || ctx_r14.column.dataType === \"time\" || ctx_r14.column.dataType === \"dateTime\" ? i0.ɵɵpipeBind4(3, 17, ctx_r14.value, ctx_r14.column.pipeArgs.format, ctx_r14.column.pipeArgs.timezone, ctx_r14.grid.locale) : ctx_r14.column.dataType === \"currency\" ? i0.ɵɵpipeBindV(4, 22, i0.ɵɵpureFunction5(32, _c71, ctx_r14.value, ctx_r14.currencyCode, ctx_r14.column.pipeArgs.display, ctx_r14.column.pipeArgs.digitsInfo, ctx_r14.grid.locale)) : ctx_r14.column.dataType === \"percent\" ? i0.ɵɵpipeBind3(5, 28, ctx_r14.value, ctx_r14.column.pipeArgs.digitsInfo, ctx_r14.grid.locale) : ctx_r14.value)(\"row\", ctx_r14.rowData)(\"column\", ctx_r14.column.field)(\"containerClass\", \"igx-grid__td-text\")(\"metadata\", ctx_r14.searchMetadata);\n    i0.ɵɵadvance(6);\n    i0.ɵɵtextInterpolate(!ctx_r14.isEmptyAddRowCell ? ctx_r14.value : ctx_r14.column.header || ctx_r14.column.field);\n  }\n}\n\nfunction IgxGridCellComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxGridCellComponent_ng_template_4_div_0_Template, 7, 38, \"div\", 11);\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.column.dataType !== \"boolean\" || ctx_r5.column.dataType === \"boolean\" && ctx_r5.formatter);\n  }\n}\n\nfunction IgxGridCellComponent_ng_template_6_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r25 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-input-group\", 13)(2, \"input\", 14);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxGridCellComponent_ng_template_6_ng_container_0_Template_input_ngModelChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r25);\n      const ctx_r24 = i0.ɵɵnextContext(2);\n      return ctx_r24.editValue = $event;\n    });\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngModel\", ctx_r16.editValue)(\"igxFocus\", true);\n  }\n}\n\nfunction IgxGridCellComponent_ng_template_6_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r27 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-input-group\", 13)(2, \"input\", 15);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxGridCellComponent_ng_template_6_ng_container_1_Template_input_ngModelChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r27);\n      const ctx_r26 = i0.ɵɵnextContext(2);\n      return ctx_r26.editValue = $event;\n    });\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r17 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngModel\", ctx_r17.editValue)(\"igxFocus\", true)(\"step\", ctx_r17.step);\n  }\n}\n\nfunction IgxGridCellComponent_ng_template_6_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r29 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-checkbox\", 16);\n    i0.ɵɵlistener(\"change\", function IgxGridCellComponent_ng_template_6_ng_container_2_Template_igx_checkbox_change_1_listener($event) {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r28 = i0.ɵɵnextContext(2);\n      return ctx_r28.editValue = $event.checked;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r18 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"checked\", ctx_r18.editValue)(\"igxFocus\", true)(\"disableRipple\", true);\n  }\n}\n\nfunction IgxGridCellComponent_ng_template_6_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r31 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-date-picker\", 17);\n    i0.ɵɵlistener(\"valueChange\", function IgxGridCellComponent_ng_template_6_ng_container_3_Template_igx_date_picker_valueChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r31);\n      const ctx_r30 = i0.ɵɵnextContext(2);\n      return ctx_r30.editValue = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r19 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"width\", 100, \"%\");\n    i0.ɵɵproperty(\"outlet\", ctx_r19.grid.outlet)(\"locale\", ctx_r19.grid.locale)(\"value\", ctx_r19.editValue)(\"igxFocus\", true);\n  }\n}\n\nfunction IgxGridCellComponent_ng_template_6_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r33 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-time-picker\", 18);\n    i0.ɵɵlistener(\"valueChange\", function IgxGridCellComponent_ng_template_6_ng_container_4_Template_igx_time_picker_valueChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r32 = i0.ɵɵnextContext(2);\n      return ctx_r32.editValue = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r20 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"width\", 100, \"%\");\n    i0.ɵɵproperty(\"outlet\", ctx_r20.grid.outlet)(\"locale\", ctx_r20.grid.locale)(\"inputFormat\", ctx_r20.column.defaultTimeFormat)(\"value\", ctx_r20.editValue)(\"igxFocus\", true);\n  }\n}\n\nfunction IgxGridCellComponent_ng_template_6_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r35 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-input-group\")(2, \"input\", 19);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxGridCellComponent_ng_template_6_ng_container_5_Template_input_ngModelChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r35);\n      const ctx_r34 = i0.ɵɵnextContext(2);\n      return ctx_r34.editValue = $event;\n    });\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r21 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"igxDateTimeEditor\", ctx_r21.column.defaultDateTimeFormat)(\"ngModel\", ctx_r21.editValue)(\"igxFocus\", true);\n  }\n}\n\nfunction IgxGridCellComponent_ng_template_6_ng_container_6_igx_prefix_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-prefix\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r36 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r36.currencyCodeSymbol);\n  }\n}\n\nfunction IgxGridCellComponent_ng_template_6_ng_container_6_igx_suffix_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-suffix\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r37 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r37.currencyCodeSymbol);\n  }\n}\n\nfunction IgxGridCellComponent_ng_template_6_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r39 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-input-group\", 13);\n    i0.ɵɵtemplate(2, IgxGridCellComponent_ng_template_6_ng_container_6_igx_prefix_2_Template, 2, 1, \"igx-prefix\", 12);\n    i0.ɵɵelementStart(3, \"input\", 15);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxGridCellComponent_ng_template_6_ng_container_6_Template_input_ngModelChange_3_listener($event) {\n      i0.ɵɵrestoreView(_r39);\n      const ctx_r38 = i0.ɵɵnextContext(2);\n      return ctx_r38.editValue = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(4, IgxGridCellComponent_ng_template_6_ng_container_6_igx_suffix_4_Template, 2, 1, \"igx-suffix\", 12);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r22 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r22.grid.currencyPositionLeft);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngModel\", ctx_r22.editValue)(\"igxFocus\", true)(\"step\", ctx_r22.step);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r22.grid.currencyPositionLeft);\n  }\n}\n\nfunction IgxGridCellComponent_ng_template_6_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r41 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-input-group\", 13)(2, \"input\", 15);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxGridCellComponent_ng_template_6_ng_container_7_Template_input_ngModelChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r41);\n      const ctx_r40 = i0.ɵɵnextContext(2);\n      return ctx_r40.editValue = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"igx-suffix\");\n    i0.ɵɵtext(4);\n    i0.ɵɵpipe(5, \"percent\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r23 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngModel\", ctx_r23.editValue)(\"igxFocus\", true)(\"step\", ctx_r23.step);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", i0.ɵɵpipeBind3(5, 4, ctx_r23.editValue, ctx_r23.column.pipeArgs.digitsInfo, ctx_r23.grid.locale), \" \");\n  }\n}\n\nfunction IgxGridCellComponent_ng_template_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxGridCellComponent_ng_template_6_ng_container_0_Template, 3, 2, \"ng-container\", 12);\n    i0.ɵɵtemplate(1, IgxGridCellComponent_ng_template_6_ng_container_1_Template, 3, 3, \"ng-container\", 12);\n    i0.ɵɵtemplate(2, IgxGridCellComponent_ng_template_6_ng_container_2_Template, 2, 3, \"ng-container\", 12);\n    i0.ɵɵtemplate(3, IgxGridCellComponent_ng_template_6_ng_container_3_Template, 2, 6, \"ng-container\", 12);\n    i0.ɵɵtemplate(4, IgxGridCellComponent_ng_template_6_ng_container_4_Template, 2, 7, \"ng-container\", 12);\n    i0.ɵɵtemplate(5, IgxGridCellComponent_ng_template_6_ng_container_5_Template, 3, 3, \"ng-container\", 12);\n    i0.ɵɵtemplate(6, IgxGridCellComponent_ng_template_6_ng_container_6_Template, 5, 5, \"ng-container\", 12);\n    i0.ɵɵtemplate(7, IgxGridCellComponent_ng_template_6_ng_container_7_Template, 6, 8, \"ng-container\", 12);\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"string\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"number\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"boolean\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"date\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"time\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"dateTime\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"currency\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"percent\");\n  }\n}\n\nfunction IgxGridCellComponent_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridCellComponent_ng_container_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nconst _c211 = [\"indentationDiv\"];\n\nfunction IgxGridExpandableCellComponent_ng_template_0_igx_chip_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-chip\", 9);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r15 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"disabled\", true)(\"displayDensity\", \"compact\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r15.grid.resourceStrings.igx_grid_pinned_row_indicator);\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxGridExpandableCellComponent_ng_template_0_igx_chip_0_Template, 2, 3, \"igx-chip\", 8);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.displayPinnedChip);\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_template_2_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 12);\n    i0.ɵɵpipe(1, \"columnFormatter\");\n    i0.ɵɵpipe(2, \"number\");\n    i0.ɵɵpipe(3, \"date\");\n    i0.ɵɵpipe(4, \"currency\");\n    i0.ɵɵpipe(5, \"percent\");\n    i0.ɵɵtext(6);\n    i0.ɵɵpipe(7, \"columnFormatter\");\n    i0.ɵɵpipe(8, \"number\");\n    i0.ɵɵpipe(9, \"date\");\n    i0.ɵɵpipe(10, \"currency\");\n    i0.ɵɵpipe(11, \"percent\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"cssClass\", ctx_r16.highlightClass)(\"activeCssClass\", ctx_r16.activeHighlightClass)(\"groupName\", ctx_r16.gridID)(\"value\", ctx_r16.formatter ? i0.ɵɵpipeBind3(1, 9, ctx_r16.value, ctx_r16.formatter, ctx_r16.rowData) : ctx_r16.column.dataType === \"number\" ? i0.ɵɵpipeBind3(2, 13, ctx_r16.value, ctx_r16.column.pipeArgs.digitsInfo, ctx_r16.grid.locale) : ctx_r16.column.dataType === \"date\" || ctx_r16.column.dataType === \"time\" || ctx_r16.column.dataType === \"dateTime\" ? i0.ɵɵpipeBind4(3, 17, ctx_r16.value, ctx_r16.column.pipeArgs.format, ctx_r16.column.pipeArgs.timezone, ctx_r16.grid.locale) : ctx_r16.column.dataType === \"currency\" ? i0.ɵɵpipeBindV(4, 22, i0.ɵɵpureFunction5(55, _c71, ctx_r16.value, ctx_r16.currencyCode, ctx_r16.column.pipeArgs.display, ctx_r16.column.pipeArgs.digitsInfo, ctx_r16.grid.locale)) : ctx_r16.column.dataType === \"percent\" ? i0.ɵɵpipeBind3(5, 28, ctx_r16.value, ctx_r16.column.pipeArgs.digitsInfo, ctx_r16.grid.locale) : ctx_r16.value)(\"row\", ctx_r16.rowData)(\"column\", ctx_r16.column.field)(\"containerClass\", \"igx-grid__td-text\")(\"metadata\", ctx_r16.searchMetadata);\n    i0.ɵɵadvance(6);\n    i0.ɵɵtextInterpolate(ctx_r16.formatter ? i0.ɵɵpipeBind3(7, 32, ctx_r16.value, ctx_r16.formatter, ctx_r16.rowData) : ctx_r16.column.dataType === \"number\" ? i0.ɵɵpipeBind3(8, 36, ctx_r16.value, ctx_r16.column.pipeArgs.digitsInfo, ctx_r16.grid.locale) : ctx_r16.column.dataType === \"date\" || ctx_r16.column.dataType === \"time\" || ctx_r16.column.dataType === \"dateTime\" ? i0.ɵɵpipeBind4(9, 40, ctx_r16.value, ctx_r16.column.pipeArgs.format, ctx_r16.column.pipeArgs.timezone, ctx_r16.grid.locale) : ctx_r16.column.dataType === \"currency\" ? i0.ɵɵpipeBindV(10, 45, i0.ɵɵpureFunction5(61, _c71, ctx_r16.value, ctx_r16.currencyCode, ctx_r16.column.pipeArgs.display, ctx_r16.column.pipeArgs.digitsInfo, ctx_r16.grid.locale)) : ctx_r16.column.dataType === \"percent\" ? i0.ɵɵpipeBind3(11, 51, ctx_r16.value, ctx_r16.column.pipeArgs.digitsInfo, ctx_r16.grid.locale) : ctx_r16.value);\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_template_2_igx_icon_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\", 13);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r17 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(2, _c210, ctx_r17.value, !ctx_r17.value));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r17.value ? \"check\" : \"close\");\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxGridExpandableCellComponent_ng_template_2_div_0_Template, 12, 67, \"div\", 10);\n    i0.ɵɵtemplate(1, IgxGridExpandableCellComponent_ng_template_2_igx_icon_1_Template, 2, 5, \"igx-icon\", 11);\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.column.dataType !== \"boolean\" || ctx_r3.column.dataType === \"boolean\" && ctx_r3.formatter);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.column.dataType === \"boolean\" && !ctx_r3.formatter);\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_template_4_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 12);\n    i0.ɵɵpipe(1, \"columnFormatter\");\n    i0.ɵɵpipe(2, \"number\");\n    i0.ɵɵpipe(3, \"date\");\n    i0.ɵɵpipe(4, \"currency\");\n    i0.ɵɵpipe(5, \"percent\");\n    i0.ɵɵtext(6);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r19 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"cssClass\", ctx_r19.highlightClass)(\"activeCssClass\", ctx_r19.activeHighlightClass)(\"groupName\", ctx_r19.gridID)(\"value\", ctx_r19.formatter ? i0.ɵɵpipeBind3(1, 9, ctx_r19.value, ctx_r19.formatter, ctx_r19.rowData) : ctx_r19.column.dataType === \"number\" ? i0.ɵɵpipeBind3(2, 13, ctx_r19.value, ctx_r19.column.pipeArgs.digitsInfo, ctx_r19.grid.locale) : ctx_r19.column.dataType === \"date\" || ctx_r19.column.dataType === \"time\" || ctx_r19.column.dataType === \"dateTime\" ? i0.ɵɵpipeBind4(3, 17, ctx_r19.value, ctx_r19.column.pipeArgs.format, ctx_r19.column.pipeArgs.timezone, ctx_r19.grid.locale) : ctx_r19.column.dataType === \"currency\" ? i0.ɵɵpipeBindV(4, 22, i0.ɵɵpureFunction5(32, _c71, ctx_r19.value, ctx_r19.currencyCode, ctx_r19.column.pipeArgs.display, ctx_r19.column.pipeArgs.digitsInfo, ctx_r19.grid.locale)) : ctx_r19.column.dataType === \"percent\" ? i0.ɵɵpipeBind3(5, 28, ctx_r19.value, ctx_r19.column.pipeArgs.digitsInfo, ctx_r19.grid.locale) : ctx_r19.value)(\"row\", ctx_r19.rowData)(\"column\", ctx_r19.column.field)(\"containerClass\", \"igx-grid__td-text\")(\"metadata\", ctx_r19.searchMetadata);\n    i0.ɵɵadvance(6);\n    i0.ɵɵtextInterpolate(ctx_r19.value ? ctx_r19.value : ctx_r19.column.header || ctx_r19.column.field);\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxGridExpandableCellComponent_ng_template_4_div_0_Template, 7, 38, \"div\", 10);\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.column.dataType !== \"boolean\" || ctx_r5.column.dataType === \"boolean\" && ctx_r5.formatter);\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_template_6_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r30 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-input-group\", 14)(2, \"input\", 15);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxGridExpandableCellComponent_ng_template_6_ng_container_0_Template_input_ngModelChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r30);\n      const ctx_r29 = i0.ɵɵnextContext(2);\n      return ctx_r29.editValue = $event;\n    });\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r21 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngModel\", ctx_r21.editValue)(\"igxFocus\", true);\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_template_6_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r32 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-input-group\", 14)(2, \"input\", 16);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxGridExpandableCellComponent_ng_template_6_ng_container_1_Template_input_ngModelChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r32);\n      const ctx_r31 = i0.ɵɵnextContext(2);\n      return ctx_r31.editValue = $event;\n    });\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r22 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngModel\", ctx_r22.editValue)(\"igxFocus\", true)(\"step\", ctx_r22.step);\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_template_6_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r34 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-checkbox\", 17);\n    i0.ɵɵlistener(\"change\", function IgxGridExpandableCellComponent_ng_template_6_ng_container_2_Template_igx_checkbox_change_1_listener($event) {\n      i0.ɵɵrestoreView(_r34);\n      const ctx_r33 = i0.ɵɵnextContext(2);\n      return ctx_r33.editValue = $event.checked;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r23 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"value\", ctx_r23.editValue)(\"checked\", ctx_r23.editValue)(\"disableRipple\", true);\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_template_6_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r36 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-date-picker\", 18);\n    i0.ɵɵlistener(\"valueChange\", function IgxGridExpandableCellComponent_ng_template_6_ng_container_3_Template_igx_date_picker_valueChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r36);\n      const ctx_r35 = i0.ɵɵnextContext(2);\n      return ctx_r35.editValue = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r24 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"width\", 100, \"%\");\n    i0.ɵɵproperty(\"outlet\", ctx_r24.grid.outlet)(\"locale\", ctx_r24.grid.locale)(\"value\", ctx_r24.editValue)(\"igxFocus\", true);\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_template_6_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r38 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-time-picker\", 19);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxGridExpandableCellComponent_ng_template_6_ng_container_4_Template_igx_time_picker_ngModelChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r38);\n      const ctx_r37 = i0.ɵɵnextContext(2);\n      return ctx_r37.editValue = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r25 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"width\", 100, \"%\");\n    i0.ɵɵproperty(\"outlet\", ctx_r25.grid.outlet)(\"inputFormat\", ctx_r25.column.defaultTimeFormat)(\"ngModel\", ctx_r25.editValue)(\"igxFocus\", true);\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_template_6_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r40 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-input-group\")(2, \"input\", 20);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxGridExpandableCellComponent_ng_template_6_ng_container_5_Template_input_ngModelChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r40);\n      const ctx_r39 = i0.ɵɵnextContext(2);\n      return ctx_r39.editValue = $event;\n    });\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r26 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"igxDateTimeEditor\", ctx_r26.column.defaultDateTimeFormat)(\"ngModel\", ctx_r26.editValue)(\"igxFocus\", true);\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_template_6_ng_container_6_igx_prefix_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-prefix\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r41 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r41.currencyCodeSymbol);\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_template_6_ng_container_6_igx_suffix_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-suffix\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r42 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r42.currencyCodeSymbol);\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_template_6_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r44 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-input-group\", 14);\n    i0.ɵɵtemplate(2, IgxGridExpandableCellComponent_ng_template_6_ng_container_6_igx_prefix_2_Template, 2, 1, \"igx-prefix\", 4);\n    i0.ɵɵelementStart(3, \"input\", 16);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxGridExpandableCellComponent_ng_template_6_ng_container_6_Template_input_ngModelChange_3_listener($event) {\n      i0.ɵɵrestoreView(_r44);\n      const ctx_r43 = i0.ɵɵnextContext(2);\n      return ctx_r43.editValue = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(4, IgxGridExpandableCellComponent_ng_template_6_ng_container_6_igx_suffix_4_Template, 2, 1, \"igx-suffix\", 4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r27 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r27.grid.currencyPositionLeft);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngModel\", ctx_r27.editValue)(\"igxFocus\", true)(\"step\", ctx_r27.step);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r27.grid.currencyPositionLeft);\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_template_6_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r46 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-input-group\", 14)(2, \"input\", 21);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxGridExpandableCellComponent_ng_template_6_ng_container_7_Template_input_ngModelChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r46);\n      const ctx_r45 = i0.ɵɵnextContext(2);\n      return ctx_r45.editValue = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"igx-suffix\");\n    i0.ɵɵtext(4);\n    i0.ɵɵpipe(5, \"percent\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r28 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngModel\", ctx_r28.editValue)(\"step\", ctx_r28.step)(\"igxFocus\", true);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", i0.ɵɵpipeBind3(5, 4, ctx_r28.editValue, ctx_r28.column.pipeArgs.digitsInfo, ctx_r28.grid.locale), \" \");\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_template_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxGridExpandableCellComponent_ng_template_6_ng_container_0_Template, 3, 2, \"ng-container\", 4);\n    i0.ɵɵtemplate(1, IgxGridExpandableCellComponent_ng_template_6_ng_container_1_Template, 3, 3, \"ng-container\", 4);\n    i0.ɵɵtemplate(2, IgxGridExpandableCellComponent_ng_template_6_ng_container_2_Template, 2, 3, \"ng-container\", 4);\n    i0.ɵɵtemplate(3, IgxGridExpandableCellComponent_ng_template_6_ng_container_3_Template, 2, 6, \"ng-container\", 4);\n    i0.ɵɵtemplate(4, IgxGridExpandableCellComponent_ng_template_6_ng_container_4_Template, 2, 6, \"ng-container\", 4);\n    i0.ɵɵtemplate(5, IgxGridExpandableCellComponent_ng_template_6_ng_container_5_Template, 3, 3, \"ng-container\", 4);\n    i0.ɵɵtemplate(6, IgxGridExpandableCellComponent_ng_template_6_ng_container_6_Template, 5, 5, \"ng-container\", 4);\n    i0.ɵɵtemplate(7, IgxGridExpandableCellComponent_ng_template_6_ng_container_7_Template, 6, 8, \"ng-container\", 4);\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"string\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"number\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"boolean\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"date\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"time\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"dateTime\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"currency\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"percent\");\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_container_8_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r50 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 22, 23);\n    i0.ɵɵlistener(\"click\", function IgxGridExpandableCellComponent_ng_container_8_Template_div_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r50);\n      const ctx_r49 = i0.ɵɵnextContext();\n      return ctx_r49.toggle($event);\n    })(\"focus\", function IgxGridExpandableCellComponent_ng_container_8_Template_div_focus_1_listener() {\n      i0.ɵɵrestoreView(_r50);\n      const ctx_r51 = i0.ɵɵnextContext();\n      return ctx_r51.onIndicatorFocus();\n    });\n    i0.ɵɵtemplate(3, IgxGridExpandableCellComponent_ng_container_8_ng_container_3_Template, 1, 0, \"ng-container\", 5);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r8.iconTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c24, ctx_r8));\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_container_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_container_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_template_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1, \"expand_more\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxGridExpandableCellComponent_ng_template_13_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1, \"chevron_right\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxGridRowComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r19 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 9);\n    i0.ɵɵlistener(\"animationend\", function IgxGridRowComponent_ng_template_1_Template_div_animationend_0_listener() {\n      i0.ɵɵrestoreView(_r19);\n      const ctx_r18 = i0.ɵɵnextContext();\n      return ctx_r18.animationEndHandler();\n    });\n    i0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_1_ng_container_1_Template, 1, 0, \"ng-container\", 0);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n\n    const _r3 = i0.ɵɵreference(4);\n\n    i0.ɵɵclassProp(\"igx-grid__tr--add-animate\", ctx_r2.triggerAddAnimationClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r3);\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_0_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 11);\n    i0.ɵɵlistener(\"click\", function IgxGridRowComponent_ng_template_3_ng_container_0_Template_div_click_1_listener($event) {\n      return $event.stopPropagation();\n    });\n    i0.ɵɵtemplate(2, IgxGridRowComponent_ng_template_3_ng_container_0_ng_container_2_Template, 1, 0, \"ng-container\", 0);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r20 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassMap(ctx_r20.resolveDragIndicatorClasses);\n    i0.ɵɵproperty(\"igxRowDrag\", ctx_r20)(\"ghostTemplate\", ctx_r20.grid.getDragGhostCustomTemplate());\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r20.grid.dragIndicatorIconTemplate ? ctx_r20.grid.dragIndicatorIconTemplate : ctx_r20.grid.dragIndicatorIconBase);\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_1_2_ng_template_0_Template(rf, ctx) {}\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_1_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxGridRowComponent_ng_template_3_ng_container_1_2_ng_template_0_Template, 0, 0, \"ng-template\");\n  }\n}\n\nconst _c212 = function (a0, a1, a2, a3) {\n  return {\n    index: a0,\n    rowID: a1,\n    key: a2,\n    selected: a3\n  };\n};\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r31 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 12);\n    i0.ɵɵlistener(\"pointerdown\", function IgxGridRowComponent_ng_template_3_ng_container_1_Template_div_pointerdown_1_listener($event) {\n      return $event.preventDefault();\n    })(\"click\", function IgxGridRowComponent_ng_template_3_ng_container_1_Template_div_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r31);\n      const ctx_r30 = i0.ɵɵnextContext(2);\n      return ctx_r30.onRowSelectorClick($event);\n    });\n    i0.ɵɵtemplate(2, IgxGridRowComponent_ng_template_3_ng_container_1_2_Template, 1, 0, null, 13);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r21 = i0.ɵɵnextContext(2);\n\n    const _r7 = i0.ɵɵreference(8);\n\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r21.grid.rowSelectorTemplate ? ctx_r21.grid.rowSelectorTemplate : _r7)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(7, _c24, i0.ɵɵpureFunction4(2, _c212, ctx_r21.viewIndex, ctx_r21.key, ctx_r21.key, ctx_r21.selected)));\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 14);\n    i0.ɵɵlistener(\"pointerdown\", function IgxGridRowComponent_ng_template_3_ng_container_2_Template_div_pointerdown_1_listener($event) {\n      return $event.preventDefault();\n    })(\"click\", function IgxGridRowComponent_ng_template_3_ng_container_2_Template_div_click_1_listener($event) {\n      return $event.stopPropagation();\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r22 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassMapInterpolate1(\"igx-grid__row-indentation igx-grid__row-indentation--level-\", ctx_r22.grid.groupingExpressions.length, \"\");\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_1_ng_template_1_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_1_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_1_ng_template_1_ng_container_0_Template, 1, 0, \"ng-container\", 13);\n  }\n\n  if (rf & 2) {\n    const col_r39 = ctx.$implicit;\n    const ctx_r38 = i0.ɵɵnextContext(4);\n\n    const _r11 = i0.ɵɵreference(12);\n\n    const _r9 = i0.ɵɵreference(10);\n\n    i0.ɵɵproperty(\"ngTemplateOutlet\", col_r39.visibleIndex === 0 && ctx_r38.grid.hasDetails ? _r11 : _r9)(\"ngTemplateOutletContext\", ctx_r38.getContext(col_r39, ctx_r38));\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_1_ng_template_1_Template, 1, 2, \"ng-template\", 17);\n    i0.ɵɵpipe(2, \"igxNotGrouped\");\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r34 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBind1(2, 1, ctx_r34.pinnedColumns));\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_3_ng_template_2_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_3_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxGridRowComponent_ng_template_3_ng_container_3_ng_template_2_ng_container_0_Template, 1, 0, \"ng-container\", 13);\n  }\n\n  if (rf & 2) {\n    const col_r41 = ctx.$implicit;\n    const ctx_r36 = i0.ɵɵnextContext(3);\n\n    const _r11 = i0.ɵɵreference(12);\n\n    const _r9 = i0.ɵɵreference(10);\n\n    i0.ɵɵproperty(\"ngTemplateOutlet\", col_r41.visibleIndex === 0 && ctx_r36.grid.hasDetails ? _r11 : _r9)(\"ngTemplateOutletContext\", ctx_r36.getContext(col_r41, ctx_r36));\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_5_ng_template_1_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_5_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_5_ng_template_1_ng_container_0_Template, 1, 0, \"ng-container\", 13);\n  }\n\n  if (rf & 2) {\n    const col_r44 = ctx.$implicit;\n    const ctx_r43 = i0.ɵɵnextContext(4);\n\n    const _r11 = i0.ɵɵreference(12);\n\n    const _r9 = i0.ɵɵreference(10);\n\n    i0.ɵɵproperty(\"ngTemplateOutlet\", col_r44.visibleIndex === 0 && ctx_r43.grid.hasDetails ? _r11 : _r9)(\"ngTemplateOutletContext\", ctx_r43.getContext(col_r44, ctx_r43));\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_5_ng_template_1_Template, 1, 2, \"ng-template\", 17);\n    i0.ɵɵpipe(2, \"igxNotGrouped\");\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r37 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBind1(2, 1, ctx_r37.pinnedColumns));\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_1_Template, 3, 3, \"ng-container\", 10);\n    i0.ɵɵtemplate(2, IgxGridRowComponent_ng_template_3_ng_container_3_ng_template_2_Template, 1, 2, \"ng-template\", 15, 16, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵpipe(4, \"igxNotGrouped\");\n    i0.ɵɵtemplate(5, IgxGridRowComponent_ng_template_3_ng_container_3_ng_container_5_Template, 3, 3, \"ng-container\", 10);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r23 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r23.pinnedColumns.length > 0 && ctx_r23.grid.isPinningToStart);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"igxGridForOf\", i0.ɵɵpipeBind1(4, 8, ctx_r23.unpinnedColumns))(\"igxForScrollContainer\", ctx_r23.grid.parentVirtDir)(\"igxForScrollOrientation\", \"horizontal\")(\"igxForContainerSize\", ctx_r23.grid.unpinnedWidth)(\"igxForSizePropName\", \"calcPixelWidth\")(\"igxForTrackBy\", ctx_r23.grid.trackColumnChanges);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", ctx_r23.pinnedColumns.length > 0 && !ctx_r23.grid.isPinningToStart);\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_4_ng_container_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_4_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_3_ng_container_4_ng_container_1_ng_container_1_Template, 1, 0, \"ng-container\", 13);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r46 = i0.ɵɵnextContext(3);\n\n    const _r5 = i0.ɵɵreference(6);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r5)(\"ngTemplateOutletContext\", ctx_r46.getContextMRL(ctx_r46.pinnedColumns, ctx_r46));\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_4_ng_template_2_ng_template_1_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_4_ng_template_2_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxGridRowComponent_ng_template_3_ng_container_4_ng_template_2_ng_template_1_ng_container_0_Template, 1, 0, \"ng-container\", 13);\n  }\n\n  if (rf & 2) {\n    const col_r54 = ctx.$implicit;\n    const ctx_r53 = i0.ɵɵnextContext(4);\n\n    const _r15 = i0.ɵɵreference(16);\n\n    const _r13 = i0.ɵɵreference(14);\n\n    i0.ɵɵproperty(\"ngTemplateOutlet\", col_r54.visibleIndex === 0 && ctx_r53.grid.hasDetails ? _r15 : _r13)(\"ngTemplateOutletContext\", ctx_r53.getContext(col_r54, ctx_r53));\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_4_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 18);\n    i0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_3_ng_container_4_ng_template_2_ng_template_1_Template, 1, 2, \"ng-template\", 17);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const col_r51 = ctx.$implicit;\n    i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction2(2, _c169, col_r51.getGridTemplate(true), col_r51.getGridTemplate(false)));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", col_r51.children);\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_4_ng_container_5_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_4_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_3_ng_container_4_ng_container_5_ng_container_1_Template, 1, 0, \"ng-container\", 13);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r49 = i0.ɵɵnextContext(3);\n\n    const _r5 = i0.ɵɵreference(6);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r5)(\"ngTemplateOutletContext\", ctx_r49.getContextMRL(ctx_r49.pinnedColumns, ctx_r49));\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_3_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_3_ng_container_4_ng_container_1_Template, 2, 2, \"ng-container\", 10);\n    i0.ɵɵtemplate(2, IgxGridRowComponent_ng_template_3_ng_container_4_ng_template_2_Template, 2, 5, \"ng-template\", 15, 16, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵpipe(4, \"igxTopLevel\");\n    i0.ɵɵtemplate(5, IgxGridRowComponent_ng_template_3_ng_container_4_ng_container_5_Template, 2, 2, \"ng-container\", 10);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r24 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r24.pinnedColumns.length > 0 && ctx_r24.grid.isPinningToStart);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"igxGridForOf\", i0.ɵɵpipeBind1(4, 8, ctx_r24.unpinnedColumns))(\"igxForScrollContainer\", ctx_r24.grid.parentVirtDir)(\"igxForScrollOrientation\", \"horizontal\")(\"igxForContainerSize\", ctx_r24.grid.unpinnedWidth)(\"igxForSizePropName\", \"calcPixelWidth\")(\"igxForTrackBy\", ctx_r24.grid.trackColumnChanges);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", ctx_r24.pinnedColumns.length > 0 && !ctx_r24.grid.isPinningToStart);\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxGridRowComponent_ng_template_3_ng_container_0_Template, 3, 5, \"ng-container\", 10);\n    i0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_3_ng_container_1_Template, 3, 9, \"ng-container\", 10);\n    i0.ɵɵtemplate(2, IgxGridRowComponent_ng_template_3_ng_container_2_Template, 2, 3, \"ng-container\", 10);\n    i0.ɵɵtemplate(3, IgxGridRowComponent_ng_template_3_ng_container_3_Template, 6, 10, \"ng-container\", 10);\n    i0.ɵɵtemplate(4, IgxGridRowComponent_ng_template_3_ng_container_4_Template, 6, 10, \"ng-container\", 10);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.rowDraggable);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.showRowSelectors);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.grid.groupingExpressions.length > 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r4.grid.hasColumnLayouts);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.grid.hasColumnLayouts);\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_5_div_0_ng_template_1_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_5_div_0_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxGridRowComponent_ng_template_5_div_0_ng_template_1_ng_container_0_Template, 1, 0, \"ng-container\", 13);\n  }\n\n  if (rf & 2) {\n    const col_r61 = ctx.$implicit;\n    const ctx_r60 = i0.ɵɵnextContext(3);\n\n    const _r15 = i0.ɵɵreference(16);\n\n    const _r13 = i0.ɵɵreference(14);\n\n    i0.ɵɵproperty(\"ngTemplateOutlet\", col_r61.visibleIndex === 0 && ctx_r60.grid.hasDetails ? _r15 : _r13)(\"ngTemplateOutletContext\", ctx_r60.getContext(col_r61, ctx_r60));\n  }\n}\n\nconst _c213 = function (a0, a1, a2) {\n  return {\n    \"grid-template-rows\": a0,\n    \"grid-template-columns\": a1,\n    \"z-index\": a2\n  };\n};\n\nfunction IgxGridRowComponent_ng_template_5_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 18);\n    i0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_5_div_0_ng_template_1_Template, 1, 2, \"ng-template\", 17);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const col_r59 = ctx.$implicit;\n    const ctx_r58 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"left\", ctx_r58.mrlRightPinnedOffset);\n    i0.ɵɵclassProp(\"igx-grid__td--pinned-last\", col_r59.hasLastPinnedChildColumn)(\"igx-grid__td--pinned-first\", col_r59.hasFirstPinnedChildColumn);\n    i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction3(8, _c213, col_r59.getGridTemplate(true), col_r59.getGridTemplate(false), col_r59.pinned ? 1 : null));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", col_r59.children);\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxGridRowComponent_ng_template_5_div_0_Template, 2, 12, \"div\", 19);\n    i0.ɵɵpipe(1, \"igxTopLevel\");\n  }\n\n  if (rf & 2) {\n    const pinnedColumns_r57 = ctx.$implicit;\n    i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBind1(1, 1, pinnedColumns_r57));\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 20);\n    i0.ɵɵelement(1, \"igx-checkbox\", 21);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"tabindex\", -1)(\"checked\", ctx_r8.selected)(\"readonly\", true)(\"disabled\", ctx_r8.deleted)(\"disableRipple\", true)(\"disableTransitions\", ctx_r8.grid.disableTransitions)(\"aria-label\", ctx_r8.rowCheckboxAriaLabel);\n  }\n}\n\nconst _c214 = function (a0, a1, a2, a3, a4, a5, a6) {\n  return [a0, a1, a2, a3, a4, a5, a6];\n};\n\nconst _c215 = function (a0, a1, a2, a3, a4, a5) {\n  return [a0, a1, a2, a3, a4, a5];\n};\n\nfunction IgxGridRowComponent_ng_template_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-grid-cell\", 22, 23);\n    i0.ɵɵpipe(2, \"transactionState\");\n    i0.ɵɵpipe(3, \"igxStringReplace\");\n    i0.ɵɵpipe(4, \"igxCellStyleClasses\");\n    i0.ɵɵpipe(5, \"igxCellStyles\");\n    i0.ɵɵpipe(6, \"dataMapper\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const col_r63 = ctx.$implicit;\n    const ctx_r10 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"min-height\", ctx_r10.cellHeight, \"px\")(\"min-width\", col_r63.width)(\"max-width\", col_r63.width)(\"flex-basis\", col_r63.width)(\"left\", col_r63.rightPinnedOffset);\n    i0.ɵɵclassProp(\"igx-grid__td--edited\", i0.ɵɵpipeBindV(2, 36, i0.ɵɵpureFunction7(68, _c214, ctx_r10.key, col_r63.field, ctx_r10.grid.rowEditable, ctx_r10.grid.transactions, ctx_r10.grid.pipeTrigger, ctx_r10.grid.gridAPI.crudService.cell, ctx_r10.grid.gridAPI.crudService.row)))(\"igx-grid__td--pinned\", col_r63.pinned)(\"igx-grid__td--number\", col_r63.dataType === \"number\" || col_r63.dataType === \"percent\" || col_r63.dataType === \"currency\")(\"igx-grid__td--bool\", col_r63.dataType === \"boolean\");\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBindV(4, 48, i0.ɵɵpureFunction6(76, _c215, col_r63.cellClasses, ctx_r10.data[col_r63.field], ctx_r10.data, col_r63.field, ctx_r10.viewIndex, ctx_r10.grid.pipeTrigger)))(\"ngStyle\", i0.ɵɵpipeBindV(5, 55, i0.ɵɵpureFunction6(83, _c215, col_r63.cellStyles, ctx_r10.data[col_r63.field], ctx_r10.data, col_r63.field, ctx_r10.viewIndex, ctx_r10.grid.pipeTrigger)))(\"editMode\", col_r63.editable && ctx_r10.grid.crudService.targetInEdit(ctx_r10.index, col_r63.index))(\"column\", col_r63)(\"formatter\", col_r63.formatter)(\"intRow\", ctx_r10)(\"lastPinned\", col_r63.columnLayoutChild ? null : col_r63.isLastPinned)(\"firstPinned\", col_r63.columnLayoutChild ? null : col_r63.isFirstPinned)(\"rowData\", ctx_r10.data)(\"width\", col_r63.getCellWidth())(\"visibleColumnIndex\", col_r63.visibleIndex)(\"value\", i0.ɵɵpipeBindV(6, 62, i0.ɵɵpureFunction5(90, _c71, ctx_r10.data, col_r63.field, ctx_r10.grid.pipeTrigger, ctx_r10.data[col_r63.field], col_r63.hasNestedPath)))(\"cellTemplate\", col_r63.bodyTemplate)(\"lastSearchInfo\", ctx_r10.grid.lastSearchInfo)(\"active\", ctx_r10.isCellActive(col_r63.visibleIndex))(\"cellSelectionMode\", ctx_r10.grid.cellSelection)(\"displayPinnedChip\", ctx_r10.shouldDisplayPinnedChip(col_r63.visibleIndex));\n    i0.ɵɵattribute(\"aria-describedby\", i0.ɵɵpipeBind3(3, 44, ctx_r10.gridID + \"_\" + col_r63.field, \".\", \"_\"));\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-expandable-grid-cell\", 24, 23);\n    i0.ɵɵpipe(2, \"transactionState\");\n    i0.ɵɵpipe(3, \"igxStringReplace\");\n    i0.ɵɵpipe(4, \"igxCellStyleClasses\");\n    i0.ɵɵpipe(5, \"igxCellStyles\");\n    i0.ɵɵpipe(6, \"dataMapper\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const col_r65 = ctx.$implicit;\n    const ctx_r12 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"min-height\", ctx_r12.cellHeight, \"px\")(\"min-width\", col_r65.width)(\"max-width\", col_r65.width)(\"flex-basis\", col_r65.width);\n    i0.ɵɵclassProp(\"igx-grid__td--pinned\", col_r65.pinned)(\"igx-grid__td--edited\", i0.ɵɵpipeBindV(2, 32, i0.ɵɵpureFunction7(64, _c214, ctx_r12.key, col_r65.field, ctx_r12.grid.rowEditable, ctx_r12.grid.transactions, ctx_r12.grid.pipeTrigger, ctx_r12.grid.gridAPI.crudService.cell, ctx_r12.grid.gridAPI.crudService.row)))(\"igx-grid__td--number\", (col_r65.dataType === \"number\" || col_r65.dataType === \"percent\" || col_r65.dataType === \"currency\") && col_r65.visibleIndex !== 0);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBindV(4, 44, i0.ɵɵpureFunction6(72, _c215, col_r65.cellClasses, ctx_r12.data[col_r65.field], ctx_r12.data, col_r65.field, ctx_r12.viewIndex, ctx_r12.grid.pipeTrigger)))(\"ngStyle\", i0.ɵɵpipeBindV(5, 51, i0.ɵɵpureFunction6(79, _c215, col_r65.cellStyles, ctx_r12.data[col_r65.field], ctx_r12.data, col_r65.field, ctx_r12.viewIndex, ctx_r12.grid.pipeTrigger)))(\"expanded\", ctx_r12.expanded)(\"editMode\", col_r65.editable && ctx_r12.grid.crudService.targetInEdit(ctx_r12.index, col_r65.index))(\"column\", col_r65)(\"formatter\", col_r65.formatter)(\"intRow\", ctx_r12)(\"lastPinned\", col_r65.columnLayoutChild ? null : col_r65.isLastPinned)(\"rowData\", ctx_r12.data)(\"width\", col_r65.getCellWidth())(\"visibleColumnIndex\", col_r65.visibleIndex)(\"value\", i0.ɵɵpipeBindV(6, 58, i0.ɵɵpureFunction5(86, _c71, ctx_r12.data, col_r65.field, ctx_r12.grid.pipeTrigger, ctx_r12.data[col_r65.field], col_r65.hasNestedPath)))(\"cellTemplate\", col_r65.bodyTemplate)(\"lastSearchInfo\", ctx_r12.grid.lastSearchInfo)(\"active\", ctx_r12.isCellActive(col_r65.visibleIndex))(\"cellSelectionMode\", ctx_r12.grid.cellSelection)(\"displayPinnedChip\", ctx_r12.shouldDisplayPinnedChip(col_r65.visibleIndex));\n    i0.ɵɵattribute(\"aria-describedby\", i0.ɵɵpipeBind3(3, 40, ctx_r12.gridID + \"_\" + col_r65.field, \".\", \"_\"));\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_13_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-grid-cell\", 25, 23);\n    i0.ɵɵpipe(2, \"transactionState\");\n    i0.ɵɵpipe(3, \"igxStringReplace\");\n    i0.ɵɵpipe(4, \"igxCellStyleClasses\");\n    i0.ɵɵpipe(5, \"igxCellStyles\");\n    i0.ɵɵpipe(6, \"dataMapper\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const col_r67 = ctx.$implicit;\n    const ctx_r14 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"grid-row-end\", col_r67.rowEnd)(\"grid-column-end\", col_r67.colEnd)(\"grid-row-start\", col_r67.rowStart)(\"grid-column-start\", col_r67.colStart)(\"min-height\", ctx_r14.cellHeight, \"px\");\n    i0.ɵɵclassProp(\"igx-grid__td--edited\", i0.ɵɵpipeBindV(2, 33, i0.ɵɵpureFunction7(65, _c214, ctx_r14.key, col_r67.field, ctx_r14.grid.rowEditable, ctx_r14.grid.transactions, ctx_r14.grid.pipeTrigger, ctx_r14.grid.gridAPI.crudService.cell, ctx_r14.grid.gridAPI.crudService.row)))(\"igx-grid__td--pinned\", col_r67.pinned)(\"igx-grid__td--number\", col_r67.dataType === \"number\" || col_r67.dataType === \"percent\" || col_r67.dataType === \"currency\");\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBindV(4, 45, i0.ɵɵpureFunction6(73, _c215, col_r67.cellClasses, ctx_r14.data[col_r67.field], ctx_r14.data, col_r67.field, ctx_r14.viewIndex, ctx_r14.grid.pipeTrigger)))(\"ngStyle\", i0.ɵɵpipeBindV(5, 52, i0.ɵɵpureFunction6(80, _c215, col_r67.cellStyles, ctx_r14.data[col_r67.field], ctx_r14.data, col_r67.field, ctx_r14.viewIndex, ctx_r14.grid.pipeTrigger)))(\"editMode\", col_r67.editable && ctx_r14.grid.crudService.targetInEdit(ctx_r14.index, col_r67.index))(\"column\", col_r67)(\"lastPinned\", col_r67.columnLayoutChild ? null : col_r67.isLastPinned)(\"firstPinned\", col_r67.columnLayoutChild ? null : col_r67.isFirstPinned)(\"formatter\", col_r67.formatter)(\"intRow\", ctx_r14)(\"rowData\", ctx_r14.data)(\"visibleColumnIndex\", col_r67.visibleIndex)(\"value\", i0.ɵɵpipeBindV(6, 59, i0.ɵɵpureFunction5(87, _c71, ctx_r14.data, col_r67.field, ctx_r14.grid.pipeTrigger, ctx_r14.data[col_r67.field], col_r67.hasNestedPath)))(\"cellTemplate\", col_r67.bodyTemplate)(\"lastSearchInfo\", ctx_r14.grid.lastSearchInfo)(\"active\", ctx_r14.isCellActive(col_r67.visibleIndex))(\"cellSelectionMode\", ctx_r14.grid.cellSelection)(\"displayPinnedChip\", ctx_r14.shouldDisplayPinnedChip(col_r67.visibleIndex));\n    i0.ɵɵattribute(\"aria-describedby\", i0.ɵɵpipeBind3(3, 41, ctx_r14.gridID + \"_\" + col_r67.field, \".\", \"_\"));\n  }\n}\n\nfunction IgxGridRowComponent_ng_template_15_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-expandable-grid-cell\", 26, 23);\n    i0.ɵɵpipe(2, \"transactionState\");\n    i0.ɵɵpipe(3, \"igxStringReplace\");\n    i0.ɵɵpipe(4, \"igxCellStyleClasses\");\n    i0.ɵɵpipe(5, \"igxCellStyles\");\n    i0.ɵɵpipe(6, \"dataMapper\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const col_r69 = ctx.$implicit;\n    const ctx_r16 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"grid-row-end\", col_r69.rowEnd)(\"grid-column-end\", col_r69.colEnd)(\"grid-row-start\", col_r69.rowStart)(\"grid-column-start\", col_r69.colStart)(\"min-height\", ctx_r16.cellHeight, \"px\");\n    i0.ɵɵclassProp(\"igx-grid__td--edited\", i0.ɵɵpipeBindV(2, 33, i0.ɵɵpureFunction7(65, _c214, ctx_r16.key, col_r69.field, ctx_r16.grid.rowEditable, ctx_r16.grid.transactions, ctx_r16.grid.pipeTrigger, ctx_r16.grid.gridAPI.crudService.cell, ctx_r16.grid.gridAPI.crudService.row)))(\"igx-grid__td--pinned\", col_r69.pinned)(\"igx-grid__td--number\", (col_r69.dataType === \"number\" || col_r69.dataType === \"percent\" || col_r69.dataType === \"currency\") && col_r69.visibleIndex !== 0);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBindV(4, 45, i0.ɵɵpureFunction6(73, _c215, col_r69.cellClasses, ctx_r16.data[col_r69.field], ctx_r16.data, col_r69.field, ctx_r16.viewIndex, ctx_r16.grid.pipeTrigger)))(\"ngStyle\", i0.ɵɵpipeBindV(5, 52, i0.ɵɵpureFunction6(80, _c215, col_r69.cellStyles, ctx_r16.data[col_r69.field], ctx_r16.data, col_r69.field, ctx_r16.viewIndex, ctx_r16.grid.pipeTrigger)))(\"expanded\", ctx_r16.expanded)(\"editMode\", col_r69.editable && ctx_r16.grid.crudService.targetInEdit(ctx_r16.index, col_r69.index))(\"column\", col_r69)(\"lastPinned\", col_r69.columnLayoutChild ? null : col_r69.isLastPinned)(\"formatter\", col_r69.formatter)(\"intRow\", ctx_r16)(\"rowData\", ctx_r16.data)(\"visibleColumnIndex\", col_r69.visibleIndex)(\"value\", i0.ɵɵpipeBindV(6, 59, i0.ɵɵpureFunction5(87, _c71, ctx_r16.data, col_r69.field, ctx_r16.grid.pipeTrigger, ctx_r16.data[col_r69.field], col_r69.hasNestedPath)))(\"cellTemplate\", col_r69.bodyTemplate)(\"lastSearchInfo\", ctx_r16.grid.lastSearchInfo)(\"active\", ctx_r16.isCellActive(col_r69.visibleIndex))(\"cellSelectionMode\", ctx_r16.grid.cellSelection)(\"displayPinnedChip\", ctx_r16.shouldDisplayPinnedChip(col_r69.visibleIndex));\n    i0.ɵɵattribute(\"aria-describedby\", i0.ɵɵpipeBind3(3, 41, ctx_r16.gridID + \"_\" + col_r69.field, \".\", \"_\"));\n  }\n}\n\nconst _c216 = [\"record_template\"];\nconst _c217 = [\"detail_template_container\"];\nconst _c218 = [\"group_template\"];\nconst _c219 = [\"summary_template\"];\n\nfunction IgxGridComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"igx-grid-group-by-area\", 61, 62);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"flex-basis\", ctx_r0.outerWidth, \"px\");\n    i0.ɵɵproperty(\"grid\", ctx_r0)(\"expressions\", ctx_r0.groupingExpressions)(\"sortingExpressions\", ctx_r0.sortingExpressions)(\"density\", ctx_r0.displayDensity)(\"dropAreaTemplate\", ctx_r0.dropAreaTemplate)(\"dropAreaMessage\", ctx_r0.dropAreaMessage);\n  }\n}\n\nfunction IgxGridComponent_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 63);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"igxColumnMovingDrop\", ctx_r2.headerContainer);\n    i0.ɵɵattribute(\"droppable\", true);\n  }\n}\n\nfunction IgxGridComponent_span_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 64);\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"left\", ctx_r3.pinnedWidth, \"px\");\n    i0.ɵɵproperty(\"igxColumnMovingDrop\", ctx_r3.headerContainer);\n    i0.ɵɵattribute(\"droppable\", true);\n  }\n}\n\nfunction IgxGridComponent_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridComponent_ng_template_9_ng_container_0_div_1_ng_container_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridComponent_ng_template_9_ng_container_0_div_1_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxGridComponent_ng_template_9_ng_container_0_div_1_ng_container_2_ng_container_1_Template, 1, 0, \"ng-container\", 69);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const rowData_r66 = ctx.$implicit;\n    const rowIndex_r67 = ctx.index;\n    const ctx_r65 = i0.ɵɵnextContext(4);\n\n    const _r12 = i0.ɵɵreference(27);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r12)(\"ngTemplateOutletContext\", ctx_r65.getContext(rowData_r66, rowIndex_r67, true));\n  }\n}\n\nconst _c220 = function (a0, a1) {\n  return {\n    \"igx-grid__tr--pinned-bottom\": a0,\n    \"igx-grid__tr--pinned-top\": a1\n  };\n};\n\nfunction IgxGridComponent_ng_template_9_ng_container_0_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 66, 67);\n    i0.ɵɵtemplate(2, IgxGridComponent_ng_template_9_ng_container_0_div_1_ng_container_2_Template, 2, 2, \"ng-container\", 68);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const pinnedData_r62 = i0.ɵɵnextContext().ngIf;\n    const ctx_r63 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"width\", ctx_r63.calcWidth, \"px\");\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(4, _c220, !ctx_r63.isRowPinningToTop, ctx_r63.isRowPinningToTop));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", pinnedData_r62);\n  }\n}\n\nfunction IgxGridComponent_ng_template_9_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxGridComponent_ng_template_9_ng_container_0_div_1_Template, 3, 7, \"div\", 65);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const pinnedData_r62 = ctx.ngIf;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", pinnedData_r62.length > 0);\n  }\n}\n\nconst _c221 = function (a0, a1, a2, a3, a4, a5, a6) {\n  return [a0, a1, a2, a3, a4, a5, a6, true];\n};\n\nconst _c222 = function (a0, a1, a2, a3, a4) {\n  return [a0, a1, a2, a3, a4, true];\n};\n\nfunction IgxGridComponent_ng_template_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxGridComponent_ng_template_9_ng_container_0_Template, 2, 1, \"ng-container\", 0);\n    i0.ɵɵpipe(1, \"gridSort\");\n    i0.ɵɵpipe(2, \"gridFiltering\");\n    i0.ɵɵpipe(3, \"gridRowPinning\");\n    i0.ɵɵpipe(4, \"gridAddRow\");\n    i0.ɵɵpipe(5, \"visibleColumns\");\n    i0.ɵɵpipe(6, \"gridTransaction\");\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", i0.ɵɵpipeBindV(1, 1, i0.ɵɵpureFunction5(41, _c222, i0.ɵɵpipeBindV(2, 8, i0.ɵɵpureFunction7(33, _c221, i0.ɵɵpipeBind4(3, 17, i0.ɵɵpipeBind3(4, 22, i0.ɵɵpipeBind2(5, 26, i0.ɵɵpipeBind3(6, 29, ctx_r6.data, ctx_r6.id, ctx_r6.pipeTrigger), ctx_r6.hasVisibleColumns), true, ctx_r6.pipeTrigger), ctx_r6.id, true, ctx_r6.pipeTrigger), ctx_r6.filteringExpressionsTree, ctx_r6.filterStrategy, ctx_r6.advancedFilteringExpressionsTree, ctx_r6.id, ctx_r6.pipeTrigger, ctx_r6.filteringPipeTrigger)), ctx_r6.sortingExpressions, ctx_r6.sortStrategy, ctx_r6.id, ctx_r6.pipeTrigger)));\n  }\n}\n\nfunction IgxGridComponent_ng_template_11_ng_template_0_Template(rf, ctx) {}\n\nfunction IgxGridComponent_ng_template_11_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r74 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵtemplate(0, IgxGridComponent_ng_template_11_ng_template_0_Template, 0, 0, \"ng-template\", 70);\n    i0.ɵɵlistener(\"cachedViewLoaded\", function IgxGridComponent_ng_template_11_Template_ng_template_cachedViewLoaded_0_listener($event) {\n      i0.ɵɵrestoreView(_r74);\n      const ctx_r73 = i0.ɵɵnextContext();\n      return ctx_r73.cachedViewLoaded($event);\n    })(\"viewCreated\", function IgxGridComponent_ng_template_11_Template_ng_template_viewCreated_0_listener($event) {\n      i0.ɵɵrestoreView(_r74);\n      const ctx_r75 = i0.ɵɵnextContext();\n      return ctx_r75.viewCreatedHandler($event);\n    })(\"viewMoved\", function IgxGridComponent_ng_template_11_Template_ng_template_viewMoved_0_listener($event) {\n      i0.ɵɵrestoreView(_r74);\n      const ctx_r76 = i0.ɵɵnextContext();\n      return ctx_r76.viewMovedHandler($event);\n    });\n  }\n\n  if (rf & 2) {\n    const rowData_r70 = ctx.$implicit;\n    const rowIndex_r71 = ctx.index;\n    const ctx_r8 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"igxTemplateOutlet\", ctx_r8.getRowTemplate(rowData_r70))(\"igxTemplateOutletContext\", ctx_r8.getContext(rowData_r70, rowIndex_r71));\n  }\n}\n\nfunction IgxGridComponent_ng_container_23_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nconst _c223 = function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a10, a11) {\n  return [a0, a1, a2, a3, a4, a5, a6, a7, a8, false, a10, a11];\n};\n\nfunction IgxGridComponent_ng_template_24_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-grid-row\", 71, 72);\n    i0.ɵɵpipe(2, \"igxGridRowClasses\");\n    i0.ɵɵpipe(3, \"igxGridRowStyles\");\n  }\n\n  if (rf & 2) {\n    const rowIndex_r77 = ctx.index;\n    const rowData_r78 = ctx.$implicit;\n    const disabledRow_r79 = ctx.disabled;\n\n    const _r80 = i0.ɵɵreference(1);\n\n    const ctx_r11 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"gridID\", ctx_r11.id)(\"index\", rowIndex_r77)(\"data\", rowData_r78)(\"disabled\", disabledRow_r79)(\"ngClass\", i0.ɵɵpipeBindV(2, 6, i0.ɵɵpureFunctionV(24, _c223, [ctx_r11.rowClasses, _r80, _r80.inEditMode, _r80.selected, _r80.dirty, _r80.deleted, _r80.dragging, rowIndex_r77, ctx_r11.hasColumnLayouts, rowData_r78, ctx_r11.pipeTrigger])))(\"ngStyle\", i0.ɵɵpipeBind4(3, 19, ctx_r11.rowStyles, rowData_r78, rowIndex_r77, ctx_r11.pipeTrigger));\n  }\n}\n\nfunction IgxGridComponent_ng_template_26_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-grid-row\", 73, 74);\n    i0.ɵɵpipe(3, \"igxGridRowClasses\");\n    i0.ɵɵpipe(4, \"igxGridRowStyles\");\n  }\n\n  if (rf & 2) {\n    const rowIndex_r81 = ctx.index;\n    const rowData_r82 = ctx.$implicit;\n\n    const _r83 = i0.ɵɵreference(1);\n\n    const ctx_r13 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"gridID\", ctx_r13.id)(\"index\", rowIndex_r81)(\"data\", rowData_r82)(\"ngClass\", i0.ɵɵpipeBindV(3, 5, i0.ɵɵpureFunctionV(23, _c223, [ctx_r13.rowClasses, _r83, _r83.inEditMode, _r83.selected, _r83.dirty, _r83.deleted, _r83.dragging, rowIndex_r81, ctx_r13.hasColumnLayouts, rowData_r82, ctx_r13.pipeTrigger])))(\"ngStyle\", i0.ɵɵpipeBind4(4, 18, ctx_r13.rowStyles, rowData_r82, rowIndex_r81, ctx_r13.pipeTrigger));\n  }\n}\n\nfunction IgxGridComponent_ng_template_28_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-grid-groupby-row\", 75, 72);\n  }\n\n  if (rf & 2) {\n    const rowIndex_r85 = ctx.index;\n    const rowData_r86 = ctx.$implicit;\n    const ctx_r15 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"gridID\", ctx_r15.id)(\"index\", rowIndex_r85)(\"groupRow\", rowData_r86)(\"hideGroupRowSelectors\", ctx_r15.hideRowSelectors)(\"rowDraggable\", ctx_r15.rowDraggable);\n  }\n}\n\nfunction IgxGridComponent_ng_template_30_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-grid-summary-row\", 76, 77);\n  }\n\n  if (rf & 2) {\n    const rowIndex_r88 = ctx.index;\n    const rowData_r89 = ctx.$implicit;\n    const ctx_r17 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"gridID\", ctx_r17.id)(\"summaries\", rowData_r89.summaries)(\"index\", rowIndex_r88);\n  }\n}\n\nfunction IgxGridComponent_ng_template_32_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"div\");\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r94 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassMapInterpolate1(\"igx-grid__row-indentation igx-grid__row-indentation--level-\", ctx_r94.groupingExpressions.length, \"\");\n  }\n}\n\nfunction IgxGridComponent_ng_template_32_ng_template_4_Template(rf, ctx) {}\n\nconst _c224 = function (a1) {\n  return {\n    \"igx-grid__tr-container\": true,\n    \"igx-grid__tr-container--active\": a1\n  };\n};\n\nfunction IgxGridComponent_ng_template_32_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r97 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 78, 79);\n    i0.ɵɵlistener(\"pointerdown\", function IgxGridComponent_ng_template_32_Template_div_pointerdown_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r97);\n      const rowIndex_r91 = restoredCtx.index;\n\n      const _r93 = i0.ɵɵreference(1);\n\n      const ctx_r96 = i0.ɵɵnextContext();\n      return ctx_r96.detailsViewFocused(_r93, rowIndex_r91);\n    });\n    i0.ɵɵelementStart(2, \"div\", 80);\n    i0.ɵɵtemplate(3, IgxGridComponent_ng_template_32_ng_container_3_Template, 2, 3, \"ng-container\", 0);\n    i0.ɵɵtemplate(4, IgxGridComponent_ng_template_32_ng_template_4_Template, 0, 0, \"ng-template\", 81);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const rowIndex_r91 = ctx.index;\n    const rowData_r92 = ctx.$implicit;\n    const ctx_r19 = i0.ɵɵnextContext();\n    i0.ɵɵpropertyInterpolate2(\"id\", \"\", ctx_r19.id, \"_\", rowIndex_r91, \"\");\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(7, _c224, ctx_r19.isDetailActive(rowIndex_r91)));\n    i0.ɵɵattribute(\"data-rowindex\", rowIndex_r91);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", ctx_r19.groupingExpressions.length > 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r19.detailTemplate.first)(\"ngTemplateOutletContext\", ctx_r19.getDetailsContext(rowData_r92, rowIndex_r91));\n  }\n}\n\nfunction IgxGridComponent_ng_container_34_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridComponent_igx_circular_bar_40_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-circular-bar\", 82);\n  }\n\n  if (rf & 2) {\n    i0.ɵɵproperty(\"indeterminate\", true);\n  }\n}\n\nfunction IgxGridComponent_span_41_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 83);\n  }\n\n  if (rf & 2) {\n    const ctx_r24 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"igxColumnMovingDrop\", ctx_r24.headerContainer);\n    i0.ɵɵattribute(\"droppable\", true);\n  }\n}\n\nfunction IgxGridComponent_ng_template_45_Template(rf, ctx) {}\n\nfunction IgxGridComponent_igx_grid_summary_row_57_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-grid-summary-row\", 84, 77);\n    i0.ɵɵpipe(2, \"igxGridSummaryDataPipe\");\n  }\n\n  if (rf & 2) {\n    const ctx_r30 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"width\", ctx_r30.calcWidth, \"px\")(\"height\", ctx_r30.summaryRowHeight, \"px\");\n    i0.ɵɵproperty(\"gridID\", ctx_r30.id)(\"summaries\", i0.ɵɵpipeBind2(2, 7, ctx_r30.id, ctx_r30.summaryService.retriggerRootPipe))(\"index\", ctx_r30.dataView.length);\n  }\n}\n\nfunction IgxGridComponent_ng_template_63_Template(rf, ctx) {}\n\nfunction IgxGridComponent_ng_container_69_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵprojection(1, 2);\n    i0.ɵɵelementContainerEnd();\n  }\n}\n\nfunction IgxGridComponent_ng_template_70_span_3_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridComponent_ng_template_70_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtemplate(1, IgxGridComponent_ng_template_70_span_3_ng_container_1_Template, 1, 0, \"ng-container\", 7);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r99 = i0.ɵɵnextContext(2);\n\n    const _r40 = i0.ɵɵreference(75);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r99.addRowEmptyTemplate || _r40);\n  }\n}\n\nfunction IgxGridComponent_ng_template_70_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 85)(1, \"span\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, IgxGridComponent_ng_template_70_span_3_Template, 2, 1, \"span\", 0);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r37 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r37.emptyFilteredGridMessage);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r37.showAddButton);\n  }\n}\n\nfunction IgxGridComponent_ng_template_72_span_3_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridComponent_ng_template_72_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtemplate(1, IgxGridComponent_ng_template_72_span_3_ng_container_1_Template, 1, 0, \"ng-container\", 7);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r101 = i0.ɵɵnextContext(2);\n\n    const _r40 = i0.ɵɵreference(75);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r101.addRowEmptyTemplate || _r40);\n  }\n}\n\nfunction IgxGridComponent_ng_template_72_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 85)(1, \"span\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, IgxGridComponent_ng_template_72_span_3_Template, 2, 1, \"span\", 0);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r39 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r39.emptyGridMessage);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r39.showAddButton);\n  }\n}\n\nfunction IgxGridComponent_ng_template_74_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r104 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 86);\n    i0.ɵɵlistener(\"click\", function IgxGridComponent_ng_template_74_Template_button_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r104);\n      const ctx_r103 = i0.ɵɵnextContext();\n      return ctx_r103.crudService.enterAddRowMode(null, false, $event);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r41 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r41.resourceStrings.igx_grid_add_row_label, \" \");\n  }\n}\n\nfunction IgxGridComponent_ng_template_76_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 87);\n    i0.ɵɵelement(1, \"igx-circular-bar\", 82);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"indeterminate\", true);\n  }\n}\n\nconst _c225 = function (a0) {\n  return {\n    \"igx-grid__group-expand-btn--push\": a0\n  };\n};\n\nfunction IgxGridComponent_ng_template_78_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\", 88);\n    i0.ɵɵtext(1, \"unfold_less\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r45 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(1, _c225, ctx_r45.filteringService.isFilterRowVisible));\n  }\n}\n\nfunction IgxGridComponent_ng_template_80_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\", 88);\n    i0.ɵɵtext(1, \"unfold_more\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r47 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(1, _c225, ctx_r47.filteringService.isFilterRowVisible));\n  }\n}\n\nfunction IgxGridComponent_div_82_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nconst _c226 = function (a0, a1) {\n  return {\n    rowChangesCount: a0,\n    endEdit: a1\n  };\n};\n\nfunction IgxGridComponent_div_82_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 18, 89)(2, \"div\", 90);\n    i0.ɵɵtemplate(3, IgxGridComponent_div_82_ng_container_3_Template, 1, 0, \"ng-container\", 69);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r48 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"className\", ctx_r48.bannerClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r48.rowEditContainer)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(3, _c226, ctx_r48.rowChangesCount, ctx_r48.endEdit.bind(ctx_r48)));\n  }\n}\n\nfunction IgxGridComponent_ng_template_83_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const ctx_r50 = i0.ɵɵnextContext();\n    i0.ɵɵtextInterpolate1(\" You have \", ctx_r50.rowChangesCount, \" changes in this row\\n\");\n  }\n}\n\nfunction IgxGridComponent_ng_template_85_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r108 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 91);\n    i0.ɵɵlistener(\"click\", function IgxGridComponent_ng_template_85_Template_button_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r108);\n      const ctx_r107 = i0.ɵɵnextContext();\n      return ctx_r107.endRowEditTabStop(false, $event);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"button\", 91);\n    i0.ɵɵlistener(\"click\", function IgxGridComponent_ng_template_85_Template_button_click_2_listener($event) {\n      i0.ɵɵrestoreView(_r108);\n      const ctx_r109 = i0.ɵɵnextContext();\n      return ctx_r109.endRowEditTabStop(true, $event);\n    });\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r52 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r52.resourceStrings.igx_grid_row_edit_btn_cancel);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r52.resourceStrings.igx_grid_row_edit_btn_done);\n  }\n}\n\nfunction IgxGridComponent_ng_template_87_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridComponent_ng_template_87_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridComponent_ng_template_87_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 92)(1, \"span\", 93);\n    i0.ɵɵtemplate(2, IgxGridComponent_ng_template_87_ng_container_2_Template, 1, 0, \"ng-container\", 69);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(3, \"div\", 94)(4, \"div\", 95);\n    i0.ɵɵtemplate(5, IgxGridComponent_ng_template_87_ng_container_5_Template, 1, 0, \"ng-container\", 69);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r54 = i0.ɵɵnextContext();\n\n    const _r49 = i0.ɵɵreference(84);\n\n    const _r51 = i0.ɵɵreference(86);\n\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", (ctx_r54.crudService.row == null ? null : ctx_r54.crudService.row.getClassName()) === \"IgxAddRow\" ? ctx_r54.rowAddText : ctx_r54.rowEditText ? ctx_r54.rowEditText : _r49)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(4, _c24, (ctx_r54.crudService.row == null ? null : ctx_r54.crudService.row.getClassName()) !== \"IgxAddRow\" ? ctx_r54.rowChangesCount : null));\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r54.rowEditActions ? ctx_r54.rowEditActions : _r51)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(6, _c24, ctx_r54.endEdit.bind(ctx_r54)));\n  }\n}\n\nfunction IgxGridComponent_ng_template_89_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1, \"drag_indicator\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxGridComponent_igx_grid_column_resizer_91_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-grid-column-resizer\");\n  }\n}\n\nconst _c227 = [[[\"igx-grid-toolbar\"]], [[\"igx-grid-footer\"]], [[\"igx-paginator\"]]];\n\nconst _c228 = function (a0, a1, a2, a3, a4, a5, a6, a7) {\n  return [a0, a1, a2, a3, a4, a5, a6, a7];\n};\n\nconst _c229 = [\"igx-grid-toolbar\", \"igx-grid-footer\", \"igx-paginator\"];\n\nfunction IgxColumnActionsComponent_h4_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"h4\", 7);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"id\", ctx_r0.titleID);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r0.title);\n  }\n}\n\nfunction IgxColumnActionsComponent_igx_input_group_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-input-group\", 8)(1, \"input\", 9);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxColumnActionsComponent_igx_input_group_2_Template_input_ngModelChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r3 = i0.ɵɵnextContext();\n      return ctx_r3.filterCriteria = $event;\n    });\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngModel\", ctx_r1.filterCriteria)(\"placeholder\", ctx_r1.filterColumnsPrompt);\n    i0.ɵɵattribute(\"aria-describedby\", ctx_r1.titleID);\n  }\n}\n\nfunction IgxColumnActionsComponent_igx_checkbox_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-checkbox\", 10);\n    i0.ɵɵlistener(\"click\", function IgxColumnActionsComponent_igx_checkbox_4_Template_igx_checkbox_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r7);\n      const column_r5 = restoredCtx.$implicit;\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.toggleColumn(column_r5);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const column_r5 = ctx.$implicit;\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"margin-left\", column_r5.level * ctx_r2.indentation, \"px\");\n    i0.ɵɵproperty(\"readonly\", true)(\"checked\", ctx_r2.actionsDirective.columnChecked(column_r5));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", column_r5.header || column_r5.field, \" \");\n  }\n}\n\nfunction IgxGridToolbarExporterComponent_span_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r2.grid == null ? null : ctx_r2.grid.resourceStrings.igx_grid_toolbar_exporter_button_label, \" \");\n  }\n}\n\nfunction IgxGridToolbarExporterComponent_li_13_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 1);\n  }\n}\n\nfunction IgxGridToolbarExporterComponent_li_13_excel_text_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"excel-text\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r9.grid == null ? null : ctx_r9.grid.resourceStrings.igx_grid_toolbar_exporter_excel_entry_text, \" \");\n  }\n}\n\nfunction IgxGridToolbarExporterComponent_li_13_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridToolbarExporterComponent_li_13_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"li\", 9, 10);\n    i0.ɵɵlistener(\"click\", function IgxGridToolbarExporterComponent_li_13_Template_li_click_0_listener() {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r11 = i0.ɵɵnextContext();\n\n      const _r3 = i0.ɵɵreference(12);\n\n      return ctx_r11.export(\"excel\", _r3);\n    });\n    i0.ɵɵtemplate(2, IgxGridToolbarExporterComponent_li_13_ng_template_2_Template, 1, 0, \"ng-template\", null, 11, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵtemplate(4, IgxGridToolbarExporterComponent_li_13_excel_text_4_Template, 2, 1, \"excel-text\", 3);\n    i0.ɵɵtemplate(5, IgxGridToolbarExporterComponent_li_13_ng_container_5_Template, 1, 0, \"ng-container\", 12);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const _r7 = i0.ɵɵreference(3);\n\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(4);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r4.hasExcelAttr);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r7);\n  }\n}\n\nfunction IgxGridToolbarExporterComponent_li_14_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 2);\n  }\n}\n\nfunction IgxGridToolbarExporterComponent_li_14_csv_text_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"csv-text\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r16.grid == null ? null : ctx_r16.grid.resourceStrings.igx_grid_toolbar_exporter_csv_entry_text, \"\");\n  }\n}\n\nfunction IgxGridToolbarExporterComponent_li_14_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxGridToolbarExporterComponent_li_14_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r19 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"li\", 13, 14);\n    i0.ɵɵlistener(\"click\", function IgxGridToolbarExporterComponent_li_14_Template_li_click_0_listener() {\n      i0.ɵɵrestoreView(_r19);\n      const ctx_r18 = i0.ɵɵnextContext();\n\n      const _r3 = i0.ɵɵreference(12);\n\n      return ctx_r18.export(\"csv\", _r3);\n    });\n    i0.ɵɵtemplate(2, IgxGridToolbarExporterComponent_li_14_ng_template_2_Template, 1, 0, \"ng-template\", null, 15, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵtemplate(4, IgxGridToolbarExporterComponent_li_14_csv_text_4_Template, 2, 1, \"csv-text\", 3);\n    i0.ɵɵtemplate(5, IgxGridToolbarExporterComponent_li_14_ng_container_5_Template, 1, 0, \"ng-container\", 12);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const _r14 = i0.ɵɵreference(3);\n\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(4);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r5.hasCSVAttr);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r14);\n  }\n}\n\nconst _c230 = [\"*\", [[\"\", \"excelText\", \"\"], [\"excel-text\"]], [[\"\", \"csvText\", \"\"], [\"csv-text\"]]];\nconst _c231 = [\"*\", \"[excelText],excel-text\", \"[csvText],csv-text\"];\n\nfunction IgxGridToolbarHidingComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"button\", 1, 2);\n    i0.ɵɵlistener(\"click\", function IgxGridToolbarHidingComponent_ng_container_0_Template_button_click_1_listener() {\n      i0.ɵɵrestoreView(_r5);\n\n      const _r1 = i0.ɵɵreference(2);\n\n      const _r3 = i0.ɵɵreference(11);\n\n      const _r2 = i0.ɵɵreference(10);\n\n      const ctx_r4 = i0.ɵɵnextContext();\n      return ctx_r4.toggle(_r1, _r3, _r2);\n    });\n    i0.ɵɵelementStart(3, \"igx-icon\");\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"span\");\n    i0.ɵɵtext(6);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(7, \"span\");\n    i0.ɵɵtext(8);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(9, \"igx-column-actions\", 3, 4);\n    i0.ɵɵlistener(\"opened\", function IgxGridToolbarHidingComponent_ng_container_0_Template_igx_column_actions_opened_9_listener() {\n      i0.ɵɵrestoreView(_r5);\n\n      const _r3 = i0.ɵɵreference(11);\n\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.focusSearch(_r3.element);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"title\", ctx_r0.grid == null ? null : ctx_r0.grid.resourceStrings.igx_grid_toolbar_hiding_button_tooltip)(\"displayDensity\", ctx_r0.grid.displayDensity);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate(!ctx_r0.grid.hiddenColumnsCount ? \"visibility\" : \"visibility_off\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r0.grid.hiddenColumnsCount);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r0.buttonText);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"grid\", ctx_r0.grid)(\"title\", ctx_r0.title || (ctx_r0.grid == null ? null : ctx_r0.grid.resourceStrings.igx_grid_toolbar_hiding_title))(\"filterColumnsPrompt\", ctx_r0.prompt || (ctx_r0.grid == null ? null : ctx_r0.grid.resourceStrings.igx_grid_toolbar_actions_filter_prompt))(\"hideFilter\", ctx_r0.hideFilter)(\"filterCriteria\", ctx_r0.filterCriteria)(\"columnDisplayOrder\", ctx_r0.columnDisplayOrder)(\"columnsAreaMaxHeight\", ctx_r0.columnsAreaMaxHeight)(\"uncheckAllText\", ctx_r0.uncheckAllText)(\"checkAllText\", ctx_r0.checkAllText)(\"indentation\", ctx_r0.indentetion);\n  }\n}\n\nfunction IgxGridToolbarPinningComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"button\", 1, 2);\n    i0.ɵɵlistener(\"click\", function IgxGridToolbarPinningComponent_ng_container_0_Template_button_click_1_listener() {\n      i0.ɵɵrestoreView(_r5);\n\n      const _r1 = i0.ɵɵreference(2);\n\n      const _r3 = i0.ɵɵreference(10);\n\n      const _r2 = i0.ɵɵreference(9);\n\n      const ctx_r4 = i0.ɵɵnextContext();\n      return ctx_r4.toggle(_r1, _r3, _r2);\n    });\n    i0.ɵɵelement(3, \"igx-icon\", 3);\n    i0.ɵɵelementStart(4, \"span\");\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(6, \"span\");\n    i0.ɵɵtext(7);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(8, \"igx-column-actions\", 4, 5);\n    i0.ɵɵlistener(\"opened\", function IgxGridToolbarPinningComponent_ng_container_0_Template_igx_column_actions_opened_8_listener() {\n      i0.ɵɵrestoreView(_r5);\n\n      const _r3 = i0.ɵɵreference(10);\n\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.focusSearch(_r3.element);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"title\", ctx_r0.grid == null ? null : ctx_r0.grid.resourceStrings.igx_grid_toolbar_pinning_button_tooltip)(\"displayDensity\", ctx_r0.grid.displayDensity);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"name\", !ctx_r0.grid.pinnedColumnsCount ? \"unpin-left\" : \"pin-left\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r0.grid.pinnedColumnsCount);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r0.buttonText);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"grid\", ctx_r0.grid)(\"title\", ctx_r0.title || (ctx_r0.grid == null ? null : ctx_r0.grid.resourceStrings.igx_grid_toolbar_pinning_title))(\"filterColumnsPrompt\", ctx_r0.prompt || (ctx_r0.grid == null ? null : ctx_r0.grid.resourceStrings.igx_grid_toolbar_actions_filter_prompt))(\"hideFilter\", ctx_r0.hideFilter)(\"filterCriteria\", ctx_r0.filterCriteria)(\"columnDisplayOrder\", ctx_r0.columnDisplayOrder)(\"columnsAreaMaxHeight\", ctx_r0.columnsAreaMaxHeight)(\"uncheckAllText\", ctx_r0.uncheckAllText)(\"checkAllText\", ctx_r0.checkAllText)(\"indentation\", ctx_r0.indentetion);\n  }\n}\n\nfunction IgxTreeGridGroupByAreaComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-chip\", 5);\n    i0.ɵɵlistener(\"keyDown\", function IgxTreeGridGroupByAreaComponent_ng_container_1_Template_igx_chip_keyDown_1_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.handleKeyDown($event.owner.id, $event.originalEvent);\n    })(\"remove\", function IgxTreeGridGroupByAreaComponent_ng_container_1_Template_igx_chip_remove_1_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.clearGrouping($event.owner.id);\n    })(\"chipClick\", function IgxTreeGridGroupByAreaComponent_ng_container_1_Template_igx_chip_chipClick_1_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r7);\n      const expression_r4 = restoredCtx.$implicit;\n      const ctx_r9 = i0.ɵɵnextContext();\n      return ctx_r9.handleClick(expression_r4.fieldName);\n    });\n    i0.ɵɵpipe(2, \"igxGroupByMeta\");\n    i0.ɵɵpipe(3, \"igxGroupByMeta\");\n    i0.ɵɵpipe(4, \"igxGroupByMeta\");\n    i0.ɵɵpipe(5, \"igxGroupByMeta\");\n    i0.ɵɵelementStart(6, \"span\");\n    i0.ɵɵtext(7);\n    i0.ɵɵpipe(8, \"igxGroupByMeta\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(9, \"igx-icon\", 6);\n    i0.ɵɵtext(10);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(11, \"span\", 7)(12, \"igx-icon\", 8);\n    i0.ɵɵtext(13, \"arrow_forward\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const expression_r4 = ctx.$implicit;\n    const last_r5 = ctx.last;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"id\", expression_r4.fieldName)(\"title\", i0.ɵɵpipeBind2(2, 9, expression_r4.fieldName, ctx_r0.grid).title)(\"displayDensity\", ctx_r0.grid.displayDensity)(\"removable\", i0.ɵɵpipeBind2(3, 12, expression_r4.fieldName, ctx_r0.grid).groupable)(\"draggable\", i0.ɵɵpipeBind2(4, 15, expression_r4.fieldName, ctx_r0.grid).groupable)(\"disabled\", !i0.ɵɵpipeBind2(5, 18, expression_r4.fieldName, ctx_r0.grid).groupable);\n    i0.ɵɵadvance(6);\n    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind2(8, 21, expression_r4.fieldName, ctx_r0.grid).title);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate(expression_r4.dir === 1 ? \"arrow_upward\" : \"arrow_downward\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"hidden\", last_r5 && !ctx_r0.dropAreaVisible);\n  }\n}\n\nfunction IgxTreeGridGroupByAreaComponent_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxTreeGridGroupByAreaComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\", 9);\n    i0.ɵɵtext(1, \"group_work\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"span\", 10);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate(ctx_r3.dropAreaMessage);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_template_0_igx_chip_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-chip\", 9);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r14 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"disabled\", true)(\"displayDensity\", \"compact\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r14.grid.resourceStrings.igx_grid_pinned_row_indicator);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxTreeGridCellComponent_ng_template_0_igx_chip_0_Template, 2, 3, \"igx-chip\", 8);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.displayPinnedChip);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_template_2_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 12);\n    i0.ɵɵpipe(1, \"columnFormatter\");\n    i0.ɵɵpipe(2, \"number\");\n    i0.ɵɵpipe(3, \"date\");\n    i0.ɵɵpipe(4, \"currency\");\n    i0.ɵɵpipe(5, \"percent\");\n    i0.ɵɵtext(6);\n    i0.ɵɵpipe(7, \"columnFormatter\");\n    i0.ɵɵpipe(8, \"number\");\n    i0.ɵɵpipe(9, \"date\");\n    i0.ɵɵpipe(10, \"currency\");\n    i0.ɵɵpipe(11, \"percent\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r15 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"cssClass\", ctx_r15.highlightClass)(\"activeCssClass\", ctx_r15.activeHighlightClass)(\"groupName\", ctx_r15.gridID)(\"value\", ctx_r15.formatter ? i0.ɵɵpipeBind3(1, 9, ctx_r15.value, ctx_r15.formatter, ctx_r15.rowData) : ctx_r15.column.dataType === \"number\" ? i0.ɵɵpipeBind3(2, 13, ctx_r15.value, ctx_r15.column.pipeArgs.digitsInfo, ctx_r15.grid.locale) : ctx_r15.column.dataType === \"date\" || ctx_r15.column.dataType === \"time\" || ctx_r15.column.dataType === \"dateTime\" ? i0.ɵɵpipeBind4(3, 17, ctx_r15.value, ctx_r15.column.pipeArgs.format, ctx_r15.column.pipeArgs.timezone, ctx_r15.grid.locale) : ctx_r15.column.dataType === \"currency\" ? i0.ɵɵpipeBindV(4, 22, i0.ɵɵpureFunction5(55, _c71, ctx_r15.value, ctx_r15.currencyCode, ctx_r15.column.pipeArgs.display, ctx_r15.column.pipeArgs.digitsInfo, ctx_r15.grid.locale)) : ctx_r15.column.dataType === \"percent\" ? i0.ɵɵpipeBind3(5, 28, ctx_r15.value, ctx_r15.column.pipeArgs.digitsInfo, ctx_r15.grid.locale) : ctx_r15.value)(\"row\", ctx_r15.rowData)(\"column\", ctx_r15.column.field)(\"containerClass\", \"igx-grid__td-text\")(\"metadata\", ctx_r15.searchMetadata);\n    i0.ɵɵadvance(6);\n    i0.ɵɵtextInterpolate(ctx_r15.formatter ? i0.ɵɵpipeBind3(7, 32, ctx_r15.value, ctx_r15.formatter, ctx_r15.rowData) : ctx_r15.column.dataType === \"number\" ? i0.ɵɵpipeBind3(8, 36, ctx_r15.value, ctx_r15.column.pipeArgs.digitsInfo, ctx_r15.grid.locale) : ctx_r15.column.dataType === \"date\" || ctx_r15.column.dataType === \"time\" || ctx_r15.column.dataType === \"dateTime\" ? i0.ɵɵpipeBind4(9, 40, ctx_r15.value, ctx_r15.column.pipeArgs.format, ctx_r15.column.pipeArgs.timezone, ctx_r15.grid.locale) : ctx_r15.column.dataType === \"currency\" ? i0.ɵɵpipeBindV(10, 45, i0.ɵɵpureFunction5(61, _c71, ctx_r15.value, ctx_r15.currencyCode, ctx_r15.column.pipeArgs.display, ctx_r15.column.pipeArgs.digitsInfo, ctx_r15.grid.locale)) : ctx_r15.column.dataType === \"percent\" ? i0.ɵɵpipeBind3(11, 51, ctx_r15.value, ctx_r15.column.pipeArgs.digitsInfo, ctx_r15.grid.locale) : ctx_r15.value);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_template_2_igx_icon_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\", 13);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(2, _c210, ctx_r16.value, !ctx_r16.value));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r16.value ? \"check\" : \"close\");\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxTreeGridCellComponent_ng_template_2_div_0_Template, 12, 67, \"div\", 10);\n    i0.ɵɵtemplate(1, IgxTreeGridCellComponent_ng_template_2_igx_icon_1_Template, 2, 5, \"igx-icon\", 11);\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.column.dataType !== \"boolean\" || ctx_r3.column.dataType === \"boolean\" && ctx_r3.formatter);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.column.dataType === \"boolean\" && !ctx_r3.formatter);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_template_4_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 12);\n    i0.ɵɵpipe(1, \"columnFormatter\");\n    i0.ɵɵpipe(2, \"number\");\n    i0.ɵɵpipe(3, \"date\");\n    i0.ɵɵpipe(4, \"currency\");\n    i0.ɵɵpipe(5, \"percent\");\n    i0.ɵɵtext(6);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r18 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"cssClass\", ctx_r18.highlightClass)(\"activeCssClass\", ctx_r18.activeHighlightClass)(\"groupName\", ctx_r18.gridID)(\"value\", ctx_r18.formatter ? i0.ɵɵpipeBind3(1, 9, ctx_r18.value, ctx_r18.formatter, ctx_r18.rowData) : ctx_r18.column.dataType === \"number\" ? i0.ɵɵpipeBind3(2, 13, ctx_r18.value, ctx_r18.column.pipeArgs.digitsInfo, ctx_r18.grid.locale) : ctx_r18.column.dataType === \"date\" || ctx_r18.column.dataType === \"time\" || ctx_r18.column.dataType === \"dateTime\" ? i0.ɵɵpipeBind4(3, 17, ctx_r18.value, ctx_r18.column.pipeArgs.format, ctx_r18.column.pipeArgs.timezone, ctx_r18.grid.locale) : ctx_r18.column.dataType === \"currency\" ? i0.ɵɵpipeBindV(4, 22, i0.ɵɵpureFunction5(32, _c71, ctx_r18.value, ctx_r18.currencyCode, ctx_r18.column.pipeArgs.display, ctx_r18.column.pipeArgs.digitsInfo, ctx_r18.grid.locale)) : ctx_r18.column.dataType === \"percent\" ? i0.ɵɵpipeBind3(5, 28, ctx_r18.value, ctx_r18.column.pipeArgs.digitsInfo, ctx_r18.grid.locale) : ctx_r18.value)(\"row\", ctx_r18.rowData)(\"column\", ctx_r18.column.field)(\"containerClass\", \"igx-grid__td-text\")(\"metadata\", ctx_r18.searchMetadata);\n    i0.ɵɵadvance(6);\n    i0.ɵɵtextInterpolate(!ctx_r18.isEmptyAddRowCell ? ctx_r18.value : ctx_r18.column.header || ctx_r18.column.field);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxTreeGridCellComponent_ng_template_4_div_0_Template, 7, 38, \"div\", 14);\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.column.dataType !== \"boolean\" || ctx_r5.column.dataType === \"boolean\" && ctx_r5.formatter);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_template_6_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r29 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-input-group\", 15)(2, \"input\", 16);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxTreeGridCellComponent_ng_template_6_ng_container_0_Template_input_ngModelChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r28 = i0.ɵɵnextContext(2);\n      return ctx_r28.editValue = $event;\n    });\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r20 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngModel\", ctx_r20.editValue)(\"igxFocus\", true);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_template_6_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r31 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-input-group\", 15)(2, \"input\", 17);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxTreeGridCellComponent_ng_template_6_ng_container_1_Template_input_ngModelChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r31);\n      const ctx_r30 = i0.ɵɵnextContext(2);\n      return ctx_r30.editValue = $event;\n    });\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r21 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngModel\", ctx_r21.editValue)(\"igxFocus\", true)(\"step\", ctx_r21.step);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_template_6_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r33 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-checkbox\", 18);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxTreeGridCellComponent_ng_template_6_ng_container_2_Template_igx_checkbox_ngModelChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r32 = i0.ɵɵnextContext(2);\n      return ctx_r32.editValue = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r22 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngModel\", ctx_r22.editValue)(\"disableRipple\", true);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_template_6_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r35 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-date-picker\", 19);\n    i0.ɵɵlistener(\"valueChange\", function IgxTreeGridCellComponent_ng_template_6_ng_container_3_Template_igx_date_picker_valueChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r35);\n      const ctx_r34 = i0.ɵɵnextContext(2);\n      return ctx_r34.editValue = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r23 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"width\", 100, \"%\");\n    i0.ɵɵproperty(\"outlet\", ctx_r23.grid.outlet)(\"locale\", ctx_r23.grid.locale)(\"value\", ctx_r23.editValue)(\"igxFocus\", true);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_template_6_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r37 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-time-picker\", 20);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxTreeGridCellComponent_ng_template_6_ng_container_4_Template_igx_time_picker_ngModelChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r37);\n      const ctx_r36 = i0.ɵɵnextContext(2);\n      return ctx_r36.editValue = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r24 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"width\", 100, \"%\");\n    i0.ɵɵproperty(\"outlet\", ctx_r24.grid.outlet)(\"inputFormat\", ctx_r24.column.defaultTimeFormat)(\"ngModel\", ctx_r24.editValue)(\"igxFocus\", true);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_template_6_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r39 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-input-group\")(2, \"input\", 21);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxTreeGridCellComponent_ng_template_6_ng_container_5_Template_input_ngModelChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r39);\n      const ctx_r38 = i0.ɵɵnextContext(2);\n      return ctx_r38.editValue = $event;\n    });\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r25 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"igxDateTimeEditor\", ctx_r25.column.defaultDateTimeFormat)(\"ngModel\", ctx_r25.editValue)(\"igxFocus\", true);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_template_6_ng_container_6_igx_prefix_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-prefix\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r40 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r40.currencyCodeSymbol);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_template_6_ng_container_6_igx_suffix_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-suffix\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r41 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r41.currencyCodeSymbol);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_template_6_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r43 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-input-group\", 15);\n    i0.ɵɵtemplate(2, IgxTreeGridCellComponent_ng_template_6_ng_container_6_igx_prefix_2_Template, 2, 1, \"igx-prefix\", 4);\n    i0.ɵɵelementStart(3, \"input\", 17);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxTreeGridCellComponent_ng_template_6_ng_container_6_Template_input_ngModelChange_3_listener($event) {\n      i0.ɵɵrestoreView(_r43);\n      const ctx_r42 = i0.ɵɵnextContext(2);\n      return ctx_r42.editValue = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(4, IgxTreeGridCellComponent_ng_template_6_ng_container_6_igx_suffix_4_Template, 2, 1, \"igx-suffix\", 4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r26 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r26.grid.currencyPositionLeft);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngModel\", ctx_r26.editValue)(\"igxFocus\", true)(\"step\", ctx_r26.step);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r26.grid.currencyPositionLeft);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_template_6_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r45 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-input-group\", 15)(2, \"input\", 17);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxTreeGridCellComponent_ng_template_6_ng_container_7_Template_input_ngModelChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r45);\n      const ctx_r44 = i0.ɵɵnextContext(2);\n      return ctx_r44.editValue = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"igx-suffix\");\n    i0.ɵɵtext(4);\n    i0.ɵɵpipe(5, \"percent\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r27 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngModel\", ctx_r27.editValue)(\"igxFocus\", true)(\"step\", ctx_r27.step);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", i0.ɵɵpipeBind3(5, 4, ctx_r27.editValue, ctx_r27.column.pipeArgs.digitsInfo, ctx_r27.grid.locale), \" \");\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_template_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxTreeGridCellComponent_ng_template_6_ng_container_0_Template, 3, 2, \"ng-container\", 4);\n    i0.ɵɵtemplate(1, IgxTreeGridCellComponent_ng_template_6_ng_container_1_Template, 3, 3, \"ng-container\", 4);\n    i0.ɵɵtemplate(2, IgxTreeGridCellComponent_ng_template_6_ng_container_2_Template, 2, 2, \"ng-container\", 4);\n    i0.ɵɵtemplate(3, IgxTreeGridCellComponent_ng_template_6_ng_container_3_Template, 2, 6, \"ng-container\", 4);\n    i0.ɵɵtemplate(4, IgxTreeGridCellComponent_ng_template_6_ng_container_4_Template, 2, 6, \"ng-container\", 4);\n    i0.ɵɵtemplate(5, IgxTreeGridCellComponent_ng_template_6_ng_container_5_Template, 3, 3, \"ng-container\", 4);\n    i0.ɵɵtemplate(6, IgxTreeGridCellComponent_ng_template_6_ng_container_6_Template, 5, 5, \"ng-container\", 4);\n    i0.ɵɵtemplate(7, IgxTreeGridCellComponent_ng_template_6_ng_container_7_Template, 6, 8, \"ng-container\", 4);\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"string\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"number\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"boolean\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"date\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"time\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"dateTime\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"currency\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"percent\");\n  }\n}\n\nconst _c232 = function (a0) {\n  return {\n    \"padding-inline-start\": a0\n  };\n};\n\nfunction IgxTreeGridCellComponent_ng_container_8_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"div\", 25, 26);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r46 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassMapInterpolate1(\"igx-grid__tree-cell--padding-level-\", ctx_r46.level, \"\");\n    i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction1(4, _c232, \"calc(var(--igx-tree-indent-size) *\" + ctx_r46.level + \")\"));\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_container_8_div_2_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_container_8_div_2_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nconst _c233 = function (a0) {\n  return {\n    visibility: a0\n  };\n};\n\nfunction IgxTreeGridCellComponent_ng_container_8_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r56 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 27, 28);\n    i0.ɵɵlistener(\"click\", function IgxTreeGridCellComponent_ng_container_8_div_2_Template_div_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r56);\n      const ctx_r55 = i0.ɵɵnextContext(2);\n      return ctx_r55.toggle($event);\n    })(\"focus\", function IgxTreeGridCellComponent_ng_container_8_div_2_Template_div_focus_0_listener() {\n      i0.ɵɵrestoreView(_r56);\n      const ctx_r57 = i0.ɵɵnextContext(2);\n      return ctx_r57.onIndicatorFocus();\n    });\n    i0.ɵɵtemplate(2, IgxTreeGridCellComponent_ng_container_8_div_2_ng_container_2_Template, 1, 0, \"ng-container\", 5);\n    i0.ɵɵtemplate(3, IgxTreeGridCellComponent_ng_container_8_div_2_ng_container_3_Template, 1, 0, \"ng-container\", 5);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r47 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction1(5, _c233, ctx_r47.showIndicator ? \"visible\" : \"hidden\"));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r47.iconTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(7, _c24, ctx_r47));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r47.pinnedIndicatorTemplate)(\"ngTemplateOutletContext\", ctx_r47.context);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_container_8_div_3_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_container_8_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r60 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 29);\n    i0.ɵɵlistener(\"dblclick\", function IgxTreeGridCellComponent_ng_container_8_div_3_Template_div_dblclick_0_listener($event) {\n      i0.ɵɵrestoreView(_r60);\n      const ctx_r59 = i0.ɵɵnextContext(2);\n      return ctx_r59.onLoadingDblClick($event);\n    });\n    i0.ɵɵtemplate(1, IgxTreeGridCellComponent_ng_container_8_div_3_ng_container_1_Template, 1, 0, \"ng-container\", 30);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r49 = i0.ɵɵreference(5);\n\n    const ctx_r48 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r48.grid.rowLoadingIndicatorTemplate ? ctx_r48.grid.rowLoadingIndicatorTemplate : _r49);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_container_8_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-circular-bar\", 31);\n  }\n\n  if (rf & 2) {\n    i0.ɵɵproperty(\"indeterminate\", true);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxTreeGridCellComponent_ng_container_8_ng_container_1_Template, 3, 6, \"ng-container\", 4);\n    i0.ɵɵtemplate(2, IgxTreeGridCellComponent_ng_container_8_div_2_Template, 4, 9, \"div\", 22);\n    i0.ɵɵtemplate(3, IgxTreeGridCellComponent_ng_container_8_div_3_Template, 2, 1, \"div\", 23);\n    i0.ɵɵtemplate(4, IgxTreeGridCellComponent_ng_container_8_ng_template_4_Template, 1, 1, \"ng-template\", null, 24, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r8.level > 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r8.isLoading);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r8.isLoading);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_container_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_template_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1, \"expand_more\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxTreeGridCellComponent_ng_template_12_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1, \"chevron_right\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nconst _c234 = [\"treeCell\"];\n\nfunction IgxTreeGridRowComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxTreeGridRowComponent_ng_template_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxTreeGridRowComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 3);\n    i0.ɵɵlistener(\"animationend\", function IgxTreeGridRowComponent_ng_template_1_Template_div_animationend_0_listener() {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.animationEndHandler();\n    });\n    i0.ɵɵtemplate(1, IgxTreeGridRowComponent_ng_template_1_ng_container_1_Template, 1, 0, \"ng-container\", 0);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n\n    const _r3 = i0.ɵɵreference(4);\n\n    i0.ɵɵclassProp(\"igx-grid__tr--add-animate\", ctx_r2.triggerAddAnimationClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r3);\n  }\n}\n\nfunction IgxTreeGridRowComponent_ng_template_3_ng_container_0_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxTreeGridRowComponent_ng_template_3_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 9);\n    i0.ɵɵlistener(\"click\", function IgxTreeGridRowComponent_ng_template_3_ng_container_0_Template_div_click_1_listener($event) {\n      return $event.stopPropagation();\n    });\n    i0.ɵɵtemplate(2, IgxTreeGridRowComponent_ng_template_3_ng_container_0_ng_container_2_Template, 1, 0, \"ng-container\", 0);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassMap(ctx_r8.resolveDragIndicatorClasses);\n    i0.ɵɵproperty(\"igxRowDrag\", ctx_r8)(\"ghostTemplate\", ctx_r8.grid.getDragGhostCustomTemplate());\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r8.grid.dragIndicatorIconTemplate ? ctx_r8.grid.dragIndicatorIconTemplate : ctx_r8.grid.dragIndicatorIconBase);\n  }\n}\n\nfunction IgxTreeGridRowComponent_ng_template_3_ng_container_1_2_ng_template_0_Template(rf, ctx) {}\n\nfunction IgxTreeGridRowComponent_ng_template_3_ng_container_1_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxTreeGridRowComponent_ng_template_3_ng_container_1_2_ng_template_0_Template, 0, 0, \"ng-template\");\n  }\n}\n\nfunction IgxTreeGridRowComponent_ng_template_3_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r23 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 10);\n    i0.ɵɵlistener(\"click\", function IgxTreeGridRowComponent_ng_template_3_ng_container_1_Template_div_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r23);\n      const ctx_r22 = i0.ɵɵnextContext(2);\n      return ctx_r22.onRowSelectorClick($event);\n    })(\"pointerdown\", function IgxTreeGridRowComponent_ng_template_3_ng_container_1_Template_div_pointerdown_1_listener($event) {\n      return $event.preventDefault();\n    });\n    i0.ɵɵtemplate(2, IgxTreeGridRowComponent_ng_template_3_ng_container_1_2_Template, 1, 0, null, 11);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r14 = i0.ɵɵreference(8);\n\n    const ctx_r9 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r9.grid.rowSelectorTemplate ? ctx_r9.grid.rowSelectorTemplate : _r14)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(7, _c24, i0.ɵɵpureFunction4(2, _c212, ctx_r9.viewIndex, ctx_r9.key, ctx_r9.key, ctx_r9.selected)));\n  }\n}\n\nfunction IgxTreeGridRowComponent_ng_template_3_ng_container_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxTreeGridRowComponent_ng_template_3_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxTreeGridRowComponent_ng_template_3_ng_container_2_ng_container_1_Template, 1, 0, \"ng-container\", 11);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r16 = i0.ɵɵreference(10);\n\n    const ctx_r10 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r16)(\"ngTemplateOutletContext\", ctx_r10);\n  }\n}\n\nfunction IgxTreeGridRowComponent_ng_template_3_ng_template_3_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-grid-cell\", 14, 15);\n    i0.ɵɵpipe(2, \"transactionState\");\n    i0.ɵɵpipe(3, \"igxStringReplace\");\n    i0.ɵɵpipe(4, \"igxCellStyleClasses\");\n    i0.ɵɵpipe(5, \"igxCellStyles\");\n    i0.ɵɵpipe(6, \"dataMapper\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const col_r26 = i0.ɵɵnextContext().$implicit;\n    const ctx_r29 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"min-height\", ctx_r29.cellHeight, \"px\")(\"min-width\", col_r26.width)(\"max-width\", col_r26.width)(\"flex-basis\", col_r26.width);\n    i0.ɵɵclassProp(\"igx-grid__td--edited\", i0.ɵɵpipeBindV(2, 30, i0.ɵɵpureFunction7(62, _c214, ctx_r29.key, col_r26.field, ctx_r29.grid.rowEditable, ctx_r29.grid.transactions, ctx_r29.grid.pipeTrigger, ctx_r29.grid.gridAPI.crudService.cell, ctx_r29.grid.gridAPI.crudService.row)))(\"igx-grid__td--number\", col_r26.dataType === \"number\" || col_r26.dataType === \"percent\" || col_r26.dataType === \"currency\")(\"igx-grid__td--bool\", col_r26.dataType === \"boolean\");\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBindV(4, 42, i0.ɵɵpureFunction6(70, _c215, col_r26.cellClasses, ctx_r29.data[col_r26.field], ctx_r29.data, col_r26.field, ctx_r29.viewIndex, ctx_r29.grid.pipeTrigger)))(\"ngStyle\", i0.ɵɵpipeBindV(5, 49, i0.ɵɵpureFunction6(77, _c215, col_r26.cellStyles, ctx_r29.data[col_r26.field], ctx_r29.data, col_r26.field, ctx_r29.viewIndex, ctx_r29.grid.pipeTrigger)))(\"editMode\", col_r26.editable && ctx_r29.grid.crudService.targetInEdit(ctx_r29.index, col_r26.index))(\"column\", col_r26)(\"formatter\", col_r26.formatter)(\"intRow\", ctx_r29)(\"rowData\", ctx_r29.data)(\"width\", col_r26.getCellWidth())(\"visibleColumnIndex\", col_r26.visibleIndex)(\"value\", i0.ɵɵpipeBindV(6, 56, i0.ɵɵpureFunction5(84, _c71, ctx_r29.data, col_r26.field, ctx_r29.grid.pipeTrigger, ctx_r29.data[col_r26.field], col_r26.hasNestedPath)))(\"cellTemplate\", col_r26.bodyTemplate)(\"lastSearchInfo\", ctx_r29.grid.lastSearchInfo)(\"active\", ctx_r29.isCellActive(col_r26.visibleIndex))(\"cellSelectionMode\", ctx_r29.grid.cellSelection)(\"displayPinnedChip\", ctx_r29.shouldDisplayPinnedChip(col_r26.visibleIndex));\n    i0.ɵɵattribute(\"aria-describedby\", i0.ɵɵpipeBind3(3, 38, ctx_r29.gridID + \"_\" + col_r26.field, \".\", \"_\"));\n  }\n}\n\nfunction IgxTreeGridRowComponent_ng_template_3_ng_template_3_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-tree-grid-cell\", 16, 15);\n    i0.ɵɵpipe(2, \"transactionState\");\n    i0.ɵɵpipe(3, \"igxStringReplace\");\n    i0.ɵɵpipe(4, \"igxCellStyleClasses\");\n    i0.ɵɵpipe(5, \"igxCellStyles\");\n    i0.ɵɵpipe(6, \"dataMapper\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const col_r26 = i0.ɵɵnextContext().$implicit;\n    const ctx_r31 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"min-height\", ctx_r31.cellHeight, \"px\")(\"min-width\", col_r26.width)(\"max-width\", col_r26.width)(\"flex-basis\", col_r26.width);\n    i0.ɵɵclassProp(\"igx-grid__td--edited\", i0.ɵɵpipeBindV(2, 32, i0.ɵɵpureFunction7(64, _c214, ctx_r31.key, col_r26.field, ctx_r31.grid.rowEditable, ctx_r31.grid.transactions, ctx_r31.grid.pipeTrigger, ctx_r31.grid.gridAPI.crudService.cell, ctx_r31.grid.gridAPI.crudService.row)))(\"igx-grid__td--number\", (col_r26.dataType === \"number\" || col_r26.dataType === \"percent\" || col_r26.dataType === \"currency\") && col_r26.visibleIndex !== 0);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBindV(4, 44, i0.ɵɵpureFunction6(72, _c215, col_r26.cellClasses, ctx_r31.data[col_r26.field], ctx_r31.data, col_r26.field, ctx_r31.viewIndex, ctx_r31.grid.pipeTrigger)))(\"ngStyle\", i0.ɵɵpipeBindV(5, 51, i0.ɵɵpureFunction6(79, _c215, col_r26.cellStyles, ctx_r31.data[col_r26.field], ctx_r31.data, col_r26.field, ctx_r31.viewIndex, ctx_r31.grid.pipeTrigger)))(\"level\", ctx_r31.treeRow.level)(\"expanded\", ctx_r31.expanded)(\"showIndicator\", ctx_r31.showIndicator)(\"editMode\", col_r26.editable && ctx_r31.grid.crudService.targetInEdit(ctx_r31.index, col_r26.index))(\"column\", col_r26)(\"formatter\", col_r26.formatter)(\"intRow\", ctx_r31)(\"rowData\", ctx_r31.data)(\"width\", col_r26.getCellWidth())(\"visibleColumnIndex\", col_r26.visibleIndex)(\"value\", i0.ɵɵpipeBindV(6, 58, i0.ɵɵpureFunction5(86, _c71, ctx_r31.data, col_r26.field, ctx_r31.grid.pipeTrigger, ctx_r31.data[col_r26.field], col_r26.hasNestedPath)))(\"isLoading\", ctx_r31.isLoading)(\"cellTemplate\", col_r26.bodyTemplate)(\"lastSearchInfo\", ctx_r31.grid.lastSearchInfo)(\"active\", ctx_r31.isCellActive(col_r26.visibleIndex))(\"cellSelectionMode\", ctx_r31.grid.cellSelection)(\"displayPinnedChip\", ctx_r31.shouldDisplayPinnedChip(col_r26.visibleIndex));\n    i0.ɵɵattribute(\"aria-describedby\", i0.ɵɵpipeBind3(3, 40, ctx_r31.gridID + \"_\" + col_r26.field, \".\", \"_\"));\n  }\n}\n\nfunction IgxTreeGridRowComponent_ng_template_3_ng_template_3_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxTreeGridRowComponent_ng_template_3_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxTreeGridRowComponent_ng_template_3_ng_template_3_ng_template_0_Template, 7, 90, \"ng-template\", null, 12, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵtemplate(2, IgxTreeGridRowComponent_ng_template_3_ng_template_3_ng_template_2_Template, 7, 92, \"ng-template\", null, 13, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵtemplate(4, IgxTreeGridRowComponent_ng_template_3_ng_template_3_ng_container_4_Template, 1, 0, \"ng-container\", 0);\n  }\n\n  if (rf & 2) {\n    const col_r26 = ctx.$implicit;\n\n    const _r28 = i0.ɵɵreference(1);\n\n    const _r30 = i0.ɵɵreference(3);\n\n    i0.ɵɵadvance(4);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", col_r26.visibleIndex === 0 ? _r30 : _r28);\n  }\n}\n\nfunction IgxTreeGridRowComponent_ng_template_3_ng_container_6_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxTreeGridRowComponent_ng_template_3_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxTreeGridRowComponent_ng_template_3_ng_container_6_ng_container_1_Template, 1, 0, \"ng-container\", 11);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r16 = i0.ɵɵreference(10);\n\n    const ctx_r13 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r16)(\"ngTemplateOutletContext\", ctx_r13);\n  }\n}\n\nfunction IgxTreeGridRowComponent_ng_template_3_ng_template_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 17);\n    i0.ɵɵelement(1, \"igx-checkbox\", 18);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r15 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"tabindex\", -1)(\"readonly\", true)(\"checked\", ctx_r15.selected)(\"indeterminate\", ctx_r15.indeterminate)(\"disabled\", ctx_r15.deleted)(\"disableRipple\", true)(\"disableTransitions\", ctx_r15.grid.disableTransitions)(\"aria-label\", ctx_r15.rowCheckboxAriaLabel);\n  }\n}\n\nfunction IgxTreeGridRowComponent_ng_template_3_ng_template_9_ng_template_0_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-grid-cell\", 20, 15);\n    i0.ɵɵpipe(2, \"transactionState\");\n    i0.ɵɵpipe(3, \"igxStringReplace\");\n    i0.ɵɵpipe(4, \"igxCellStyleClasses\");\n    i0.ɵɵpipe(5, \"igxCellStyles\");\n    i0.ɵɵpipe(6, \"dataMapper\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const col_r40 = i0.ɵɵnextContext().$implicit;\n    const ctx_r42 = i0.ɵɵnextContext(3);\n    i0.ɵɵstyleProp(\"min-height\", ctx_r42.cellHeight, \"px\")(\"min-width\", col_r40.width)(\"max-width\", col_r40.width)(\"flex-basis\", col_r40.width)(\"left\", col_r40.rightPinnedOffset);\n    i0.ɵɵclassProp(\"igx-grid__td--edited\", i0.ɵɵpipeBindV(2, 32, i0.ɵɵpureFunction7(64, _c214, ctx_r42.key, col_r40.field, ctx_r42.grid.rowEditable, ctx_r42.grid.transactions, ctx_r42.grid.pipeTrigger, ctx_r42.grid.gridAPI.crudService.cell, ctx_r42.grid.gridAPI.crudService.row)))(\"igx-grid__td--number\", col_r40.dataType === \"number\" || col_r40.dataType === \"percent\" || col_r40.dataType === \"currency\");\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBindV(4, 44, i0.ɵɵpureFunction6(72, _c215, col_r40.cellClasses, ctx_r42.data[col_r40.field], ctx_r42.data, col_r40.field, ctx_r42.viewIndex, ctx_r42.grid.pipeTrigger)))(\"ngStyle\", i0.ɵɵpipeBindV(5, 51, i0.ɵɵpureFunction6(79, _c215, col_r40.cellStyles, ctx_r42.data[col_r40.field], ctx_r42.data, col_r40.field, ctx_r42.viewIndex, ctx_r42.grid.pipeTrigger)))(\"editMode\", col_r40.editable && ctx_r42.grid.crudService.targetInEdit(ctx_r42.index, col_r40.index))(\"column\", col_r40)(\"formatter\", col_r40.formatter)(\"intRow\", ctx_r42)(\"firstPinned\", col_r40.isFirstPinned)(\"lastPinned\", col_r40.isLastPinned)(\"rowData\", ctx_r42.data)(\"width\", col_r40.getCellWidth())(\"visibleColumnIndex\", col_r40.visibleIndex)(\"value\", i0.ɵɵpipeBindV(6, 58, i0.ɵɵpureFunction5(86, _c71, ctx_r42.data, col_r40.field, ctx_r42.grid.pipeTrigger, ctx_r42.data[col_r40.field], col_r40.hasNestedPath)))(\"cellTemplate\", col_r40.bodyTemplate)(\"lastSearchInfo\", ctx_r42.grid.lastSearchInfo)(\"active\", ctx_r42.isCellActive(col_r40.visibleIndex))(\"cellSelectionMode\", ctx_r42.grid.cellSelection)(\"displayPinnedChip\", ctx_r42.shouldDisplayPinnedChip(col_r40.visibleIndex));\n    i0.ɵɵattribute(\"aria-describedby\", i0.ɵɵpipeBind3(3, 40, ctx_r42.gridID + \"_\" + col_r40.field, \".\", \"_\"));\n  }\n}\n\nfunction IgxTreeGridRowComponent_ng_template_3_ng_template_9_ng_template_0_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-tree-grid-cell\", 21, 15);\n    i0.ɵɵpipe(2, \"transactionState\");\n    i0.ɵɵpipe(3, \"igxStringReplace\");\n    i0.ɵɵpipe(4, \"igxCellStyleClasses\");\n    i0.ɵɵpipe(5, \"igxCellStyles\");\n    i0.ɵɵpipe(6, \"dataMapper\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const col_r40 = i0.ɵɵnextContext().$implicit;\n    const ctx_r44 = i0.ɵɵnextContext(3);\n    i0.ɵɵstyleProp(\"min-height\", ctx_r44.cellHeight, \"px\")(\"min-width\", col_r40.width)(\"max-width\", col_r40.width)(\"flex-basis\", col_r40.width)(\"left\", col_r40.rightPinnedOffset);\n    i0.ɵɵclassProp(\"igx-grid__td--edited\", i0.ɵɵpipeBindV(2, 35, i0.ɵɵpureFunction7(67, _c214, ctx_r44.key, col_r40.field, ctx_r44.grid.rowEditable, ctx_r44.grid.transactions, ctx_r44.grid.pipeTrigger, ctx_r44.grid.gridAPI.crudService.cell, ctx_r44.grid.gridAPI.crudService.row)))(\"igx-grid__td--number\", (col_r40.dataType === \"number\" || col_r40.dataType === \"percent\" || col_r40.dataType === \"currency\") && col_r40.visibleIndex !== 0);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBindV(4, 47, i0.ɵɵpureFunction6(75, _c215, col_r40.cellClasses, ctx_r44.data[col_r40.field], ctx_r44.data, col_r40.field, ctx_r44.viewIndex, ctx_r44.grid.pipeTrigger)))(\"ngStyle\", i0.ɵɵpipeBindV(5, 54, i0.ɵɵpureFunction6(82, _c215, col_r40.cellStyles, ctx_r44.data[col_r40.field], ctx_r44.data, col_r40.field, ctx_r44.viewIndex, ctx_r44.grid.pipeTrigger)))(\"level\", ctx_r44.treeRow.level)(\"expanded\", ctx_r44.expanded)(\"showIndicator\", ctx_r44.showIndicator)(\"editMode\", col_r40.editable && ctx_r44.grid.crudService.targetInEdit(ctx_r44.index, col_r40.index))(\"column\", col_r40)(\"formatter\", col_r40.formatter)(\"intRow\", ctx_r44)(\"lastPinned\", col_r40.isLastPinned)(\"rowData\", ctx_r44.data)(\"width\", col_r40.getCellWidth())(\"visibleColumnIndex\", col_r40.visibleIndex)(\"value\", i0.ɵɵpipeBindV(6, 61, i0.ɵɵpureFunction5(89, _c71, ctx_r44.data, col_r40.field, ctx_r44.grid.pipeTrigger, ctx_r44.data[col_r40.field], col_r40.hasNestedPath)))(\"isLoading\", ctx_r44.isLoading)(\"cellTemplate\", col_r40.bodyTemplate)(\"lastSearchInfo\", ctx_r44.grid.lastSearchInfo)(\"active\", ctx_r44.isCellActive(col_r40.visibleIndex))(\"cellSelectionMode\", ctx_r44.grid.cellSelection)(\"displayPinnedChip\", ctx_r44.shouldDisplayPinnedChip(col_r40.visibleIndex));\n    i0.ɵɵattribute(\"aria-describedby\", i0.ɵɵpipeBind3(3, 43, ctx_r44.gridID + \"_\" + col_r40.field, \".\", \"_\"));\n  }\n}\n\nfunction IgxTreeGridRowComponent_ng_template_3_ng_template_9_ng_template_0_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxTreeGridRowComponent_ng_template_3_ng_template_9_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxTreeGridRowComponent_ng_template_3_ng_template_9_ng_template_0_ng_template_0_Template, 7, 92, \"ng-template\", null, 12, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵtemplate(2, IgxTreeGridRowComponent_ng_template_3_ng_template_9_ng_template_0_ng_template_2_Template, 7, 95, \"ng-template\", null, 13, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵtemplate(4, IgxTreeGridRowComponent_ng_template_3_ng_template_9_ng_template_0_ng_container_4_Template, 1, 0, \"ng-container\", 0);\n  }\n\n  if (rf & 2) {\n    const col_r40 = ctx.$implicit;\n\n    const _r41 = i0.ɵɵreference(1);\n\n    const _r43 = i0.ɵɵreference(3);\n\n    i0.ɵɵadvance(4);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", col_r40.visibleIndex === 0 ? _r43 : _r41);\n  }\n}\n\nfunction IgxTreeGridRowComponent_ng_template_3_ng_template_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxTreeGridRowComponent_ng_template_3_ng_template_9_ng_template_0_Template, 5, 1, \"ng-template\", 19);\n    i0.ɵɵpipe(1, \"igxNotGrouped\");\n  }\n\n  if (rf & 2) {\n    const ctx_r17 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBind1(1, 1, ctx_r17.pinnedColumns));\n  }\n}\n\nfunction IgxTreeGridRowComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxTreeGridRowComponent_ng_template_3_ng_container_0_Template, 3, 5, \"ng-container\", 4);\n    i0.ɵɵtemplate(1, IgxTreeGridRowComponent_ng_template_3_ng_container_1_Template, 3, 9, \"ng-container\", 4);\n    i0.ɵɵtemplate(2, IgxTreeGridRowComponent_ng_template_3_ng_container_2_Template, 2, 2, \"ng-container\", 4);\n    i0.ɵɵtemplate(3, IgxTreeGridRowComponent_ng_template_3_ng_template_3_Template, 5, 1, \"ng-template\", 5, 6, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵpipe(5, \"igxNotGrouped\");\n    i0.ɵɵtemplate(6, IgxTreeGridRowComponent_ng_template_3_ng_container_6_Template, 2, 2, \"ng-container\", 4);\n    i0.ɵɵtemplate(7, IgxTreeGridRowComponent_ng_template_3_ng_template_7_Template, 2, 8, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵtemplate(9, IgxTreeGridRowComponent_ng_template_3_ng_template_9_Template, 2, 3, \"ng-template\", null, 8, i0.ɵɵtemplateRefExtractor);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.rowDraggable);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.showRowSelectors);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.pinnedColumns.length > 0 && ctx_r4.grid.isPinningToStart);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"igxGridForOf\", i0.ɵɵpipeBind1(5, 10, ctx_r4.unpinnedColumns))(\"igxForScrollContainer\", ctx_r4.grid.parentVirtDir)(\"igxForScrollOrientation\", \"horizontal\")(\"igxForContainerSize\", ctx_r4.grid.unpinnedWidth)(\"igxForSizePropName\", \"calcPixelWidth\")(\"igxForTrackBy\", ctx_r4.grid.trackColumnChanges);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.pinnedColumns.length > 0 && !ctx_r4.grid.isPinningToStart);\n  }\n}\n\nfunction IgxTreeGridComponent_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 57);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"igxColumnMovingDrop\", ctx_r1.headerContainer);\n    i0.ɵɵattribute(\"droppable\", true);\n  }\n}\n\nfunction IgxTreeGridComponent_span_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 58);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"left\", ctx_r2.pinnedWidth, \"px\");\n    i0.ɵɵproperty(\"igxColumnMovingDrop\", ctx_r2.headerContainer);\n    i0.ɵɵattribute(\"droppable\", true);\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_8_ng_container_0_div_1_ng_container_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_8_ng_container_0_div_1_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxTreeGridComponent_ng_template_8_ng_container_0_div_1_ng_container_2_ng_container_1_Template, 1, 0, \"ng-container\", 63);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const rowData_r56 = ctx.$implicit;\n    const rowIndex_r57 = ctx.index;\n    const ctx_r55 = i0.ɵɵnextContext(4);\n\n    const _r11 = i0.ɵɵreference(27);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r11)(\"ngTemplateOutletContext\", ctx_r55.getContext(rowData_r56, rowIndex_r57, true));\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_8_ng_container_0_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 60, 61);\n    i0.ɵɵtemplate(2, IgxTreeGridComponent_ng_template_8_ng_container_0_div_1_ng_container_2_Template, 2, 2, \"ng-container\", 62);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const pinnedData_r52 = i0.ɵɵnextContext().ngIf;\n    const ctx_r53 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"width\", ctx_r53.calcWidth, \"px\");\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(4, _c220, !ctx_r53.isRowPinningToTop, ctx_r53.isRowPinningToTop));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", pinnedData_r52);\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_8_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxTreeGridComponent_ng_template_8_ng_container_0_div_1_Template, 3, 7, \"div\", 59);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const pinnedData_r52 = ctx.ngIf;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", pinnedData_r52.length > 0);\n  }\n}\n\nconst _c235 = function (a0, a1, a2, a3, a4, a5) {\n  return [a0, a1, a2, a3, a4, a5, true];\n};\n\nfunction IgxTreeGridComponent_ng_template_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxTreeGridComponent_ng_template_8_ng_container_0_Template, 2, 1, \"ng-container\", 43);\n    i0.ɵɵpipe(1, \"treeGridSorting\");\n    i0.ɵɵpipe(2, \"treeGridFiltering\");\n    i0.ɵɵpipe(3, \"gridRowPinning\");\n    i0.ɵɵpipe(4, \"treeGridAddRow\");\n    i0.ɵɵpipe(5, \"treeGridNormalizeRecord\");\n    i0.ɵɵpipe(6, \"visibleColumns\");\n    i0.ɵɵpipe(7, \"treeGridTransaction\");\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", i0.ɵɵpipeBindV(1, 1, i0.ɵɵpureFunction4(40, _c73, i0.ɵɵpipeBindV(2, 7, i0.ɵɵpureFunction6(33, _c235, i0.ɵɵpipeBind4(3, 15, i0.ɵɵpipeBind3(4, 20, i0.ɵɵpipeBind2(5, 24, i0.ɵɵpipeBind2(6, 27, i0.ɵɵpipeBind2(7, 30, ctx_r4.data, ctx_r4.pipeTrigger), ctx_r4.hasVisibleColumns), ctx_r4.pipeTrigger), true, ctx_r4.pipeTrigger), ctx_r4.id, true, ctx_r4.pipeTrigger), ctx_r4.filteringExpressionsTree, ctx_r4.filterStrategy, ctx_r4.advancedFilteringExpressionsTree, ctx_r4.pipeTrigger, ctx_r4.filteringPipeTrigger)), ctx_r4.sortingExpressions, ctx_r4.sortStrategy, ctx_r4.pipeTrigger)));\n  }\n}\n\nfunction IgxTreeGridComponent_ng_container_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_11_ng_template_0_Template(rf, ctx) {}\n\nfunction IgxTreeGridComponent_ng_template_11_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r64 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵtemplate(0, IgxTreeGridComponent_ng_template_11_ng_template_0_Template, 0, 0, \"ng-template\", 64);\n    i0.ɵɵlistener(\"cachedViewLoaded\", function IgxTreeGridComponent_ng_template_11_Template_ng_template_cachedViewLoaded_0_listener($event) {\n      i0.ɵɵrestoreView(_r64);\n      const ctx_r63 = i0.ɵɵnextContext();\n      return ctx_r63.cachedViewLoaded($event);\n    });\n  }\n\n  if (rf & 2) {\n    const rowData_r60 = ctx.$implicit;\n    const rowIndex_r61 = ctx.index;\n    const ctx_r7 = i0.ɵɵnextContext();\n\n    const _r13 = i0.ɵɵreference(29);\n\n    const _r9 = i0.ɵɵreference(25);\n\n    i0.ɵɵproperty(\"igxTemplateOutlet\", ctx_r7.isSummaryRow(rowData_r60) ? _r13 : _r9)(\"igxTemplateOutletContext\", ctx_r7.getContext(rowData_r60, rowIndex_r61, false));\n  }\n}\n\nfunction IgxTreeGridComponent_ng_container_23_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nconst _c236 = function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {\n  return [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11];\n};\n\nfunction IgxTreeGridComponent_ng_template_24_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-tree-grid-row\", 65, 66);\n    i0.ɵɵpipe(2, \"igxGridRowClasses\");\n    i0.ɵɵpipe(3, \"igxGridRowStyles\");\n  }\n\n  if (rf & 2) {\n    const rowIndex_r65 = ctx.index;\n    const disabledRow_r66 = ctx.disabled;\n    const rowData_r67 = ctx.$implicit;\n\n    const _r68 = i0.ɵɵreference(1);\n\n    const ctx_r10 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"gridID\", ctx_r10.id)(\"index\", rowIndex_r65)(\"treeRow\", rowData_r67)(\"disabled\", disabledRow_r66)(\"ngClass\", i0.ɵɵpipeBindV(2, 6, i0.ɵɵpureFunctionV(24, _c236, [ctx_r10.rowClasses, _r68, _r68.inEditMode, _r68.selected, _r68.dirty, _r68.deleted, _r68.dragging, rowIndex_r65, ctx_r10.hasColumnLayouts, _r68.treeRow.isFilteredOutParent, rowData_r67, ctx_r10.pipeTrigger])))(\"ngStyle\", i0.ɵɵpipeBind4(3, 19, ctx_r10.rowStyles, rowData_r67, rowIndex_r65, ctx_r10.pipeTrigger));\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_26_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-tree-grid-row\", 67, 68);\n    i0.ɵɵpipe(3, \"igxGridRowClasses\");\n    i0.ɵɵpipe(4, \"igxGridRowStyles\");\n  }\n\n  if (rf & 2) {\n    const rowIndex_r69 = ctx.index;\n    const rowData_r70 = ctx.$implicit;\n\n    const _r71 = i0.ɵɵreference(1);\n\n    const ctx_r12 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"gridID\", ctx_r12.id)(\"index\", rowIndex_r69)(\"treeRow\", rowData_r70)(\"ngClass\", i0.ɵɵpipeBindV(3, 5, i0.ɵɵpureFunctionV(23, _c236, [ctx_r12.rowClasses, _r71, _r71.inEditMode, _r71.selected, _r71.dirty, _r71.deleted, _r71.dragging, rowIndex_r69, ctx_r12.hasColumnLayouts, _r71.treeRow.isFilteredOutParent, rowData_r70, ctx_r12.pipeTrigger])))(\"ngStyle\", i0.ɵɵpipeBind4(4, 18, ctx_r12.rowStyles, rowData_r70, rowIndex_r69, ctx_r12.pipeTrigger));\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_28_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-grid-summary-row\", 69, 70);\n  }\n\n  if (rf & 2) {\n    const rowIndex_r73 = ctx.index;\n    const rowData_r74 = ctx.$implicit;\n    const ctx_r14 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"gridID\", ctx_r14.id)(\"summaries\", rowData_r74.summaries)(\"firstCellIndentation\", rowData_r74.cellIndentation)(\"index\", rowIndex_r73);\n  }\n}\n\nfunction IgxTreeGridComponent_ng_container_30_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxTreeGridComponent_igx_circular_bar_36_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-circular-bar\", 71);\n  }\n\n  if (rf & 2) {\n    i0.ɵɵproperty(\"indeterminate\", true);\n  }\n}\n\nfunction IgxTreeGridComponent_span_37_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 72);\n  }\n\n  if (rf & 2) {\n    const ctx_r19 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"igxColumnMovingDrop\", ctx_r19.headerContainer);\n    i0.ɵɵattribute(\"droppable\", true);\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_41_Template(rf, ctx) {}\n\nfunction IgxTreeGridComponent_igx_grid_summary_row_53_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-grid-summary-row\", 73, 70);\n    i0.ɵɵpipe(2, \"igxGridSummaryDataPipe\");\n  }\n\n  if (rf & 2) {\n    const ctx_r25 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"width\", ctx_r25.calcWidth, \"px\")(\"height\", ctx_r25.summaryRowHeight, \"px\");\n    i0.ɵɵproperty(\"gridID\", ctx_r25.id)(\"summaries\", i0.ɵɵpipeBind2(2, 7, ctx_r25.id, ctx_r25.summaryService.retriggerRootPipe))(\"index\", ctx_r25.dataView.length);\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_59_Template(rf, ctx) {}\n\nfunction IgxTreeGridComponent_ng_container_65_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵprojection(1, 3);\n    i0.ɵɵelementContainerEnd();\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_66_span_3_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_66_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtemplate(1, IgxTreeGridComponent_ng_template_66_span_3_ng_container_1_Template, 1, 0, \"ng-container\", 7);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r77 = i0.ɵɵnextContext(2);\n\n    const _r35 = i0.ɵɵreference(71);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r77.addRowEmptyTemplate || _r35);\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_66_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 74)(1, \"span\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, IgxTreeGridComponent_ng_template_66_span_3_Template, 2, 1, \"span\", 43);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r32 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r32.emptyFilteredGridMessage);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r32.showAddButton);\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_68_span_3_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_68_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtemplate(1, IgxTreeGridComponent_ng_template_68_span_3_ng_container_1_Template, 1, 0, \"ng-container\", 7);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r79 = i0.ɵɵnextContext(2);\n\n    const _r35 = i0.ɵɵreference(71);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r79.addRowEmptyTemplate || _r35);\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_68_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 74)(1, \"span\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, IgxTreeGridComponent_ng_template_68_span_3_Template, 2, 1, \"span\", 43);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r34 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r34.emptyGridMessage);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r34.showAddButton);\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_70_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r82 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 75);\n    i0.ɵɵlistener(\"click\", function IgxTreeGridComponent_ng_template_70_Template_button_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r82);\n      const ctx_r81 = i0.ɵɵnextContext();\n      return ctx_r81.crudService.enterAddRowMode(null, false, $event);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r36 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r36.resourceStrings.igx_grid_add_row_label, \" \");\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_72_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 76);\n    i0.ɵɵelement(1, \"igx-circular-bar\", 71);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"indeterminate\", true);\n  }\n}\n\nfunction IgxTreeGridComponent_div_74_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxTreeGridComponent_div_74_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 15, 77)(2, \"div\", 78);\n    i0.ɵɵtemplate(3, IgxTreeGridComponent_div_74_ng_container_3_Template, 1, 0, \"ng-container\", 63);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r39 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"className\", ctx_r39.bannerClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r39.rowEditContainer)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(3, _c226, ctx_r39.rowChangesCount, ctx_r39.crudService.endEdit.bind(ctx_r39)));\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_75_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const ctx_r41 = i0.ɵɵnextContext();\n    i0.ɵɵtextInterpolate1(\" You have \", ctx_r41.rowChangesCount, \" changes in this row\\n\");\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_77_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r86 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 79);\n    i0.ɵɵlistener(\"click\", function IgxTreeGridComponent_ng_template_77_Template_button_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r86);\n      const ctx_r85 = i0.ɵɵnextContext();\n      return ctx_r85.endRowEditTabStop(false, $event);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"button\", 79);\n    i0.ɵɵlistener(\"click\", function IgxTreeGridComponent_ng_template_77_Template_button_click_2_listener($event) {\n      i0.ɵɵrestoreView(_r86);\n      const ctx_r87 = i0.ɵɵnextContext();\n      return ctx_r87.endRowEditTabStop(true, $event);\n    });\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r43 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r43.resourceStrings.igx_grid_row_edit_btn_cancel);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r43.resourceStrings.igx_grid_row_edit_btn_done);\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_79_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_79_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_79_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 80)(1, \"span\", 81);\n    i0.ɵɵtemplate(2, IgxTreeGridComponent_ng_template_79_ng_container_2_Template, 1, 0, \"ng-container\", 63);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(3, \"div\", 82)(4, \"div\", 83);\n    i0.ɵɵtemplate(5, IgxTreeGridComponent_ng_template_79_ng_container_5_Template, 1, 0, \"ng-container\", 63);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r45 = i0.ɵɵnextContext();\n\n    const _r40 = i0.ɵɵreference(76);\n\n    const _r42 = i0.ɵɵreference(78);\n\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", (ctx_r45.crudService.row == null ? null : ctx_r45.crudService.row.getClassName()) === \"IgxAddRow\" ? ctx_r45.rowAddText : ctx_r45.rowEditText ? ctx_r45.rowEditText : _r40)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(4, _c24, (ctx_r45.crudService.row == null ? null : ctx_r45.crudService.row.getClassName()) !== \"IgxAddRow\" ? ctx_r45.rowChangesCount : null));\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r45.rowEditActions ? ctx_r45.rowEditActions : _r42)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(6, _c24, ctx_r45.endEdit.bind(ctx_r45)));\n  }\n}\n\nfunction IgxTreeGridComponent_ng_template_81_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1, \"drag_indicator\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxTreeGridComponent_igx_grid_column_resizer_83_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-grid-column-resizer\");\n  }\n}\n\nconst _c237 = [[[\"igx-grid-toolbar\"]], [[\"igx-tree-grid-group-by-area\"]], [[\"igx-grid-footer\"]], [[\"igx-paginator\"]]];\nconst _c238 = [\"igx-grid-toolbar\", \"igx-tree-grid-group-by-area\", \"igx-grid-footer\", \"igx-paginator\"];\n\nfunction IgxHierarchicalGridCellComponent_ng_template_0_igx_chip_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-chip\", 6);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r10 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"disabled\", true)(\"displayDensity\", \"compact\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r10.grid.resourceStrings.igx_grid_pinned_row_indicator);\n  }\n}\n\nfunction IgxHierarchicalGridCellComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxHierarchicalGridCellComponent_ng_template_0_igx_chip_0_Template, 2, 3, \"igx-chip\", 5);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.displayPinnedChip);\n  }\n}\n\nfunction IgxHierarchicalGridCellComponent_ng_template_2_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 9);\n    i0.ɵɵpipe(1, \"columnFormatter\");\n    i0.ɵɵpipe(2, \"number\");\n    i0.ɵɵpipe(3, \"date\");\n    i0.ɵɵpipe(4, \"currency\");\n    i0.ɵɵpipe(5, \"percent\");\n    i0.ɵɵtext(6);\n    i0.ɵɵpipe(7, \"columnFormatter\");\n    i0.ɵɵpipe(8, \"number\");\n    i0.ɵɵpipe(9, \"date\");\n    i0.ɵɵpipe(10, \"currency\");\n    i0.ɵɵpipe(11, \"percent\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"cssClass\", ctx_r11.highlightClass)(\"activeCssClass\", ctx_r11.activeHighlightClass)(\"groupName\", ctx_r11.gridID)(\"value\", ctx_r11.formatter ? i0.ɵɵpipeBind3(1, 9, ctx_r11.value, ctx_r11.formatter, ctx_r11.rowData) : ctx_r11.column.dataType === \"number\" ? i0.ɵɵpipeBind3(2, 13, ctx_r11.value, ctx_r11.column.pipeArgs.digitsInfo, ctx_r11.grid.locale) : ctx_r11.column.dataType === \"date\" || ctx_r11.column.dataType === \"time\" || ctx_r11.column.dataType === \"dateTime\" ? i0.ɵɵpipeBind4(3, 17, ctx_r11.value, ctx_r11.column.pipeArgs.format, ctx_r11.column.pipeArgs.timezone, ctx_r11.grid.locale) : ctx_r11.column.dataType === \"currency\" ? i0.ɵɵpipeBindV(4, 22, i0.ɵɵpureFunction5(55, _c71, ctx_r11.value, ctx_r11.currencyCode, ctx_r11.column.pipeArgs.display, ctx_r11.column.pipeArgs.digitsInfo, ctx_r11.grid.locale)) : ctx_r11.column.dataType === \"percent\" ? i0.ɵɵpipeBind3(5, 28, ctx_r11.value, ctx_r11.column.pipeArgs.digitsInfo, ctx_r11.grid.locale) : ctx_r11.value)(\"row\", ctx_r11.rowData)(\"column\", ctx_r11.column.field)(\"containerClass\", \"igx-grid__td-text\")(\"metadata\", ctx_r11.searchMetadata);\n    i0.ɵɵadvance(6);\n    i0.ɵɵtextInterpolate(ctx_r11.formatter ? i0.ɵɵpipeBind3(7, 32, ctx_r11.value, ctx_r11.formatter, ctx_r11.rowData) : ctx_r11.column.dataType === \"number\" ? i0.ɵɵpipeBind3(8, 36, ctx_r11.value, ctx_r11.column.pipeArgs.digitsInfo, ctx_r11.grid.locale) : ctx_r11.column.dataType === \"date\" || ctx_r11.column.dataType === \"time\" || ctx_r11.column.dataType === \"dateTime\" ? i0.ɵɵpipeBind4(9, 40, ctx_r11.value, ctx_r11.column.pipeArgs.format, ctx_r11.column.pipeArgs.timezone, ctx_r11.grid.locale) : ctx_r11.column.dataType === \"currency\" ? i0.ɵɵpipeBindV(10, 45, i0.ɵɵpureFunction5(61, _c71, ctx_r11.value, ctx_r11.currencyCode, ctx_r11.column.pipeArgs.display, ctx_r11.column.pipeArgs.digitsInfo, ctx_r11.grid.locale)) : ctx_r11.column.dataType === \"percent\" ? i0.ɵɵpipeBind3(11, 51, ctx_r11.value, ctx_r11.column.pipeArgs.digitsInfo, ctx_r11.grid.locale) : ctx_r11.value);\n  }\n}\n\nfunction IgxHierarchicalGridCellComponent_ng_template_2_igx_icon_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\", 10);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(2, _c210, ctx_r12.value, !ctx_r12.value));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r12.value ? \"check\" : \"close\");\n  }\n}\n\nfunction IgxHierarchicalGridCellComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxHierarchicalGridCellComponent_ng_template_2_div_0_Template, 12, 67, \"div\", 7);\n    i0.ɵɵtemplate(1, IgxHierarchicalGridCellComponent_ng_template_2_igx_icon_1_Template, 2, 5, \"igx-icon\", 8);\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.column.dataType !== \"boolean\" || ctx_r3.column.dataType === \"boolean\" && ctx_r3.formatter);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.column.dataType === \"boolean\" && !ctx_r3.formatter);\n  }\n}\n\nfunction IgxHierarchicalGridCellComponent_ng_template_4_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 9);\n    i0.ɵɵpipe(1, \"columnFormatter\");\n    i0.ɵɵpipe(2, \"number\");\n    i0.ɵɵpipe(3, \"date\");\n    i0.ɵɵpipe(4, \"currency\");\n    i0.ɵɵpipe(5, \"percent\");\n    i0.ɵɵtext(6);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r14 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"cssClass\", ctx_r14.highlightClass)(\"activeCssClass\", ctx_r14.activeHighlightClass)(\"groupName\", ctx_r14.gridID)(\"value\", ctx_r14.formatter ? i0.ɵɵpipeBind3(1, 9, ctx_r14.value, ctx_r14.formatter, ctx_r14.rowData) : ctx_r14.column.dataType === \"number\" ? i0.ɵɵpipeBind3(2, 13, ctx_r14.value, ctx_r14.column.pipeArgs.digitsInfo, ctx_r14.grid.locale) : ctx_r14.column.dataType === \"date\" || ctx_r14.column.dataType === \"time\" || ctx_r14.column.dataType === \"dateTime\" ? i0.ɵɵpipeBind4(3, 17, ctx_r14.value, ctx_r14.column.pipeArgs.format, ctx_r14.column.pipeArgs.timezone, ctx_r14.grid.locale) : ctx_r14.column.dataType === \"currency\" ? i0.ɵɵpipeBindV(4, 22, i0.ɵɵpureFunction5(32, _c71, ctx_r14.value, ctx_r14.currencyCode, ctx_r14.column.pipeArgs.display, ctx_r14.column.pipeArgs.digitsInfo, ctx_r14.grid.locale)) : ctx_r14.column.dataType === \"percent\" ? i0.ɵɵpipeBind3(5, 28, ctx_r14.value, ctx_r14.column.pipeArgs.digitsInfo, ctx_r14.grid.locale) : ctx_r14.value)(\"row\", ctx_r14.rowData)(\"column\", ctx_r14.column.field)(\"containerClass\", \"igx-grid__td-text\")(\"metadata\", ctx_r14.searchMetadata);\n    i0.ɵɵadvance(6);\n    i0.ɵɵtextInterpolate(!ctx_r14.isEmptyAddRowCell ? ctx_r14.value : ctx_r14.column.header || ctx_r14.column.field);\n  }\n}\n\nfunction IgxHierarchicalGridCellComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxHierarchicalGridCellComponent_ng_template_4_div_0_Template, 7, 38, \"div\", 11);\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.column.dataType !== \"boolean\" || ctx_r5.column.dataType === \"boolean\" && ctx_r5.formatter);\n  }\n}\n\nfunction IgxHierarchicalGridCellComponent_ng_template_6_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r25 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-input-group\", 13)(2, \"input\", 14);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxHierarchicalGridCellComponent_ng_template_6_ng_container_0_Template_input_ngModelChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r25);\n      const ctx_r24 = i0.ɵɵnextContext(2);\n      return ctx_r24.editValue = $event;\n    });\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngModel\", ctx_r16.editValue)(\"igxFocus\", true);\n  }\n}\n\nfunction IgxHierarchicalGridCellComponent_ng_template_6_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r27 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-input-group\", 13)(2, \"input\", 15);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxHierarchicalGridCellComponent_ng_template_6_ng_container_1_Template_input_ngModelChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r27);\n      const ctx_r26 = i0.ɵɵnextContext(2);\n      return ctx_r26.editValue = $event;\n    });\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r17 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngModel\", ctx_r17.editValue)(\"igxFocus\", true)(\"step\", ctx_r17.step);\n  }\n}\n\nfunction IgxHierarchicalGridCellComponent_ng_template_6_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r29 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-checkbox\", 16);\n    i0.ɵɵlistener(\"change\", function IgxHierarchicalGridCellComponent_ng_template_6_ng_container_2_Template_igx_checkbox_change_1_listener($event) {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r28 = i0.ɵɵnextContext(2);\n      return ctx_r28.editValue = $event.checked;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r18 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"checked\", ctx_r18.editValue)(\"igxFocus\", true)(\"disableRipple\", true);\n  }\n}\n\nfunction IgxHierarchicalGridCellComponent_ng_template_6_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r31 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-date-picker\", 17);\n    i0.ɵɵlistener(\"valueChange\", function IgxHierarchicalGridCellComponent_ng_template_6_ng_container_3_Template_igx_date_picker_valueChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r31);\n      const ctx_r30 = i0.ɵɵnextContext(2);\n      return ctx_r30.editValue = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r19 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"width\", 100, \"%\");\n    i0.ɵɵproperty(\"outlet\", ctx_r19.grid.outlet)(\"locale\", ctx_r19.grid.locale)(\"value\", ctx_r19.editValue)(\"igxFocus\", true);\n  }\n}\n\nfunction IgxHierarchicalGridCellComponent_ng_template_6_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r33 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-time-picker\", 18);\n    i0.ɵɵlistener(\"valueChange\", function IgxHierarchicalGridCellComponent_ng_template_6_ng_container_4_Template_igx_time_picker_valueChange_1_listener($event) {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r32 = i0.ɵɵnextContext(2);\n      return ctx_r32.editValue = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r20 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"width\", 100, \"%\");\n    i0.ɵɵproperty(\"outlet\", ctx_r20.grid.outlet)(\"locale\", ctx_r20.grid.locale)(\"inputFormat\", ctx_r20.column.defaultTimeFormat)(\"value\", ctx_r20.editValue)(\"igxFocus\", true);\n  }\n}\n\nfunction IgxHierarchicalGridCellComponent_ng_template_6_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r35 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-input-group\")(2, \"input\", 19);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxHierarchicalGridCellComponent_ng_template_6_ng_container_5_Template_input_ngModelChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r35);\n      const ctx_r34 = i0.ɵɵnextContext(2);\n      return ctx_r34.editValue = $event;\n    });\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r21 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"igxDateTimeEditor\", ctx_r21.column.defaultDateTimeFormat)(\"ngModel\", ctx_r21.editValue)(\"igxFocus\", true);\n  }\n}\n\nfunction IgxHierarchicalGridCellComponent_ng_template_6_ng_container_6_igx_prefix_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-prefix\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r36 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r36.currencyCodeSymbol);\n  }\n}\n\nfunction IgxHierarchicalGridCellComponent_ng_template_6_ng_container_6_igx_suffix_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-suffix\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r37 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r37.currencyCodeSymbol);\n  }\n}\n\nfunction IgxHierarchicalGridCellComponent_ng_template_6_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r39 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-input-group\", 13);\n    i0.ɵɵtemplate(2, IgxHierarchicalGridCellComponent_ng_template_6_ng_container_6_igx_prefix_2_Template, 2, 1, \"igx-prefix\", 12);\n    i0.ɵɵelementStart(3, \"input\", 15);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxHierarchicalGridCellComponent_ng_template_6_ng_container_6_Template_input_ngModelChange_3_listener($event) {\n      i0.ɵɵrestoreView(_r39);\n      const ctx_r38 = i0.ɵɵnextContext(2);\n      return ctx_r38.editValue = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(4, IgxHierarchicalGridCellComponent_ng_template_6_ng_container_6_igx_suffix_4_Template, 2, 1, \"igx-suffix\", 12);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r22 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r22.grid.currencyPositionLeft);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngModel\", ctx_r22.editValue)(\"igxFocus\", true)(\"step\", ctx_r22.step);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r22.grid.currencyPositionLeft);\n  }\n}\n\nfunction IgxHierarchicalGridCellComponent_ng_template_6_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r41 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-input-group\", 13)(2, \"input\", 15);\n    i0.ɵɵlistener(\"ngModelChange\", function IgxHierarchicalGridCellComponent_ng_template_6_ng_container_7_Template_input_ngModelChange_2_listener($event) {\n      i0.ɵɵrestoreView(_r41);\n      const ctx_r40 = i0.ɵɵnextContext(2);\n      return ctx_r40.editValue = $event;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"igx-suffix\");\n    i0.ɵɵtext(4);\n    i0.ɵɵpipe(5, \"percent\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r23 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngModel\", ctx_r23.editValue)(\"igxFocus\", true)(\"step\", ctx_r23.step);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", i0.ɵɵpipeBind3(5, 4, ctx_r23.editValue, ctx_r23.column.pipeArgs.digitsInfo, ctx_r23.grid.locale), \" \");\n  }\n}\n\nfunction IgxHierarchicalGridCellComponent_ng_template_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxHierarchicalGridCellComponent_ng_template_6_ng_container_0_Template, 3, 2, \"ng-container\", 12);\n    i0.ɵɵtemplate(1, IgxHierarchicalGridCellComponent_ng_template_6_ng_container_1_Template, 3, 3, \"ng-container\", 12);\n    i0.ɵɵtemplate(2, IgxHierarchicalGridCellComponent_ng_template_6_ng_container_2_Template, 2, 3, \"ng-container\", 12);\n    i0.ɵɵtemplate(3, IgxHierarchicalGridCellComponent_ng_template_6_ng_container_3_Template, 2, 6, \"ng-container\", 12);\n    i0.ɵɵtemplate(4, IgxHierarchicalGridCellComponent_ng_template_6_ng_container_4_Template, 2, 7, \"ng-container\", 12);\n    i0.ɵɵtemplate(5, IgxHierarchicalGridCellComponent_ng_template_6_ng_container_5_Template, 3, 3, \"ng-container\", 12);\n    i0.ɵɵtemplate(6, IgxHierarchicalGridCellComponent_ng_template_6_ng_container_6_Template, 5, 5, \"ng-container\", 12);\n    i0.ɵɵtemplate(7, IgxHierarchicalGridCellComponent_ng_template_6_ng_container_7_Template, 6, 8, \"ng-container\", 12);\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"string\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"number\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"boolean\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"date\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"time\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"dateTime\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"currency\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.dataType === \"percent\");\n  }\n}\n\nfunction IgxHierarchicalGridCellComponent_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxHierarchicalGridCellComponent_ng_container_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nconst _c239 = [\"expander\"];\nconst _c240 = [\"defaultEmptyTemplate\"];\n\nfunction IgxHierarchicalRowComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxHierarchicalRowComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\", 6);\n    i0.ɵɵtext(1, \"expand_more\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"active\", !ctx_r2.added);\n  }\n}\n\nfunction IgxHierarchicalRowComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\", 6);\n    i0.ɵɵtext(1, \"chevron_right\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"active\", !ctx_r4.added);\n  }\n}\n\nfunction IgxHierarchicalRowComponent_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-icon\");\n  }\n}\n\nfunction IgxHierarchicalRowComponent_ng_template_7_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxHierarchicalRowComponent_ng_template_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 7);\n    i0.ɵɵlistener(\"animationend\", function IgxHierarchicalRowComponent_ng_template_7_Template_div_animationend_0_listener() {\n      i0.ɵɵrestoreView(_r13);\n      const ctx_r12 = i0.ɵɵnextContext();\n      return ctx_r12.animationEndHandler();\n    });\n    i0.ɵɵtemplate(1, IgxHierarchicalRowComponent_ng_template_7_ng_container_1_Template, 1, 0, \"ng-container\", 0);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext();\n\n    const _r9 = i0.ɵɵreference(10);\n\n    i0.ɵɵclassProp(\"igx-grid__tr--add-animate\", ctx_r8.triggerAddAnimationClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r9);\n  }\n}\n\nfunction IgxHierarchicalRowComponent_ng_template_9_ng_container_0_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxHierarchicalRowComponent_ng_template_9_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 14);\n    i0.ɵɵlistener(\"click\", function IgxHierarchicalRowComponent_ng_template_9_ng_container_0_Template_div_click_1_listener($event) {\n      return $event.stopPropagation();\n    })(\"pointerdown\", function IgxHierarchicalRowComponent_ng_template_9_ng_container_0_Template_div_pointerdown_1_listener($event) {\n      return $event.preventDefault();\n    });\n    i0.ɵɵtemplate(2, IgxHierarchicalRowComponent_ng_template_9_ng_container_0_ng_container_2_Template, 1, 0, \"ng-container\", 0);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r14 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassMap(ctx_r14.resolveDragIndicatorClasses);\n    i0.ɵɵproperty(\"igxRowDrag\", ctx_r14)(\"ghostTemplate\", ctx_r14.grid.getDragGhostCustomTemplate());\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r14.grid.dragIndicatorIconTemplate ? ctx_r14.grid.dragIndicatorIconTemplate : ctx_r14.grid.dragIndicatorIconBase);\n  }\n}\n\nfunction IgxHierarchicalRowComponent_ng_template_9_ng_container_1_2_ng_template_0_Template(rf, ctx) {}\n\nfunction IgxHierarchicalRowComponent_ng_template_9_ng_container_1_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxHierarchicalRowComponent_ng_template_9_ng_container_1_2_ng_template_0_Template, 0, 0, \"ng-template\");\n  }\n}\n\nconst _c241 = function (a0, a1, a2, a3, a4, a5) {\n  return {\n    index: a0,\n    rowID: a1,\n    key: a2,\n    selected: a3,\n    select: a4,\n    deselect: a5\n  };\n};\n\nfunction IgxHierarchicalRowComponent_ng_template_9_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r31 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 15);\n    i0.ɵɵlistener(\"click\", function IgxHierarchicalRowComponent_ng_template_9_ng_container_1_Template_div_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r31);\n      const ctx_r30 = i0.ɵɵnextContext(2);\n      return ctx_r30.onRowSelectorClick($event);\n    })(\"pointerdown\", function IgxHierarchicalRowComponent_ng_template_9_ng_container_1_Template_div_pointerdown_1_listener($event) {\n      return $event.preventDefault();\n    });\n    i0.ɵɵtemplate(2, IgxHierarchicalRowComponent_ng_template_9_ng_container_1_2_Template, 1, 0, null, 16);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r21 = i0.ɵɵreference(9);\n\n    const ctx_r15 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r15.grid.rowSelectorTemplate ? ctx_r15.grid.rowSelectorTemplate : _r21)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(9, _c24, i0.ɵɵpureFunction6(2, _c241, ctx_r15.viewIndex, ctx_r15.key, ctx_r15.key, ctx_r15.selected, ctx_r15.select, ctx_r15.deselect)));\n  }\n}\n\nfunction IgxHierarchicalRowComponent_ng_template_9_div_2_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxHierarchicalRowComponent_ng_template_9_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r36 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 17, 18);\n    i0.ɵɵlistener(\"click\", function IgxHierarchicalRowComponent_ng_template_9_div_2_Template_div_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r36);\n      const ctx_r35 = i0.ɵɵnextContext(2);\n      return ctx_r35.expanderClick($event);\n    })(\"mousedown\", function IgxHierarchicalRowComponent_ng_template_9_div_2_Template_div_mousedown_0_listener($event) {\n      return $event.preventDefault();\n    });\n    i0.ɵɵtemplate(2, IgxHierarchicalRowComponent_ng_template_9_div_2_ng_container_2_Template, 1, 0, \"ng-container\", 16);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngClass\", ctx_r16.expanderClassResolved);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r16.iconTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(3, _c24, ctx_r16));\n  }\n}\n\nfunction IgxHierarchicalRowComponent_ng_template_9_ng_container_3_1_ng_template_0_Template(rf, ctx) {}\n\nfunction IgxHierarchicalRowComponent_ng_template_9_ng_container_3_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxHierarchicalRowComponent_ng_template_9_ng_container_3_1_ng_template_0_Template, 0, 0, \"ng-template\");\n  }\n}\n\nfunction IgxHierarchicalRowComponent_ng_template_9_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxHierarchicalRowComponent_ng_template_9_ng_container_3_1_Template, 1, 0, null, 16);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r23 = i0.ɵɵreference(11);\n\n    const ctx_r17 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r23)(\"ngTemplateOutletContext\", ctx_r17);\n  }\n}\n\nfunction IgxHierarchicalRowComponent_ng_template_9_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-hierarchical-grid-cell\", 19);\n    i0.ɵɵpipe(1, \"transactionState\");\n    i0.ɵɵpipe(2, \"igxStringReplace\");\n    i0.ɵɵpipe(3, \"igxCellStyleClasses\");\n    i0.ɵɵpipe(4, \"igxCellStyles\");\n    i0.ɵɵpipe(5, \"dataMapper\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const col_r40 = ctx.$implicit;\n    const ctx_r19 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"min-height\", ctx_r19.cellHeight, \"px\")(\"min-width\", col_r40.width)(\"max-width\", col_r40.width)(\"flex-basis\", col_r40.width);\n    i0.ɵɵclassProp(\"igx-grid__td--edited\", i0.ɵɵpipeBindV(1, 30, i0.ɵɵpureFunction7(62, _c214, ctx_r19.key, col_r40.field, ctx_r19.grid.rowEditable, ctx_r19.grid.transactions, ctx_r19.grid.pipeTrigger, ctx_r19.grid.gridAPI.crudService.cell, ctx_r19.grid.gridAPI.crudService.row)))(\"igx-grid__td--number\", col_r40.dataType === \"number\" || col_r40.dataType === \"percent\" || col_r40.dataType === \"currency\")(\"igx-grid__td--bool\", col_r40.dataType === \"boolean\");\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBindV(3, 42, i0.ɵɵpureFunction6(70, _c215, col_r40.cellClasses, ctx_r19.data[col_r40.field], ctx_r19.data, col_r40.field, ctx_r19.viewIndex, ctx_r19.grid.pipeTrigger)))(\"ngStyle\", i0.ɵɵpipeBindV(4, 49, i0.ɵɵpureFunction6(77, _c215, col_r40.cellStyles, ctx_r19.data[col_r40.field], ctx_r19.data, col_r40.field, ctx_r19.viewIndex, ctx_r19.grid.pipeTrigger)))(\"editMode\", col_r40.editable && ctx_r19.grid.crudService.targetInEdit(ctx_r19.index, col_r40.index))(\"column\", col_r40)(\"formatter\", col_r40.formatter)(\"intRow\", ctx_r19)(\"active\", ctx_r19.isCellActive(col_r40.visibleIndex))(\"rowData\", ctx_r19.data)(\"width\", col_r40.getCellWidth())(\"visibleColumnIndex\", col_r40.visibleIndex)(\"value\", i0.ɵɵpipeBindV(5, 56, i0.ɵɵpureFunction5(84, _c71, ctx_r19.data, col_r40.field, ctx_r19.grid.pipeTrigger, ctx_r19.data[col_r40.field], col_r40.hasNestedPath)))(\"cellTemplate\", col_r40.bodyTemplate)(\"lastSearchInfo\", ctx_r19.grid.lastSearchInfo)(\"cellSelectionMode\", ctx_r19.grid.cellSelection)(\"displayPinnedChip\", ctx_r19.shouldDisplayPinnedChip(col_r40.visibleIndex));\n    i0.ɵɵattribute(\"aria-describedby\", i0.ɵɵpipeBind3(2, 38, ctx_r19.gridID + \"_\" + col_r40.field, \".\", \"_\"));\n  }\n}\n\nfunction IgxHierarchicalRowComponent_ng_template_9_ng_container_7_1_ng_template_0_Template(rf, ctx) {}\n\nfunction IgxHierarchicalRowComponent_ng_template_9_ng_container_7_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxHierarchicalRowComponent_ng_template_9_ng_container_7_1_ng_template_0_Template, 0, 0, \"ng-template\");\n  }\n}\n\nfunction IgxHierarchicalRowComponent_ng_template_9_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxHierarchicalRowComponent_ng_template_9_ng_container_7_1_Template, 1, 0, null, 16);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r23 = i0.ɵɵreference(11);\n\n    const ctx_r20 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r23)(\"ngTemplateOutletContext\", ctx_r20);\n  }\n}\n\nfunction IgxHierarchicalRowComponent_ng_template_9_ng_template_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 20);\n    i0.ɵɵelement(1, \"igx-checkbox\", 21);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r22 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"tabindex\", -1)(\"readonly\", true)(\"checked\", ctx_r22.selected)(\"disableRipple\", true)(\"disabled\", ctx_r22.deleted)(\"disableTransitions\", ctx_r22.grid.disableTransitions)(\"aria-label\", ctx_r22.rowCheckboxAriaLabel);\n  }\n}\n\nfunction IgxHierarchicalRowComponent_ng_template_9_ng_template_10_igx_hierarchical_grid_cell_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-hierarchical-grid-cell\", 23);\n    i0.ɵɵpipe(1, \"transactionState\");\n    i0.ɵɵpipe(2, \"igxStringReplace\");\n    i0.ɵɵpipe(3, \"igxCellStyleClasses\");\n    i0.ɵɵpipe(4, \"igxCellStyles\");\n    i0.ɵɵpipe(5, \"dataMapper\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const col_r46 = ctx.$implicit;\n    const ctx_r45 = i0.ɵɵnextContext(3);\n    i0.ɵɵstyleProp(\"min-height\", ctx_r45.cellHeight, \"px\")(\"min-width\", col_r46.width)(\"max-width\", col_r46.width)(\"flex-basis\", col_r46.width)(\"left\", col_r46.rightPinnedOffset);\n    i0.ɵɵclassProp(\"igx-grid__td--edited\", i0.ɵɵpipeBindV(1, 32, i0.ɵɵpureFunction7(64, _c214, ctx_r45.key, col_r46.field, ctx_r45.grid.rowEditable, ctx_r45.grid.transactions, ctx_r45.grid.pipeTrigger, ctx_r45.grid.gridAPI.crudService.cell, ctx_r45.grid.gridAPI.crudService.row)))(\"igx-grid__td--number\", col_r46.dataType === \"number\" || col_r46.dataType === \"percent\" || col_r46.dataType === \"currency\");\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBindV(3, 44, i0.ɵɵpureFunction6(72, _c215, col_r46.cellClasses, ctx_r45.data[col_r46.field], ctx_r45.data, col_r46.field, ctx_r45.viewIndex, ctx_r45.grid.pipeTrigger)))(\"ngStyle\", i0.ɵɵpipeBindV(4, 51, i0.ɵɵpureFunction6(79, _c215, col_r46.cellStyles, ctx_r45.data[col_r46.field], ctx_r45.data, col_r46.field, ctx_r45.viewIndex, ctx_r45.grid.pipeTrigger)))(\"editMode\", col_r46.editable && ctx_r45.grid.crudService.targetInEdit(ctx_r45.index, col_r46.index))(\"column\", col_r46)(\"formatter\", col_r46.formatter)(\"intRow\", ctx_r45)(\"active\", ctx_r45.isCellActive(col_r46.visibleIndex))(\"firstPinned\", col_r46.isFirstPinned)(\"lastPinned\", col_r46.isLastPinned)(\"rowData\", ctx_r45.data)(\"width\", col_r46.getCellWidth())(\"visibleColumnIndex\", col_r46.visibleIndex)(\"value\", i0.ɵɵpipeBindV(5, 58, i0.ɵɵpureFunction5(86, _c71, ctx_r45.data, col_r46.field, ctx_r45.grid.pipeTrigger, ctx_r45.data[col_r46.field], col_r46.hasNestedPath)))(\"cellTemplate\", col_r46.bodyTemplate)(\"lastSearchInfo\", ctx_r45.grid.lastSearchInfo)(\"cellSelectionMode\", ctx_r45.grid.cellSelection)(\"displayPinnedChip\", ctx_r45.shouldDisplayPinnedChip(col_r46.visibleIndex));\n    i0.ɵɵattribute(\"aria-describedby\", i0.ɵɵpipeBind3(2, 40, ctx_r45.gridID + \"_\" + col_r46.field, \".\", \"_\"));\n  }\n}\n\nfunction IgxHierarchicalRowComponent_ng_template_9_ng_template_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxHierarchicalRowComponent_ng_template_9_ng_template_10_igx_hierarchical_grid_cell_0_Template, 6, 92, \"igx-hierarchical-grid-cell\", 22);\n    i0.ɵɵpipe(1, \"igxNotGrouped\");\n  }\n\n  if (rf & 2) {\n    const ctx_r24 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBind1(1, 1, ctx_r24.pinnedColumns));\n  }\n}\n\nfunction IgxHierarchicalRowComponent_ng_template_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxHierarchicalRowComponent_ng_template_9_ng_container_0_Template, 3, 5, \"ng-container\", 8);\n    i0.ɵɵtemplate(1, IgxHierarchicalRowComponent_ng_template_9_ng_container_1_Template, 3, 11, \"ng-container\", 8);\n    i0.ɵɵtemplate(2, IgxHierarchicalRowComponent_ng_template_9_div_2_Template, 3, 5, \"div\", 9);\n    i0.ɵɵtemplate(3, IgxHierarchicalRowComponent_ng_template_9_ng_container_3_Template, 2, 2, \"ng-container\", 8);\n    i0.ɵɵtemplate(4, IgxHierarchicalRowComponent_ng_template_9_ng_template_4_Template, 6, 90, \"ng-template\", 10, 11, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵpipe(6, \"igxNotGrouped\");\n    i0.ɵɵtemplate(7, IgxHierarchicalRowComponent_ng_template_9_ng_container_7_Template, 2, 2, \"ng-container\", 8);\n    i0.ɵɵtemplate(8, IgxHierarchicalRowComponent_ng_template_9_ng_template_8_Template, 2, 7, \"ng-template\", null, 12, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵtemplate(10, IgxHierarchicalRowComponent_ng_template_9_ng_template_10_Template, 2, 3, \"ng-template\", null, 13, i0.ɵɵtemplateRefExtractor);\n  }\n\n  if (rf & 2) {\n    const ctx_r10 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r10.rowDraggable);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r10.showRowSelectors);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r10.hasChildren);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r10.pinnedColumns.length > 0 && ctx_r10.grid.isPinningToStart);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"igxGridForOf\", i0.ɵɵpipeBind1(6, 11, ctx_r10.unpinnedColumns))(\"igxForScrollContainer\", ctx_r10.grid.parentVirtDir)(\"igxForSizePropName\", \"calcPixelWidth\")(\"igxForScrollOrientation\", \"horizontal\")(\"igxForContainerSize\", ctx_r10.grid.unpinnedWidth)(\"igxForTrackBy\", ctx_r10.grid.trackColumnChanges);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", ctx_r10.pinnedColumns.length > 0 && !ctx_r10.grid.isPinningToStart);\n  }\n}\n\nconst _c242 = [\"hgrid\"];\n\nconst _c243 = function (a0) {\n  return {\n    \"igx-grid__hierarchical-indent--scroll\": a0\n  };\n};\n\nconst _c244 = [\"toolbarOutlet\"];\nconst _c245 = [\"paginatorOutlet\"];\nconst _c246 = [\"hierarchical_record_template\"];\nconst _c247 = [\"child_record_template\"];\n\nfunction IgxHierarchicalGridComponent_span_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 61);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"igxColumnMovingDrop\", ctx_r2.headerContainer);\n    i0.ɵɵattribute(\"droppable\", true);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_span_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 62);\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"left\", ctx_r3.pinnedWidth, \"px\");\n    i0.ɵɵproperty(\"igxColumnMovingDrop\", ctx_r3.headerContainer);\n    i0.ɵɵattribute(\"droppable\", true);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_9_ng_container_0_div_1_ng_container_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_9_ng_container_0_div_1_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxHierarchicalGridComponent_ng_template_9_ng_container_0_div_1_ng_container_2_ng_container_1_Template, 1, 0, \"ng-container\", 67);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const rowData_r64 = ctx.$implicit;\n    const rowIndex_r65 = ctx.index;\n    const ctx_r63 = i0.ɵɵnextContext(4);\n\n    const _r11 = i0.ɵɵreference(25);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r11)(\"ngTemplateOutletContext\", ctx_r63.getContext(rowData_r64, rowIndex_r65, true));\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_9_ng_container_0_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 64, 65);\n    i0.ɵɵtemplate(2, IgxHierarchicalGridComponent_ng_template_9_ng_container_0_div_1_ng_container_2_Template, 2, 2, \"ng-container\", 66);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const pinnedData_r60 = i0.ɵɵnextContext().ngIf;\n    const ctx_r61 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"width\", ctx_r61.calcWidth, \"px\");\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(4, _c220, !ctx_r61.isRowPinningToTop, ctx_r61.isRowPinningToTop));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", pinnedData_r60);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_9_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxHierarchicalGridComponent_ng_template_9_ng_container_0_div_1_Template, 3, 7, \"div\", 63);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const pinnedData_r60 = ctx.ngIf;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", pinnedData_r60.length > 0);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxHierarchicalGridComponent_ng_template_9_ng_container_0_Template, 2, 1, \"ng-container\", 17);\n    i0.ɵɵpipe(1, \"gridSort\");\n    i0.ɵɵpipe(2, \"gridFiltering\");\n    i0.ɵɵpipe(3, \"gridRowPinning\");\n    i0.ɵɵpipe(4, \"gridAddRow\");\n    i0.ɵɵpipe(5, \"visibleColumns\");\n    i0.ɵɵpipe(6, \"gridTransaction\");\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", i0.ɵɵpipeBindV(1, 1, i0.ɵɵpureFunction5(41, _c222, i0.ɵɵpipeBindV(2, 8, i0.ɵɵpureFunction7(33, _c221, i0.ɵɵpipeBind4(3, 17, i0.ɵɵpipeBind3(4, 22, i0.ɵɵpipeBind2(5, 26, i0.ɵɵpipeBind3(6, 29, ctx_r5.data, ctx_r5.id, ctx_r5.pipeTrigger), ctx_r5.hasVisibleColumns), true, ctx_r5.pipeTrigger), ctx_r5.id, true, ctx_r5.pipeTrigger), ctx_r5.filteringExpressionsTree, ctx_r5.filterStrategy, ctx_r5.advancedFilteringExpressionsTree, ctx_r5.id, ctx_r5.pipeTrigger, ctx_r5.filteringPipeTrigger)), ctx_r5.sortingExpressions, ctx_r5.sortStrategy, ctx_r5.id, ctx_r5.pipeTrigger)));\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_container_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_12_ng_template_0_Template(rf, ctx) {}\n\nfunction IgxHierarchicalGridComponent_ng_template_12_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r72 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵtemplate(0, IgxHierarchicalGridComponent_ng_template_12_ng_template_0_Template, 0, 0, \"ng-template\", 68);\n    i0.ɵɵlistener(\"viewCreated\", function IgxHierarchicalGridComponent_ng_template_12_Template_ng_template_viewCreated_0_listener($event) {\n      i0.ɵɵrestoreView(_r72);\n      const ctx_r71 = i0.ɵɵnextContext();\n      return ctx_r71.viewCreatedHandler($event);\n    })(\"viewMoved\", function IgxHierarchicalGridComponent_ng_template_12_Template_ng_template_viewMoved_0_listener($event) {\n      i0.ɵɵrestoreView(_r72);\n      const ctx_r73 = i0.ɵɵnextContext();\n      return ctx_r73.viewMovedHandler($event);\n    })(\"cachedViewLoaded\", function IgxHierarchicalGridComponent_ng_template_12_Template_ng_template_cachedViewLoaded_0_listener($event) {\n      i0.ɵɵrestoreView(_r72);\n      const ctx_r74 = i0.ɵɵnextContext();\n      return ctx_r74.cachedViewLoaded($event);\n    });\n  }\n\n  if (rf & 2) {\n    const rowData_r68 = ctx.$implicit;\n    const rowIndex_r69 = ctx.index;\n    const ctx_r8 = i0.ɵɵnextContext();\n\n    const _r9 = i0.ɵɵreference(23);\n\n    const _r13 = i0.ɵɵreference(27);\n\n    i0.ɵɵproperty(\"igxTemplateOutlet\", ctx_r8.isHierarchicalRecord(rowData_r68) ? _r9 : ctx_r8.isChildGridRecord(rowData_r68) ? _r13 : _r9)(\"igxTemplateOutletContext\", ctx_r8.getContext(rowData_r68, rowIndex_r69, false));\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_22_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-hierarchical-grid-row\", 69, 70);\n    i0.ɵɵpipe(2, \"igxGridRowClasses\");\n    i0.ɵɵpipe(3, \"igxGridRowStyles\");\n  }\n\n  if (rf & 2) {\n    const rowIndex_r75 = ctx.index;\n    const disabledRow_r76 = ctx.disabled;\n    const rowData_r77 = ctx.$implicit;\n\n    const _r78 = i0.ɵɵreference(1);\n\n    const ctx_r10 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"gridID\", ctx_r10.id)(\"index\", rowIndex_r75)(\"disabled\", disabledRow_r76)(\"data\", rowData_r77)(\"ngClass\", i0.ɵɵpipeBindV(2, 6, i0.ɵɵpureFunctionV(24, _c223, [ctx_r10.rowClasses, _r78, _r78.inEditMode, _r78.selected, _r78.dirty, _r78.deleted, _r78.dragging, rowIndex_r75, ctx_r10.hasColumnLayouts, rowData_r77, ctx_r10.pipeTrigger])))(\"ngStyle\", i0.ɵɵpipeBind4(3, 19, ctx_r10.rowStyles, rowData_r77, rowIndex_r75, ctx_r10.pipeTrigger));\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_24_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-hierarchical-grid-row\", 71, 72);\n    i0.ɵɵpipe(3, \"igxGridRowClasses\");\n    i0.ɵɵpipe(4, \"igxGridRowStyles\");\n  }\n\n  if (rf & 2) {\n    const rowIndex_r79 = ctx.index;\n    const rowData_r80 = ctx.$implicit;\n\n    const _r81 = i0.ɵɵreference(1);\n\n    const ctx_r12 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"gridID\", ctx_r12.id)(\"index\", rowIndex_r79)(\"data\", rowData_r80)(\"ngClass\", i0.ɵɵpipeBindV(3, 5, i0.ɵɵpureFunctionV(23, _c223, [ctx_r12.rowClasses, _r81, _r81.inEditMode, _r81.selected, _r81.dirty, _r81.deleted, _r81.dragging, rowIndex_r79, ctx_r12.hasColumnLayouts, rowData_r80, ctx_r12.pipeTrigger])))(\"ngStyle\", i0.ɵɵpipeBind4(4, 18, ctx_r12.rowStyles, rowData_r80, rowIndex_r79, ctx_r12.pipeTrigger));\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_26_igx_child_grid_row_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-child-grid-row\", 75, 70);\n  }\n\n  if (rf & 2) {\n    const layout_r86 = ctx.$implicit;\n    const ctx_r88 = i0.ɵɵnextContext();\n    const rowIndex_r83 = ctx_r88.index;\n    const rowData_r84 = ctx_r88.$implicit;\n    const ctx_r85 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"parentGridID\", ctx_r85.id)(\"index\", rowIndex_r83)(\"data\", rowData_r84)(\"layout\", layout_r86);\n  }\n}\n\nconst _c248 = function (a1) {\n  return {\n    \"igx-grid__tr-container\": true,\n    \"igx-grid__tr--highlighted\": a1\n  };\n};\n\nfunction IgxHierarchicalGridComponent_ng_template_26_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r90 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 73);\n    i0.ɵɵlistener(\"scroll\", function IgxHierarchicalGridComponent_ng_template_26_Template_div_scroll_0_listener() {\n      i0.ɵɵrestoreView(_r90);\n      const ctx_r89 = i0.ɵɵnextContext();\n      return ctx_r89.onContainerScroll();\n    });\n    i0.ɵɵtemplate(1, IgxHierarchicalGridComponent_ng_template_26_igx_child_grid_row_1_Template, 2, 4, \"igx-child-grid-row\", 74);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const rowIndex_r83 = ctx.index;\n    const rowData_r84 = ctx.$implicit;\n    const ctx_r14 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(3, _c248, ctx_r14.isRowHighlighted(rowData_r84)));\n    i0.ɵɵattribute(\"data-rowindex\", rowIndex_r83);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r14.childLayoutList);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_container_28_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_container_29_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_span_30_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 76);\n  }\n\n  if (rf & 2) {\n    const ctx_r17 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"igxColumnMovingDrop\", ctx_r17.headerContainer);\n    i0.ɵɵattribute(\"droppable\", true);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_igc_trial_watermark_33_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igc-trial-watermark\");\n  }\n}\n\nfunction IgxHierarchicalGridComponent_igx_circular_bar_36_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-circular-bar\", 77);\n  }\n\n  if (rf & 2) {\n    i0.ɵɵproperty(\"indeterminate\", true);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_span_37_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 76);\n  }\n\n  if (rf & 2) {\n    const ctx_r22 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"igxColumnMovingDrop\", ctx_r22.headerContainer);\n    i0.ɵɵattribute(\"droppable\", true);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_41_Template(rf, ctx) {}\n\nfunction IgxHierarchicalGridComponent_igx_grid_summary_row_53_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-grid-summary-row\", 78, 79);\n    i0.ɵɵpipe(2, \"igxGridSummaryDataPipe\");\n  }\n\n  if (rf & 2) {\n    const ctx_r28 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"width\", ctx_r28.calcWidth, \"px\")(\"height\", ctx_r28.summaryRowHeight, \"px\");\n    i0.ɵɵproperty(\"gridID\", ctx_r28.id)(\"summaries\", i0.ɵɵpipeBind2(2, 7, ctx_r28.id, ctx_r28.summaryService.retriggerRootPipe))(\"index\", ctx_r28.dataView.length);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_59_Template(rf, ctx) {}\n\nfunction IgxHierarchicalGridComponent_ng_content_65_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 2, [\"*ngIf\", \"totalRecords || pagingMode === 1\"]);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_68_span_3_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_68_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtemplate(1, IgxHierarchicalGridComponent_ng_template_68_span_3_ng_container_1_Template, 1, 0, \"ng-container\", 8);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r92 = i0.ɵɵnextContext(2);\n\n    const _r39 = i0.ɵɵreference(73);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r92.addRowEmptyTemplate || _r39);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_68_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 80)(1, \"span\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, IgxHierarchicalGridComponent_ng_template_68_span_3_Template, 2, 1, \"span\", 17);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r36 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r36.emptyFilteredGridMessage);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r36.showAddButton);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_70_span_3_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_70_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtemplate(1, IgxHierarchicalGridComponent_ng_template_70_span_3_ng_container_1_Template, 1, 0, \"ng-container\", 8);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r94 = i0.ɵɵnextContext(2);\n\n    const _r39 = i0.ɵɵreference(73);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r94.addRowEmptyTemplate || _r39);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_70_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 80)(1, \"span\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, IgxHierarchicalGridComponent_ng_template_70_span_3_Template, 2, 1, \"span\", 17);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r38 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r38.emptyGridMessage);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r38.showAddButton);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_72_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r97 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 81);\n    i0.ɵɵlistener(\"click\", function IgxHierarchicalGridComponent_ng_template_72_Template_button_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r97);\n      const ctx_r96 = i0.ɵɵnextContext();\n      return ctx_r96.crudService.enterAddRowMode(null, false, $event);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r40 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r40.resourceStrings.igx_grid_add_row_label, \" \");\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_74_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 82);\n    i0.ɵɵelement(1, \"igx-circular-bar\", 77);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"indeterminate\", true);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_76_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\", 83);\n    i0.ɵɵtext(1, \"unfold_more\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_78_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\", 84);\n    i0.ɵɵtext(1, \"unfold_less\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r46 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"active\", ctx_r46.hasExpandedRecords() && ctx_r46.hasExpandableChildren);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_div_80_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_div_80_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 18, 85)(2, \"div\", 86);\n    i0.ɵɵtemplate(3, IgxHierarchicalGridComponent_div_80_ng_container_3_Template, 1, 0, \"ng-container\", 67);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r47 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"className\", ctx_r47.bannerClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r47.resolveRowEditContainer)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(3, _c226, ctx_r47.rowChangesCount, ctx_r47.crudService.endEdit.bind(ctx_r47)));\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_81_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const ctx_r49 = i0.ɵɵnextContext();\n    i0.ɵɵtextInterpolate1(\" You have \", ctx_r49.rowChangesCount, \" changes in this row\\n\");\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_83_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r101 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 87);\n    i0.ɵɵlistener(\"click\", function IgxHierarchicalGridComponent_ng_template_83_Template_button_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r101);\n      const ctx_r100 = i0.ɵɵnextContext();\n      return ctx_r100.endRowEditTabStop(false, $event);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"button\", 87);\n    i0.ɵɵlistener(\"click\", function IgxHierarchicalGridComponent_ng_template_83_Template_button_click_2_listener($event) {\n      i0.ɵɵrestoreView(_r101);\n      const ctx_r102 = i0.ɵɵnextContext();\n      return ctx_r102.endRowEditTabStop(true, $event);\n    });\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r51 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r51.resourceStrings.igx_grid_row_edit_btn_cancel);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r51.resourceStrings.igx_grid_row_edit_btn_done);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_85_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_85_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_85_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 88)(1, \"span\", 89);\n    i0.ɵɵtemplate(2, IgxHierarchicalGridComponent_ng_template_85_ng_container_2_Template, 1, 0, \"ng-container\", 67);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(3, \"div\", 90)(4, \"div\", 91);\n    i0.ɵɵtemplate(5, IgxHierarchicalGridComponent_ng_template_85_ng_container_5_Template, 1, 0, \"ng-container\", 67);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r53 = i0.ɵɵnextContext();\n\n    const _r48 = i0.ɵɵreference(82);\n\n    const _r50 = i0.ɵɵreference(84);\n\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", (ctx_r53.crudService.row == null ? null : ctx_r53.crudService.row.getClassName()) === \"IgxAddRow\" ? ctx_r53.rowAddText : ctx_r53.resolveRowEditText || _r48)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(4, _c24, (ctx_r53.crudService.row == null ? null : ctx_r53.crudService.row.getClassName()) !== \"IgxAddRow\" ? ctx_r53.rowChangesCount : null));\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r53.resolveRowEditActions || _r50)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(6, _c24, ctx_r53.endEdit.bind(ctx_r53)));\n  }\n}\n\nfunction IgxHierarchicalGridComponent_ng_template_87_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1, \"drag_indicator\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxHierarchicalGridComponent_igx_grid_column_resizer_89_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-grid-column-resizer\");\n  }\n}\n\nfunction IgxNavbarComponent_igx_icon_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-icon\", 5);\n    i0.ɵɵlistener(\"click\", function IgxNavbarComponent_igx_icon_2_Template_igx_icon_click_0_listener() {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return ctx_r2._triggerAction();\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.actionButtonIcon, \" \");\n  }\n}\n\nfunction IgxNavbarComponent_h1_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"h1\", 6);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"id\", ctx_r1.titleId);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.title, \" \");\n  }\n}\n\nconst _c249 = [[[\"igx-navbar-action\"], [\"\", \"igxNavbarAction\", \"\"]], [[\"igx-navbar-title\"], [\"\", \"igxNavbarTitle\", \"\"]], \"*\"];\nconst _c250 = [\"igx-navbar-action, [igxNavbarAction]\", \"igx-navbar-title, [igxNavbarTitle]\", \"*\"];\nconst _c251 = [\"aside\"];\nconst _c252 = [\"overlay\"];\nconst _c253 = [\"dummy\"];\n\nfunction IgxNavigationDrawerComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 8);\n    i0.ɵɵtext(1, \"Navigation Drawer\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"div\", 9);\n    i0.ɵɵtext(3, \" Start by adding\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"div\", 9)(5, \"code\");\n    i0.ɵɵtext(6, \"<ng-template igxDrawer>\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(7, \"div\", 9);\n    i0.ɵɵtext(8, \" And some items inside \");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(9, \"div\", 9);\n    i0.ɵɵtext(10, \" Style with igxDrawerItem \");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(11, \"div\", 9);\n    i0.ɵɵtext(12, \" and igxRipple directives\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵproperty(\"isHeader\", true);\n  }\n}\n\nfunction IgxNavigationDrawerComponent_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxThumbLabelComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxThumbLabelComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵtextInterpolate1(\" \", ctx_r2.value, \"\\n\");\n  }\n}\n\nfunction IgxTicksComponent_div_0_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nconst _c254 = function (a0) {\n  return {\n    \"igx-slider__ticks-group--tall\": a0\n  };\n};\n\nconst _c255 = function (a0) {\n  return {\n    \"igx-slider__tick-label--hidden\": a0\n  };\n};\n\nfunction IgxTicksComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 2)(1, \"div\", 3)(2, \"span\", 4);\n    i0.ɵɵtemplate(3, IgxTicksComponent_div_0_ng_container_3_Template, 1, 0, \"ng-container\", 5);\n    i0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const idx_r4 = ctx.index;\n    const ctx_r0 = i0.ɵɵnextContext();\n\n    const _r1 = i0.ɵɵreference(2);\n\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(4, _c254, ctx_r0.isPrimary(idx_r4)));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(6, _c255, !ctx_r0.hiddenTickLabels(idx_r4)));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.tickLabelTemplateRef ? ctx_r0.tickLabelTemplateRef : _r1)(\"ngTemplateOutletContext\", ctx_r0.context(idx_r4));\n  }\n}\n\nfunction IgxTicksComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const value_r6 = ctx.$implicit;\n    i0.ɵɵtextInterpolate1(\" \", value_r6, \"\\n\");\n  }\n}\n\nconst _c256 = [\"track\"];\nconst _c257 = [\"ticks\"];\n\nfunction IgxSliderComponent_igx_ticks_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-ticks\", 13);\n    i0.ɵɵpipe(1, \"spreadTickLabels\");\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"primaryTicks\", ctx_r0.primaryTicks)(\"secondaryTicks\", ctx_r0.secondaryTicks)(\"primaryTickLabels\", ctx_r0.primaryTickLabels)(\"secondaryTickLabels\", ctx_r0.secondaryTickLabels)(\"tickLabelsOrientation\", ctx_r0.tickLabelsOrientation)(\"labelsViewEnabled\", ctx_r0.labelsViewEnabled)(\"labels\", i0.ɵɵpipeBind2(1, 10, ctx_r0.labels, ctx_r0.secondaryTicks))(\"tickLabelTemplateRef\", ctx_r0.tickLabelTemplateRef)(\"minValue\", ctx_r0.minValue)(\"maxValue\", ctx_r0.maxValue);\n  }\n}\n\nfunction IgxSliderComponent_igx_ticks_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-ticks\", 14);\n    i0.ɵɵpipe(1, \"spreadTickLabels\");\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"primaryTicks\", ctx_r3.primaryTicks)(\"secondaryTicks\", ctx_r3.secondaryTicks)(\"primaryTickLabels\", ctx_r3.primaryTickLabels)(\"secondaryTickLabels\", ctx_r3.secondaryTickLabels)(\"tickLabelsOrientation\", ctx_r3.tickLabelsOrientation)(\"labelsViewEnabled\", ctx_r3.labelsViewEnabled)(\"labels\", i0.ɵɵpipeBind2(1, 10, ctx_r3.labels, ctx_r3.secondaryTicks))(\"tickLabelTemplateRef\", ctx_r3.tickLabelTemplateRef)(\"minValue\", ctx_r3.minValue)(\"maxValue\", ctx_r3.maxValue);\n  }\n}\n\nfunction IgxSliderComponent_igx_thumb_label_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-thumb-label\", 15);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"value\", ctx_r4.lowerLabel)(\"templateRef\", ctx_r4.thumbFromTemplateRef)(\"continuous\", ctx_r4.continuous)(\"context\", ctx_r4.context)(\"deactiveState\", ctx_r4.deactivateThumbLabel)(\"thumb\", ctx_r4.thumbFrom);\n  }\n}\n\nfunction IgxSliderComponent_igx_thumb_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-thumb\", 16, 17);\n    i0.ɵɵlistener(\"thumbChange\", function IgxSliderComponent_igx_thumb_9_Template_igx_thumb_thumbChange_0_listener() {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.onThumbChange();\n    })(\"hoverChange\", function IgxSliderComponent_igx_thumb_9_Template_igx_thumb_hoverChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return ctx_r10.onHoverChange($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"value\", ctx_r5.lowerLabel)(\"disabled\", ctx_r5.disabled)(\"continuous\", ctx_r5.continuous)(\"onPan\", ctx_r5.onPan)(\"stepDistance\", ctx_r5.stepDistance)(\"step\", ctx_r5.step)(\"templateRef\", ctx_r5.thumbFromTemplateRef)(\"context\", ctx_r5.context)(\"deactiveState\", ctx_r5.deactivateThumbLabel)(\"thumbLabelVisibilityDuration\", ctx_r5.thumbLabelVisibilityDuration);\n  }\n}\n\nconst _c258 = [\"headerTemplate\"];\nconst _c259 = [\"panelTemplate\"];\n\nfunction IgxBottomNavComponent_ng_container_0_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxBottomNavComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxBottomNavComponent_ng_container_0_ng_container_1_Template, 1, 0, \"ng-container\", 3);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const tab_r3 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", tab_r3.panelTemplate);\n  }\n}\n\nfunction IgxBottomNavComponent_ng_container_3_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxBottomNavComponent_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxBottomNavComponent_ng_container_3_ng_container_1_Template, 1, 0, \"ng-container\", 3);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const tab_r6 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", tab_r6.headerTemplate);\n  }\n}\n\nfunction IgxBottomNavItemComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0);\n  }\n}\n\nfunction IgxBottomNavItemComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 1);\n  }\n}\n\nconst _c260 = [[[\"igx-bottom-nav-header\"]], [[\"igx-bottom-nav-content\"]]];\nconst _c261 = [\"igx-bottom-nav-header\", \"igx-bottom-nav-content\"];\n\nfunction IgxBottomNavContentComponent_ng_content_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngIf\", \"tab.selected || tab.previous\"]);\n  }\n}\n\nconst _c262 = [\"headerContainer\"];\nconst _c263 = [\"viewPort\"];\nconst _c264 = [\"itemsWrapper\"];\nconst _c265 = [\"itemsContainer\"];\nconst _c266 = [\"selectedIndicator\"];\nconst _c267 = [\"scrollPrevButton\"];\nconst _c268 = [\"scrollNextButton\"];\n\nfunction IgxTabsComponent_ng_container_12_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxTabsComponent_ng_container_12_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxTabsComponent_ng_container_12_ng_container_1_Template, 1, 0, \"ng-container\", 14);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const tab_r9 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", tab_r9.headerTemplate);\n  }\n}\n\nfunction IgxTabsComponent_div_13_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 15, 16);\n  }\n}\n\nfunction IgxTabsComponent_ng_container_19_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxTabsComponent_ng_container_19_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxTabsComponent_ng_container_19_ng_container_1_Template, 1, 0, \"ng-container\", 14);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const tab_r13 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", tab_r13.panelTemplate);\n  }\n}\n\nfunction IgxTabItemComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0);\n  }\n}\n\nfunction IgxTabItemComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 1);\n  }\n}\n\nconst _c269 = [[[\"igx-tab-header\"]], [[\"igx-tab-content\"]]];\nconst _c270 = [\"igx-tab-header\", \"igx-tab-content\"];\n\nfunction IgxTabContentComponent_ng_content_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngIf\", \"tab.selected || tab.previous\"]);\n  }\n}\n\nfunction IgxSplitterComponent_ng_container_1_igx_splitter_bar_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-splitter-bar\", 2);\n    i0.ɵɵlistener(\"moveStart\", function IgxSplitterComponent_ng_container_1_igx_splitter_bar_1_Template_igx_splitter_bar_moveStart_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext(2);\n      return ctx_r5.onMoveStart($event);\n    })(\"moving\", function IgxSplitterComponent_ng_container_1_igx_splitter_bar_1_Template_igx_splitter_bar_moving_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r7 = i0.ɵɵnextContext(2);\n      return ctx_r7.onMoving($event);\n    })(\"movingEnd\", function IgxSplitterComponent_ng_container_1_igx_splitter_bar_1_Template_igx_splitter_bar_movingEnd_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r8 = i0.ɵɵnextContext(2);\n      return ctx_r8.onMoveEnd($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext();\n    const pane_r1 = ctx_r9.$implicit;\n    const index_r3 = ctx_r9.index;\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"order\", pane_r1.order + 1)(\"type\", ctx_r4.type)(\"pane\", pane_r1)(\"siblings\", ctx_r4.getPaneSiblingsByOrder(pane_r1.order + 1, index_r3));\n  }\n}\n\nfunction IgxSplitterComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxSplitterComponent_ng_container_1_igx_splitter_bar_1_Template, 1, 4, \"igx-splitter-bar\", 1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const last_r2 = ctx.last;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !last_r2);\n  }\n}\n\nconst _c271 = [[[\"igx-splitter-pane\"]]];\nconst _c272 = [\"igx-splitter-pane\"];\nconst _c273 = [\"contentTemplate\"];\nconst _c274 = [\"customIndicator\"];\nconst _c275 = [\"contentContainer\"];\n\nfunction IgxStepComponent_ng_template_0_ng_content_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngIf\", \"isTitleVisible\"]);\n  }\n}\n\nfunction IgxStepComponent_ng_template_0_ng_content_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 1, [\"*ngIf\", \"isTitleVisible\"]);\n  }\n}\n\nfunction IgxStepComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxStepComponent_ng_template_0_ng_content_0_Template, 1, 0, \"ng-content\", 8);\n    i0.ɵɵtemplate(1, IgxStepComponent_ng_template_0_ng_content_1_Template, 1, 0, \"ng-content\", 8);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.isTitleVisible);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.isTitleVisible);\n  }\n}\n\nfunction IgxStepComponent_ng_template_2_ng_content_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 2, [\"*ngIf\", \"active || collapsing\"]);\n  }\n}\n\nfunction IgxStepComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 9, 10);\n    i0.ɵɵtemplate(2, IgxStepComponent_ng_template_2_ng_content_2_Template, 1, 0, \"ng-content\", 8);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", ctx_r3.contentClasses);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.active || ctx_r3.collapsing);\n  }\n}\n\nfunction IgxStepComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r5.index + 1);\n  }\n}\n\nfunction IgxStepComponent_ng_template_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 3);\n  }\n}\n\nfunction IgxStepComponent_div_9_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxStepComponent_div_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 11);\n    i0.ɵɵtemplate(1, IgxStepComponent_div_9_ng_container_1_Template, 1, 0, \"ng-container\", 7);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext();\n\n    const _r4 = i0.ɵɵreference(5);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r8.indicatorTemplate ? ctx_r8.indicatorTemplate : _r4);\n  }\n}\n\nfunction IgxStepComponent_ng_container_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxStepComponent_ng_container_12_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxStepComponent_ng_container_12_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 12);\n    i0.ɵɵtemplate(2, IgxStepComponent_ng_container_12_ng_container_2_Template, 1, 0, \"ng-container\", 7);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r2 = i0.ɵɵreference(3);\n\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r2);\n  }\n}\n\nconst _c276 = [[[\"\", \"igxStepTitle\", \"\"]], [[\"\", \"igxStepSubTitle\", \"\"]], [[\"\", \"igxStepContent\", \"\"]], [[\"\", \"igxStepIndicator\", \"\"]]];\nconst _c277 = [\"[igxStepTitle]\", \"[igxStepSubTitle]\", \"[igxStepContent]\", \"[igxStepIndicator]\"];\n\nfunction IgxStepperComponent_div_0_1_ng_template_0_Template(rf, ctx) {}\n\nfunction IgxStepperComponent_div_0_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxStepperComponent_div_0_1_ng_template_0_Template, 0, 0, \"ng-template\");\n  }\n}\n\nfunction IgxStepperComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 3);\n    i0.ɵɵtemplate(1, IgxStepperComponent_div_0_1_Template, 1, 0, null, 4);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r3 = i0.ɵɵreference(4);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r3);\n  }\n}\n\nfunction IgxStepperComponent_div_1_ng_container_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxStepperComponent_div_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxStepperComponent_div_1_ng_container_1_ng_container_1_Template, 1, 0, \"ng-container\", 4);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const step_r8 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", step_r8.contentTemplate);\n  }\n}\n\nfunction IgxStepperComponent_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 5);\n    i0.ɵɵtemplate(1, IgxStepperComponent_div_1_ng_container_1_Template, 2, 1, \"ng-container\", 6);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.steps);\n  }\n}\n\nfunction IgxStepperComponent_div_2_1_ng_template_0_Template(rf, ctx) {}\n\nfunction IgxStepperComponent_div_2_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxStepperComponent_div_2_1_ng_template_0_Template, 0, 0, \"ng-template\");\n  }\n}\n\nfunction IgxStepperComponent_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 3);\n    i0.ɵɵtemplate(1, IgxStepperComponent_div_2_1_Template, 1, 0, null, 4);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r3 = i0.ɵɵreference(4);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r3);\n  }\n}\n\nfunction IgxStepperComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0);\n  }\n}\n\nconst _c278 = [[[\"igx-step\"]]];\nconst _c279 = [\"igx-step\"];\n\nfunction IgxDateRangeStartComponent_div_0_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 14);\n    i0.ɵɵtemplate(1, IgxDateRangeStartComponent_div_0_ng_container_1_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r22 = i0.ɵɵreference(25);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r22);\n  }\n}\n\nfunction IgxDateRangeStartComponent_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 16);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 1);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 2);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 3);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_10_igx_prefix_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r27 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-prefix\", 18)(1, \"button\", 19);\n    i0.ɵɵlistener(\"click\", function IgxDateRangeStartComponent_ng_template_10_igx_prefix_0_Template_button_click_1_listener() {\n      i0.ɵɵrestoreView(_r27);\n      const ctx_r26 = i0.ɵɵnextContext(2);\n      return ctx_r26.uploadButtonHandler();\n    });\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r25 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r25.displayDensity)(\"disabled\", ctx_r25.disabled)(\"ngClass\", i0.ɵɵpureFunction1(4, _c12, ctx_r25.isTypeLine));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r25.resourceStrings.igx_input_upload_button, \" \");\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxDateRangeStartComponent_ng_template_10_igx_prefix_0_Template, 3, 6, \"igx-prefix\", 17);\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r9.isFileType);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_12_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 21)(1, \"span\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r28 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"title\", ctx_r28.fileNames);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r28.fileNames);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_12_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxDateRangeStartComponent_ng_template_12_div_0_Template, 3, 2, \"div\", 20);\n  }\n\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r11.isFileType);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_14_igx_suffix_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r31 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-suffix\", 23);\n    i0.ɵɵlistener(\"click\", function IgxDateRangeStartComponent_ng_template_14_igx_suffix_0_Template_igx_suffix_click_0_listener() {\n      i0.ɵɵrestoreView(_r31);\n      const ctx_r30 = i0.ɵɵnextContext(2);\n      return ctx_r30.clearValueHandler();\n    })(\"keydown.Enter\", function IgxDateRangeStartComponent_ng_template_14_igx_suffix_0_Template_igx_suffix_keydown_Enter_0_listener() {\n      i0.ɵɵrestoreView(_r31);\n      const ctx_r32 = i0.ɵɵnextContext(2);\n      return ctx_r32.clearValueHandler();\n    });\n    i0.ɵɵelementStart(1, \"igx-icon\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r29 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r29.resourceStrings.igx_input_clear_button);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_14_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxDateRangeStartComponent_ng_template_14_igx_suffix_0_Template, 3, 1, \"igx-suffix\", 22);\n  }\n\n  if (rf & 2) {\n    const ctx_r13 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r13.isFileType && ctx_r13.isFilled);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_16_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 4);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_18_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_18_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_18_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_18_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_18_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_18_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_18_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_18_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 24);\n    i0.ɵɵtemplate(1, IgxDateRangeStartComponent_ng_template_18_ng_container_1_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(2, IgxDateRangeStartComponent_ng_template_18_ng_container_2_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementStart(3, \"div\", 25);\n    i0.ɵɵtemplate(4, IgxDateRangeStartComponent_ng_template_18_ng_container_4_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(5, IgxDateRangeStartComponent_ng_template_18_ng_container_5_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(6, IgxDateRangeStartComponent_ng_template_18_ng_container_6_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(7, IgxDateRangeStartComponent_ng_template_18_ng_container_7_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(8, IgxDateRangeStartComponent_ng_template_18_ng_container_8_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r6 = i0.ɵɵreference(9);\n\n    const _r8 = i0.ɵɵreference(11);\n\n    const _r2 = i0.ɵɵreference(5);\n\n    const _r4 = i0.ɵɵreference(7);\n\n    const _r10 = i0.ɵɵreference(13);\n\n    const _r12 = i0.ɵɵreference(15);\n\n    const _r14 = i0.ɵɵreference(17);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r6);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r8);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r10);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r12);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r14);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_20_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_20_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_20_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_20_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_20_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_20_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_20_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_20_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxDateRangeStartComponent_ng_template_20_ng_container_0_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementStart(1, \"div\", 24);\n    i0.ɵɵtemplate(2, IgxDateRangeStartComponent_ng_template_20_ng_container_2_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(3, IgxDateRangeStartComponent_ng_template_20_ng_container_3_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementStart(4, \"div\", 25);\n    i0.ɵɵtemplate(5, IgxDateRangeStartComponent_ng_template_20_ng_container_5_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(6, IgxDateRangeStartComponent_ng_template_20_ng_container_6_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(7, IgxDateRangeStartComponent_ng_template_20_ng_container_7_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(8, IgxDateRangeStartComponent_ng_template_20_ng_container_8_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r2 = i0.ɵɵreference(5);\n\n    const _r6 = i0.ɵɵreference(9);\n\n    const _r8 = i0.ɵɵreference(11);\n\n    const _r4 = i0.ɵɵreference(7);\n\n    const _r10 = i0.ɵɵreference(13);\n\n    const _r12 = i0.ɵɵreference(15);\n\n    const _r14 = i0.ɵɵreference(17);\n\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r6);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r8);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r10);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r12);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r14);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_22_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_22_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_22_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_22_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_22_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_22_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_22_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_22_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxDateRangeStartComponent_ng_template_22_ng_container_0_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementStart(1, \"div\", 24);\n    i0.ɵɵtemplate(2, IgxDateRangeStartComponent_ng_template_22_ng_container_2_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(3, IgxDateRangeStartComponent_ng_template_22_ng_container_3_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(4, IgxDateRangeStartComponent_ng_template_22_ng_container_4_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(5, IgxDateRangeStartComponent_ng_template_22_ng_container_5_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(6, IgxDateRangeStartComponent_ng_template_22_ng_container_6_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(7, IgxDateRangeStartComponent_ng_template_22_ng_container_7_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r2 = i0.ɵɵreference(5);\n\n    const _r6 = i0.ɵɵreference(9);\n\n    const _r8 = i0.ɵɵreference(11);\n\n    const _r4 = i0.ɵɵreference(7);\n\n    const _r10 = i0.ɵɵreference(13);\n\n    const _r12 = i0.ɵɵreference(15);\n\n    const _r14 = i0.ɵɵreference(17);\n\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r6);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r8);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r10);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r12);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r14);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_24_ng_container_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_24_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxDateRangeStartComponent_ng_template_24_ng_container_1_ng_container_1_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n\n    const _r20 = i0.ɵɵreference(23);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r20);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_24_ng_container_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_24_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxDateRangeStartComponent_ng_template_24_ng_container_2_ng_container_1_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n\n    const _r18 = i0.ɵɵreference(21);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r18);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_24_ng_container_3_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_24_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxDateRangeStartComponent_ng_template_24_ng_container_3_ng_container_1_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n\n    const _r18 = i0.ɵɵreference(21);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r18);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_24_ng_container_4_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_24_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxDateRangeStartComponent_ng_template_24_ng_container_4_ng_container_1_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n\n    const _r16 = i0.ɵɵreference(19);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r16);\n  }\n}\n\nfunction IgxDateRangeStartComponent_ng_template_24_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0, 26);\n    i0.ɵɵtemplate(1, IgxDateRangeStartComponent_ng_template_24_ng_container_1_Template, 2, 1, \"ng-container\", 27);\n    i0.ɵɵtemplate(2, IgxDateRangeStartComponent_ng_template_24_ng_container_2_Template, 2, 1, \"ng-container\", 27);\n    i0.ɵɵtemplate(3, IgxDateRangeStartComponent_ng_template_24_ng_container_3_Template, 2, 1, \"ng-container\", 27);\n    i0.ɵɵtemplate(4, IgxDateRangeStartComponent_ng_template_24_ng_container_4_Template, 2, 1, \"ng-container\", 28);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r23 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngSwitch\", ctx_r23.theme);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", \"bootstrap\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", \"fluent\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", \"indigo-design\");\n  }\n}\n\nfunction IgxDateRangeEndComponent_div_0_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 14);\n    i0.ɵɵtemplate(1, IgxDateRangeEndComponent_div_0_ng_container_1_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r22 = i0.ɵɵreference(25);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r22);\n  }\n}\n\nfunction IgxDateRangeEndComponent_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 16);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 1);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 2);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 3);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_10_igx_prefix_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r27 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-prefix\", 18)(1, \"button\", 19);\n    i0.ɵɵlistener(\"click\", function IgxDateRangeEndComponent_ng_template_10_igx_prefix_0_Template_button_click_1_listener() {\n      i0.ɵɵrestoreView(_r27);\n      const ctx_r26 = i0.ɵɵnextContext(2);\n      return ctx_r26.uploadButtonHandler();\n    });\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r25 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"displayDensity\", ctx_r25.displayDensity)(\"disabled\", ctx_r25.disabled)(\"ngClass\", i0.ɵɵpureFunction1(4, _c12, ctx_r25.isTypeLine));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r25.resourceStrings.igx_input_upload_button, \" \");\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxDateRangeEndComponent_ng_template_10_igx_prefix_0_Template, 3, 6, \"igx-prefix\", 17);\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r9.isFileType);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_12_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 21)(1, \"span\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r28 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"title\", ctx_r28.fileNames);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r28.fileNames);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_12_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxDateRangeEndComponent_ng_template_12_div_0_Template, 3, 2, \"div\", 20);\n  }\n\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r11.isFileType);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_14_igx_suffix_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r31 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-suffix\", 23);\n    i0.ɵɵlistener(\"click\", function IgxDateRangeEndComponent_ng_template_14_igx_suffix_0_Template_igx_suffix_click_0_listener() {\n      i0.ɵɵrestoreView(_r31);\n      const ctx_r30 = i0.ɵɵnextContext(2);\n      return ctx_r30.clearValueHandler();\n    })(\"keydown.Enter\", function IgxDateRangeEndComponent_ng_template_14_igx_suffix_0_Template_igx_suffix_keydown_Enter_0_listener() {\n      i0.ɵɵrestoreView(_r31);\n      const ctx_r32 = i0.ɵɵnextContext(2);\n      return ctx_r32.clearValueHandler();\n    });\n    i0.ɵɵelementStart(1, \"igx-icon\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r29 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r29.resourceStrings.igx_input_clear_button);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_14_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxDateRangeEndComponent_ng_template_14_igx_suffix_0_Template, 3, 1, \"igx-suffix\", 22);\n  }\n\n  if (rf & 2) {\n    const ctx_r13 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r13.isFileType && ctx_r13.isFilled);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_16_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 4);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_18_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_18_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_18_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_18_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_18_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_18_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_18_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_18_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 24);\n    i0.ɵɵtemplate(1, IgxDateRangeEndComponent_ng_template_18_ng_container_1_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(2, IgxDateRangeEndComponent_ng_template_18_ng_container_2_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementStart(3, \"div\", 25);\n    i0.ɵɵtemplate(4, IgxDateRangeEndComponent_ng_template_18_ng_container_4_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(5, IgxDateRangeEndComponent_ng_template_18_ng_container_5_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(6, IgxDateRangeEndComponent_ng_template_18_ng_container_6_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(7, IgxDateRangeEndComponent_ng_template_18_ng_container_7_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(8, IgxDateRangeEndComponent_ng_template_18_ng_container_8_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r6 = i0.ɵɵreference(9);\n\n    const _r8 = i0.ɵɵreference(11);\n\n    const _r2 = i0.ɵɵreference(5);\n\n    const _r4 = i0.ɵɵreference(7);\n\n    const _r10 = i0.ɵɵreference(13);\n\n    const _r12 = i0.ɵɵreference(15);\n\n    const _r14 = i0.ɵɵreference(17);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r6);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r8);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r10);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r12);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r14);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_20_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_20_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_20_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_20_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_20_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_20_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_20_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_20_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxDateRangeEndComponent_ng_template_20_ng_container_0_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementStart(1, \"div\", 24);\n    i0.ɵɵtemplate(2, IgxDateRangeEndComponent_ng_template_20_ng_container_2_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(3, IgxDateRangeEndComponent_ng_template_20_ng_container_3_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementStart(4, \"div\", 25);\n    i0.ɵɵtemplate(5, IgxDateRangeEndComponent_ng_template_20_ng_container_5_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(6, IgxDateRangeEndComponent_ng_template_20_ng_container_6_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(7, IgxDateRangeEndComponent_ng_template_20_ng_container_7_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(8, IgxDateRangeEndComponent_ng_template_20_ng_container_8_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r2 = i0.ɵɵreference(5);\n\n    const _r6 = i0.ɵɵreference(9);\n\n    const _r8 = i0.ɵɵreference(11);\n\n    const _r4 = i0.ɵɵreference(7);\n\n    const _r10 = i0.ɵɵreference(13);\n\n    const _r12 = i0.ɵɵreference(15);\n\n    const _r14 = i0.ɵɵreference(17);\n\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r6);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r8);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r10);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r12);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r14);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_22_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_22_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_22_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_22_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_22_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_22_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_22_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_22_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxDateRangeEndComponent_ng_template_22_ng_container_0_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementStart(1, \"div\", 24);\n    i0.ɵɵtemplate(2, IgxDateRangeEndComponent_ng_template_22_ng_container_2_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(3, IgxDateRangeEndComponent_ng_template_22_ng_container_3_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(4, IgxDateRangeEndComponent_ng_template_22_ng_container_4_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(5, IgxDateRangeEndComponent_ng_template_22_ng_container_5_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(6, IgxDateRangeEndComponent_ng_template_22_ng_container_6_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵtemplate(7, IgxDateRangeEndComponent_ng_template_22_ng_container_7_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n\n    const _r2 = i0.ɵɵreference(5);\n\n    const _r6 = i0.ɵɵreference(9);\n\n    const _r8 = i0.ɵɵreference(11);\n\n    const _r4 = i0.ɵɵreference(7);\n\n    const _r10 = i0.ɵɵreference(13);\n\n    const _r12 = i0.ɵɵreference(15);\n\n    const _r14 = i0.ɵɵreference(17);\n\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r6);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r8);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r10);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r12);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r14);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_24_ng_container_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_24_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxDateRangeEndComponent_ng_template_24_ng_container_1_ng_container_1_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n\n    const _r20 = i0.ɵɵreference(23);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r20);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_24_ng_container_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_24_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxDateRangeEndComponent_ng_template_24_ng_container_2_ng_container_1_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n\n    const _r18 = i0.ɵɵreference(21);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r18);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_24_ng_container_3_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_24_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxDateRangeEndComponent_ng_template_24_ng_container_3_ng_container_1_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n\n    const _r18 = i0.ɵɵreference(21);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r18);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_24_ng_container_4_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_24_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxDateRangeEndComponent_ng_template_24_ng_container_4_ng_container_1_Template, 1, 0, \"ng-container\", 15);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n\n    const _r16 = i0.ɵɵreference(19);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r16);\n  }\n}\n\nfunction IgxDateRangeEndComponent_ng_template_24_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0, 26);\n    i0.ɵɵtemplate(1, IgxDateRangeEndComponent_ng_template_24_ng_container_1_Template, 2, 1, \"ng-container\", 27);\n    i0.ɵɵtemplate(2, IgxDateRangeEndComponent_ng_template_24_ng_container_2_Template, 2, 1, \"ng-container\", 27);\n    i0.ɵɵtemplate(3, IgxDateRangeEndComponent_ng_template_24_ng_container_3_Template, 2, 1, \"ng-container\", 27);\n    i0.ɵɵtemplate(4, IgxDateRangeEndComponent_ng_template_24_ng_container_4_Template, 2, 1, \"ng-container\", 28);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r23 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngSwitch\", ctx_r23.theme);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", \"bootstrap\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", \"fluent\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngSwitchCase\", \"indigo-design\");\n  }\n}\n\nfunction IgxDateRangePickerComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangePickerComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 6);\n    i0.ɵɵlistener(\"click\", function IgxDateRangePickerComponent_ng_template_1_Template_div_click_0_listener() {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return ctx_r11.open();\n    });\n    i0.ɵɵprojection(1);\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxDateRangePickerComponent_ng_template_3_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangePickerComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 1);\n    i0.ɵɵelementStart(1, \"div\", 7);\n    i0.ɵɵtemplate(2, IgxDateRangePickerComponent_ng_template_3_ng_container_2_Template, 1, 0, \"ng-container\", 0);\n    i0.ɵɵelementEnd();\n    i0.ɵɵprojection(3, 2);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n\n    const _r7 = i0.ɵɵreference(8);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"className\", ctx_r4.separatorClass);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r4.dateSeparatorTemplate || _r7);\n  }\n}\n\nfunction IgxDateRangePickerComponent_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1, \" date_range \");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxDateRangePickerComponent_ng_template_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext();\n    i0.ɵɵtextInterpolate(ctx_r8.dateSeparator);\n  }\n}\n\nfunction IgxDateRangePickerComponent_ng_template_9_igx_prefix_4_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxDateRangePickerComponent_ng_template_9_igx_prefix_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-prefix\");\n    i0.ɵɵtemplate(1, IgxDateRangePickerComponent_ng_template_9_igx_prefix_4_ng_container_1_Template, 1, 0, \"ng-container\", 0);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n\n    const _r5 = i0.ɵɵreference(6);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r5);\n  }\n}\n\nfunction IgxDateRangePickerComponent_ng_template_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r18 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-input-group\", 8);\n    i0.ɵɵlistener(\"click\", function IgxDateRangePickerComponent_ng_template_9_Template_igx_input_group_click_0_listener() {\n      i0.ɵɵrestoreView(_r18);\n      const ctx_r17 = i0.ɵɵnextContext();\n      return ctx_r17.open();\n    });\n    i0.ɵɵelement(1, \"input\", 9, 10);\n    i0.ɵɵpipe(3, \"dateRange\");\n    i0.ɵɵtemplate(4, IgxDateRangePickerComponent_ng_template_9_igx_prefix_4_Template, 2, 1, \"igx-prefix\", 11);\n    i0.ɵɵelementContainerStart(5, 12);\n    i0.ɵɵprojection(6, 3);\n    i0.ɵɵelementContainerEnd();\n    i0.ɵɵelementContainerStart(7, 13);\n    i0.ɵɵprojection(8, 4);\n    i0.ɵɵelementContainerEnd();\n    i0.ɵɵelementContainerStart(9, 14);\n    i0.ɵɵprojection(10, 5);\n    i0.ɵɵelementContainerEnd();\n    i0.ɵɵelementContainerStart(11, 15);\n    i0.ɵɵprojection(12, 6);\n    i0.ɵɵelementContainerEnd();\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r10 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"type\", ctx_r10.type)(\"displayDensity\", ctx_r10.displayDensity);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"disabled\", ctx_r10.disabled)(\"placeholder\", ctx_r10.value ? \"\" : ctx_r10.singleInputFormat)(\"value\", i0.ɵɵpipeBind4(3, 8, ctx_r10.value, ctx_r10.appliedFormat, ctx_r10.locale, ctx_r10.formatter));\n    i0.ɵɵattribute(\"aria-expanded\", !ctx_r10.collapsed)(\"aria-labelledby\", ctx_r10.label == null ? null : ctx_r10.label.id);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r10.toggleComponents.length);\n  }\n}\n\nconst _c280 = [[[\"igx-date-single\"]], [[\"igx-date-range-start\"]], [[\"igx-date-range-end\"]], [[\"\", \"igxLabel\", \"\"]], [[\"igx-prefix\"], [\"\", \"igxPrefix\", \"\"]], [[\"igx-suffix\"], [\"\", \"igxSuffix\", \"\"]], [[\"igx-hint\"], [\"\", \"igxHint\", \"\"]]];\nconst _c281 = [\"igx-date-single\", \"igx-date-range-start\", \"igx-date-range-end\", \"[igxLabel]\", \"igx-prefix,[igxPrefix]\", \"igx-suffix,[igxSuffix]\", \"igx-hint,[igxHint]\"];\nconst _c282 = [\"esf\"];\nconst _c283 = [\"filterAreaHidden\"];\nconst _c284 = [\"filterIcon\"];\nconst _c285 = [\"dropdownChips\"];\nconst _c286 = [\"pivotFilterContainer\"];\nconst _c287 = [\"notifyChip\"];\n\nfunction IgxPivotHeaderRowComponent_div_4_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r23 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 37);\n    i0.ɵɵlistener(\"dropped\", function IgxPivotHeaderRowComponent_div_4_span_4_Template_span_dropped_0_listener($event) {\n      i0.ɵɵrestoreView(_r23);\n      i0.ɵɵnextContext();\n\n      const _r17 = i0.ɵɵreference(3);\n\n      const ctx_r22 = i0.ɵɵnextContext();\n      return ctx_r22.onDimDrop($event, _r17, 2);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r18 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r18.grid.resourceStrings.igx_grid_pivot_empty_filter_drop_area);\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_div_4_ng_container_5_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"span\", 38);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n\n    const _r17 = i0.ɵɵreference(3);\n\n    const ctx_r26 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"visibility\", \"hidden\")(\"height\", ctx_r26.getAreaHeight(_r17), \"px\");\n  }\n}\n\nconst _c288 = function () {\n  return {\n    pivotArea: \"filter\"\n  };\n};\n\nfunction IgxPivotHeaderRowComponent_div_4_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r28 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"span\", 38);\n    i0.ɵɵelementStart(2, \"igx-chip\", 39);\n    i0.ɵɵlistener(\"remove\", function IgxPivotHeaderRowComponent_div_4_ng_container_5_Template_igx_chip_remove_2_listener($event) {\n      i0.ɵɵrestoreView(_r28);\n      const ctx_r27 = i0.ɵɵnextContext(2);\n      return ctx_r27.filterRemoved($event);\n    })(\"dragOver\", function IgxPivotHeaderRowComponent_div_4_ng_container_5_Template_igx_chip_dragOver_2_listener($event) {\n      i0.ɵɵrestoreView(_r28);\n      const ctx_r29 = i0.ɵɵnextContext(2);\n      return ctx_r29.onDimDragOver($event, 2);\n    })(\"dragLeave\", function IgxPivotHeaderRowComponent_div_4_ng_container_5_Template_igx_chip_dragLeave_2_listener($event) {\n      i0.ɵɵrestoreView(_r28);\n      const ctx_r30 = i0.ɵɵnextContext(2);\n      return ctx_r30.onDimDragLeave($event);\n    })(\"dragDrop\", function IgxPivotHeaderRowComponent_div_4_ng_container_5_Template_igx_chip_dragDrop_2_listener($event) {\n      i0.ɵɵrestoreView(_r28);\n      i0.ɵɵnextContext();\n\n      const _r17 = i0.ɵɵreference(3);\n\n      const ctx_r31 = i0.ɵɵnextContext();\n      return ctx_r31.onDimDrop($event, _r17, 2);\n    })(\"moveStart\", function IgxPivotHeaderRowComponent_div_4_ng_container_5_Template_igx_chip_moveStart_2_listener($event) {\n      i0.ɵɵrestoreView(_r28);\n      i0.ɵɵnextContext();\n\n      const _r17 = i0.ɵɵreference(3);\n\n      const ctx_r32 = i0.ɵɵnextContext();\n      return ctx_r32.onDimDragStart($event, _r17);\n    })(\"moveEnd\", function IgxPivotHeaderRowComponent_div_4_ng_container_5_Template_igx_chip_moveEnd_2_listener() {\n      i0.ɵɵrestoreView(_r28);\n      const ctx_r33 = i0.ɵɵnextContext(2);\n      return ctx_r33.onDimDragEnd();\n    });\n    i0.ɵɵelementStart(3, \"igx-icon\", 40);\n    i0.ɵɵlistener(\"pointerdown\", function IgxPivotHeaderRowComponent_div_4_ng_container_5_Template_igx_icon_pointerdown_3_listener($event) {\n      i0.ɵɵrestoreView(_r28);\n      const ctx_r34 = i0.ɵɵnextContext(2);\n      return ctx_r34.onFilteringIconPointerDown($event);\n    })(\"click\", function IgxPivotHeaderRowComponent_div_4_ng_container_5_Template_igx_icon_click_3_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r28);\n      const filter_r24 = restoredCtx.$implicit;\n      const ctx_r35 = i0.ɵɵnextContext(2);\n      return ctx_r35.onFilteringIconClick($event, filter_r24);\n    });\n    i0.ɵɵtext(4, \"filter_list\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(6, IgxPivotHeaderRowComponent_div_4_ng_container_5_ng_container_6_Template, 2, 4, \"ng-container\", 13);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const filter_r24 = ctx.$implicit;\n    const last_r25 = ctx.last;\n    i0.ɵɵnextContext();\n\n    const _r17 = i0.ɵɵreference(3);\n\n    const ctx_r19 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"visibility\", \"hidden\")(\"height\", ctx_r19.getAreaHeight(_r17), \"px\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"id\", filter_r24.memberName)(\"draggable\", true)(\"displayDensity\", ctx_r19.grid.displayDensity)(\"data\", i0.ɵɵpureFunction0(11, _c288))(\"removable\", true);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate1(\" \", filter_r24.memberName, \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", last_r25);\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_div_4_div_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r38 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 41)(1, \"igx-icon\", 42, 43);\n    i0.ɵɵlistener(\"pointerdown\", function IgxPivotHeaderRowComponent_div_4_div_9_Template_igx_icon_pointerdown_1_listener($event) {\n      i0.ɵɵrestoreView(_r38);\n      const ctx_r37 = i0.ɵɵnextContext(2);\n      return ctx_r37.onFilteringIconPointerDown($event);\n    })(\"click\", function IgxPivotHeaderRowComponent_div_4_div_9_Template_igx_icon_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r38);\n      const ctx_r39 = i0.ɵɵnextContext(2);\n      return ctx_r39.onFiltersAreaDropdownClick($event);\n    });\n    i0.ɵɵtext(3, \"filter_list\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(4, \"igx-badge\", 44);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r21 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(4);\n    i0.ɵɵpropertyInterpolate(\"value\", ctx_r21.filterDropdownDimensions.size);\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r41 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 29, 30);\n    i0.ɵɵlistener(\"igxDragLeave\", function IgxPivotHeaderRowComponent_div_4_Template_div_igxDragLeave_0_listener($event) {\n      i0.ɵɵrestoreView(_r41);\n\n      const _r17 = i0.ɵɵreference(3);\n\n      const ctx_r40 = i0.ɵɵnextContext();\n      return ctx_r40.onAreaDragLeave($event, _r17);\n    })(\"dropped\", function IgxPivotHeaderRowComponent_div_4_Template_div_dropped_0_listener($event) {\n      i0.ɵɵrestoreView(_r41);\n\n      const _r17 = i0.ɵɵreference(3);\n\n      const ctx_r42 = i0.ɵɵnextContext();\n      return ctx_r42.onDimDrop($event, _r17, 2);\n    })(\"pointerdown\", function IgxPivotHeaderRowComponent_div_4_Template_div_pointerdown_0_listener($event) {\n      return $event.preventDefault();\n    });\n    i0.ɵɵelementStart(2, \"igx-chips-area\", 11, 31);\n    i0.ɵɵtemplate(4, IgxPivotHeaderRowComponent_div_4_span_4_Template, 2, 1, \"span\", 32);\n    i0.ɵɵtemplate(5, IgxPivotHeaderRowComponent_div_4_ng_container_5_Template, 7, 12, \"ng-container\", 33);\n    i0.ɵɵelementStart(6, \"igx-chip\", 34, 35);\n    i0.ɵɵlistener(\"dragDrop\", function IgxPivotHeaderRowComponent_div_4_Template_igx_chip_dragDrop_6_listener($event) {\n      i0.ɵɵrestoreView(_r41);\n\n      const _r17 = i0.ɵɵreference(3);\n\n      const ctx_r44 = i0.ɵɵnextContext();\n      return ctx_r44.onDimDrop($event, _r17, 2);\n    });\n    i0.ɵɵtext(8);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵtemplate(9, IgxPivotHeaderRowComponent_div_4_div_9_Template, 5, 1, \"div\", 36);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"min-width\", ctx_r0.grid.pivotRowWidths - 1, \"px\")(\"max-width\", ctx_r0.grid.pivotRowWidths - 1, \"px\");\n    i0.ɵɵadvance(4);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.grid.filterDimensions.length === 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.filterAreaDimensions);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"hidden\", true)(\"displayDensity\", ctx_r0.grid.displayDensity);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.grid.resourceStrings.igx_grid_pivot_filter_drop_chip, \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.isFiltersButton && ctx_r0.grid.filterDimensions.length !== 0);\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_div_7_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r51 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 37);\n    i0.ɵɵlistener(\"dropped\", function IgxPivotHeaderRowComponent_div_7_span_4_Template_span_dropped_0_listener($event) {\n      i0.ɵɵrestoreView(_r51);\n      i0.ɵɵnextContext();\n\n      const _r46 = i0.ɵɵreference(3);\n\n      const ctx_r50 = i0.ɵɵnextContext();\n      return ctx_r50.onDimDrop($event, _r46, 1);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r47 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r47.grid.resourceStrings.igx_grid_pivot_empty_column_drop_area, \"\");\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_div_7_ng_container_5_igx_icon_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\", 51);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const col_r52 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", col_r52.sortDirection < 2 ? \"arrow_upward\" : \"arrow_downward\", \"\");\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_div_7_ng_container_5_ng_container_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"span\", 38);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n\n    const _r46 = i0.ɵɵreference(3);\n\n    const ctx_r55 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"visibility\", \"hidden\")(\"height\", ctx_r55.getAreaHeight(_r46), \"px\");\n  }\n}\n\nconst _c289 = function () {\n  return {\n    pivotArea: \"column\"\n  };\n};\n\nfunction IgxPivotHeaderRowComponent_div_7_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r58 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"span\", 38);\n    i0.ɵɵelementStart(2, \"igx-chip\", 48);\n    i0.ɵɵlistener(\"remove\", function IgxPivotHeaderRowComponent_div_7_ng_container_5_Template_igx_chip_remove_2_listener($event) {\n      i0.ɵɵrestoreView(_r58);\n      const ctx_r57 = i0.ɵɵnextContext(2);\n      return ctx_r57.columnRemoved($event);\n    })(\"dragOver\", function IgxPivotHeaderRowComponent_div_7_ng_container_5_Template_igx_chip_dragOver_2_listener($event) {\n      i0.ɵɵrestoreView(_r58);\n      const ctx_r59 = i0.ɵɵnextContext(2);\n      return ctx_r59.onDimDragOver($event, 1);\n    })(\"dragLeave\", function IgxPivotHeaderRowComponent_div_7_ng_container_5_Template_igx_chip_dragLeave_2_listener($event) {\n      i0.ɵɵrestoreView(_r58);\n      const ctx_r60 = i0.ɵɵnextContext(2);\n      return ctx_r60.onDimDragLeave($event);\n    })(\"dragDrop\", function IgxPivotHeaderRowComponent_div_7_ng_container_5_Template_igx_chip_dragDrop_2_listener($event) {\n      i0.ɵɵrestoreView(_r58);\n      i0.ɵɵnextContext();\n\n      const _r46 = i0.ɵɵreference(3);\n\n      const ctx_r61 = i0.ɵɵnextContext();\n      return ctx_r61.onDimDrop($event, _r46, 1);\n    })(\"moveStart\", function IgxPivotHeaderRowComponent_div_7_ng_container_5_Template_igx_chip_moveStart_2_listener($event) {\n      i0.ɵɵrestoreView(_r58);\n      i0.ɵɵnextContext();\n\n      const _r46 = i0.ɵɵreference(3);\n\n      const ctx_r62 = i0.ɵɵnextContext();\n      return ctx_r62.onDimDragStart($event, _r46);\n    })(\"moveEnd\", function IgxPivotHeaderRowComponent_div_7_ng_container_5_Template_igx_chip_moveEnd_2_listener() {\n      i0.ɵɵrestoreView(_r58);\n      const ctx_r63 = i0.ɵɵnextContext(2);\n      return ctx_r63.onDimDragEnd();\n    })(\"click\", function IgxPivotHeaderRowComponent_div_7_ng_container_5_Template_igx_chip_click_2_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r58);\n      const col_r52 = restoredCtx.$implicit;\n      const ctx_r64 = i0.ɵɵnextContext(2);\n      return ctx_r64.onChipSort($event, col_r52);\n    });\n    i0.ɵɵelementStart(3, \"igx-icon\", 49);\n    i0.ɵɵtext(4, \"view_column\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"igx-icon\", 40);\n    i0.ɵɵlistener(\"pointerdown\", function IgxPivotHeaderRowComponent_div_7_ng_container_5_Template_igx_icon_pointerdown_5_listener($event) {\n      i0.ɵɵrestoreView(_r58);\n      const ctx_r65 = i0.ɵɵnextContext(2);\n      return ctx_r65.onFilteringIconPointerDown($event);\n    })(\"click\", function IgxPivotHeaderRowComponent_div_7_ng_container_5_Template_igx_icon_click_5_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r58);\n      const col_r52 = restoredCtx.$implicit;\n      const ctx_r66 = i0.ɵɵnextContext(2);\n      return ctx_r66.onFilteringIconClick($event, col_r52);\n    });\n    i0.ɵɵtext(6, \"filter_list\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵtext(7);\n    i0.ɵɵtemplate(8, IgxPivotHeaderRowComponent_div_7_ng_container_5_igx_icon_8_Template, 2, 1, \"igx-icon\", 50);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(9, IgxPivotHeaderRowComponent_div_7_ng_container_5_ng_container_9_Template, 2, 4, \"ng-container\", 13);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const col_r52 = ctx.$implicit;\n    const last_r53 = ctx.last;\n    i0.ɵɵnextContext();\n\n    const _r46 = i0.ɵɵreference(3);\n\n    const ctx_r48 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"visibility\", \"hidden\")(\"height\", ctx_r48.getAreaHeight(_r46), \"px\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"draggable\", true)(\"id\", col_r52.memberName)(\"displayDensity\", ctx_r48.grid.displayDensity)(\"data\", i0.ɵɵpureFunction0(12, _c289))(\"removable\", true);\n    i0.ɵɵadvance(5);\n    i0.ɵɵtextInterpolate1(\" \", col_r52.memberName, \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", col_r52.sortDirection);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", last_r53);\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_div_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r68 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 45, 46);\n    i0.ɵɵlistener(\"dropped\", function IgxPivotHeaderRowComponent_div_7_Template_div_dropped_0_listener($event) {\n      i0.ɵɵrestoreView(_r68);\n\n      const _r46 = i0.ɵɵreference(3);\n\n      const ctx_r67 = i0.ɵɵnextContext();\n      return ctx_r67.onDimDrop($event, _r46, 1);\n    })(\"igxDragLeave\", function IgxPivotHeaderRowComponent_div_7_Template_div_igxDragLeave_0_listener($event) {\n      i0.ɵɵrestoreView(_r68);\n\n      const _r46 = i0.ɵɵreference(3);\n\n      const ctx_r69 = i0.ɵɵnextContext();\n      return ctx_r69.onAreaDragLeave($event, _r46);\n    });\n    i0.ɵɵelementStart(2, \"igx-chips-area\", 11, 47);\n    i0.ɵɵtemplate(4, IgxPivotHeaderRowComponent_div_7_span_4_Template, 2, 1, \"span\", 32);\n    i0.ɵɵtemplate(5, IgxPivotHeaderRowComponent_div_7_ng_container_5_Template, 10, 13, \"ng-container\", 33);\n    i0.ɵɵelementStart(6, \"igx-chip\", 34, 35);\n    i0.ɵɵlistener(\"dragDrop\", function IgxPivotHeaderRowComponent_div_7_Template_igx_chip_dragDrop_6_listener($event) {\n      i0.ɵɵrestoreView(_r68);\n\n      const _r46 = i0.ɵɵreference(3);\n\n      const ctx_r70 = i0.ɵɵnextContext();\n      return ctx_r70.onDimDrop($event, _r46, 1);\n    });\n    i0.ɵɵtext(8);\n    i0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(4);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.grid.columnDimensions.length === 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.grid.columnDimensions);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"hidden\", true)(\"displayDensity\", ctx_r1.grid.displayDensity);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.grid.resourceStrings.igx_grid_pivot_column_drop_chip, \" \");\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_div_8_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r77 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 37);\n    i0.ɵɵlistener(\"dropped\", function IgxPivotHeaderRowComponent_div_8_span_4_Template_span_dropped_0_listener($event) {\n      i0.ɵɵrestoreView(_r77);\n      i0.ɵɵnextContext();\n\n      const _r72 = i0.ɵɵreference(3);\n\n      const ctx_r76 = i0.ɵɵnextContext();\n      return ctx_r76.onValueDrop($event, _r72);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r73 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r73.grid.resourceStrings.igx_grid_pivot_empty_value_drop_area);\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_div_8_ng_container_5_ng_container_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"span\", 38);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n\n    const _r72 = i0.ɵɵreference(3);\n\n    const ctx_r81 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"visibility\", \"hidden\")(\"height\", ctx_r81.getAreaHeight(_r72), \"px\");\n  }\n}\n\nconst _c290 = function () {\n  return {\n    pivotArea: \"value\"\n  };\n};\n\nfunction IgxPivotHeaderRowComponent_div_8_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r83 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"span\", 38);\n    i0.ɵɵelementStart(2, \"igx-chip\", 56, 57);\n    i0.ɵɵlistener(\"remove\", function IgxPivotHeaderRowComponent_div_8_ng_container_5_Template_igx_chip_remove_2_listener($event) {\n      i0.ɵɵrestoreView(_r83);\n      const ctx_r82 = i0.ɵɵnextContext(2);\n      return ctx_r82.valueRemoved($event);\n    })(\"dragLeave\", function IgxPivotHeaderRowComponent_div_8_ng_container_5_Template_igx_chip_dragLeave_2_listener($event) {\n      i0.ɵɵrestoreView(_r83);\n      const ctx_r84 = i0.ɵɵnextContext(2);\n      return ctx_r84.onDimDragLeave($event);\n    })(\"dragOver\", function IgxPivotHeaderRowComponent_div_8_ng_container_5_Template_igx_chip_dragOver_2_listener($event) {\n      i0.ɵɵrestoreView(_r83);\n      const ctx_r85 = i0.ɵɵnextContext(2);\n      return ctx_r85.onDimDragOver($event);\n    })(\"dragDrop\", function IgxPivotHeaderRowComponent_div_8_ng_container_5_Template_igx_chip_dragDrop_2_listener($event) {\n      i0.ɵɵrestoreView(_r83);\n      i0.ɵɵnextContext();\n\n      const _r72 = i0.ɵɵreference(3);\n\n      const ctx_r86 = i0.ɵɵnextContext();\n      return ctx_r86.onValueDrop($event, _r72);\n    });\n    i0.ɵɵelementStart(4, \"div\", 58);\n    i0.ɵɵlistener(\"click\", function IgxPivotHeaderRowComponent_div_8_ng_container_5_Template_div_click_4_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r83);\n      const value_r78 = restoredCtx.$implicit;\n\n      const _r80 = i0.ɵɵreference(3);\n\n      const ctx_r87 = i0.ɵɵnextContext(2);\n\n      const _r9 = i0.ɵɵreference(22);\n\n      return ctx_r87.onSummaryClick($event, value_r78, _r9, _r80);\n    })(\"pointerdown\", function IgxPivotHeaderRowComponent_div_8_ng_container_5_Template_div_pointerdown_4_listener($event) {\n      return $event.stopPropagation();\n    });\n    i0.ɵɵelementStart(5, \"igx-icon\");\n    i0.ɵɵtext(6, \"functions\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(7, \"igx-icon\");\n    i0.ɵɵtext(8, \"arrow_drop_down\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵtext(9);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(10, IgxPivotHeaderRowComponent_div_8_ng_container_5_ng_container_10_Template, 2, 4, \"ng-container\", 13);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const value_r78 = ctx.$implicit;\n    const last_r79 = ctx.last;\n    i0.ɵɵnextContext();\n\n    const _r72 = i0.ɵɵreference(3);\n\n    const ctx_r74 = i0.ɵɵnextContext();\n\n    const _r9 = i0.ɵɵreference(22);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"visibility\", \"hidden\")(\"height\", ctx_r74.getAreaHeight(_r72), \"px\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"draggable\", true)(\"id\", value_r78.displayName || value_r78.member)(\"data\", i0.ɵɵpureFunction0(13, _c290))(\"displayDensity\", ctx_r74.grid.displayDensity)(\"removable\", true);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"igxDropDownItemNavigation\", _r9);\n    i0.ɵɵadvance(5);\n    i0.ɵɵtextInterpolate2(\" \", value_r78.aggregate.key, \"(\", value_r78.displayName || value_r78.member, \") \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", last_r79);\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_div_8_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r91 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 52, 53);\n    i0.ɵɵlistener(\"pointerdown\", function IgxPivotHeaderRowComponent_div_8_Template_div_pointerdown_0_listener($event) {\n      return $event.preventDefault();\n    })(\"dropped\", function IgxPivotHeaderRowComponent_div_8_Template_div_dropped_0_listener($event) {\n      i0.ɵɵrestoreView(_r91);\n\n      const _r72 = i0.ɵɵreference(3);\n\n      const ctx_r90 = i0.ɵɵnextContext();\n      return ctx_r90.onValueDrop($event, _r72);\n    })(\"igxDragLeave\", function IgxPivotHeaderRowComponent_div_8_Template_div_igxDragLeave_0_listener($event) {\n      i0.ɵɵrestoreView(_r91);\n\n      const _r72 = i0.ɵɵreference(3);\n\n      const ctx_r92 = i0.ɵɵnextContext();\n      return ctx_r92.onAreaDragLeave($event, _r72);\n    });\n    i0.ɵɵelementStart(2, \"igx-chips-area\", 11, 54);\n    i0.ɵɵtemplate(4, IgxPivotHeaderRowComponent_div_8_span_4_Template, 2, 1, \"span\", 32);\n    i0.ɵɵtemplate(5, IgxPivotHeaderRowComponent_div_8_ng_container_5_Template, 11, 14, \"ng-container\", 33);\n    i0.ɵɵelementStart(6, \"igx-chip\", 34, 55);\n    i0.ɵɵlistener(\"dragDrop\", function IgxPivotHeaderRowComponent_div_8_Template_igx_chip_dragDrop_6_listener($event) {\n      i0.ɵɵrestoreView(_r91);\n\n      const _r72 = i0.ɵɵreference(3);\n\n      const ctx_r93 = i0.ɵɵnextContext();\n      return ctx_r93.onValueDrop($event, _r72);\n    });\n    i0.ɵɵtext(8);\n    i0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(4);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.grid.values.length === 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r2.grid.values);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"hidden\", true)(\"displayDensity\", ctx_r2.grid.displayDensity);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r2.grid.resourceStrings.igx_grid_pivot_value_drop_chip, \" \");\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_ng_container_15_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r98 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"span\", 37);\n    i0.ɵɵlistener(\"dropped\", function IgxPivotHeaderRowComponent_ng_container_15_span_1_Template_span_dropped_0_listener($event) {\n      i0.ɵɵrestoreView(_r98);\n      const ctx_r97 = i0.ɵɵnextContext(2);\n\n      const _r4 = i0.ɵɵreference(14);\n\n      return ctx_r97.onDimDrop($event, _r4, 0);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r94 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r94.grid.resourceStrings.igx_grid_pivot_empty_row_drop_area);\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_ng_container_15_ng_container_2_igx_icon_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\", 51);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const row_r99 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", row_r99.sortDirection < 2 ? \"arrow_upward\" : \"arrow_downward\", \"\");\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_ng_container_15_ng_container_2_ng_container_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"span\", 38);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r102 = i0.ɵɵnextContext(3);\n\n    const _r4 = i0.ɵɵreference(14);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"visibility\", \"hidden\")(\"height\", ctx_r102.getAreaHeight(_r4), \"px\");\n  }\n}\n\nconst _c291 = function () {\n  return {\n    pivotArea: \"row\"\n  };\n};\n\nfunction IgxPivotHeaderRowComponent_ng_container_15_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r105 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"span\", 38);\n    i0.ɵɵelementStart(2, \"igx-chip\", 59);\n    i0.ɵɵlistener(\"remove\", function IgxPivotHeaderRowComponent_ng_container_15_ng_container_2_Template_igx_chip_remove_2_listener($event) {\n      i0.ɵɵrestoreView(_r105);\n      const ctx_r104 = i0.ɵɵnextContext(2);\n      return ctx_r104.rowRemoved($event);\n    })(\"dragLeave\", function IgxPivotHeaderRowComponent_ng_container_15_ng_container_2_Template_igx_chip_dragLeave_2_listener($event) {\n      i0.ɵɵrestoreView(_r105);\n      const ctx_r106 = i0.ɵɵnextContext(2);\n      return ctx_r106.onDimDragLeave($event);\n    })(\"dragDrop\", function IgxPivotHeaderRowComponent_ng_container_15_ng_container_2_Template_igx_chip_dragDrop_2_listener($event) {\n      i0.ɵɵrestoreView(_r105);\n      const ctx_r107 = i0.ɵɵnextContext(2);\n\n      const _r4 = i0.ɵɵreference(14);\n\n      return ctx_r107.onDimDrop($event, _r4, 0);\n    })(\"dragOver\", function IgxPivotHeaderRowComponent_ng_container_15_ng_container_2_Template_igx_chip_dragOver_2_listener($event) {\n      i0.ɵɵrestoreView(_r105);\n      const ctx_r108 = i0.ɵɵnextContext(2);\n      return ctx_r108.onDimDragOver($event, 0);\n    })(\"moveStart\", function IgxPivotHeaderRowComponent_ng_container_15_ng_container_2_Template_igx_chip_moveStart_2_listener($event) {\n      i0.ɵɵrestoreView(_r105);\n      const ctx_r109 = i0.ɵɵnextContext(2);\n\n      const _r4 = i0.ɵɵreference(14);\n\n      return ctx_r109.onDimDragStart($event, _r4);\n    })(\"moveEnd\", function IgxPivotHeaderRowComponent_ng_container_15_ng_container_2_Template_igx_chip_moveEnd_2_listener() {\n      i0.ɵɵrestoreView(_r105);\n      const ctx_r110 = i0.ɵɵnextContext(2);\n      return ctx_r110.onDimDragEnd();\n    })(\"click\", function IgxPivotHeaderRowComponent_ng_container_15_ng_container_2_Template_igx_chip_click_2_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r105);\n      const row_r99 = restoredCtx.$implicit;\n      const ctx_r111 = i0.ɵɵnextContext(2);\n      return ctx_r111.onChipSort($event, row_r99);\n    });\n    i0.ɵɵelementStart(3, \"igx-icon\", 49);\n    i0.ɵɵtext(4, \"table_rows\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"igx-icon\", 40);\n    i0.ɵɵlistener(\"pointerdown\", function IgxPivotHeaderRowComponent_ng_container_15_ng_container_2_Template_igx_icon_pointerdown_5_listener($event) {\n      i0.ɵɵrestoreView(_r105);\n      const ctx_r112 = i0.ɵɵnextContext(2);\n      return ctx_r112.onFilteringIconPointerDown($event);\n    })(\"click\", function IgxPivotHeaderRowComponent_ng_container_15_ng_container_2_Template_igx_icon_click_5_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r105);\n      const row_r99 = restoredCtx.$implicit;\n      const ctx_r113 = i0.ɵɵnextContext(2);\n      return ctx_r113.onFilteringIconClick($event, row_r99);\n    });\n    i0.ɵɵtext(6, \"filter_list\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵtext(7);\n    i0.ɵɵtemplate(8, IgxPivotHeaderRowComponent_ng_container_15_ng_container_2_igx_icon_8_Template, 2, 1, \"igx-icon\", 50);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(9, IgxPivotHeaderRowComponent_ng_container_15_ng_container_2_ng_container_9_Template, 2, 4, \"ng-container\", 13);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const row_r99 = ctx.$implicit;\n    const last_r100 = ctx.last;\n    const ctx_r95 = i0.ɵɵnextContext(2);\n\n    const _r4 = i0.ɵɵreference(14);\n\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"visibility\", \"hidden\")(\"height\", ctx_r95.getAreaHeight(_r4), \"px\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"draggable\", true)(\"id\", row_r99.memberName)(\"displayDensity\", ctx_r95.grid.displayDensity)(\"data\", i0.ɵɵpureFunction0(12, _c291))(\"removable\", true);\n    i0.ɵɵadvance(5);\n    i0.ɵɵtextInterpolate1(\" \", row_r99.memberName, \" \");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", row_r99.sortDirection);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", last_r100);\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_ng_container_15_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r115 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxPivotHeaderRowComponent_ng_container_15_span_1_Template, 2, 1, \"span\", 32);\n    i0.ɵɵtemplate(2, IgxPivotHeaderRowComponent_ng_container_15_ng_container_2_Template, 10, 13, \"ng-container\", 33);\n    i0.ɵɵelementStart(3, \"igx-chip\", 34, 35);\n    i0.ɵɵlistener(\"dragDrop\", function IgxPivotHeaderRowComponent_ng_container_15_Template_igx_chip_dragDrop_3_listener($event) {\n      i0.ɵɵrestoreView(_r115);\n      const ctx_r114 = i0.ɵɵnextContext();\n\n      const _r4 = i0.ɵɵreference(14);\n\n      return ctx_r114.onDimDrop($event, _r4, 0);\n    });\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.grid.rowDimensions.length === 0 && ctx_r5.grid.showPivotConfigurationUI);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r5.grid.rowDimensions);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"hidden\", true)(\"displayDensity\", ctx_r5.grid.displayDensity);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r5.grid.resourceStrings.igx_grid_pivot_row_drop_chip, \" \");\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_ng_container_16_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r119 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-grid-header-group\", 60);\n    i0.ɵɵlistener(\"pointerdown\", function IgxPivotHeaderRowComponent_ng_container_16_ng_container_1_Template_igx_grid_header_group_pointerdown_1_listener($event) {\n      i0.ɵɵrestoreView(_r119);\n      const ctx_r118 = i0.ɵɵnextContext(2);\n      return ctx_r118.grid.navigation.focusOutRowHeader($event);\n    });\n    i0.ɵɵpipe(2, \"igxHeaderGroupWidth\");\n    i0.ɵɵpipe(3, \"igxHeaderGroupWidth\");\n    i0.ɵɵpipe(4, \"igxHeaderGroupStyle\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const column_r117 = ctx.$implicit;\n    const ctx_r116 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"min-width\", i0.ɵɵpipeBind3(2, 7, column_r117.calcWidth, ctx_r116.grid.defaultHeaderGroupMinWidth, ctx_r116.hasMRL))(\"flex-basis\", i0.ɵɵpipeBind3(3, 11, column_r117.calcWidth, ctx_r116.grid.defaultHeaderGroupMinWidth, ctx_r116.hasMRL));\n    i0.ɵɵproperty(\"ngClass\", column_r117.headerGroupClasses)(\"ngStyle\", i0.ɵɵpipeBind3(4, 15, column_r117.headerGroupStyles, column_r117, ctx_r116.grid.pipeTrigger))(\"column\", column_r117);\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_ng_container_16_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxPivotHeaderRowComponent_ng_container_16_ng_container_1_Template, 5, 19, \"ng-container\", 33);\n    i0.ɵɵpipe(2, \"igxTopLevel\");\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBind1(2, 1, ctx_r6.pinnedColumnCollection));\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_div_18_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-grid-header-group\", 64);\n    i0.ɵɵpipe(1, \"igxHeaderGroupWidth\");\n    i0.ɵɵpipe(2, \"igxHeaderGroupWidth\");\n    i0.ɵɵpipe(3, \"igxHeaderGroupStyle\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const column_r124 = ctx.$implicit;\n    const i_r121 = i0.ɵɵnextContext().index;\n    const ctx_r123 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"height\", ctx_r123.totalDepth > 1 ? ctx_r123.calcHeight(column_r124, i_r121) : undefined, \"px\")(\"min-width\", i0.ɵɵpipeBind3(1, 13, column_r124.calcWidth, ctx_r123.grid.defaultHeaderGroupMinWidth, ctx_r123.hasMRL))(\"flex-basis\", i0.ɵɵpipeBind3(2, 17, column_r124.calcWidth, ctx_r123.grid.defaultHeaderGroupMinWidth, ctx_r123.hasMRL));\n    i0.ɵɵclassProp(\"igx-grid__tr-pivot--columnDimensionLeaf\", ctx_r123.isDuplicateOfExistingParent(column_r124, i_r121))(\"igx-grid__tr-pivot--columnMultiRowSpan\", ctx_r123.isMultiRow(column_r124, i_r121));\n    i0.ɵɵproperty(\"ngClass\", column_r124.headerGroupClasses)(\"ngStyle\", i0.ɵɵpipeBind3(3, 21, column_r124.headerGroupStyles, column_r124, ctx_r123.grid.pipeTrigger))(\"column\", column_r124);\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_div_18_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 61);\n    i0.ɵɵtemplate(1, IgxPivotHeaderRowComponent_div_18_ng_template_1_Template, 4, 25, \"ng-template\", 62, 63, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const dimLevelColumns_r120 = ctx.$implicit;\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"height\", ctx_r7.totalDepth > 1 ? ctx_r7.grid.rowHeight : undefined, \"px\")(\"width\", ctx_r7.grid.unpinnedWidth, \"px\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"igxGridForOf\", dimLevelColumns_r120)(\"igxGridForOfUniqueSizeCache\", true)(\"igxForScrollContainer\", ctx_r7.grid.parentVirtDir)(\"igxForContainerSize\", ctx_r7.grid.unpinnedWidth)(\"igxForTrackBy\", ctx_r7.grid.trackColumnChanges)(\"igxForSizePropName\", \"calcPixelWidth\")(\"igxForScrollOrientation\", \"horizontal\");\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_ng_container_19_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r129 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"igx-grid-header-group\", 60);\n    i0.ɵɵlistener(\"pointerdown\", function IgxPivotHeaderRowComponent_ng_container_19_ng_container_1_Template_igx_grid_header_group_pointerdown_1_listener($event) {\n      i0.ɵɵrestoreView(_r129);\n      const ctx_r128 = i0.ɵɵnextContext(2);\n      return ctx_r128.grid.navigation.focusOutRowHeader($event);\n    });\n    i0.ɵɵpipe(2, \"igxHeaderGroupWidth\");\n    i0.ɵɵpipe(3, \"igxHeaderGroupWidth\");\n    i0.ɵɵpipe(4, \"igxHeaderGroupStyle\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const column_r127 = ctx.$implicit;\n    const ctx_r126 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"min-width\", i0.ɵɵpipeBind3(2, 9, column_r127.calcWidth, ctx_r126.grid.defaultHeaderGroupMinWidth, ctx_r126.hasMRL))(\"flex-basis\", i0.ɵɵpipeBind3(3, 13, column_r127.calcWidth, ctx_r126.grid.defaultHeaderGroupMinWidth, ctx_r126.hasMRL))(\"left\", column_r127.rightPinnedOffset);\n    i0.ɵɵproperty(\"ngClass\", column_r127.headerGroupClasses)(\"ngStyle\", i0.ɵɵpipeBind3(4, 17, column_r127.headerGroupStyles, column_r127, ctx_r126.grid.pipeTrigger))(\"column\", column_r127);\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_ng_container_19_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxPivotHeaderRowComponent_ng_container_19_ng_container_1_Template, 5, 21, \"ng-container\", 33);\n    i0.ɵɵpipe(2, \"igxTopLevel\");\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBind1(2, 1, ctx_r8.pinnedColumnCollection));\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_igx_drop_down_item_23_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-drop-down-item\", 65);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r130 = ctx.$implicit;\n    const ctx_r10 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"selected\", ctx_r10.isSelected(item_r130))(\"value\", item_r130);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", item_r130.label, \" \");\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_igx_chip_30_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r133 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-chip\", 66);\n    i0.ɵɵlistener(\"remove\", function IgxPivotHeaderRowComponent_igx_chip_30_Template_igx_chip_remove_0_listener($event) {\n      i0.ɵɵrestoreView(_r133);\n      const ctx_r132 = i0.ɵɵnextContext();\n      return ctx_r132.filterRemoved($event);\n    })(\"chipClick\", function IgxPivotHeaderRowComponent_igx_chip_30_Template_igx_chip_chipClick_0_listener($event) {\n      i0.ɵɵrestoreView(_r133);\n      const ctx_r134 = i0.ɵɵnextContext();\n      return ctx_r134.onFiltersSelectionChanged($event);\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const filter_r131 = ctx.$implicit;\n    const ctx_r13 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"id\", filter_r131.memberName)(\"displayDensity\", ctx_r13.grid.displayDensity)(\"removable\", true)(\"selectable\", true)(\"selected\", filter_r131 === ctx_r13.filterDropdownDimensions.values().next().value);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", filter_r131.memberName, \" \");\n  }\n}\n\nfunction IgxPivotHeaderRowComponent_igx_chip_36_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r137 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-chip\", 67);\n    i0.ɵɵlistener(\"remove\", function IgxPivotHeaderRowComponent_igx_chip_36_Template_igx_chip_remove_0_listener($event) {\n      i0.ɵɵrestoreView(_r137);\n      const ctx_r136 = i0.ɵɵnextContext();\n      return ctx_r136.filterRemoved($event);\n    });\n    i0.ɵɵelementStart(1, \"igx-icon\", 49);\n    i0.ɵɵtext(2, \"filter_list\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const filter_r135 = ctx.$implicit;\n    const ctx_r15 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"id\", filter_r135.memberName)(\"draggable\", true)(\"displayDensity\", ctx_r15.grid.displayDensity)(\"removable\", true);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate1(\" \", filter_r135.memberName, \" \");\n  }\n}\n\nfunction IgxPivotRowDimensionHeaderComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 6);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"title\", ctx_r1.title);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.column.header || ctx_r1.column.field);\n  }\n}\n\nfunction IgxPivotRowDimensionHeaderComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1, \"more_vert\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxPivotRowDimensionHeaderComponent_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r5.sortDirection < 2 ? \"arrow_upward\" : \"arrow_downward\");\n  }\n}\n\nfunction IgxPivotRowDimensionHeaderComponent_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxPivotRowDimensionHeaderComponent_ng_container_8_ng_container_2_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxPivotRowDimensionHeaderComponent_ng_container_8_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 8);\n    i0.ɵɵlistener(\"click\", function IgxPivotRowDimensionHeaderComponent_ng_container_8_ng_container_2_Template_div_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r11 = i0.ɵɵnextContext(2);\n      return ctx_r11.onSortingIconClick($event);\n    })(\"pointerdown\", function IgxPivotRowDimensionHeaderComponent_ng_container_8_ng_container_2_Template_div_pointerdown_1_listener($event) {\n      return $event.stopPropagation();\n    });\n    i0.ɵɵpipe(2, \"sortingIndex\");\n    i0.ɵɵtemplate(3, IgxPivotRowDimensionHeaderComponent_ng_container_8_ng_container_2_ng_container_3_Template, 1, 0, \"ng-container\", 4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"data-sortIndex\", i0.ɵɵpipeBind2(2, 4, ctx_r8.column.field, ctx_r8.grid.sortingExpressions))(\"draggable\", false);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r8.sortIconTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(7, _c24, ctx_r8));\n  }\n}\n\nfunction IgxPivotRowDimensionHeaderComponent_ng_container_8_ng_container_3_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxPivotRowDimensionHeaderComponent_ng_container_8_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r16 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 9);\n    i0.ɵɵlistener(\"click\", function IgxPivotRowDimensionHeaderComponent_ng_container_8_ng_container_3_Template_div_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r15 = i0.ɵɵnextContext(2);\n      return ctx_r15.onFilteringIconClick($event);\n    })(\"pointerdown\", function IgxPivotRowDimensionHeaderComponent_ng_container_8_ng_container_3_Template_div_pointerdown_1_listener($event) {\n      return $event.stopPropagation();\n    });\n    i0.ɵɵtemplate(2, IgxPivotRowDimensionHeaderComponent_ng_container_8_ng_container_3_ng_container_2_Template, 1, 0, \"ng-container\", 4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngClass\", ctx_r9.filterIconClassName);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r9.esfIconTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(3, _c24, ctx_r9));\n  }\n}\n\nfunction IgxPivotRowDimensionHeaderComponent_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 7);\n    i0.ɵɵtemplate(2, IgxPivotRowDimensionHeaderComponent_ng_container_8_ng_container_2_Template, 4, 9, \"ng-container\", 5);\n    i0.ɵɵtemplate(3, IgxPivotRowDimensionHeaderComponent_ng_container_8_ng_container_3_Template, 3, 5, \"ng-container\", 5);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.column.sortable);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.grid.allowFiltering && ctx_r7.column.filterable && ctx_r7.grid.filterMode === \"excelStyleFilter\");\n  }\n}\n\nfunction IgxPivotRowDimensionHeaderGroupComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 3);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"title\", ctx_r1.title);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r1.column.header);\n  }\n}\n\nfunction IgxPivotRowDimensionHeaderGroupComponent_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"draggable\", false);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r3.column.expanded ? \"expand_more\" : \"chevron_right\", \" \");\n  }\n}\n\nfunction IgxPivotRowDimensionHeaderGroupComponent_ng_container_4_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 9);\n  }\n}\n\nfunction IgxPivotRowDimensionHeaderGroupComponent_ng_container_4_igx_grid_filtering_cell_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-grid-filtering-cell\", 10);\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"column\", ctx_r6.column);\n    i0.ɵɵattribute(\"draggable\", false);\n  }\n}\n\nfunction IgxPivotRowDimensionHeaderGroupComponent_ng_container_4_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 11);\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"cursor\", ctx_r7.colResizingService.resizeCursor);\n    i0.ɵɵproperty(\"igxPivotResizeHandle\", ctx_r7.column)(\"igxPivotResizeHandleHeader\", ctx_r7);\n    i0.ɵɵattribute(\"draggable\", false);\n  }\n}\n\nfunction IgxPivotRowDimensionHeaderGroupComponent_ng_container_4_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 12);\n  }\n}\n\nfunction IgxPivotRowDimensionHeaderGroupComponent_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, IgxPivotRowDimensionHeaderGroupComponent_ng_container_4_span_1_Template, 1, 0, \"span\", 4);\n    i0.ɵɵelementStart(2, \"igx-pivot-row-dimension-header\", 5);\n    i0.ɵɵlistener(\"pointerdown\", function IgxPivotRowDimensionHeaderGroupComponent_ng_container_4_Template_igx_pivot_row_dimension_header_pointerdown_2_listener($event) {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return ctx_r9.pointerdown($event);\n    });\n    i0.ɵɵpipe(3, \"igxHeaderGroupStyle\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(4, IgxPivotRowDimensionHeaderGroupComponent_ng_container_4_igx_grid_filtering_cell_4_Template, 1, 2, \"igx-grid-filtering-cell\", 6);\n    i0.ɵɵtemplate(5, IgxPivotRowDimensionHeaderGroupComponent_ng_container_4_span_5_Template, 1, 5, \"span\", 7);\n    i0.ɵɵtemplate(6, IgxPivotRowDimensionHeaderGroupComponent_ng_container_4_span_6_Template, 1, 0, \"span\", 8);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.grid.hasMovableColumns);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"id\", ctx_r4.grid.id + \"_\" + ctx_r4.column.field)(\"ngClass\", ctx_r4.column.headerClasses)(\"ngStyle\", i0.ɵɵpipeBind3(3, 13, ctx_r4.column.headerStyles, ctx_r4.column, ctx_r4.grid.pipeTrigger))(\"igxColumnMovingDrag\", ctx_r4.column)(\"ghostHost\", ctx_r4.grid.outlet.nativeElement)(\"igxColumnMovingDrop\", ctx_r4.column)(\"column\", ctx_r4.column)(\"density\", ctx_r4.grid.displayDensity);\n    i0.ɵɵattribute(\"droppable\", true);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.grid.allowFiltering && ctx_r4.grid.filterMode === \"quickFilter\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r4.column.columnGroup && ctx_r4.column.resizable);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.grid.hasMovableColumns);\n  }\n}\n\nconst _c292 = [\"headerDefaultTemplate\"];\n\nfunction IgxPivotRowDimensionContentComponent_ng_template_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\")(1, \"igx-icon\", 5);\n    i0.ɵɵlistener(\"click\", function IgxPivotRowDimensionContentComponent_ng_template_6_Template_igx_icon_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return ctx_r5.toggleRowDimension($event);\n    });\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const column_r4 = ctx.$implicit;\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵclassMapInterpolate1(\"igx-grid__tr--header igx-grid__row-indentation--level-\", ctx_r1.getLevel(), \"\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"draggable\", false);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.getExpandState() ? \"expand_more\" : \"chevron_right\", \"\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", column_r4.header, \" \");\n  }\n}\n\nfunction IgxPivotRowDimensionContentComponent_ng_template_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵelement(1, \"igx-icon\", 6);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const column_r7 = ctx.$implicit;\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵclassMapInterpolate1(\"igx-grid__tr--header igx-grid__row-indentation--level-\", ctx_r3.getLevel(), \"\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"draggable\", false);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", column_r7.header, \" \");\n  }\n}\n\nfunction IgxPivotRowComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-grid-cell\", 3, 4);\n    i0.ɵɵlistener(\"pointerdown\", function IgxPivotRowComponent_ng_template_0_Template_igx_grid_cell_pointerdown_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return ctx_r7.grid.navigation.focusOutRowHeader($event);\n    });\n    i0.ɵɵpipe(2, \"transactionState\");\n    i0.ɵɵpipe(3, \"igxStringReplace\");\n    i0.ɵɵpipe(4, \"igxCellStyleClasses\");\n    i0.ɵɵpipe(5, \"igxCellStyles\");\n    i0.ɵɵpipe(6, \"dataMapper\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const col_r4 = ctx.$implicit;\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"min-height\", ctx_r1.cellHeight, \"px\")(\"min-width\", col_r4.width)(\"max-width\", col_r4.width)(\"flex-basis\", col_r4.width);\n    i0.ɵɵclassProp(\"igx-grid__td--edited\", i0.ɵɵpipeBindV(2, 30, i0.ɵɵpureFunction7(62, _c214, ctx_r1.key, col_r4.field, ctx_r1.grid.rowEditable, ctx_r1.grid.transactions, ctx_r1.grid.pipeTrigger, ctx_r1.grid.gridAPI.crudService.cell, ctx_r1.grid.gridAPI.crudService.row)))(\"igx-grid__td--number\", col_r4.dataType === \"number\" || col_r4.dataType === \"percent\" || col_r4.dataType === \"currency\")(\"igx-grid__td--bool\", col_r4.dataType === \"boolean\");\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpipeBindV(4, 42, i0.ɵɵpureFunction6(70, _c215, ctx_r1.getCellClass(col_r4), ctx_r1.data[col_r4.field], ctx_r1.pivotAggregationData, col_r4.field, ctx_r1.viewIndex, ctx_r1.grid.pipeTrigger)))(\"ngStyle\", i0.ɵɵpipeBindV(5, 49, i0.ɵɵpureFunction6(77, _c215, col_r4.cellStyles, ctx_r1.pivotAggregationData[col_r4.field], ctx_r1.pivotAggregationData, col_r4.field, ctx_r1.viewIndex, ctx_r1.grid.pipeTrigger)))(\"editMode\", col_r4.editable && ctx_r1.grid.crudService.targetInEdit(ctx_r1.index, col_r4.index))(\"column\", col_r4)(\"formatter\", col_r4.formatter)(\"intRow\", ctx_r1)(\"active\", ctx_r1.isCellActive(col_r4.visibleIndex))(\"rowData\", ctx_r1.pivotAggregationData)(\"width\", col_r4.getCellWidth())(\"visibleColumnIndex\", col_r4.visibleIndex)(\"value\", i0.ɵɵpipeBindV(6, 56, i0.ɵɵpureFunction5(84, _c71, ctx_r1.pivotAggregationData[col_r4.field], col_r4.field, ctx_r1.grid.pipeTrigger, ctx_r1.pivotAggregationData[col_r4.field], col_r4.hasNestedPath)))(\"cellTemplate\", col_r4.bodyTemplate)(\"lastSearchInfo\", ctx_r1.grid.lastSearchInfo)(\"cellSelectionMode\", ctx_r1.grid.cellSelection)(\"displayPinnedChip\", ctx_r1.shouldDisplayPinnedChip(col_r4.visibleIndex));\n    i0.ɵɵattribute(\"aria-describedby\", i0.ɵɵpipeBind3(3, 38, ctx_r1.gridID + \"_\" + col_r4.field, \".\", \"_\"));\n  }\n}\n\nfunction IgxPivotRowComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 5);\n    i0.ɵɵelement(1, \"igx-checkbox\", 6);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"tabindex\", -1)(\"readonly\", true)(\"checked\", ctx_r3.selected)(\"disableRipple\", true)(\"disabled\", ctx_r3.deleted)(\"disableTransitions\", ctx_r3.grid.disableTransitions)(\"aria-label\", ctx_r3.rowCheckboxAriaLabel);\n  }\n}\n\nconst _c293 = [\"emptyPivotGridTemplate\"];\nconst _c294 = [\"verticalRowDimScrollContainer\"];\n\nfunction IgxPivotGridComponent_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxPivotGridComponent_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 51);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"igxColumnMovingDrop\", ctx_r2.headerContainer);\n    i0.ɵɵattribute(\"droppable\", true);\n  }\n}\n\nfunction IgxPivotGridComponent_span_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 52);\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"left\", ctx_r3.pinnedWidth, \"px\");\n    i0.ɵɵproperty(\"igxColumnMovingDrop\", ctx_r3.headerContainer);\n    i0.ɵɵattribute(\"droppable\", true);\n  }\n}\n\nfunction IgxPivotGridComponent_ng_template_8_ng_template_0_Template(rf, ctx) {}\n\nfunction IgxPivotGridComponent_ng_template_8_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r42 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵtemplate(0, IgxPivotGridComponent_ng_template_8_ng_template_0_Template, 0, 0, \"ng-template\", 53);\n    i0.ɵɵlistener(\"cachedViewLoaded\", function IgxPivotGridComponent_ng_template_8_Template_ng_template_cachedViewLoaded_0_listener($event) {\n      i0.ɵɵrestoreView(_r42);\n      const ctx_r41 = i0.ɵɵnextContext();\n      return ctx_r41.cachedViewLoaded($event);\n    });\n  }\n\n  if (rf & 2) {\n    const rowData_r38 = ctx.$implicit;\n    const rowIndex_r39 = ctx.index;\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"igxTemplateOutlet\", ctx_r5.recordTemplate)(\"igxTemplateOutletContext\", ctx_r5.getContext(rowData_r38, rowIndex_r39));\n  }\n}\n\nfunction IgxPivotGridComponent_ng_template_17_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-pivot-row\", 54, 55);\n    i0.ɵɵpipe(2, \"igxGridRowClasses\");\n    i0.ɵɵpipe(3, \"igxGridRowStyles\");\n  }\n\n  if (rf & 2) {\n    const rowIndex_r43 = ctx.index;\n    const rowData_r44 = ctx.$implicit;\n\n    const _r45 = i0.ɵɵreference(1);\n\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"height\", ctx_r7.renderedRowHeight, \"px\");\n    i0.ɵɵproperty(\"gridID\", ctx_r7.id)(\"index\", rowIndex_r43)(\"data\", rowData_r44)(\"ngClass\", i0.ɵɵpipeBindV(2, 7, i0.ɵɵpureFunctionV(25, _c223, [ctx_r7.rowClasses, _r45, _r45.inEditMode, _r45.selected, _r45.dirty, _r45.deleted, _r45.dragging, rowIndex_r43, ctx_r7.hasColumnLayouts, rowData_r44, ctx_r7.pipeTrigger])))(\"ngStyle\", i0.ɵɵpipeBind4(3, 20, ctx_r7.rowStyles, rowData_r44, rowIndex_r43, ctx_r7.pipeTrigger));\n  }\n}\n\nfunction IgxPivotGridComponent_ng_container_19_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction IgxPivotGridComponent_igx_circular_bar_23_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-circular-bar\", 56);\n  }\n\n  if (rf & 2) {\n    i0.ɵɵproperty(\"indeterminate\", true);\n  }\n}\n\nfunction IgxPivotGridComponent_span_24_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 57);\n  }\n\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"igxColumnMovingDrop\", ctx_r11.headerContainer);\n    i0.ɵɵattribute(\"droppable\", true);\n  }\n}\n\nfunction IgxPivotGridComponent_ng_template_28_Template(rf, ctx) {}\n\nfunction IgxPivotGridComponent_ng_template_41_Template(rf, ctx) {}\n\nfunction IgxPivotGridComponent_ng_template_49_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 58)(1, \"span\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r22 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r22.emptyFilteredGridMessage);\n  }\n}\n\nfunction IgxPivotGridComponent_ng_template_51_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 58)(1, \"span\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r24 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r24.emptyGridMessage);\n  }\n}\n\nfunction IgxPivotGridComponent_ng_template_53_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 59);\n    i0.ɵɵelement(1, \"igx-circular-bar\", 56);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"indeterminate\", true);\n  }\n}\n\nfunction IgxPivotGridComponent_igx_pivot_grid_column_resizer_55_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-pivot-grid-column-resizer\", 60);\n  }\n\n  if (rf & 2) {\n    const ctx_r27 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"restrictResizerTop\", ctx_r27.theadRow.nativeElement.clientHeight);\n  }\n}\n\nfunction IgxPivotGridComponent_ng_template_60_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r48 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 61)(1, \"igx-icon\", 62);\n    i0.ɵɵlistener(\"click\", function IgxPivotGridComponent_ng_template_60_Template_igx_icon_click_1_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r48);\n      const column_r46 = restoredCtx.$implicit;\n      const ctx_r47 = i0.ɵɵnextContext();\n      return ctx_r47.toggleColumn(column_r46);\n    });\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const column_r46 = ctx.$implicit;\n    const ctx_r31 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"draggable\", false);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r31.getColumnGroupExpandState(column_r46) ? \"chevron_right\" : \"expand_more\", \"\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", column_r46.header, \" \");\n  }\n}\n\nfunction IgxPivotGridComponent_ng_template_62_div_0_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"igx-pivot-row-dimension-content\", 68);\n  }\n\n  if (rf & 2) {\n    const rowData_r55 = ctx.$implicit;\n    const rowIndex_r56 = ctx.index;\n    const ctx_r57 = i0.ɵɵnextContext();\n    const dimIndex_r51 = ctx_r57.index;\n    const dim_r50 = ctx_r57.$implicit;\n    const ctx_r54 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"height\", ctx_r54.renderedRowHeight * (rowData_r55.rowSpan || 1), \"px\");\n    i0.ɵɵproperty(\"grid\", ctx_r54)(\"dimension\", rowData_r55.dimensions[dimIndex_r51])(\"rootDimension\", dim_r50)(\"rowIndex\", rowIndex_r56)(\"rowData\", rowData_r55)(\"density\", ctx_r54.displayDensity)(\"width\", ctx_r54.rowDimensionWidthToPixels(dim_r50));\n  }\n}\n\nfunction IgxPivotGridComponent_ng_template_62_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r59 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 64, 65);\n    i0.ɵɵlistener(\"focus\", function IgxPivotGridComponent_ng_template_62_div_0_Template_div_focus_0_listener($event) {\n      i0.ɵɵrestoreView(_r59);\n      const ctx_r58 = i0.ɵɵnextContext(2);\n      return ctx_r58.navigation.focusTbody($event);\n    })(\"keydown\", function IgxPivotGridComponent_ng_template_62_div_0_Template_div_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r59);\n      const ctx_r60 = i0.ɵɵnextContext(2);\n      return ctx_r60.navigation.handleNavigation($event);\n    });\n    i0.ɵɵtemplate(2, IgxPivotGridComponent_ng_template_62_div_0_ng_template_2_Template, 1, 9, \"ng-template\", 66, 67, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵpipe(4, \"pivotGridCellMerging\");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const dim_r50 = ctx.$implicit;\n    const ctx_r49 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"height\", ctx_r49.totalHeight, \"px\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"igxGridForOf\", i0.ɵɵpipeBind4(4, 8, ctx_r49.dataView, ctx_r49.pivotConfiguration, dim_r50, ctx_r49.pipeTrigger))(\"igxForScrollOrientation\", \"vertical\")(\"igxForScrollContainer\", ctx_r49.verticalScroll)(\"igxForContainerSize\", ctx_r49.calcHeight)(\"igxForItemSize\", ctx_r49.renderedRowHeight)(\"igxForSizePropName\", \"height\");\n  }\n}\n\nfunction IgxPivotGridComponent_ng_template_62_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxPivotGridComponent_ng_template_62_div_0_Template, 5, 13, \"div\", 63);\n  }\n\n  if (rf & 2) {\n    const ctx_r33 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngForOf\", ctx_r33.rowDimensions);\n  }\n}\n\nfunction IgxPivotGridComponent_ng_template_64_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r64 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 64, 65);\n    i0.ɵɵlistener(\"focus\", function IgxPivotGridComponent_ng_template_64_div_0_Template_div_focus_0_listener($event) {\n      i0.ɵɵrestoreView(_r64);\n      const ctx_r63 = i0.ɵɵnextContext(2);\n      return ctx_r63.navigation.focusTbody($event);\n    })(\"keydown\", function IgxPivotGridComponent_ng_template_64_div_0_Template_div_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r64);\n      const ctx_r65 = i0.ɵɵnextContext(2);\n      return ctx_r65.navigation.handleNavigation($event);\n    });\n    i0.ɵɵelement(2, \"igx-pivot-row-dimension-content\", 68);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r61 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"grid\", ctx_r61)(\"dimension\", ctx_r61.emptyRowDimension)(\"rootDimension\", ctx_r61.emptyRowDimension)(\"rowIndex\", 0)(\"rowData\", ctx_r61.dataView[0])(\"density\", ctx_r61.displayDensity)(\"width\", ctx_r61.rowDimensionWidthToPixels(ctx_r61.emptyRowDimension));\n  }\n}\n\nfunction IgxPivotGridComponent_ng_template_64_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, IgxPivotGridComponent_ng_template_64_div_0_Template, 3, 7, \"div\", 69);\n  }\n\n  if (rf & 2) {\n    const ctx_r35 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r35.columnDimensions.length > 0 || ctx_r35.values.length > 0);\n  }\n}\n\nfunction IgxPivotGridComponent_ng_template_66_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 58)(1, \"span\");\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r37 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r37.resourceStrings.igx_grid_pivot_empty_message);\n  }\n}\n\nconst _c295 = [[[\"igx-grid-toolbar\"]], [[\"igx-grid-footer\"]]];\nconst _c296 = [\"igx-grid-toolbar\", \"igx-grid-footer\"];\n\nfunction IgxPivotDataSelectorComponent_igx_list_item_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-list-item\", 12)(1, \"igx-checkbox\", 13);\n    i0.ɵɵlistener(\"click\", function IgxPivotDataSelectorComponent_igx_list_item_7_Template_igx_checkbox_click_1_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r10);\n      const item_r8 = restoredCtx.$implicit;\n      const ctx_r9 = i0.ɵɵnextContext();\n      return ctx_r9.toggleItem(item_r8);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"span\");\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const item_r8 = ctx.$implicit;\n    i0.ɵɵproperty(\"id\", item_r8.memberName);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"aria-labelledby\", item_r8.memberName)(\"disableRipple\", true)(\"checked\", item_r8.enabled);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(item_r8.memberName);\n  }\n}\n\nfunction IgxPivotDataSelectorComponent_igx_list_item_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-list-item\", 12)(1, \"igx-checkbox\", 13);\n    i0.ɵɵlistener(\"click\", function IgxPivotDataSelectorComponent_igx_list_item_9_Template_igx_checkbox_click_1_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r13);\n      const item_r11 = restoredCtx.$implicit;\n      const ctx_r12 = i0.ɵɵnextContext();\n      return ctx_r12.toggleItem(item_r11);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"span\");\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const item_r11 = ctx.$implicit;\n    i0.ɵɵproperty(\"id\", item_r11.member);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"aria-labelledby\", item_r11.member)(\"disableRipple\", true)(\"checked\", item_r11.enabled);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(item_r11.displayName || item_r11.member);\n  }\n}\n\nfunction IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r18 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(item_r18.aggregate.key);\n  }\n}\n\nfunction IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1, \"(\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_span_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1, \")\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_igx_icon_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\", 33);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r18 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", item_r18.sortDirection < 2 ? \"arrow_upward\" : \"arrow_downward\", \" \");\n  }\n}\n\nfunction IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_igx_icon_11_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r30 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-icon\", 34);\n    i0.ɵɵlistener(\"pointerdown\", function IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_igx_icon_11_Template_igx_icon_pointerdown_0_listener($event) {\n      i0.ɵɵrestoreView(_r30);\n      const ctx_r29 = i0.ɵɵnextContext(4);\n      return ctx_r29.onFilteringIconPointerDown($event);\n    })(\"click\", function IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_igx_icon_11_Template_igx_icon_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r30);\n      const item_r18 = i0.ɵɵnextContext().$implicit;\n      const ctx_r31 = i0.ɵɵnextContext(3);\n      return ctx_r31.onFilteringIconClick($event, item_r18);\n    });\n    i0.ɵɵtext(1, \"filter_list \");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_igx_icon_12_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r35 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-icon\", 35);\n    i0.ɵɵlistener(\"click\", function IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_igx_icon_12_Template_igx_icon_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r35);\n      const item_r18 = i0.ɵɵnextContext().$implicit;\n      const ctx_r33 = i0.ɵɵnextContext(3);\n\n      const _r4 = i0.ɵɵreference(14);\n\n      return ctx_r33.onSummaryClick($event, item_r18, _r4);\n    });\n    i0.ɵɵtext(1, \" functions \");\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    i0.ɵɵnextContext(4);\n\n    const _r4 = i0.ɵɵreference(14);\n\n    i0.ɵɵproperty(\"igxDropDownItemNavigation\", _r4);\n  }\n}\n\nfunction IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_igx_icon_13_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-icon\", 36);\n    i0.ɵɵtext(1, \"drag_handle\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nconst _c297 = function (a0, a1) {\n  return {\n    gridID: a0,\n    selectorChannels: a1\n  };\n};\n\nfunction IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r37 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-list-item\", 23);\n    i0.ɵɵlistener(\"ghostCreate\", function IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_Template_igx_list_item_ghostCreate_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r37);\n      const item_r18 = restoredCtx.$implicit;\n      const panel_r14 = i0.ɵɵnextContext(2).$implicit;\n      const ctx_r36 = i0.ɵɵnextContext();\n      return ctx_r36.ghostCreated($event, item_r18[panel_r14.itemKey]);\n    })(\"over\", function IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_Template_igx_list_item_over_0_listener($event) {\n      i0.ɵɵrestoreView(_r37);\n      const ctx_r39 = i0.ɵɵnextContext(3);\n      return ctx_r39.onItemDragOver($event);\n    })(\"leave\", function IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_Template_igx_list_item_leave_0_listener($event) {\n      i0.ɵɵrestoreView(_r37);\n      const ctx_r40 = i0.ɵɵnextContext(3);\n      return ctx_r40.onItemDragLeave($event);\n    })(\"dragMove\", function IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_Template_igx_list_item_dragMove_0_listener($event) {\n      i0.ɵɵrestoreView(_r37);\n      const ctx_r41 = i0.ɵɵnextContext(3);\n      return ctx_r41.onItemDragMove($event);\n    })(\"dragEnd\", function IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_Template_igx_list_item_dragEnd_0_listener($event) {\n      i0.ɵɵrestoreView(_r37);\n      const ctx_r42 = i0.ɵɵnextContext(3);\n      return ctx_r42.onItemDragEnd($event);\n    })(\"dropped\", function IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_Template_igx_list_item_dropped_0_listener($event) {\n      i0.ɵɵrestoreView(_r37);\n      const panel_r14 = i0.ɵɵnextContext(2).$implicit;\n      const ctx_r43 = i0.ɵɵnextContext();\n      return ctx_r43.onItemDropped($event, panel_r14.type);\n    });\n    i0.ɵɵelementStart(1, \"div\", 24)(2, \"div\", 25);\n    i0.ɵɵlistener(\"click\", function IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_Template_div_click_2_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r37);\n      const item_r18 = restoredCtx.$implicit;\n      const panel_r14 = i0.ɵɵnextContext(2).$implicit;\n      const ctx_r45 = i0.ɵɵnextContext();\n      return ctx_r45.onItemSort($event, item_r18, panel_r14.type);\n    });\n    i0.ɵɵelementStart(3, \"div\", 26);\n    i0.ɵɵtemplate(4, IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_span_4_Template, 2, 1, \"span\", 27);\n    i0.ɵɵtemplate(5, IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_span_5_Template, 2, 0, \"span\", 27);\n    i0.ɵɵelementStart(6, \"span\");\n    i0.ɵɵtext(7);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(8, IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_span_8_Template, 2, 0, \"span\", 27);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(9, IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_igx_icon_9_Template, 2, 1, \"igx-icon\", 28);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(10, \"div\", 29);\n    i0.ɵɵtemplate(11, IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_igx_icon_11_Template, 2, 0, \"igx-icon\", 30);\n    i0.ɵɵtemplate(12, IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_igx_icon_12_Template, 2, 1, \"igx-icon\", 31);\n    i0.ɵɵtemplate(13, IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_igx_icon_13_Template, 2, 0, \"igx-icon\", 32);\n    i0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const item_r18 = ctx.$implicit;\n    const panel_r14 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r17 = i0.ɵɵnextContext();\n\n    const _r6 = i0.ɵɵreference(17);\n\n    i0.ɵɵproperty(\"igxDrag\", i0.ɵɵpureFunction2(13, _c297, ctx_r17.grid.id, panel_r14.dragChannels))(\"ghostTemplate\", _r6)(\"id\", item_r18[panel_r14.itemKey]);\n    i0.ɵɵadvance(2);\n    i0.ɵɵclassProp(\"igx-pivot-data-selector__action-sort\", panel_r14.sortable);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", panel_r14.type === null);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", panel_r14.type === null);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(item_r18[panel_r14.displayKey] || item_r18[panel_r14.itemKey]);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", panel_r14.type === null);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", panel_r14.sortable && item_r18.sortDirection);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", panel_r14.type !== null);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", panel_r14.type === null);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", panel_r14.dragChannels.length > 0);\n  }\n}\n\nfunction IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-list\", 5);\n    i0.ɵɵtemplate(1, IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_igx_list_item_1_Template, 14, 16, \"igx-list-item\", 22);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const panel_r14 = i0.ɵɵnextContext().$implicit;\n    const ctx_r15 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"displayDensity\", ctx_r15.displayDensity);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r15.grid[panel_r14.dataKey]);\n  }\n}\n\nfunction IgxPivotDataSelectorComponent_igx_expansion_panel_12_div_12_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 37);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r16.grid.resourceStrings.igx_grid_pivot_selector_panel_empty, \" \");\n  }\n}\n\nfunction IgxPivotDataSelectorComponent_igx_expansion_panel_12_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r50 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"igx-expansion-panel\", 14);\n    i0.ɵɵlistener(\"collapsedChange\", function IgxPivotDataSelectorComponent_igx_expansion_panel_12_Template_igx_expansion_panel_collapsedChange_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r50);\n      const panel_r14 = restoredCtx.$implicit;\n      const ctx_r49 = i0.ɵɵnextContext();\n      return ctx_r49.onCollapseChange($event, panel_r14.type);\n    });\n    i0.ɵɵelementStart(1, \"igx-expansion-panel-header\", 15);\n    i0.ɵɵlistener(\"enter\", function IgxPivotDataSelectorComponent_igx_expansion_panel_12_Template_igx_expansion_panel_header_enter_1_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r50);\n      const panel_r14 = restoredCtx.$implicit;\n      const ctx_r51 = i0.ɵɵnextContext();\n      return ctx_r51.onPanelEntry($event, panel_r14.name);\n    })(\"dropped\", function IgxPivotDataSelectorComponent_igx_expansion_panel_12_Template_igx_expansion_panel_header_dropped_1_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r50);\n      const panel_r14 = restoredCtx.$implicit;\n      const ctx_r52 = i0.ɵɵnextContext();\n      return ctx_r52.onItemDropped($event, panel_r14.type);\n    });\n    i0.ɵɵelementStart(2, \"igx-expansion-panel-title\", 16)(3, \"h6\", 17);\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"div\", 18)(6, \"igx-icon\");\n    i0.ɵɵtext(7);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(8, \"igx-chip\");\n    i0.ɵɵtext(9);\n    i0.ɵɵelementEnd()()()();\n    i0.ɵɵelementStart(10, \"igx-expansion-panel-body\", 19);\n    i0.ɵɵlistener(\"enter\", function IgxPivotDataSelectorComponent_igx_expansion_panel_12_Template_igx_expansion_panel_body_enter_10_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r50);\n      const panel_r14 = restoredCtx.$implicit;\n      const ctx_r53 = i0.ɵɵnextContext();\n      return ctx_r53.onPanelEntry($event, panel_r14.name);\n    })(\"dropped\", function IgxPivotDataSelectorComponent_igx_expansion_panel_12_Template_igx_expansion_panel_body_dropped_10_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r50);\n      const panel_r14 = restoredCtx.$implicit;\n      const ctx_r54 = i0.ɵɵnextContext();\n      return ctx_r54.onItemDropped($event, panel_r14.type);\n    });\n    i0.ɵɵtemplate(11, IgxPivotDataSelectorComponent_igx_expansion_panel_12_igx_list_11_Template, 2, 2, \"igx-list\", 20);\n    i0.ɵɵtemplate(12, IgxPivotDataSelectorComponent_igx_expansion_panel_12_div_12_Template, 2, 1, \"div\", 21);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const panel_r14 = ctx.$implicit;\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"animationSettings\", ctx_r3.animationSettings)(\"collapsed\", ctx_r3.getPanelCollapsed(panel_r14.type));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"disabled\", false);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r3.grid.resourceStrings[panel_r14.i18n], \" \");\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate(panel_r14.icon);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r3.grid[panel_r14.dataKey].length);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.grid[panel_r14.dataKey].length > 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.grid[panel_r14.dataKey].length === 0);\n  }\n}\n\nfunction IgxPivotDataSelectorComponent_igx_drop_down_item_15_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"igx-drop-down-item\", 38);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r55 = ctx.$implicit;\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"selected\", ctx_r5.isSelected(item_r55))(\"value\", item_r55);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", item_r55.label, \" \");\n  }\n}\n\nfunction IgxPivotDataSelectorComponent_ng_template_16_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 39)(1, \"div\", 40)(2, \"igx-icon\");\n    i0.ɵɵtext(3, \"unfold_more\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"span\");\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(6, \"igx-icon\");\n    i0.ɵɵtext(7, \"drag_handle\");\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"width\", ctx_r7.ghostWidth, \"px\");\n    i0.ɵɵclassProp(\"igx-pivot-data-selector__item-ghost--no-drop\", !ctx_r7.dropAllowed);\n    i0.ɵɵadvance(5);\n    i0.ɵɵtextInterpolate(ctx_r7.ghostText);\n  }\n}\n\nvar EaseIn = /*#__PURE__*/(() => {\n  (function (EaseIn) {\n    EaseIn[EaseIn[\"Quad\"] = `cubic-bezier(0.550, 0.085, 0.680, 0.530)`] = \"Quad\";\n    EaseIn[EaseIn[\"Cubic\"] = `cubic-bezier(0.550, 0.055, 0.675, 0.190)`] = \"Cubic\";\n    EaseIn[EaseIn[\"Quart\"] = `cubic-bezier(0.895, 0.030, 0.685, 0.220)`] = \"Quart\";\n    EaseIn[EaseIn[\"Quint\"] = `cubic-bezier(0.755, 0.050, 0.855, 0.060)`] = \"Quint\";\n    EaseIn[EaseIn[\"Sine\"] = `cubic-bezier(0.470, 0.000, 0.745, 0.715)`] = \"Sine\";\n    EaseIn[EaseIn[\"Expo\"] = `cubic-bezier(0.950, 0.050, 0.795, 0.035)`] = \"Expo\";\n    EaseIn[EaseIn[\"Circ\"] = `cubic-bezier(0.600, 0.040, 0.980, 0.335)`] = \"Circ\";\n    EaseIn[EaseIn[\"Back\"] = `cubic-bezier(0.600, -0.280, 0.735, 0.045)`] = \"Back\";\n  })(EaseIn || (EaseIn = {}));\n\n  return EaseIn;\n})();\nvar EaseOut = /*#__PURE__*/(() => {\n  (function (EaseOut) {\n    EaseOut[EaseOut[\"Quad\"] = `cubic-bezier(0.250, 0.460, 0.450, 0.940)`] = \"Quad\";\n    EaseOut[EaseOut[\"Cubic\"] = `cubic-bezier(0.215, 0.610, 0.355, 1.000)`] = \"Cubic\";\n    EaseOut[EaseOut[\"Quart\"] = `cubic-bezier(0.165, 0.840, 0.440, 1.000)`] = \"Quart\";\n    EaseOut[EaseOut[\"Quint\"] = `cubic-bezier(0.230, 1.000, 0.320, 1.000)`] = \"Quint\";\n    EaseOut[EaseOut[\"Sine\"] = `cubic-bezier(0.390, 0.575, 0.565, 1.000)`] = \"Sine\";\n    EaseOut[EaseOut[\"Expo\"] = `cubic-bezier(0.190, 1.000, 0.220, 1.000)`] = \"Expo\";\n    EaseOut[EaseOut[\"Circ\"] = `cubic-bezier(0.075, 0.820, 0.165, 1.000)`] = \"Circ\";\n    EaseOut[EaseOut[\"Back\"] = `cubic-bezier(0.175, 0.885, 0.320, 1.275)`] = \"Back\";\n  })(EaseOut || (EaseOut = {}));\n\n  return EaseOut;\n})();\nvar EaseInOut = /*#__PURE__*/(() => {\n  (function (EaseInOut) {\n    EaseInOut[EaseInOut[\"Quad\"] = `cubic-bezier(0.455, 0.030, 0.515, 0.955)`] = \"Quad\";\n    EaseInOut[EaseInOut[\"Cubic\"] = `cubic-bezier(0.645, 0.045, 0.355, 1.000)`] = \"Cubic\";\n    EaseInOut[EaseInOut[\"Quart\"] = `cubic-bezier(0.770, 0.000, 0.175, 1.000)`] = \"Quart\";\n    EaseInOut[EaseInOut[\"Quint\"] = `cubic-bezier(0.860, 0.000, 0.070, 1.000)`] = \"Quint\";\n    EaseInOut[EaseInOut[\"Sine\"] = `cubic-bezier(0.445, 0.050, 0.550, 0.950)`] = \"Sine\";\n    EaseInOut[EaseInOut[\"Expo\"] = `cubic-bezier(1.000, 0.000, 0.000, 1.000)`] = \"Expo\";\n    EaseInOut[EaseInOut[\"Circ\"] = `cubic-bezier(0.785, 0.135, 0.150, 0.860)`] = \"Circ\";\n    EaseInOut[EaseInOut[\"Back\"] = `cubic-bezier(0.680, -0.550, 0.265, 1.550)`] = \"Back\";\n  })(EaseInOut || (EaseInOut = {}));\n\n  return EaseInOut;\n})();\nconst base$3 = [style({\n  opacity: `{{startOpacity}}`\n}), animate(`{{duration}} {{delay}} {{easing}}`, style({\n  opacity: `{{endOpacity}}`\n}))];\nconst baseParams$3 = {\n  delay: '0s',\n  duration: '350ms',\n  easing: EaseOut.Sine,\n  endOpacity: 1,\n  startOpacity: 0\n};\nconst fadeIn = animation(base$3, {\n  params: baseParams$3\n});\nconst fadeOut = animation(base$3, {\n  params: {\n    delay: '0s',\n    duration: '350ms',\n    easing: EaseOut.Sine,\n    endOpacity: 0,\n    startOpacity: 1\n  }\n});\nconst baseRecipe$2 = [style({\n  backfaceVisibility: 'hidden',\n  transformStyle: 'preserve-3d'\n}), animate(`{{duration}} {{delay}} {{easing}}`, keyframes([style({\n  offset: 0,\n  transform: `translateZ({{startDistance}})\n                rotate3d({{rotateX}}, {{rotateY}}, {{rotateZ}}, {{startAngle}}deg)`\n}), style({\n  offset: 1,\n  transform: `translateZ({{endDistance}})\n                rotate3d({{rotateX}}, {{rotateY}}, {{rotateZ}}, {{endAngle}}deg)`\n})]))];\nconst baseParams$2 = {\n  delay: '0s',\n  duration: '600ms',\n  easing: EaseOut.Quad,\n  endAngle: 180,\n  endDistance: '0px',\n  rotateX: 1,\n  rotateY: 0,\n  rotateZ: 0,\n  startAngle: 0,\n  startDistance: '0px'\n};\nconst flipTop = animation(baseRecipe$2, {\n  params: Object.assign({}, baseParams$2)\n});\nconst flipBottom = animation(baseRecipe$2, {\n  params: Object.assign(Object.assign({}, baseParams$2), {\n    endAngle: -180\n  })\n});\nconst flipLeft = animation(baseRecipe$2, {\n  params: Object.assign(Object.assign({}, baseParams$2), {\n    rotateX: 0,\n    rotateY: 1\n  })\n});\nconst flipRight = animation(baseRecipe$2, {\n  params: Object.assign(Object.assign({}, baseParams$2), {\n    endAngle: -180,\n    rotateX: 0,\n    rotateY: 1\n  })\n});\nconst flipHorFwd = animation(baseRecipe$2, {\n  params: Object.assign(Object.assign({}, baseParams$2), {\n    endDistance: '170px'\n  })\n});\nconst flipHorBck = animation(baseRecipe$2, {\n  params: Object.assign(Object.assign({}, baseParams$2), {\n    endDistance: '-170px'\n  })\n});\nconst flipVerFwd = animation(baseRecipe$2, {\n  params: Object.assign(Object.assign({}, baseParams$2), {\n    endDistance: '170px',\n    rotateX: 0,\n    rotateY: 1\n  })\n});\nconst flipVerBck = animation(baseRecipe$2, {\n  params: Object.assign(Object.assign({}, baseParams$2), {\n    endDistance: '-170px',\n    rotateX: 0,\n    rotateY: 1\n  })\n});\nconst baseRecipe$1 = [style({\n  opacity: `{{startOpacity}}`,\n  transform: `rotate3d({{rotateX}},{{rotateY}},{{rotateZ}},{{startAngle}}deg)`,\n  transformOrigin: `{{xPos}} {{yPos}}`\n}), animate(`{{duration}} {{delay}} {{easing}}`, style({\n  offset: 0,\n  opacity: `{{endOpacity}}`,\n  transform: `rotate3d({{rotateX}},{{rotateY}},{{rotateZ}},{{endAngle}}deg)`,\n  transformOrigin: `{{xPos}} {{yPos}}`\n}))];\nconst baseInParams$2 = {\n  delay: '0s',\n  duration: '600ms',\n  easing: EaseOut.Quad,\n  endAngle: 0,\n  endOpacity: 1,\n  rotateX: 0,\n  rotateY: 0,\n  rotateZ: 1,\n  startAngle: -360,\n  startOpacity: 0,\n  xPos: 'center',\n  yPos: 'center'\n};\nconst baseOutParams$2 = Object.assign(Object.assign({}, baseInParams$2), {\n  easing: EaseIn.Quad,\n  endOpacity: 0,\n  startOpacity: 1\n});\nconst rotateInCenter = animation(baseRecipe$1, {\n  params: Object.assign({}, baseInParams$2)\n});\nconst rotateOutCenter = animation(baseRecipe$1, {\n  params: Object.assign({}, baseOutParams$2)\n});\nconst rotateInTop = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseInParams$2), {\n    xPos: 'top'\n  })\n});\nconst rotateOutTop = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseOutParams$2), {\n    xPos: 'top'\n  })\n});\nconst rotateInRight = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseInParams$2), {\n    xPos: 'right'\n  })\n});\nconst rotateOutRight = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseOutParams$2), {\n    xPos: 'right'\n  })\n});\nconst rotateInBottom = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseInParams$2), {\n    xPos: 'bottom'\n  })\n});\nconst rotateOutBottom = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseOutParams$2), {\n    xPos: 'bottom'\n  })\n});\nconst rotateInLeft = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseInParams$2), {\n    xPos: 'left'\n  })\n});\nconst rotateOutLeft = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseOutParams$2), {\n    xPos: 'left'\n  })\n});\nconst rotateInTr = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseInParams$2), {\n    xPos: 'right',\n    yPos: 'top'\n  })\n});\nconst rotateOutTr = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseOutParams$2), {\n    xPos: 'right',\n    yPos: 'top'\n  })\n});\nconst rotateInBr = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseInParams$2), {\n    xPos: 'right',\n    yPos: 'bottom'\n  })\n});\nconst rotateOutBr = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseOutParams$2), {\n    xPos: 'right',\n    yPos: 'bottom'\n  })\n});\nconst rotateInBl = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseInParams$2), {\n    xPos: 'left',\n    yPos: 'bottom'\n  })\n});\nconst rotateOutBl = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseOutParams$2), {\n    xPos: 'left',\n    yPos: 'bottom'\n  })\n});\nconst rotateInTl = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseInParams$2), {\n    xPos: 'left',\n    yPos: 'top'\n  })\n});\nconst rotateOutTl = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseOutParams$2), {\n    xPos: 'left',\n    yPos: 'top'\n  })\n});\nconst rotateInDiagonal1 = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseInParams$2), {\n    rotateX: 1,\n    rotateY: 1,\n    rotateZ: 0\n  })\n});\nconst rotateOutDiagonal1 = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseOutParams$2), {\n    rotateX: 1,\n    rotateY: 1,\n    rotateZ: 0\n  })\n});\nconst rotateInDiagonal2 = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseInParams$2), {\n    rotateX: -1,\n    rotateY: 1,\n    rotateZ: 0\n  })\n});\nconst rotateOutDiagonal2 = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseOutParams$2), {\n    rotateX: -1,\n    rotateY: 1,\n    rotateZ: 0\n  })\n});\nconst rotateInHor = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseInParams$2), {\n    rotateX: 0,\n    rotateY: 1,\n    rotateZ: 0\n  })\n});\nconst rotateOutHor = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseOutParams$2), {\n    rotateX: 0,\n    rotateY: 1,\n    rotateZ: 0\n  })\n});\nconst rotateInVer = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseInParams$2), {\n    rotateX: 1,\n    rotateY: 0,\n    rotateZ: 0\n  })\n});\nconst rotateOutVer = animation(baseRecipe$1, {\n  params: Object.assign(Object.assign({}, baseOutParams$2), {\n    rotateX: 1,\n    rotateY: 0,\n    rotateZ: 0\n  })\n});\nconst baseRecipe = [animate(`{{duration}} {{delay}} {{easing}}`, keyframes([style({\n  offset: 0,\n  transform: `rotate(0deg) translate{{direction}}(0)`,\n  transformOrigin: `{{xPos}} {{yPos}}`\n}), style({\n  offset: 0.1,\n  transform: `rotate({{endAngle}}deg) translate{{direction}}(-{{startDistance}})`\n}), style({\n  offset: 0.2,\n  transform: `rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})`\n}), style({\n  offset: 0.3,\n  transform: `rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})`\n}), style({\n  offset: 0.4,\n  transform: `rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})`\n}), style({\n  offset: 0.5,\n  transform: `rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})`\n}), style({\n  offset: 0.6,\n  transform: `rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})`\n}), style({\n  offset: 0.7,\n  transform: `rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})`\n}), style({\n  offset: 0.8,\n  transform: `rotate(-{{endAngle}}deg) translate{{direction}}({{endDistance}})`\n}), style({\n  offset: 0.9,\n  transform: `rotate({{endAngle}}deg) translate{{direction}}(-{{endDistance}})`\n}), style({\n  offset: 1,\n  transform: `rotate(0deg) translate{{direction}}(0)`,\n  transformOrigin: `{{xPos}} {{yPos}}`\n})]))];\nconst baseParams$1 = {\n  delay: '0s',\n  direction: 'X',\n  duration: '800ms',\n  easing: EaseInOut.Quad,\n  endAngle: 0,\n  endDistance: '8px',\n  startAngle: 0,\n  startDistance: '10px',\n  xPos: 'center',\n  yPos: 'center'\n};\nconst shakeHor = animation(baseRecipe, {\n  params: Object.assign(Object.assign({}, baseParams$1), {\n    direction: 'X'\n  })\n});\nconst shakeVer = animation(baseRecipe, {\n  params: Object.assign(Object.assign({}, baseParams$1), {\n    direction: 'Y'\n  })\n});\nconst shakeTop = animation(baseRecipe, {\n  params: Object.assign(Object.assign({}, baseParams$1), {\n    endAngle: 2,\n    endDistance: '0',\n    startAngle: 4,\n    startDistance: '0',\n    yPos: 'top'\n  })\n});\nconst shakeBottom = animation(baseRecipe, {\n  params: Object.assign(Object.assign({}, baseParams$1), {\n    direction: 'Y',\n    endAngle: 2,\n    endDistance: '0',\n    startAngle: 4,\n    startDistance: '0',\n    yPos: 'bottom'\n  })\n});\nconst shakeRight = animation(baseRecipe, {\n  params: Object.assign(Object.assign({}, baseParams$1), {\n    direction: 'Y',\n    endAngle: 2,\n    endDistance: '0',\n    startAngle: 4,\n    startDistance: '0',\n    xPos: 'right',\n    yPos: 'center'\n  })\n});\nconst shakeLeft = animation(baseRecipe, {\n  params: Object.assign(Object.assign({}, baseParams$1), {\n    direction: 'Y',\n    endAngle: 2,\n    endDistance: '0',\n    startAngle: 4,\n    startDistance: '0',\n    xPos: 'left',\n    yPos: 'center'\n  })\n});\nconst shakeCenter = animation(baseRecipe, {\n  params: Object.assign(Object.assign({}, baseParams$1), {\n    direction: 'Y',\n    endAngle: 8,\n    endDistance: '0',\n    startAngle: 10,\n    startDistance: '0',\n    xPos: 'center',\n    yPos: 'center'\n  })\n});\nconst shakeTr = animation(baseRecipe, {\n  params: Object.assign(Object.assign({}, baseParams$1), {\n    direction: 'Y',\n    endAngle: 2,\n    endDistance: '0',\n    startAngle: 4,\n    startDistance: '0',\n    xPos: 'right',\n    yPos: 'top'\n  })\n});\nconst shakeBr = animation(baseRecipe, {\n  params: Object.assign(Object.assign({}, baseParams$1), {\n    direction: 'Y',\n    endAngle: 2,\n    endDistance: '0',\n    startAngle: 4,\n    startDistance: '0',\n    xPos: 'right',\n    yPos: 'bottom'\n  })\n});\nconst shakeBl = animation(baseRecipe, {\n  params: Object.assign(Object.assign({}, baseParams$1), {\n    direction: 'Y',\n    endAngle: 2,\n    endDistance: '0',\n    startAngle: 4,\n    startDistance: '0',\n    xPos: 'left',\n    yPos: 'bottom'\n  })\n});\nconst shakeTl = animation(baseRecipe, {\n  params: Object.assign(Object.assign({}, baseParams$1), {\n    direction: 'Y',\n    endAngle: 2,\n    endDistance: '0',\n    startAngle: 4,\n    startDistance: '0',\n    xPos: 'left',\n    yPos: 'top'\n  })\n});\nconst heartbeatBase = [style({\n  animationTimingFunction: `ease-out`,\n  transform: `scale(1)`,\n  transformOrigin: `center center`\n}), animate(`{{duration}} {{delay}} {{easing}}`, keyframes([style({\n  animationTimingFunction: `ease-in`,\n  offset: 0.1,\n  transform: `scale(0.91)`\n}), style({\n  animationTimingFunction: `ease-out`,\n  offset: 0.17,\n  transform: `scale(0.98)`\n}), style({\n  animationTimingFunction: `ease-in`,\n  offset: 0.33,\n  transform: `scale(0.87)`\n}), style({\n  animationTimingFunction: `ease-out`,\n  offset: 0.45,\n  transform: `scale(1)`\n})]))];\nconst heartbeatParams = {\n  delay: '0s',\n  duration: '1.5s',\n  easing: 'ease-in-out'\n};\nconst pulsateBase = [animate(`{{duration}} {{delay}} {{easing}}`, keyframes([style({\n  offset: 0,\n  transform: `scale({{fromScale}})`\n}), style({\n  offset: 0.5,\n  transform: `scale({{toScale}})`\n}), style({\n  offset: 1,\n  transform: `scale({{fromScale}})`\n})]))];\nconst pulsateParams = {\n  delay: '0s',\n  duration: '.5s',\n  easing: 'ease-in-out',\n  fromScale: 1,\n  toScale: 1.1\n};\nconst blinkBase = [animate(`{{duration}} {{delay}} {{easing}}`, keyframes([style({\n  offset: 0,\n  opacity: .8,\n  transform: `scale({{fromScale}})`\n}), style({\n  offset: 0.8,\n  opacity: 0,\n  transform: `scale({{midScale}})`\n}), style({\n  offset: 1,\n  opacity: 0,\n  transform: `scale({{toScale}})`\n})]))];\nconst blinkParams = {\n  delay: '0s',\n  duration: '.8s',\n  easing: 'ease-in-out',\n  fromScale: .2,\n  midScale: 1.2,\n  toScale: 2.2\n};\nconst pulsateFwd = animation(pulsateBase, {\n  params: Object.assign({}, pulsateParams)\n});\nconst pulsateBck = animation(pulsateBase, {\n  params: Object.assign(Object.assign({}, pulsateParams), {\n    toScale: .9\n  })\n});\nconst heartbeat = animation(heartbeatBase, {\n  params: Object.assign({}, heartbeatParams)\n});\nconst blink = animation(blinkBase, {\n  params: Object.assign({}, blinkParams)\n});\nconst base$2 = [style({\n  opacity: `{{startOpacity}}`,\n  transform: `scale{{direction}}({{fromScale}})`,\n  transformOrigin: `{{xPos}} {{yPos}}`\n}), animate(`{{duration}} {{delay}} {{easing}}`, style({\n  opacity: `{{endOpacity}}`,\n  transform: `scale{{direction}}({{toScale}})`,\n  transformOrigin: `{{xPos}} {{yPos}}`\n}))];\nconst baseInParams$1 = {\n  delay: '0s',\n  direction: '',\n  duration: '350ms',\n  easing: EaseOut.Quad,\n  endOpacity: 1,\n  fromScale: .5,\n  startOpacity: 0,\n  toScale: 1,\n  xPos: '50%',\n  yPos: '50%'\n};\nconst baseOutParams$1 = Object.assign(Object.assign({}, baseInParams$1), {\n  easing: EaseOut.Sine,\n  endOpacity: 0,\n  fromScale: 1,\n  startOpacity: 1,\n  toScale: .5\n});\nconst scaleInCenter = animation(base$2, {\n  params: baseInParams$1\n});\nconst scaleInBl = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseInParams$1), {\n    xPos: '0',\n    yPos: '100%'\n  })\n});\nconst scaleInVerCenter = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseInParams$1), {\n    direction: 'Y',\n    fromScale: .4\n  })\n});\nconst scaleInTop = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseInParams$1), {\n    xPos: '50%',\n    yPos: '0'\n  })\n});\nconst scaleInLeft = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseInParams$1), {\n    xPos: '0',\n    yPos: '50%'\n  })\n});\nconst scaleInVerTop = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseInParams$1), {\n    direction: 'Y',\n    fromScale: .4,\n    xPos: '100%',\n    yPos: '0'\n  })\n});\nconst scaleInTr = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseInParams$1), {\n    xPos: '100%',\n    yPos: '0'\n  })\n});\nconst scaleInTl = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseInParams$1), {\n    xPos: '0',\n    yPos: '0'\n  })\n});\nconst scaleInVerBottom = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseInParams$1), {\n    direction: 'Y',\n    fromScale: .4,\n    xPos: '0',\n    yPos: '100%'\n  })\n});\nconst scaleInRight = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseInParams$1), {\n    xPos: '100%',\n    yPos: '50%'\n  })\n});\nconst scaleInHorCenter = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseInParams$1), {\n    direction: 'X',\n    fromScale: .4\n  })\n});\nconst scaleInBr = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseInParams$1), {\n    xPos: '100%',\n    yPos: '100%'\n  })\n});\nconst scaleInHorLeft = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseInParams$1), {\n    direction: 'X',\n    fromScale: .4,\n    xPos: '0',\n    yPos: '0'\n  })\n});\nconst scaleInBottom = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseInParams$1), {\n    xPos: '50%',\n    yPos: '100%'\n  })\n});\nconst scaleInHorRight = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseInParams$1), {\n    direction: 'X',\n    fromScale: .4,\n    xPos: '100%',\n    yPos: '100%'\n  })\n});\nconst scaleOutCenter = animation(base$2, {\n  params: baseOutParams$1\n});\nconst scaleOutBl = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseOutParams$1), {\n    xPos: '0',\n    yPos: '100%'\n  })\n});\nconst scaleOutBr = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseOutParams$1), {\n    xPos: '100%',\n    yPos: '100%'\n  })\n});\nconst scaleOutVerCenter = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseOutParams$1), {\n    direction: 'Y',\n    toScale: .3\n  })\n});\nconst scaleOutVerTop = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseOutParams$1), {\n    direction: 'Y',\n    toScale: .3,\n    xPos: '100%',\n    yPos: '0'\n  })\n});\nconst scaleOutVerBottom = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseOutParams$1), {\n    direction: 'Y',\n    toScale: .3,\n    xPos: '0',\n    yPos: '100%'\n  })\n});\nconst scaleOutTop = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseOutParams$1), {\n    xPos: '50%',\n    yPos: '0'\n  })\n});\nconst scaleOutLeft = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseOutParams$1), {\n    xPos: '0',\n    yPos: '50%'\n  })\n});\nconst scaleOutTr = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseOutParams$1), {\n    xPos: '100%',\n    yPos: '0'\n  })\n});\nconst scaleOutTl = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseOutParams$1), {\n    xPos: '0',\n    yPos: '0'\n  })\n});\nconst scaleOutRight = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseOutParams$1), {\n    xPos: '100%',\n    yPos: '50%'\n  })\n});\nconst scaleOutBottom = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseOutParams$1), {\n    xPos: '50%',\n    yPos: '100%'\n  })\n});\nconst scaleOutHorCenter = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseOutParams$1), {\n    direction: 'X',\n    toScale: .3\n  })\n});\nconst scaleOutHorLeft = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseOutParams$1), {\n    direction: 'X',\n    toScale: .3,\n    xPos: '0',\n    yPos: '0'\n  })\n});\nconst scaleOutHorRight = animation(base$2, {\n  params: Object.assign(Object.assign({}, baseOutParams$1), {\n    direction: 'X',\n    toScale: .3,\n    xPos: '100%',\n    yPos: '100%'\n  })\n});\nconst base$1 = [style({\n  opacity: `{{startOpacity}}`,\n  transform: `{{fromPosition}}`\n}), animate(`{{duration}} {{delay}} {{easing}}`, style({\n  opacity: `{{endOpacity}}`,\n  transform: `{{toPosition}}`\n}))];\nconst baseInParams = {\n  delay: '0s',\n  duration: '350ms',\n  easing: EaseOut.Quad,\n  endOpacity: 1,\n  fromPosition: 'translateY(-500px)',\n  startOpacity: 0,\n  toPosition: 'translateY(0)'\n};\nconst baseOutParams = {\n  delay: '0s',\n  duration: '350ms',\n  easing: EaseIn.Quad,\n  endOpacity: 0,\n  fromPosition: 'translateY(0)',\n  startOpacity: 1,\n  toPosition: 'translateY(-500px)'\n};\nconst slideInTop = animation(base$1, {\n  params: baseInParams\n});\nconst slideInLeft = animation(base$1, {\n  params: {\n    delay: '0s',\n    duration: '350ms',\n    easing: EaseOut.Quad,\n    endOpacity: 1,\n    fromPosition: 'translateX(-500px)',\n    startOpacity: 0,\n    toPosition: 'translateY(0)'\n  }\n});\nconst slideInRight = animation(base$1, {\n  params: {\n    delay: '0s',\n    duration: '350ms',\n    easing: EaseOut.Quad,\n    endOpacity: 1,\n    fromPosition: 'translateX(500px)',\n    startOpacity: 0,\n    toPosition: 'translateY(0)'\n  }\n});\nconst slideInBottom = animation(base$1, {\n  params: {\n    delay: '0s',\n    duration: '350ms',\n    easing: EaseOut.Quad,\n    endOpacity: 1,\n    fromPosition: 'translateY(500px)',\n    startOpacity: 0,\n    toPosition: 'translateY(0)'\n  }\n});\nconst slideInTr = animation(base$1, {\n  params: Object.assign(Object.assign({}, baseInParams), {\n    fromPosition: 'translateY(-500px) translateX(500px)',\n    toPosition: 'translateY(0) translateX(0)'\n  })\n});\nconst slideInTl = animation(base$1, {\n  params: Object.assign(Object.assign({}, baseInParams), {\n    fromPosition: 'translateY(-500px) translateX(-500px)',\n    toPosition: 'translateY(0) translateX(0)'\n  })\n});\nconst slideInBr = animation(base$1, {\n  params: Object.assign(Object.assign({}, baseInParams), {\n    fromPosition: 'translateY(500px) translateX(500px)',\n    toPosition: 'translateY(0) translateX(0)'\n  })\n});\nconst slideInBl = animation(base$1, {\n  params: Object.assign(Object.assign({}, baseInParams), {\n    fromPosition: 'translateY(500px) translateX(-500px)',\n    toPosition: 'translateY(0) translateX(0)'\n  })\n});\nconst slideOutTop = animation(base$1, {\n  params: baseOutParams\n});\nconst slideOutRight = animation(base$1, {\n  params: Object.assign(Object.assign({}, baseOutParams), {\n    toPosition: 'translateX(500px)'\n  })\n});\nconst slideOutBottom = animation(base$1, {\n  params: {\n    delay: '0s',\n    duration: '350ms',\n    easing: EaseIn.Quad,\n    endOpacity: 0,\n    fromPosition: 'translateY(0)',\n    startOpacity: 1,\n    toPosition: 'translateY(500px)'\n  }\n});\nconst slideOutLeft = animation(base$1, {\n  params: Object.assign(Object.assign({}, baseOutParams), {\n    toPosition: 'translateX(-500px)'\n  })\n});\nconst slideOutTr = animation(base$1, {\n  params: Object.assign(Object.assign({}, baseOutParams), {\n    fromPosition: 'translateY(0) translateX(0)',\n    toPosition: 'translateY(-500px) translateX(500px)'\n  })\n});\nconst slideOutBr = animation(base$1, {\n  params: Object.assign(Object.assign({}, baseOutParams), {\n    fromPosition: 'translateY(0) translateX(0)',\n    toPosition: 'translateY(500px) translateX(500px)'\n  })\n});\nconst slideOutBl = animation(base$1, {\n  params: Object.assign(Object.assign({}, baseOutParams), {\n    fromPosition: 'translateY(0) translateX(0)',\n    toPosition: 'translateY(500px) translateX(-500px)'\n  })\n});\nconst slideOutTl = animation(base$1, {\n  params: Object.assign(Object.assign({}, baseOutParams), {\n    fromPosition: 'translateY(0) translateX(0)',\n    toPosition: 'translateY(-500px) translateX(-500px)'\n  })\n});\nconst swingBase = [style({\n  opacity: `{{startOpacity}}`,\n  transform: `rotate{{direction}}({{startAngle}}deg)`,\n  transformOrigin: `{{xPos}} {{yPos}}`\n}), animate(`{{duration}} {{delay}} {{easing}}`, style({\n  opacity: `{{endOpacity}}`,\n  transform: `rotate{{direction}}({{endAngle}}deg)`,\n  transformOrigin: `{{xPos}} {{yPos}}`\n}))];\nconst swingParams = {\n  delay: '0s',\n  direction: 'X',\n  duration: '.5s',\n  easing: EaseOut.Back,\n  endAngle: 0,\n  endOpacity: 1,\n  startAngle: -100,\n  startOpacity: 0,\n  xPos: 'top',\n  yPos: 'center'\n};\nconst swingOutParams = Object.assign(Object.assign({}, swingParams), {\n  duration: '.55s',\n  easing: EaseIn.Back,\n  endAngle: 70,\n  endOpacity: 0,\n  startAngle: 0,\n  startOpacity: 1\n});\nconst swingInTopFwd = animation(swingBase, {\n  params: Object.assign({}, swingParams)\n});\nconst swingInRightFwd = animation(swingBase, {\n  params: Object.assign(Object.assign({}, swingParams), {\n    direction: 'Y',\n    xPos: 'center',\n    yPos: 'right'\n  })\n});\nconst swingInBottomFwd = animation(swingBase, {\n  params: Object.assign(Object.assign({}, swingParams), {\n    startAngle: 100,\n    xPos: 'bottom'\n  })\n});\nconst swingInLeftFwd = animation(swingBase, {\n  params: Object.assign(Object.assign({}, swingParams), {\n    direction: 'Y',\n    startAngle: 100,\n    xPos: 'center',\n    yPos: 'left'\n  })\n});\nconst swingInTopBck = animation(swingBase, {\n  params: Object.assign(Object.assign({}, swingParams), {\n    duration: '.6s',\n    startAngle: 70\n  })\n});\nconst swingInRightBck = animation(swingBase, {\n  params: Object.assign(Object.assign({}, swingParams), {\n    direction: 'Y',\n    duration: '.6s',\n    startAngle: 70,\n    xPos: 'center',\n    yPos: 'right'\n  })\n});\nconst swingInBottomBck = animation(swingBase, {\n  params: Object.assign(Object.assign({}, swingParams), {\n    duration: '.6s',\n    startAngle: -70,\n    xPos: 'bottom'\n  })\n});\nconst swingInLeftBck = animation(swingBase, {\n  params: Object.assign(Object.assign({}, swingParams), {\n    direction: 'Y',\n    duration: '.6s',\n    startAngle: -70,\n    xPos: 'center',\n    yPos: 'left'\n  })\n});\nconst swingOutTopFwd = animation(swingBase, {\n  params: Object.assign({}, swingOutParams)\n});\nconst swingOutRightFwd = animation(swingBase, {\n  params: Object.assign(Object.assign({}, swingOutParams), {\n    direction: 'Y',\n    xPos: 'center',\n    yPos: 'right'\n  })\n});\nconst swingOutBottomFwd = animation(swingBase, {\n  params: Object.assign(Object.assign({}, swingOutParams), {\n    endAngle: -70,\n    xPos: 'bottom'\n  })\n});\nconst swingOutLefttFwd = animation(swingBase, {\n  params: Object.assign(Object.assign({}, swingOutParams), {\n    direction: 'Y',\n    endAngle: -70,\n    xPos: 'center',\n    yPos: 'left'\n  })\n});\nconst swingOutTopBck = animation(swingBase, {\n  params: Object.assign(Object.assign({}, swingOutParams), {\n    duration: '.45s',\n    endAngle: -100\n  })\n});\nconst swingOutRightBck = animation(swingBase, {\n  params: Object.assign(Object.assign({}, swingOutParams), {\n    direction: 'Y',\n    duration: '.45s',\n    endAngle: -100,\n    xPos: 'center',\n    yPos: 'right'\n  })\n});\nconst swingOutBottomBck = animation(swingBase, {\n  params: Object.assign(Object.assign({}, swingOutParams), {\n    duration: '.45s',\n    endAngle: 100,\n    xPos: 'bottom'\n  })\n});\nconst swingOutLeftBck = animation(swingBase, {\n  params: Object.assign(Object.assign({}, swingOutParams), {\n    direction: 'Y',\n    duration: '.45s',\n    endAngle: 100,\n    xPos: 'center',\n    yPos: 'left'\n  })\n});\nconst base = [style({\n  opacity: `{{ startOpacity }}`,\n  height: `{{ startHeight }}`\n}), animate(`{{duration}} {{delay}} {{easing}}`, style({\n  opacity: `{{ endOpacity }}`,\n  height: `{{ endHeight }}`\n}))];\nconst baseParams = {\n  delay: '0s',\n  duration: '350ms',\n  easing: EaseIn.Quad,\n  startOpacity: 0,\n  endOpacity: 1,\n  startHeight: '',\n  endHeight: ''\n};\nconst growVerIn = animation(base, {\n  params: Object.assign(Object.assign({}, baseParams), {\n    easing: EaseOut.Quad,\n    startOpacity: 0,\n    endOpacity: 1,\n    startHeight: '0px',\n    endHeight: '*'\n  })\n});\nconst growVerOut = animation(base, {\n  params: Object.assign(Object.assign({}, baseParams), {\n    easing: EaseOut.Quad,\n    startOpacity: 1,\n    endOpacity: 0,\n    startHeight: '*',\n    endHeight: '0px'\n  })\n});\n/**\n * Common service to be injected between components where those implementing common\n * ToggleView interface can register and toggle directives can call their methods.\n * TODO: Track currently active? Events?\n */\n\nlet IgxNavigationService = /*#__PURE__*/(() => {\n  class IgxNavigationService {\n    constructor() {\n      this.navs = {};\n    }\n\n    add(id, navItem) {\n      this.navs[id] = navItem;\n    }\n\n    remove(id) {\n      delete this.navs[id];\n    }\n\n    get(id) {\n      if (id) {\n        return this.navs[id];\n      }\n    }\n\n    toggle(id, ...args) {\n      if (this.navs[id]) {\n        return this.navs[id].toggle(...args);\n      }\n    }\n\n    open(id, ...args) {\n      if (this.navs[id]) {\n        return this.navs[id].open(...args);\n      }\n    }\n\n    close(id, ...args) {\n      if (this.navs[id]) {\n        return this.navs[id].close(...args);\n      }\n    }\n\n  }\n\n  IgxNavigationService.ɵfac = function IgxNavigationService_Factory(t) {\n    return new (t || IgxNavigationService)();\n  };\n\n  IgxNavigationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxNavigationService,\n    factory: IgxNavigationService.ɵfac\n  });\n  return IgxNavigationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Directive that can toggle targets through provided NavigationService.\n *\n * Usage:\n * ```\n * <button igxNavToggle=\"ID\"> Toggle </button>\n * ```\n * Where the `ID` matches the ID of compatible `IToggleView` component.\n */\n\n\nlet IgxNavigationToggleDirective = /*#__PURE__*/(() => {\n  class IgxNavigationToggleDirective {\n    constructor(nav) {\n      this.state = nav;\n    }\n\n    toggleNavigationDrawer() {\n      this.state.toggle(this.target, true);\n    }\n\n  }\n\n  IgxNavigationToggleDirective.ɵfac = function IgxNavigationToggleDirective_Factory(t) {\n    return new (t || IgxNavigationToggleDirective)(i0.ɵɵdirectiveInject(IgxNavigationService));\n  };\n\n  IgxNavigationToggleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxNavigationToggleDirective,\n    selectors: [[\"\", \"igxNavToggle\", \"\"]],\n    hostBindings: function IgxNavigationToggleDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function IgxNavigationToggleDirective_click_HostBindingHandler() {\n          return ctx.toggleNavigationDrawer();\n        });\n      }\n    },\n    inputs: {\n      target: [\"igxNavToggle\", \"target\"]\n    }\n  });\n  return IgxNavigationToggleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Directive that can close targets through provided NavigationService.\n *\n * Usage:\n * ```\n * <button igxNavClose=\"ID\"> Close </button>\n * ```\n * Where the `ID` matches the ID of compatible `IToggleView` component.\n */\n\n\nlet IgxNavigationCloseDirective = /*#__PURE__*/(() => {\n  class IgxNavigationCloseDirective {\n    constructor(nav) {\n      this.state = nav;\n    }\n\n    closeNavigationDrawer() {\n      this.state.close(this.target, true);\n    }\n\n  }\n\n  IgxNavigationCloseDirective.ɵfac = function IgxNavigationCloseDirective_Factory(t) {\n    return new (t || IgxNavigationCloseDirective)(i0.ɵɵdirectiveInject(IgxNavigationService));\n  };\n\n  IgxNavigationCloseDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxNavigationCloseDirective,\n    selectors: [[\"\", \"igxNavClose\", \"\"]],\n    hostBindings: function IgxNavigationCloseDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function IgxNavigationCloseDirective_click_HostBindingHandler() {\n          return ctx.closeNavigationDrawer();\n        });\n      }\n    },\n    inputs: {\n      target: [\"igxNavClose\", \"target\"]\n    }\n  });\n  return IgxNavigationCloseDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxNavigationModule = /*#__PURE__*/(() => {\n  class IgxNavigationModule {}\n\n  IgxNavigationModule.ɵfac = function IgxNavigationModule_Factory(t) {\n    return new (t || IgxNavigationModule)();\n  };\n\n  IgxNavigationModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxNavigationModule\n  });\n  IgxNavigationModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IgxNavigationService]\n  });\n  return IgxNavigationModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/* Copyright (c) 2014-2020 Denis Pushkarev\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE\n */\n// Note: Originally copied from core-js-pure package and modified. (https://github.com/zloirock/core-js)\n\n\nconst queue = {};\nlet counter = 0;\nlet eventListenerAdded = false;\n\nconst run = id => {\n  if (queue.hasOwnProperty(id)) {\n    const fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\n\nconst listener = event => run(event.data); // Use function instead of arrow function to workaround an issue in codesandbox\n\n\nfunction setImmediate(cb, ...args) {\n  if (window.setImmediate) {\n    return window.setImmediate(cb);\n  }\n\n  if (!eventListenerAdded) {\n    eventListenerAdded = true;\n    window.addEventListener('message', listener, false);\n  }\n\n  queue[++counter] = () => {\n    cb.apply(undefined, args);\n  };\n\n  const windowLocation = window.location;\n  window.postMessage(counter + '', windowLocation.protocol + '//' + windowLocation.host);\n  return counter;\n}\n\nfunction clearImmediate(id) {\n  if (window.clearImmediate) {\n    return window.clearImmediate(id);\n  }\n\n  delete queue[id];\n}\n/**\n * @hidden\n */\n\n\nconst showMessage = (message, isMessageShown) => {\n  if (!isMessageShown && isDevMode()) {\n    console.warn(message);\n  }\n\n  return true;\n};\n\nconst mkenum = x => x;\n/**\n *\n * @hidden @internal\n */\n\n\nconst getResizeObserver = () => window.ResizeObserver;\n/**\n * @hidden\n */\n\n\nconst cloneArray = (array, deep) => {\n  const arr = [];\n\n  if (!array) {\n    return arr;\n  }\n\n  let i = array.length;\n\n  while (i--) {\n    arr[i] = deep ? cloneValue(array[i]) : array[i];\n  }\n\n  return arr;\n};\n/**\n * Doesn't clone leaf items\n *\n * @hidden\n */\n\n\nconst cloneHierarchicalArray = (array, childDataKey) => {\n  const result = [];\n\n  if (!array) {\n    return result;\n  }\n\n  for (const item of array) {\n    const clonedItem = cloneValue(item);\n\n    if (Array.isArray(item[childDataKey])) {\n      clonedItem[childDataKey] = cloneHierarchicalArray(clonedItem[childDataKey], childDataKey);\n    }\n\n    result.push(clonedItem);\n  }\n\n  return result;\n};\n/**\n * Creates an object with prototype from provided source and copies\n * all properties descriptors from provided source\n * @param obj Source to copy prototype and descriptors from\n * @returns New object with cloned prototype and property descriptors\n */\n\n\nconst copyDescriptors = obj => {\n  if (obj) {\n    return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));\n  }\n};\n/**\n * Deep clones all first level keys of Obj2 and merges them to Obj1\n *\n * @param obj1 Object to merge into\n * @param obj2 Object to merge from\n * @returns Obj1 with merged cloned keys from Obj2\n * @hidden\n */\n\n\nconst mergeObjects = (obj1, obj2) => mergeWith(obj1, obj2, (objValue, srcValue) => {\n  if (Array.isArray(srcValue)) {\n    return objValue = srcValue;\n  }\n});\n/**\n * Creates deep clone of provided value.\n * Supports primitive values, dates and objects.\n * If passed value is array returns shallow copy of the array.\n *\n * @param value value to clone\n * @returns Deep copy of provided value\n * @hidden\n */\n\n\nconst cloneValue = value => {\n  if (isDate(value)) {\n    return new Date(value.getTime());\n  }\n\n  if (Array.isArray(value)) {\n    return [...value];\n  }\n\n  if (value instanceof Map || value instanceof Set) {\n    return value;\n  }\n\n  if (isObject(value)) {\n    const result = {};\n\n    for (const key of Object.keys(value)) {\n      result[key] = cloneValue(value[key]);\n    }\n\n    return result;\n  }\n\n  return value;\n};\n/**\n * Parse provided input to Date.\n *\n * @param value input to parse\n * @returns Date if parse succeed or null\n * @hidden\n */\n\n\nconst parseDate = value => {\n  // if value is Invalid Date return null\n  if (isDate(value)) {\n    return !isNaN(value.getTime()) ? value : null;\n  }\n\n  return value ? new Date(value) : null;\n};\n/**\n * Returns an array with unique dates only.\n *\n * @param columnValues collection of date values (might be numbers or ISO 8601 strings)\n * @returns collection of unique dates.\n * @hidden\n */\n\n\nconst uniqueDates = columnValues => columnValues.reduce((a, c) => {\n  if (!a.cache[c.label]) {\n    a.result.push(c);\n  }\n\n  a.cache[c.label] = true;\n  return a;\n}, {\n  result: [],\n  cache: {}\n}).result;\n/**\n * Checks if provided variable is Object\n *\n * @param value Value to check\n * @returns true if provided variable is Object\n * @hidden\n */\n\n\nconst isObject = value => !!(value && value.toString() === '[object Object]');\n/**\n * Checks if provided variable is Date\n *\n * @param value Value to check\n * @returns true if provided variable is Date\n * @hidden\n */\n\n\nconst isDate = value => value instanceof Date;\n/**\n * Checks if the two passed arguments are equal\n * Currently supports date objects\n *\n * @param obj1\n * @param obj2\n * @returns: `boolean`\n * @hidden\n */\n\n\nconst isEqual = (obj1, obj2) => {\n  if (isDate(obj1) && isDate(obj2)) {\n    return obj1.getTime() === obj2.getTime();\n  }\n\n  return obj1 === obj2;\n};\n/**\n * Utility service taking care of various utility functions such as\n * detecting browser features, general cross browser DOM manipulation, etc.\n *\n * @hidden @internal\n */\n\n\nlet PlatformUtil = /*#__PURE__*/(() => {\n  class PlatformUtil {\n    constructor(platformId) {\n      this.platformId = platformId;\n      this.isBrowser = isPlatformBrowser(this.platformId);\n      this.isIOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);\n      this.isFirefox = this.isBrowser && /Firefox[\\/\\s](\\d+\\.\\d+)/.test(navigator.userAgent);\n      this.isEdge = this.isBrowser && /Edge[\\/\\s](\\d+\\.\\d+)/.test(navigator.userAgent);\n      this.isChromium = this.isBrowser && (/Chrom|e?ium/g.test(navigator.userAgent) || /Google Inc/g.test(navigator.vendor)) && !/Edge/g.test(navigator.userAgent);\n      this.KEYMAP = mkenum({\n        ENTER: 'Enter',\n        SPACE: ' ',\n        ESCAPE: 'Escape',\n        ARROW_DOWN: 'ArrowDown',\n        ARROW_UP: 'ArrowUp',\n        ARROW_LEFT: 'ArrowLeft',\n        ARROW_RIGHT: 'ArrowRight',\n        END: 'End',\n        HOME: 'Home',\n        PAGE_DOWN: 'PageDown',\n        PAGE_UP: 'PageUp',\n        F2: 'F2',\n        TAB: 'Tab',\n        SEMICOLON: ';',\n        // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values#editing_keys\n        DELETE: 'Delete',\n        BACKSPACE: 'Backspace',\n        CONTROL: 'Control',\n        X: 'x',\n        Y: 'y',\n        Z: 'z'\n      });\n    }\n    /**\n     * @hidden @internal\n     * Returns the actual size of the node content, using Range\n     * ```typescript\n     * let range = document.createRange();\n     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];\n     *\n     * let size = getNodeSizeViaRange(range, column.cells[0].nativeElement);\n     *\n     * @remarks\n     * The last parameter is useful when the size of the element to measure is modified by a\n     * parent element that has explicit size. In such cases the calculated size is never lower\n     * and the function may instead remove the parent size while measuring to get the correct value.\n     * ```\n     */\n\n\n    getNodeSizeViaRange(range, node, sizeHoldingNode) {\n      let overflow = null;\n      let nodeStyles;\n\n      if (!this.isFirefox) {\n        overflow = node.style.overflow; // we need that hack - otherwise content won't be measured correctly in IE/Edge\n\n        node.style.overflow = 'visible';\n      }\n\n      if (sizeHoldingNode) {\n        const style = sizeHoldingNode.style;\n        nodeStyles = [style.width, style.minWidth, style.flexBasis];\n        style.width = '';\n        style.minWidth = '';\n        style.flexBasis = '';\n      }\n\n      range.selectNodeContents(node);\n      const width = range.getBoundingClientRect().width;\n\n      if (!this.isFirefox) {\n        // we need that hack - otherwise content won't be measured correctly in IE/Edge\n        node.style.overflow = overflow;\n      }\n\n      if (sizeHoldingNode) {\n        sizeHoldingNode.style.width = nodeStyles[0];\n        sizeHoldingNode.style.minWidth = nodeStyles[1];\n        sizeHoldingNode.style.flexBasis = nodeStyles[2];\n      }\n\n      return width;\n    }\n    /**\n     * Returns true if the current keyboard event is an activation key (Enter/Space bar)\n     *\n     * @hidden\n     * @internal\n     *\n     * @memberof PlatformUtil\n     */\n\n\n    isActivationKey(event) {\n      return event.key === this.KEYMAP.ENTER || event.key === this.KEYMAP.SPACE;\n    }\n    /**\n     * Returns true if the current keyboard event is a combination that closes the filtering UI of the grid. (Escape/Ctrl+Shift+L)\n     *\n     * @hidden\n     * @internal\n     * @param event\n     * @memberof PlatformUtil\n     */\n\n\n    isFilteringKeyCombo(event) {\n      return event.key === this.KEYMAP.ESCAPE || event.ctrlKey && event.shiftKey && event.key.toLowerCase() === 'l';\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    isLeftClick(event) {\n      return event.button === 0;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    isNavigationKey(key) {\n      return [this.KEYMAP.HOME, this.KEYMAP.END, this.KEYMAP.SPACE, this.KEYMAP.ARROW_DOWN, this.KEYMAP.ARROW_LEFT, this.KEYMAP.ARROW_RIGHT, this.KEYMAP.ARROW_UP].includes(key);\n    }\n\n  }\n\n  PlatformUtil.ɵfac = function PlatformUtil_Factory(t) {\n    return new (t || PlatformUtil)(i0.ɵɵinject(PLATFORM_ID));\n  };\n\n  PlatformUtil.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PlatformUtil,\n    factory: PlatformUtil.ɵfac,\n    providedIn: 'root'\n  });\n  return PlatformUtil;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst flatten$1 = arr => {\n  let result = [];\n  arr.forEach(el => {\n    result.push(el);\n\n    if (el.children) {\n      const children = Array.isArray(el.children) ? el.children : el.children.toArray();\n      result = result.concat(flatten$1(children));\n    }\n  });\n  return result;\n};\n\nconst HORIZONTAL_NAV_KEYS = new Set(['arrowleft', 'left', 'arrowright', 'right', 'home', 'end']);\nconst NAVIGATION_KEYS = new Set(['down', 'up', 'left', 'right', 'arrowdown', 'arrowup', 'arrowleft', 'arrowright', 'home', 'end', 'space', 'spacebar', ' ']);\nconst ACCORDION_NAVIGATION_KEYS = new Set('up down arrowup arrowdown home end'.split(' '));\nconst ROW_EXPAND_KEYS = new Set('right down arrowright arrowdown'.split(' '));\nconst ROW_COLLAPSE_KEYS = new Set('left up arrowleft arrowup'.split(' '));\nconst ROW_ADD_KEYS = new Set(['+', 'add', '≠', '±', '=']);\nconst SUPPORTED_KEYS = new Set([...Array.from(NAVIGATION_KEYS), ...Array.from(ROW_ADD_KEYS), 'enter', 'f2', 'escape', 'esc', 'pagedown', 'pageup']);\nconst HEADER_KEYS = new Set([...Array.from(NAVIGATION_KEYS), 'escape', 'esc', 'l',\n/** This symbol corresponds to the Alt + L combination under MAC. */\n'¬']);\n/**\n * @hidden\n * @internal\n *\n * Creates a new ResizeObserver on `target` and returns it as an Observable.\n * Run the resizeObservable outside angular zone, because it patches the MutationObserver which causes an infinite loop.\n * Related issue: https://github.com/angular/angular/issues/31712\n */\n\nconst resizeObservable = target => new Observable(observer => {\n  const instance = new (getResizeObserver())(entries => {\n    observer.next(entries);\n  });\n  instance.observe(target);\n\n  const unsubscribe = () => instance.disconnect();\n\n  return unsubscribe;\n});\n/**\n * @hidden\n * @internal\n *\n * Compares two maps.\n */\n\n\nconst compareMaps = (map1, map2) => {\n  if (!map2) {\n    return !map1 ? true : false;\n  }\n\n  if (map1.size !== map2.size) {\n    return false;\n  }\n\n  let match = true;\n  const keys = Array.from(map2.keys());\n\n  for (const key of keys) {\n    if (map1.has(key)) {\n      match = map1.get(key) === map2.get(key);\n    } else {\n      match = false;\n    }\n\n    if (!match) {\n      break;\n    }\n  }\n\n  return match;\n};\n/**\n *\n * Given a property access path in the format `x.y.z` resolves and returns\n * the value of the `z` property in the passed object.\n *\n * @hidden\n * @internal\n */\n\n\nconst resolveNestedPath = (obj, path) => {\n  var _a;\n\n  const parts = (_a = path === null || path === void 0 ? void 0 : path.split('.')) !== null && _a !== void 0 ? _a : [];\n  let current = obj[parts.shift()];\n  parts.forEach(prop => {\n    if (current) {\n      current = current[prop];\n    }\n  });\n  return current;\n};\n/**\n *\n * Given a property access path in the format `x.y.z` and a value\n * this functions builds and returns an object following the access path.\n *\n * @example\n * ```typescript\n * console.log('x.y.z.', 42);\n * >> { x: { y: { z: 42 } } }\n * ```\n *\n * @hidden\n * @internal\n */\n\n\nconst reverseMapper = (path, value) => {\n  var _a;\n\n  const obj = {};\n  const parts = (_a = path === null || path === void 0 ? void 0 : path.split('.')) !== null && _a !== void 0 ? _a : [];\n\n  let _prop = parts.shift();\n\n  let mapping; // Initial binding for first level bindings\n\n  obj[_prop] = value;\n  mapping = obj;\n  parts.forEach(prop => {\n    // Start building the hierarchy\n    mapping[_prop] = {}; // Go down a level\n\n    mapping = mapping[_prop]; // Bind the value and move the key\n\n    mapping[prop] = value;\n    _prop = prop;\n  });\n  return obj;\n};\n\nconst yieldingLoop = (count, chunkSize, callback, done) => {\n  let i = 0;\n\n  const chunk = () => {\n    const end = Math.min(i + chunkSize, count);\n\n    for (; i < end; ++i) {\n      callback(i);\n    }\n\n    if (i < count) {\n      setImmediate(chunk);\n    } else {\n      done();\n    }\n  };\n\n  chunk();\n};\n\nconst isConstructor = ref => typeof ref === 'function' && Boolean(ref.prototype) && Boolean(ref.prototype.constructor);\n\nconst reverseAnimationResolver = animation => {\n  var _a;\n\n  return (_a = oppositeAnimation.get(animation)) !== null && _a !== void 0 ? _a : animation;\n};\n\nconst isHorizontalAnimation = animation => horizontalAnimations.includes(animation);\n\nconst isVerticalAnimation = animation => verticalAnimations.includes(animation);\n\nconst oppositeAnimation = new Map([[fadeIn, fadeIn], [fadeOut, fadeOut], [flipTop, flipBottom], [flipBottom, flipTop], [flipRight, flipLeft], [flipLeft, flipRight], [flipHorFwd, flipHorBck], [flipHorBck, flipHorFwd], [flipVerFwd, flipVerBck], [flipVerBck, flipVerFwd], [growVerIn, growVerIn], [growVerOut, growVerOut], [heartbeat, heartbeat], [pulsateFwd, pulsateBck], [pulsateBck, pulsateFwd], [blink, blink], [shakeHor, shakeHor], [shakeVer, shakeVer], [shakeTop, shakeTop], [shakeBottom, shakeBottom], [shakeRight, shakeRight], [shakeLeft, shakeLeft], [shakeCenter, shakeCenter], [shakeTr, shakeTr], [shakeBr, shakeBr], [shakeBl, shakeBl], [shakeTl, shakeTl], [rotateInCenter, rotateInCenter], [rotateOutCenter, rotateOutCenter], [rotateInTop, rotateInBottom], [rotateOutTop, rotateOutBottom], [rotateInRight, rotateInLeft], [rotateOutRight, rotateOutLeft], [rotateInLeft, rotateInRight], [rotateOutLeft, rotateOutRight], [rotateInBottom, rotateInTop], [rotateOutBottom, rotateOutTop], [rotateInTr, rotateInBl], [rotateOutTr, rotateOutBl], [rotateInBr, rotateInTl], [rotateOutBr, rotateOutTl], [rotateInBl, rotateInTr], [rotateOutBl, rotateOutTr], [rotateInTl, rotateInBr], [rotateOutTl, rotateOutBr], [rotateInDiagonal1, rotateInDiagonal1], [rotateOutDiagonal1, rotateOutDiagonal1], [rotateInDiagonal2, rotateInDiagonal2], [rotateOutDiagonal2, rotateOutDiagonal2], [rotateInHor, rotateInHor], [rotateOutHor, rotateOutHor], [rotateInVer, rotateInVer], [rotateOutVer, rotateOutVer], [scaleInTop, scaleInBottom], [scaleOutTop, scaleOutBottom], [scaleInRight, scaleInLeft], [scaleOutRight, scaleOutLeft], [scaleInBottom, scaleInTop], [scaleOutBottom, scaleOutTop], [scaleInLeft, scaleInRight], [scaleOutLeft, scaleOutRight], [scaleInCenter, scaleInCenter], [scaleOutCenter, scaleOutCenter], [scaleInTr, scaleInBl], [scaleOutTr, scaleOutBl], [scaleInBr, scaleInTl], [scaleOutBr, scaleOutTl], [scaleInBl, scaleInTr], [scaleOutBl, scaleOutTr], [scaleInTl, scaleInBr], [scaleOutTl, scaleOutBr], [scaleInVerTop, scaleInVerBottom], [scaleOutVerTop, scaleOutVerBottom], [scaleInVerBottom, scaleInVerTop], [scaleOutVerBottom, scaleOutVerTop], [scaleInVerCenter, scaleInVerCenter], [scaleOutVerCenter, scaleOutVerCenter], [scaleInHorCenter, scaleInHorCenter], [scaleOutHorCenter, scaleOutHorCenter], [scaleInHorLeft, scaleInHorRight], [scaleOutHorLeft, scaleOutHorRight], [scaleInHorRight, scaleInHorLeft], [scaleOutHorRight, scaleOutHorLeft], [slideInTop, slideInBottom], [slideOutTop, slideOutBottom], [slideInRight, slideInLeft], [slideOutRight, slideOutLeft], [slideInBottom, slideInTop], [slideOutBottom, slideOutTop], [slideInLeft, slideInRight], [slideOutLeft, slideOutRight], [slideInTr, slideInBl], [slideOutTr, slideOutBl], [slideInBr, slideInTl], [slideOutBr, slideOutTl], [slideInBl, slideInTr], [slideOutBl, slideOutTr], [slideInTl, slideInBr], [slideOutTl, slideOutBr], [swingInTopFwd, swingInBottomFwd], [swingOutTopFwd, swingOutBottomFwd], [swingInRightFwd, swingInLeftFwd], [swingOutRightFwd, swingOutLefttFwd], [swingInLeftFwd, swingInRightFwd], [swingOutLefttFwd, swingOutRightFwd], [swingInBottomFwd, swingInTopFwd], [swingOutBottomFwd, swingOutTopFwd], [swingInTopBck, swingInBottomBck], [swingOutTopBck, swingOutBottomBck], [swingInRightBck, swingInLeftBck], [swingOutRightBck, swingOutLeftBck], [swingInBottomBck, swingInTopBck], [swingOutBottomBck, swingOutTopBck], [swingInLeftBck, swingInRightBck], [swingOutLeftBck, swingOutRightBck]]);\nconst horizontalAnimations = [flipRight, flipLeft, flipVerFwd, flipVerBck, rotateInRight, rotateOutRight, rotateInLeft, rotateOutLeft, rotateInTr, rotateOutTr, rotateInBr, rotateOutBr, rotateInBl, rotateOutBl, rotateInTl, rotateOutTl, scaleInRight, scaleOutRight, scaleInLeft, scaleOutLeft, scaleInTr, scaleOutTr, scaleInBr, scaleOutBr, scaleInBl, scaleOutBl, scaleInTl, scaleOutTl, scaleInHorLeft, scaleOutHorLeft, scaleInHorRight, scaleOutHorRight, slideInRight, slideOutRight, slideInLeft, slideOutLeft, slideInTr, slideOutTr, slideInBr, slideOutBr, slideInBl, slideOutBl, slideInTl, slideOutTl, swingInRightFwd, swingOutRightFwd, swingInLeftFwd, swingOutLefttFwd, swingInRightBck, swingOutRightBck, swingInLeftBck, swingOutLeftBck];\nconst verticalAnimations = [flipTop, flipBottom, flipHorFwd, flipHorBck, growVerIn, growVerOut, rotateInTop, rotateOutTop, rotateInBottom, rotateOutBottom, rotateInTr, rotateOutTr, rotateInBr, rotateOutBr, rotateInBl, rotateOutBl, rotateInTl, rotateOutTl, scaleInTop, scaleOutTop, scaleInBottom, scaleOutBottom, scaleInTr, scaleOutTr, scaleInBr, scaleOutBr, scaleInBl, scaleOutBl, scaleInTl, scaleOutTl, scaleInVerTop, scaleOutVerTop, scaleInVerBottom, scaleOutVerBottom, slideInTop, slideOutTop, slideInBottom, slideOutBottom, slideInTr, slideOutTr, slideInBr, slideOutBr, slideInBl, slideOutBl, slideInTl, slideOutTl, swingInTopFwd, swingOutTopFwd, swingInBottomFwd, swingOutBottomFwd, swingInTopBck, swingOutTopBck, swingInBottomBck, swingOutBottomBck];\n/**\n * Similar to Angular's formatDate. However it will not throw on `undefined | null` instead\n * coalescing to an empty string.\n */\n\nconst formatDate = (value, format, locale, timezone) => {\n  if (value === null || value === undefined) {\n    return '';\n  }\n\n  return formatDate$1(value, format, locale, timezone);\n};\n\nconst formatCurrency = new CurrencyPipe(undefined).transform;\nvar PagingError = /*#__PURE__*/(() => {\n  (function (PagingError) {\n    PagingError[PagingError[\"None\"] = 0] = \"None\";\n    PagingError[PagingError[\"IncorrectPageIndex\"] = 1] = \"IncorrectPageIndex\";\n    PagingError[PagingError[\"IncorrectRecordsPerPage\"] = 2] = \"IncorrectRecordsPerPage\";\n  })(PagingError || (PagingError = {}));\n\n  return PagingError;\n})();\nvar TransactionType = /*#__PURE__*/(() => {\n  (function (TransactionType) {\n    TransactionType[\"ADD\"] = \"add\";\n    TransactionType[\"DELETE\"] = \"delete\";\n    TransactionType[\"UPDATE\"] = \"update\";\n  })(TransactionType || (TransactionType = {}));\n\n  return TransactionType;\n})();\nvar TransactionEventOrigin = /*#__PURE__*/(() => {\n  (function (TransactionEventOrigin) {\n    TransactionEventOrigin[\"UNDO\"] = \"undo\";\n    TransactionEventOrigin[\"REDO\"] = \"redo\";\n    TransactionEventOrigin[\"CLEAR\"] = \"clear\";\n    TransactionEventOrigin[\"ADD\"] = \"add\";\n    TransactionEventOrigin[\"END\"] = \"endPending\";\n  })(TransactionEventOrigin || (TransactionEventOrigin = {}));\n\n  return TransactionEventOrigin;\n})();\n\nconst isHierarchyMatch = (h1, h2) => {\n  if (h1.length !== h2.length) {\n    return false;\n  }\n\n  return h1.every((level, index) => level.fieldName === h2[index].fieldName && level.value === h2[index].value);\n};\n\nconst getHierarchy = gRow => {\n  const hierarchy = [];\n\n  if (gRow !== undefined && gRow.expression) {\n    hierarchy.push({\n      fieldName: gRow.expression.fieldName,\n      value: gRow.value\n    });\n\n    while (gRow.groupParent) {\n      gRow = gRow.groupParent;\n      hierarchy.unshift({\n        fieldName: gRow.expression.fieldName,\n        value: gRow.value\n      });\n    }\n  }\n\n  return hierarchy;\n};\n\nvar SortingDirection = /*#__PURE__*/(() => {\n  (function (SortingDirection) {\n    SortingDirection[SortingDirection[\"None\"] = 0] = \"None\";\n    SortingDirection[SortingDirection[\"Asc\"] = 1] = \"Asc\";\n    SortingDirection[SortingDirection[\"Desc\"] = 2] = \"Desc\";\n  })(SortingDirection || (SortingDirection = {}));\n\n  return SortingDirection;\n})();\nlet DefaultSortingStrategy = /*#__PURE__*/(() => {\n  class DefaultSortingStrategy {\n    constructor() {}\n\n    static instance() {\n      return this._instance || (this._instance = new this());\n    }\n\n    sort(data, fieldName, dir, ignoreCase, valueResolver, isDate, isTime) {\n      const key = fieldName;\n      const reverse = dir === SortingDirection.Desc ? -1 : 1;\n\n      const cmpFunc = (obj1, obj2) => this.compareObjects(obj1, obj2, key, reverse, ignoreCase, valueResolver, isDate, isTime);\n\n      return this.arraySort(data, cmpFunc);\n    }\n\n    compareValues(a, b) {\n      const an = a === null || a === undefined;\n      const bn = b === null || b === undefined;\n\n      if (an) {\n        if (bn) {\n          return 0;\n        }\n\n        return -1;\n      } else if (bn) {\n        return 1;\n      }\n\n      return a > b ? 1 : a < b ? -1 : 0;\n    }\n\n    compareObjects(obj1, obj2, key, reverse, ignoreCase, valueResolver, isDate, isTime) {\n      let a = valueResolver.call(this, obj1, key, isDate, isTime);\n      let b = valueResolver.call(this, obj2, key, isDate, isTime);\n\n      if (ignoreCase) {\n        a = a && a.toLowerCase ? a.toLowerCase() : a;\n        b = b && b.toLowerCase ? b.toLowerCase() : b;\n      }\n\n      return reverse * this.compareValues(a, b);\n    }\n\n    arraySort(data, compareFn) {\n      return data.sort(compareFn);\n    }\n\n  }\n\n  DefaultSortingStrategy._instance = null;\n  return DefaultSortingStrategy;\n})();\nconst DATE_TYPE = 'date';\nconst TIME_TYPE = 'time';\nconst DATE_TIME_TYPE = 'dateTime';\nconst STRING_TYPE = 'string';\n\nclass IgxSorting {\n  sort(data, expressions, grid) {\n    return this.sortDataRecursive(data, expressions, 0, grid);\n  }\n\n  groupDataRecursive(data, state, level, parent, metadata, grid = null, groupsRecords = [], fullResult = {\n    data: [],\n    metadata: []\n  }) {\n    const expressions = state.expressions;\n    const expansion = state.expansion;\n    let i = 0;\n    let result = [];\n\n    while (i < data.length) {\n      const column = grid ? grid.getColumnByName(expressions[level].fieldName) : null;\n      const isDate = (column === null || column === void 0 ? void 0 : column.dataType) === DATE_TYPE || (column === null || column === void 0 ? void 0 : column.dataType) === DATE_TIME_TYPE;\n      const isTime = (column === null || column === void 0 ? void 0 : column.dataType) === TIME_TYPE;\n      const isString = (column === null || column === void 0 ? void 0 : column.dataType) === STRING_TYPE;\n      const group = this.groupedRecordsByExpression(data, i, expressions[level], isDate, isString);\n      const groupRow = {\n        expression: expressions[level],\n        level,\n        records: cloneArray(group),\n        value: this.getFieldValue(group[0], expressions[level].fieldName, isDate, isTime),\n        groupParent: parent,\n        groups: [],\n        height: grid ? grid.renderedRowHeight : null,\n        column\n      };\n\n      if (parent) {\n        parent.groups.push(groupRow);\n      } else {\n        groupsRecords.push(groupRow);\n      }\n\n      const hierarchy = getHierarchy(groupRow);\n      const expandState = expansion.find(s => isHierarchyMatch(s.hierarchy || [{\n        fieldName: groupRow.expression.fieldName,\n        value: groupRow.value\n      }], hierarchy));\n      const expanded = expandState ? expandState.expanded : state.defaultExpanded;\n      let recursiveResult;\n      result.push(groupRow);\n      metadata.push(null);\n      fullResult.data.push(groupRow);\n      fullResult.metadata.push(null);\n\n      if (level < expressions.length - 1) {\n        recursiveResult = this.groupDataRecursive(group, state, level + 1, groupRow, expanded ? metadata : [], grid, groupsRecords, fullResult);\n\n        if (expanded) {\n          result = result.concat(recursiveResult);\n        }\n      } else {\n        for (const groupItem of group) {\n          fullResult.metadata.push(groupRow);\n          fullResult.data.push(groupItem);\n        }\n\n        if (expanded) {\n          metadata.push(...fullResult.metadata.slice(fullResult.metadata.length - group.length));\n          result.push(...fullResult.data.slice(fullResult.data.length - group.length));\n        }\n      }\n\n      i += group.length;\n    }\n\n    return result;\n  }\n\n  getFieldValue(obj, key, isDate = false, isTime = false) {\n    let resolvedValue = resolveNestedPath(obj, key);\n\n    if (isDate || isTime) {\n      const date = parseDate(resolvedValue);\n      resolvedValue = isTime && date ? new Date().setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()) : date;\n    }\n\n    return resolvedValue;\n  }\n\n  groupedRecordsByExpression(data, index, expression, isDate = false, isString) {\n    const res = [];\n    const key = expression.fieldName;\n    const len = data.length;\n    let groupval = this.getFieldValue(data[index], key, isDate);\n    res.push(data[index]);\n    index++;\n    const comparer = expression.groupingComparer || DefaultSortingStrategy.instance().compareValues;\n\n    for (let i = index; i < len; i++) {\n      let fieldValue = this.getFieldValue(data[i], key, isDate);\n\n      if (expression.ignoreCase && isString) {\n        // when column's dataType is string but the value is number\n        fieldValue = fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.toString().toLowerCase();\n        groupval = groupval === null || groupval === void 0 ? void 0 : groupval.toString().toLowerCase();\n      }\n\n      if (comparer(fieldValue, groupval) === 0) {\n        res.push(data[i]);\n      } else {\n        break;\n      }\n    }\n\n    return res;\n  }\n\n  sortDataRecursive(data, expressions, expressionIndex = 0, grid) {\n    let i;\n    let j;\n    let gbData;\n    let gbDataLen;\n    const exprsLen = expressions.length;\n    const dataLen = data.length;\n    expressionIndex = expressionIndex || 0;\n\n    if (expressionIndex >= exprsLen || dataLen <= 1) {\n      return data;\n    }\n\n    const expr = expressions[expressionIndex];\n\n    if (!expr.strategy) {\n      expr.strategy = DefaultSortingStrategy.instance();\n    }\n\n    const column = grid === null || grid === void 0 ? void 0 : grid.getColumnByName(expr.fieldName);\n    const isDate = (column === null || column === void 0 ? void 0 : column.dataType) === DATE_TYPE || (column === null || column === void 0 ? void 0 : column.dataType) === DATE_TIME_TYPE;\n    const isTime = (column === null || column === void 0 ? void 0 : column.dataType) === TIME_TYPE;\n    const isString = (column === null || column === void 0 ? void 0 : column.dataType) === STRING_TYPE;\n    data = expr.strategy.sort(data, expr.fieldName, expr.dir, expr.ignoreCase, this.getFieldValue, isDate, isTime, grid);\n\n    if (expressionIndex === exprsLen - 1) {\n      return data;\n    } // in case of multiple sorting\n\n\n    for (i = 0; i < dataLen; i++) {\n      gbData = this.groupedRecordsByExpression(data, i, expr, isDate, isString);\n      gbDataLen = gbData.length;\n\n      if (gbDataLen > 1) {\n        gbData = this.sortDataRecursive(gbData, expressions, expressionIndex + 1, grid);\n      }\n\n      for (j = 0; j < gbDataLen; j++) {\n        data[i + j] = gbData[j];\n      }\n\n      i += gbDataLen - 1;\n    }\n\n    return data;\n  }\n\n}\n\nclass IgxGrouping extends IgxSorting {\n  groupBy(data, state, grid, groupsRecords, fullResult = {\n    data: [],\n    metadata: []\n  }) {\n    const metadata = [];\n    const grouping = this.groupDataRecursive(data, state, 0, null, metadata, grid, groupsRecords, fullResult);\n    return {\n      data: grouping,\n      metadata\n    };\n  }\n\n}\n\nlet NoopSortingStrategy = /*#__PURE__*/(() => {\n  class NoopSortingStrategy {\n    constructor() {}\n\n    static instance() {\n      return this._instance || (this._instance = new NoopSortingStrategy());\n    }\n\n    sort(data) {\n      return data;\n    }\n\n  }\n\n  NoopSortingStrategy._instance = null;\n  return NoopSortingStrategy;\n})();\n\nclass IgxDataRecordSorting extends IgxSorting {\n  getFieldValue(obj, key, isDate = false, isTime = false) {\n    return super.getFieldValue(obj.data, key, isDate, isTime);\n  }\n\n}\n\nclass DefaultDataCloneStrategy {\n  clone(data) {\n    return cloneValue(data);\n  }\n\n}\n/**\n * @hidden\n */\n\n\nconst GridColumnDataType = mkenum({\n  String: 'string',\n  Number: 'number',\n  Boolean: 'boolean',\n  Date: 'date',\n  DateTime: 'dateTime',\n  Time: 'time',\n  Currency: 'currency',\n  Percent: 'percent'\n});\n/**\n * @hidden\n */\n\nclass DataUtil {\n  static sort(data, expressions, sorting = new IgxSorting(), grid) {\n    return sorting.sort(data, expressions, grid);\n  }\n\n  static treeGridSort(hierarchicalData, expressions, sorting = new IgxDataRecordSorting(), parent, grid) {\n    let res = [];\n    hierarchicalData.forEach(hr => {\n      const rec = DataUtil.cloneTreeGridRecord(hr);\n      rec.parent = parent;\n\n      if (rec.children) {\n        rec.children = DataUtil.treeGridSort(rec.children, expressions, sorting, rec, grid);\n      }\n\n      res.push(rec);\n    });\n    res = DataUtil.sort(res, expressions, sorting, grid);\n    return res;\n  }\n\n  static cloneTreeGridRecord(hierarchicalRecord) {\n    const rec = {\n      key: hierarchicalRecord.key,\n      data: hierarchicalRecord.data,\n      children: hierarchicalRecord.children,\n      isFilteredOutParent: hierarchicalRecord.isFilteredOutParent,\n      level: hierarchicalRecord.level,\n      expanded: hierarchicalRecord.expanded\n    };\n    return rec;\n  }\n\n  static group(data, state, grouping = new IgxGrouping(), grid = null, groupsRecords = [], fullResult = {\n    data: [],\n    metadata: []\n  }) {\n    groupsRecords.splice(0, groupsRecords.length);\n    return grouping.groupBy(data, state, grid, groupsRecords, fullResult);\n  }\n\n  static page(data, state, dataLength) {\n    if (!state) {\n      return data;\n    }\n\n    const len = dataLength !== undefined ? dataLength : data.length;\n    const index = state.index;\n    const res = [];\n    const recordsPerPage = dataLength !== undefined && state.recordsPerPage > dataLength ? dataLength : state.recordsPerPage;\n    state.metadata = {\n      countPages: 0,\n      countRecords: len,\n      error: PagingError.None\n    };\n\n    if (index < 0 || isNaN(index)) {\n      state.metadata.error = PagingError.IncorrectPageIndex;\n      return res;\n    }\n\n    if (recordsPerPage <= 0 || isNaN(recordsPerPage)) {\n      state.metadata.error = PagingError.IncorrectRecordsPerPage;\n      return res;\n    }\n\n    state.metadata.countPages = Math.ceil(len / recordsPerPage);\n\n    if (!len) {\n      return data;\n    }\n\n    if (index >= state.metadata.countPages) {\n      state.metadata.error = PagingError.IncorrectPageIndex;\n      return res;\n    }\n\n    return data.slice(index * recordsPerPage, (index + 1) * recordsPerPage);\n  }\n\n  static correctPagingState(state, length) {\n    const maxPage = Math.ceil(length / state.recordsPerPage) - 1;\n\n    if (!isNaN(maxPage) && state.index > maxPage) {\n      state.index = maxPage;\n    }\n  }\n\n  static getHierarchy(gRow) {\n    return getHierarchy(gRow);\n  }\n\n  static isHierarchyMatch(h1, h2) {\n    return isHierarchyMatch(h1, h2);\n  }\n  /**\n   * Merges all changes from provided transactions into provided data collection\n   *\n   * @param data Collection to merge\n   * @param transactions Transactions to merge into data\n   * @param primaryKey Primary key of the collection, if any\n   * @param deleteRows Should delete rows with DELETE transaction type from data\n   * @returns Provided data collections updated with all provided transactions\n   */\n\n\n  static mergeTransactions(data, transactions, primaryKey, cloneStrategy = new DefaultDataCloneStrategy(), deleteRows = false) {\n    data.forEach((item, index) => {\n      const rowId = primaryKey ? item[primaryKey] : item;\n      const transaction = transactions.find(t => t.id === rowId);\n\n      if (transaction && transaction.type === TransactionType.UPDATE) {\n        data[index] = mergeObjects(cloneStrategy.clone(data[index]), transaction.newValue);\n      }\n    });\n\n    if (deleteRows) {\n      transactions.filter(t => t.type === TransactionType.DELETE).forEach(t => {\n        const index = primaryKey ? data.findIndex(d => d[primaryKey] === t.id) : data.findIndex(d => d === t.id);\n\n        if (0 <= index && index < data.length) {\n          data.splice(index, 1);\n        }\n      });\n    }\n\n    data.push(...transactions.filter(t => t.type === TransactionType.ADD).map(t => t.newValue));\n    return data;\n  }\n  /**\n   * Merges all changes from provided transactions into provided hierarchical data collection\n   *\n   * @param data Collection to merge\n   * @param transactions Transactions to merge into data\n   * @param childDataKey Data key of child collections\n   * @param primaryKey Primary key of the collection, if any\n   * @param deleteRows Should delete rows with DELETE transaction type from data\n   * @returns Provided data collections updated with all provided transactions\n   */\n\n\n  static mergeHierarchicalTransactions(data, transactions, childDataKey, primaryKey, cloneStrategy = new DefaultDataCloneStrategy(), deleteRows = false) {\n    for (const transaction of transactions) {\n      if (transaction.path) {\n        const parent = this.findParentFromPath(data, primaryKey, childDataKey, transaction.path);\n        let collection = parent ? parent[childDataKey] : data;\n\n        switch (transaction.type) {\n          case TransactionType.ADD:\n            //  if there is no parent this is ADD row at root level\n            if (parent && !parent[childDataKey]) {\n              parent[childDataKey] = collection = [];\n            }\n\n            collection.push(transaction.newValue);\n            break;\n\n          case TransactionType.UPDATE:\n            const updateIndex = collection.findIndex(x => x[primaryKey] === transaction.id);\n\n            if (updateIndex !== -1) {\n              collection[updateIndex] = mergeObjects(cloneStrategy.clone(collection[updateIndex]), transaction.newValue);\n            }\n\n            break;\n\n          case TransactionType.DELETE:\n            if (deleteRows) {\n              const deleteIndex = collection.findIndex(r => r[primaryKey] === transaction.id);\n\n              if (deleteIndex !== -1) {\n                collection.splice(deleteIndex, 1);\n              }\n            }\n\n            break;\n        }\n      } else {\n        //  if there is no path this is ADD row in root. Push the newValue to data\n        data.push(transaction.newValue);\n      }\n    }\n\n    return data;\n  }\n\n  static parseValue(dataType, value) {\n    if (dataType === GridColumnDataType.Number || dataType === GridColumnDataType.Currency || dataType === GridColumnDataType.Percent) {\n      value = parseFloat(value);\n    }\n\n    return value;\n  }\n\n  static findParentFromPath(data, primaryKey, childDataKey, path) {\n    let collection = data;\n    let result;\n\n    for (const id of path) {\n      result = collection && collection.find(x => x[primaryKey] === id);\n\n      if (!result) {\n        break;\n      }\n\n      collection = result[childDataKey];\n    }\n\n    return result;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass ExportUtilities {\n  static getKeysFromData(data) {\n    const length = data.length;\n\n    if (length === 0) {\n      return [];\n    }\n\n    const dataEntry = data[0];\n    const dataEntryMiddle = data[Math.floor(length / 2)];\n    const dataEntryLast = data[length - 1];\n    const keys1 = Object.keys(dataEntry);\n    const keys2 = Object.keys(dataEntryMiddle);\n    const keys3 = Object.keys(dataEntryLast);\n    const keys = new Set(keys1.concat(keys2).concat(keys3));\n    return !ExportUtilities.isSpecialData(dataEntry) ? Array.from(keys) : ['Column 1'];\n  }\n\n  static saveBlobToFile(blob, fileName) {\n    const a = document.createElement('a');\n    const url = window.URL.createObjectURL(blob);\n    a.download = fileName;\n    a.href = url;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    window.URL.revokeObjectURL(url);\n  }\n\n  static stringToArrayBuffer(s) {\n    const buf = new ArrayBuffer(s.length);\n    const view = new Uint8Array(buf);\n\n    for (let i = 0; i !== s.length; ++i) {\n      /* eslint-disable  no-bitwise */\n      view[i] = s.charCodeAt(i) & 0xFF;\n      /* eslint-enable  no-bitwise */\n    }\n\n    return buf;\n  }\n\n  static isSpecialData(data) {\n    return typeof data === 'string' || typeof data === 'number' || data instanceof Date;\n  }\n\n  static hasValue(value) {\n    return value !== undefined && value !== null;\n  }\n\n  static isNullOrWhitespaces(value) {\n    return value === undefined || value === null || !value.trim();\n  }\n\n}\n\nvar FilteringExpressionsTreeType = /*#__PURE__*/(() => {\n  (function (FilteringExpressionsTreeType) {\n    FilteringExpressionsTreeType[FilteringExpressionsTreeType[\"Regular\"] = 0] = \"Regular\";\n    FilteringExpressionsTreeType[FilteringExpressionsTreeType[\"Advanced\"] = 1] = \"Advanced\";\n  })(FilteringExpressionsTreeType || (FilteringExpressionsTreeType = {}));\n\n  return FilteringExpressionsTreeType;\n})();\n\nclass FilteringExpressionsTree {\n  constructor(operator, fieldName) {\n    /**\n     * Sets/gets the filtering operands.\n     * ```typescript\n     * const gridExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And);\n     * const expression = [\n     * {\n     *   condition: IgxStringFilteringOperand.instance().condition('contains'),\n     *   fieldName: 'Column Field',\n     *   searchVal: 'Value',\n     *   ignoreCase: false\n     * }];\n     * gridExpressionsTree.filteringOperands.push(expression);\n     * this.grid.filteringExpressionsTree = gridExpressionsTree;\n     * ```\n     * ```typescript\n     * let filteringOperands = gridExpressionsTree.filteringOperands;\n     * ```\n     *\n     * @memberof FilteringExpressionsTree\n     */\n    this.filteringOperands = [];\n    this.operator = operator;\n    this.fieldName = fieldName;\n  }\n  /**\n   * Checks if filtering expressions tree is empty.\n   *\n   * @param expressionTree filtering expressions tree.\n   */\n\n\n  static empty(expressionTree) {\n    return !expressionTree || !expressionTree.filteringOperands || !expressionTree.filteringOperands.length;\n  }\n  /**\n   * Returns the filtering expression for a column with the provided fieldName.\n   * ```typescript\n   * let filteringExpression = gridExpressionTree.find('Column Field');\n   * ```\n   *\n   * @memberof FilteringExpressionsTree\n   */\n\n\n  find(fieldName) {\n    const index = this.findIndex(fieldName);\n\n    if (index > -1) {\n      return this.filteringOperands[index];\n    }\n\n    return null;\n  }\n  /**\n   * Returns the index of the filtering expression for a column with the provided fieldName.\n   * ```typescript\n   * let filteringExpressionIndex = gridExpressionTree.findIndex('Column Field');\n   * ```\n   *\n   * @memberof FilteringExpressionsTree\n   */\n\n\n  findIndex(fieldName) {\n    let expr;\n\n    for (let i = 0; i < this.filteringOperands.length; i++) {\n      expr = this.filteringOperands[i];\n\n      if (expr instanceof FilteringExpressionsTree) {\n        if (this.isFilteringExpressionsTreeForColumn(expr, fieldName)) {\n          return i;\n        }\n      } else {\n        if (expr.fieldName === fieldName) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  }\n\n  isFilteringExpressionsTreeForColumn(expressionsTree, fieldName) {\n    if (expressionsTree.fieldName === fieldName) {\n      return true;\n    }\n\n    for (const expr of expressionsTree.filteringOperands) {\n      if (expr instanceof FilteringExpressionsTree) {\n        return this.isFilteringExpressionsTreeForColumn(expr, fieldName);\n      } else {\n        return expr.fieldName === fieldName;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nvar FilteringLogic = /*#__PURE__*/(() => {\n  (function (FilteringLogic) {\n    FilteringLogic[FilteringLogic[\"And\"] = 0] = \"And\";\n    FilteringLogic[FilteringLogic[\"Or\"] = 1] = \"Or\";\n  })(FilteringLogic || (FilteringLogic = {}));\n\n  return FilteringLogic;\n})();\nconst DateType = 'date';\nconst DateTimeType = 'dateTime';\nconst TimeType = 'time';\n\nclass FilterUtil {\n  static filter(data, state, grid) {\n    if (!state.strategy) {\n      state.strategy = new FilteringStrategy();\n    }\n\n    return state.strategy.filter(data, state.expressionsTree, state.advancedExpressionsTree, grid);\n  }\n\n}\n\nclass BaseFilteringStrategy {\n  // protected\n  findMatchByExpression(rec, expr, isDate, isTime, grid) {\n    const cond = expr.condition;\n    const val = this.getFieldValue(rec, expr.fieldName, isDate, isTime, grid);\n    return cond.logic(val, expr.searchVal, expr.ignoreCase);\n  } // protected\n\n\n  matchRecord(rec, expressions, grid) {\n    if (expressions) {\n      if (expressions instanceof FilteringExpressionsTree) {\n        const expressionsTree = expressions;\n        const operator = expressionsTree.operator;\n        let matchOperand;\n\n        if (expressionsTree.filteringOperands && expressionsTree.filteringOperands.length) {\n          for (const operand of expressionsTree.filteringOperands) {\n            matchOperand = this.matchRecord(rec, operand, grid); // Return false if at least one operand does not match and the filtering logic is And\n\n            if (!matchOperand && operator === FilteringLogic.And) {\n              return false;\n            } // Return true if at least one operand matches and the filtering logic is Or\n\n\n            if (matchOperand && operator === FilteringLogic.Or) {\n              return true;\n            }\n          }\n\n          return matchOperand;\n        }\n\n        return true;\n      } else {\n        const expression = expressions;\n        const column = grid && grid.getColumnByName(expression.fieldName);\n        const isDate = column ? column.dataType === DateType || column.dataType === DateTimeType : false;\n        const isTime = column ? column.dataType === TimeType : false;\n        return this.findMatchByExpression(rec, expression, isDate, isTime, grid);\n      }\n    }\n\n    return true;\n  }\n\n  getFilterItems(column, tree) {\n    let data = column.grid.gridAPI.filterDataByExpressions(tree);\n    data = column.grid.gridAPI.sortDataByExpressions(data, [{\n      fieldName: column.field,\n      dir: SortingDirection.Asc,\n      ignoreCase: column.sortingIgnoreCase\n    }]);\n    const columnField = column.field;\n    let filterItems = data.map(record => {\n      let value = resolveNestedPath(record, columnField);\n      const applyFormatter = column.formatter && this.shouldFormatFilterValues(column);\n      value = applyFormatter ? column.formatter(value, record) : value;\n      return {\n        value,\n        label: this.getFilterItemLabel(column, value, !applyFormatter, record)\n      };\n    });\n    filterItems = this.getUniqueFilterItems(column, filterItems);\n    return Promise.resolve(filterItems);\n  }\n\n  getFilterItemLabel(column, value, applyFormatter, data) {\n    if (column.formatter) {\n      if (applyFormatter) {\n        return column.formatter(value, data);\n      }\n\n      return value;\n    }\n\n    const {\n      display,\n      format,\n      digitsInfo,\n      currencyCode,\n      timezone\n    } = column.pipeArgs;\n    const locale = column.grid.locale;\n\n    switch (column.dataType) {\n      case GridColumnDataType.Date:\n      case GridColumnDataType.DateTime:\n      case GridColumnDataType.Time:\n        return formatDate(value, format, locale, timezone);\n\n      case GridColumnDataType.Currency:\n        return formatCurrency(value, currencyCode || getLocaleCurrencyCode(locale), display, digitsInfo, locale);\n\n      case GridColumnDataType.Number:\n        return formatNumber(value, locale, digitsInfo);\n\n      case GridColumnDataType.Percent:\n        return formatPercent(value, locale, digitsInfo);\n\n      default:\n        return value;\n    }\n  }\n\n  getUniqueFilterItems(column, filterItems) {\n    const filteredUniqueValues = filterItems.reduce((map, item) => {\n      var _a;\n\n      let key = item.value;\n\n      if (column.dataType === GridColumnDataType.String && column.filteringIgnoreCase) {\n        key = key === null || key === void 0 ? void 0 : key.toString().toLowerCase();\n      } else if (column.dataType === GridColumnDataType.DateTime) {\n        key = (_a = item.value) === null || _a === void 0 ? void 0 : _a.toString();\n        item.value = key ? new Date(key) : key;\n      } else if (column.dataType === GridColumnDataType.Time) {\n        const date = key ? new Date(key) : key;\n        key = date ? new Date().setHours(date.getHours(), date.getMinutes(), date.getSeconds()) : key;\n        item.value = key ? new Date(key) : key;\n      } else if (column.dataType === GridColumnDataType.Date) {\n        const date = key ? new Date(key) : key;\n        key = date ? new Date(date.getFullYear(), date.getMonth(), date.getDate()).toISOString() : key;\n        item.value = date;\n      }\n\n      return map.has(key) ? map : map.set(key, item);\n    }, new Map());\n    const uniqueValues = Array.from(filteredUniqueValues.values());\n    return uniqueValues;\n  }\n\n  shouldFormatFilterValues(_column) {\n    return false;\n  }\n\n}\n\nlet NoopFilteringStrategy = /*#__PURE__*/(() => {\n  class NoopFilteringStrategy extends BaseFilteringStrategy {\n    getFieldValue(rec, _fieldName) {\n      return rec;\n    }\n\n    static instance() {\n      return this._instance || (this._instance = new NoopFilteringStrategy());\n    }\n\n    filter(data, _, __) {\n      return data;\n    }\n\n  }\n\n  NoopFilteringStrategy._instance = null;\n  return NoopFilteringStrategy;\n})();\nlet FilteringStrategy = /*#__PURE__*/(() => {\n  class FilteringStrategy extends BaseFilteringStrategy {\n    constructor() {\n      super();\n    }\n\n    static instance() {\n      return this._instance || (this._instance = new this());\n    }\n\n    filter(data, expressionsTree, advancedExpressionsTree, grid) {\n      let i;\n      let rec;\n      const len = data.length;\n      const res = [];\n\n      if (FilteringExpressionsTree.empty(expressionsTree) && FilteringExpressionsTree.empty(advancedExpressionsTree) || !len) {\n        return data;\n      }\n\n      for (i = 0; i < len; i++) {\n        rec = data[i];\n\n        if (this.matchRecord(rec, expressionsTree, grid) && this.matchRecord(rec, advancedExpressionsTree, grid)) {\n          res.push(rec);\n        }\n      }\n\n      return res;\n    }\n\n    getFieldValue(rec, fieldName, isDate = false, isTime = false, grid) {\n      const column = grid === null || grid === void 0 ? void 0 : grid.getColumnByName(fieldName);\n      let value = resolveNestedPath(rec, fieldName);\n      value = (column === null || column === void 0 ? void 0 : column.formatter) && this.shouldFormatFilterValues(column) ? column.formatter(value, rec) : value && (isDate || isTime) ? parseDate(value) : value;\n      return value;\n    }\n\n  }\n\n  FilteringStrategy._instance = null;\n  return FilteringStrategy;\n})();\n\nclass FormattedValuesFilteringStrategy extends FilteringStrategy {\n  /**\n   * Creates a new instance of FormattedValuesFilteringStrategy.\n   *\n   * @param fields An array of column field names that should be formatted.\n   * If omitted the values of all columns which has formatter will be formatted.\n   */\n  constructor(fields) {\n    super();\n    this.fields = fields;\n  }\n\n  shouldFormatFilterValues(column) {\n    return !this.fields || this.fields.length === 0 || this.fields.some(f => f === column.field);\n  }\n\n}\n\nclass TreeGridFilteringStrategy extends BaseFilteringStrategy {\n  constructor(hierarchicalFilterFields) {\n    super();\n    this.hierarchicalFilterFields = hierarchicalFilterFields;\n  }\n\n  filter(data, expressionsTree, advancedExpressionsTree, grid) {\n    return this.filterImpl(data, expressionsTree, advancedExpressionsTree, undefined, grid);\n  }\n\n  getFieldValue(rec, fieldName, isDate = false, isTime = false, grid) {\n    const column = grid === null || grid === void 0 ? void 0 : grid.getColumnByName(fieldName);\n    const hierarchicalRecord = rec;\n    let value = this.isHierarchicalFilterField(fieldName) ? this.getHierarchicalFieldValue(hierarchicalRecord, fieldName) : resolveNestedPath(hierarchicalRecord.data, fieldName);\n    value = (column === null || column === void 0 ? void 0 : column.formatter) && this.shouldFormatFilterValues(column) ? column.formatter(value, rec.data) : value && (isDate || isTime) ? parseDate(value) : value;\n    return value;\n  }\n\n  getHierarchicalFieldValue(record, field) {\n    const value = resolveNestedPath(record.data, field);\n    return record.parent ? `${this.getHierarchicalFieldValue(record.parent, field)}${value ? `.[${value}]` : ''}` : `[${value}]`;\n  }\n\n  filterImpl(data, expressionsTree, advancedExpressionsTree, parent, grid) {\n    let i;\n    let rec;\n    const len = data.length;\n    const res = [];\n\n    if (FilteringExpressionsTree.empty(expressionsTree) && FilteringExpressionsTree.empty(advancedExpressionsTree) || !len) {\n      return data;\n    }\n\n    for (i = 0; i < len; i++) {\n      rec = DataUtil.cloneTreeGridRecord(data[i]);\n      rec.parent = parent;\n\n      if (rec.children) {\n        const filteredChildren = this.filterImpl(rec.children, expressionsTree, advancedExpressionsTree, rec, grid);\n        rec.children = filteredChildren.length > 0 ? filteredChildren : null;\n      }\n\n      if (this.matchRecord(rec, expressionsTree, grid) && this.matchRecord(rec, advancedExpressionsTree, grid)) {\n        res.push(rec);\n      } else if (rec.children && rec.children.length > 0) {\n        rec.isFilteredOutParent = true;\n        res.push(rec);\n      }\n    }\n\n    return res;\n  }\n\n  isHierarchicalFilterField(field) {\n    return this.hierarchicalFilterFields && this.hierarchicalFilterFields.indexOf(field) !== -1;\n  }\n\n  getFilterItems(column, tree) {\n    if (!this.isHierarchicalFilterField(column.field)) {\n      return super.getFilterItems(column, tree);\n    }\n\n    let data = column.grid.gridAPI.filterTreeDataByExpressions(tree);\n    data = DataUtil.treeGridSort(data, [{\n      fieldName: column.field,\n      dir: SortingDirection.Asc,\n      ignoreCase: column.sortingIgnoreCase\n    }], column.grid.sortStrategy, null, column.grid);\n    const items = this.getHierarchicalFilterItems(data, column);\n    return Promise.resolve(items);\n  }\n\n  getHierarchicalFilterItems(records, column, parent) {\n    return records === null || records === void 0 ? void 0 : records.map(record => {\n      let value = resolveNestedPath(record.data, column.field);\n      const applyFormatter = column.formatter && this.shouldFormatFilterValues(column);\n      value = applyFormatter ? column.formatter(value, record.data) : value;\n      const hierarchicalValue = parent ? value || value === 0 ? `${parent.value}.[${value}]` : value : `[${value}]`;\n      const filterItem = {\n        value: hierarchicalValue\n      };\n      filterItem.label = this.getFilterItemLabel(column, value, !applyFormatter, record.data);\n      filterItem.children = this.getHierarchicalFilterItems(record.children, column, filterItem);\n      return filterItem;\n    });\n  }\n\n}\n\nclass TreeGridFormattedValuesFilteringStrategy extends TreeGridFilteringStrategy {\n  /**\n   * Creates a new instance of FormattedValuesFilteringStrategy.\n   *\n   * @param fields An array of column field names that should be formatted.\n   * If omitted the values of all columns which has formatter will be formatted.\n   */\n  constructor(fields) {\n    super();\n    this.fields = fields;\n  }\n\n  shouldFormatFilterValues(column) {\n    return !this.fields || this.fields.length === 0 || this.fields.some(f => f === column.field);\n  }\n\n}\n\nclass TreeGridMatchingRecordsOnlyFilteringStrategy extends TreeGridFilteringStrategy {\n  filter(data, expressionsTree, advancedExpressionsTree, grid) {\n    return this.filterImplementation(data, expressionsTree, advancedExpressionsTree, undefined, grid);\n  }\n\n  filterImplementation(data, expressionsTree, advancedExpressionsTree, parent, grid) {\n    let i;\n    let rec;\n    const len = data.length;\n    const res = [];\n\n    if (FilteringExpressionsTree.empty(expressionsTree) && FilteringExpressionsTree.empty(advancedExpressionsTree) || !len) {\n      return data;\n    }\n\n    for (i = 0; i < len; i++) {\n      rec = DataUtil.cloneTreeGridRecord(data[i]);\n      rec.parent = parent;\n\n      if (rec.children) {\n        const filteredChildren = this.filterImplementation(rec.children, expressionsTree, advancedExpressionsTree, rec, grid);\n        rec.children = filteredChildren.length > 0 ? filteredChildren : null;\n      }\n\n      if (this.matchRecord(rec, expressionsTree, grid) && this.matchRecord(rec, advancedExpressionsTree, grid)) {\n        res.push(rec);\n      } else if (rec.children && rec.children.length > 0) {\n        rec = this.setCorrectLevelToFilteredRecords(rec);\n        res.push(...rec.children);\n      }\n    }\n\n    return res;\n  }\n\n  setCorrectLevelToFilteredRecords(rec) {\n    if (rec.children && rec.children.length > 0) {\n      rec.children.map(child => {\n        child.level = child.level - 1;\n        return this.setCorrectLevelToFilteredRecords(child);\n      });\n    }\n\n    return rec;\n  }\n\n}\n\nvar ExportRecordType = /*#__PURE__*/(() => {\n  (function (ExportRecordType) {\n    ExportRecordType[\"GroupedRecord\"] = \"GroupedRecord\";\n    ExportRecordType[\"TreeGridRecord\"] = \"TreeGridRecord\";\n    ExportRecordType[\"DataRecord\"] = \"DataRecord\";\n    ExportRecordType[\"HierarchicalGridRecord\"] = \"HierarchicalGridRecord\";\n    ExportRecordType[\"HeaderRecord\"] = \"HeaderRecord\";\n  })(ExportRecordType || (ExportRecordType = {}));\n\n  return ExportRecordType;\n})();\nvar HeaderType = /*#__PURE__*/(() => {\n  (function (HeaderType) {\n    HeaderType[\"ColumnHeader\"] = \"ColumnHeader\";\n    HeaderType[\"MultiColumnHeader\"] = \"MultiColumnHeader\";\n  })(HeaderType || (HeaderType = {}));\n\n  return HeaderType;\n})();\n\n/**hidden\n * A helper class used to identify whether the user has set a specific columnIndex\n * during columnExporting, so we can honor it at the exported file.\n*/\nclass IgxColumnExportingEventArgs {\n  constructor(original) {\n    this.userSetIndex = false;\n    this.header = original.header;\n    this.field = original.field;\n    this.cancel = original.cancel;\n    this.skipFormatter = original.skipFormatter;\n    this.grid = original.grid;\n    this.owner = original.owner;\n    this._columnIndex = original.columnIndex;\n  }\n\n  get columnIndex() {\n    return this._columnIndex;\n  }\n\n  set columnIndex(value) {\n    this._columnIndex = value;\n    this.userSetIndex = true;\n  }\n\n}\n\nconst DEFAULT_OWNER = 'default';\nconst DEFAULT_COLUMN_WIDTH = 8.43;\n\nclass IgxBaseExporter {\n  constructor() {\n    this.exportEnded = new EventEmitter();\n    /**\n     * This event is emitted when a row is exported.\n     * ```typescript\n     * this.exporterService.rowExporting.subscribe((args: IRowExportingEventArgs) => {\n     * // put event handler code here\n     * });\n     * ```\n     *\n     * @memberof IgxBaseExporter\n     */\n\n    this.rowExporting = new EventEmitter();\n    /**\n     * This event is emitted when a column is exported.\n     * ```typescript\n     * this.exporterService.columnExporting.subscribe((args: IColumnExportingEventArgs) => {\n     * // put event handler code here\n     * });\n     * ```\n     *\n     * @memberof IgxBaseExporter\n     */\n\n    this.columnExporting = new EventEmitter();\n    this._sort = null;\n    this._ownersMap = new Map();\n    this.flatRecords = [];\n  }\n  /**\n   * Method for exporting IgxGrid component's data.\n   * ```typescript\n   * this.exporterService.export(this.igxGridForExport, this.exportOptions);\n   * ```\n   *\n   * @memberof IgxBaseExporter\n   */\n\n\n  export(grid, options) {\n    if (options === undefined || options === null) {\n      throw Error('No options provided!');\n    }\n\n    this.options = options;\n    let columns = grid.columnList.toArray();\n\n    if (this.options.ignoreMultiColumnHeaders) {\n      columns = columns.filter(col => col.children === undefined);\n    }\n\n    const columnList = this.getColumns(columns);\n    const tagName = grid.nativeElement.tagName.toLowerCase();\n\n    if (tagName === 'igx-hierarchical-grid') {\n      this._ownersMap.set(grid, columnList);\n\n      const childLayoutList = grid.childLayoutList;\n\n      for (const island of childLayoutList) {\n        this.mapHierarchicalGridColumns(island, grid.data[0]);\n      }\n    } else {\n      this._ownersMap.set(DEFAULT_OWNER, columnList);\n    }\n\n    this.prepareData(grid);\n    this.exportGridRecordsData(this.flatRecords, grid);\n  }\n  /**\n   * Method for exporting any kind of array data.\n   * ```typescript\n   * this.exporterService.exportData(this.arrayForExport, this.exportOptions);\n   * ```\n   *\n   * @memberof IgxBaseExporter\n   */\n\n\n  exportData(data, options) {\n    if (options === undefined || options === null) {\n      throw Error('No options provided!');\n    }\n\n    this.options = options;\n    const records = data.map(d => {\n      const record = {\n        data: d,\n        type: ExportRecordType.DataRecord,\n        level: 0\n      };\n      return record;\n    });\n    this.exportGridRecordsData(records);\n  }\n\n  exportGridRecordsData(records, grid) {\n    var _a;\n\n    if (this._ownersMap.size === 0) {\n      const recordsData = records.map(r => r.data);\n      const keys = ExportUtilities.getKeysFromData(recordsData);\n      const columns = keys.map(k => ({\n        header: k,\n        field: k,\n        skip: false,\n        headerType: HeaderType.ColumnHeader,\n        level: 0,\n        columnSpan: 1\n      }));\n      const columnWidths = new Array(keys.length).fill(DEFAULT_COLUMN_WIDTH);\n      const mapRecord = {\n        columns,\n        columnWidths,\n        indexOfLastPinnedColumn: -1,\n        maxLevel: 0\n      };\n\n      this._ownersMap.set(DEFAULT_OWNER, mapRecord);\n    }\n\n    let shouldReorderColumns = false;\n\n    for (const [key, mapRecord] of this._ownersMap) {\n      let skippedPinnedColumnsCount = 0;\n      let columnsWithoutHeaderCount = 1;\n      let indexOfLastPinnedColumn = mapRecord.indexOfLastPinnedColumn;\n      mapRecord.columns.forEach((column, index) => {\n        if (!column.skip) {\n          const columnExportArgs = {\n            header: !ExportUtilities.isNullOrWhitespaces(column.header) ? column.header : 'Column' + columnsWithoutHeaderCount++,\n            field: column.field,\n            columnIndex: index,\n            cancel: false,\n            skipFormatter: false,\n            grid: key === DEFAULT_OWNER ? grid : key\n          };\n          const newColumnExportArgs = new IgxColumnExportingEventArgs(columnExportArgs);\n          this.columnExporting.emit(newColumnExportArgs);\n          column.header = newColumnExportArgs.header;\n          column.skip = newColumnExportArgs.cancel;\n          column.skipFormatter = newColumnExportArgs.skipFormatter;\n\n          if (newColumnExportArgs.userSetIndex) {\n            column.exportIndex = newColumnExportArgs.columnIndex;\n            shouldReorderColumns = true;\n          }\n\n          if (column.skip) {\n            if (index <= indexOfLastPinnedColumn) {\n              skippedPinnedColumnsCount++;\n            }\n\n            this.calculateColumnSpans(column, mapRecord, column.columnSpan);\n            const nonSkippedColumns = mapRecord.columns.filter(c => !c.skip);\n\n            if (nonSkippedColumns.length > 0) {\n              this._ownersMap.get(key).maxLevel = nonSkippedColumns.sort((a, b) => b.level - a.level)[0].level;\n            }\n          }\n\n          if (this._sort && this._sort.fieldName === column.field) {\n            if (column.skip) {\n              this._sort = null;\n            } else {\n              this._sort.fieldName = column.header;\n            }\n          }\n        }\n      });\n      indexOfLastPinnedColumn -= skippedPinnedColumnsCount; // Reorder columns only if a column has been assigned a specific columnIndex during columnExporting event\n\n      if (shouldReorderColumns) {\n        mapRecord.columns = this.reorderColumns(mapRecord.columns);\n      }\n    }\n\n    const dataToExport = new Array();\n    const actualData = (_a = records[0]) === null || _a === void 0 ? void 0 : _a.data;\n    const isSpecialData = ExportUtilities.isSpecialData(actualData);\n    yieldingLoop(records.length, 100, i => {\n      const row = records[i];\n      this.exportRow(dataToExport, row, i, isSpecialData);\n    }, () => {\n      this.exportDataImplementation(dataToExport, this.options, () => {\n        this.resetDefaults();\n      });\n    });\n  }\n\n  calculateColumnSpans(column, mapRecord, span) {\n    if (column.headerType === HeaderType.MultiColumnHeader && column.skip) {\n      const columnGroupChildren = mapRecord.columns.filter(c => c.columnGroupParent === column.columnGroup);\n      columnGroupChildren.forEach(cgc => {\n        if (cgc.headerType === HeaderType.MultiColumnHeader) {\n          cgc.columnSpan = 0;\n          cgc.columnGroupParent = null;\n          cgc.skip = true;\n          this.calculateColumnSpans(cgc, mapRecord, cgc.columnSpan);\n        } else {\n          cgc.skip = true;\n        }\n      });\n    }\n\n    const targetCol = mapRecord.columns.filter(c => column.columnGroupParent !== null && c.columnGroup === column.columnGroupParent)[0];\n\n    if (targetCol !== undefined) {\n      targetCol.columnSpan -= span;\n\n      if (targetCol.columnGroupParent !== null) {\n        this.calculateColumnSpans(targetCol, mapRecord, span);\n      }\n\n      if (targetCol.columnSpan === 0) {\n        targetCol.skip = true;\n      }\n    }\n  }\n\n  exportRow(data, record, index, isSpecialData) {\n    if (!isSpecialData) {\n      const owner = record.owner === undefined ? DEFAULT_OWNER : record.owner;\n\n      const ownerCols = this._ownersMap.get(owner).columns;\n\n      if (record.type !== ExportRecordType.HeaderRecord) {\n        const columns = ownerCols.filter(c => c.headerType !== HeaderType.MultiColumnHeader && !c.skip).sort((a, b) => a.startIndex - b.startIndex).sort((a, b) => a.pinnedIndex - b.pinnedIndex);\n        record.data = columns.reduce((a, e) => {\n          if (!e.skip) {\n            let rawValue = resolveNestedPath(record.data, e.field);\n            const shouldApplyFormatter = e.formatter && !e.skipFormatter && record.type !== ExportRecordType.GroupedRecord;\n\n            if (e.dataType === 'date' && !(rawValue instanceof Date) && !shouldApplyFormatter && rawValue !== undefined && rawValue !== null) {\n              rawValue = new Date(rawValue);\n            } else if (e.dataType === 'string' && rawValue instanceof Date) {\n              rawValue = rawValue.toString();\n            }\n\n            a[e.field] = shouldApplyFormatter ? e.formatter(rawValue) : rawValue;\n          }\n\n          return a;\n        }, {});\n      } else {\n        const filteredHeaders = ownerCols.filter(c => c.skip).map(c => c.header ? c.header : c.field);\n        record.data = record.data.filter(d => filteredHeaders.indexOf(d) === -1);\n      }\n    }\n\n    const rowArgs = {\n      rowData: record.data,\n      rowIndex: index,\n      cancel: false\n    };\n    this.rowExporting.emit(rowArgs);\n\n    if (!rowArgs.cancel) {\n      data.push(record);\n    }\n  }\n\n  reorderColumns(columns) {\n    const filteredColumns = columns.filter(c => !c.skip);\n    const length = filteredColumns.length;\n    const specificIndicesColumns = filteredColumns.filter(col => !isNaN(col.exportIndex)).sort((a, b) => a.exportIndex - b.exportIndex);\n    const indices = specificIndicesColumns.map(col => col.exportIndex);\n    specificIndicesColumns.forEach(col => {\n      filteredColumns.splice(filteredColumns.indexOf(col), 1);\n    });\n    const reorderedColumns = new Array(length);\n\n    if (specificIndicesColumns.length > Math.max(...indices)) {\n      return specificIndicesColumns.concat(filteredColumns);\n    } else {\n      indices.forEach((i, index) => {\n        if (i < 0 || i >= length) {\n          filteredColumns.push(specificIndicesColumns[index]);\n        } else {\n          let k = i;\n\n          while (k < length && reorderedColumns[k] !== undefined) {\n            ++k;\n          }\n\n          reorderedColumns[k] = specificIndicesColumns[index];\n        }\n      });\n\n      for (let i = 0; i < length; i++) {\n        if (reorderedColumns[i] === undefined) {\n          reorderedColumns[i] = filteredColumns.splice(0, 1)[0];\n        }\n      }\n    }\n\n    return reorderedColumns;\n  }\n\n  prepareData(grid) {\n    this.flatRecords = [];\n    const tagName = grid.nativeElement.tagName.toLowerCase();\n    const hasFiltering = grid.filteringExpressionsTree && grid.filteringExpressionsTree.filteringOperands.length > 0 || grid.advancedFilteringExpressionsTree && grid.advancedFilteringExpressionsTree.filteringOperands.length > 0;\n    const hasSorting = grid.sortingExpressions && grid.sortingExpressions.length > 0;\n\n    switch (tagName) {\n      case 'igx-hierarchical-grid':\n        {\n          this.prepareHierarchicalGridData(grid, hasFiltering, hasSorting);\n          break;\n        }\n\n      case 'igx-tree-grid':\n        {\n          this.prepareTreeGridData(grid, hasFiltering, hasSorting);\n          break;\n        }\n\n      default:\n        {\n          this.prepareGridData(grid, hasFiltering, hasSorting);\n          break;\n        }\n    }\n  }\n\n  prepareHierarchicalGridData(grid, hasFiltering, hasSorting) {\n    const skipOperations = (!hasFiltering || !this.options.ignoreFiltering) && (!hasSorting || !this.options.ignoreSorting);\n\n    if (skipOperations) {\n      const data = grid.filteredSortedData;\n      this.addHierarchicalGridData(grid, data);\n    } else {\n      let data = grid.data;\n\n      if (hasFiltering && !this.options.ignoreFiltering) {\n        const filteringState = {\n          expressionsTree: grid.filteringExpressionsTree,\n          advancedExpressionsTree: grid.advancedFilteringExpressionsTree,\n          strategy: grid.filterStrategy\n        };\n        data = FilterUtil.filter(data, filteringState, grid);\n      }\n\n      if (hasSorting && !this.options.ignoreSorting) {\n        this._sort = cloneValue(grid.sortingExpressions[0]);\n        data = DataUtil.sort(data, grid.sortingExpressions, grid.sortStrategy, grid);\n      }\n\n      this.addHierarchicalGridData(grid, data);\n    }\n  }\n\n  addHierarchicalGridData(grid, records) {\n    const childLayoutList = grid.childLayoutList;\n\n    const columnFields = this._ownersMap.get(grid).columns.map(col => col.field);\n\n    for (const entry of records) {\n      const expansionStateVal = grid.expansionStates.has(entry) ? grid.expansionStates.get(entry) : false;\n      const dataWithoutChildren = Object.keys(entry).filter(k => columnFields.includes(k)).reduce((obj, key) => {\n        obj[key] = entry[key];\n        return obj;\n      }, {});\n      const hierarchicalGridRecord = {\n        data: dataWithoutChildren,\n        level: 0,\n        type: ExportRecordType.HierarchicalGridRecord,\n        owner: grid\n      };\n      this.flatRecords.push(hierarchicalGridRecord);\n\n      for (const island of childLayoutList) {\n        const path = {\n          rowID: island.primaryKey ? entry[island.primaryKey] : entry,\n          rowIslandKey: island.key\n        };\n        const islandGrid = grid === null || grid === void 0 ? void 0 : grid.gridAPI.getChildGrid([path]);\n        const keyRecordData = this.prepareIslandData(island, islandGrid, entry[island.key]) || [];\n        this.getAllChildColumnsAndData(island, keyRecordData, expansionStateVal, islandGrid);\n      }\n    }\n  }\n\n  prepareIslandData(island, islandGrid, data) {\n    if (islandGrid !== undefined) {\n      const hasFiltering = islandGrid.filteringExpressionsTree && islandGrid.filteringExpressionsTree.filteringOperands.length > 0 || islandGrid.advancedFilteringExpressionsTree && islandGrid.advancedFilteringExpressionsTree.filteringOperands.length > 0;\n      const hasSorting = islandGrid.sortingExpressions && islandGrid.sortingExpressions.length > 0;\n      const skipOperations = (!hasFiltering || !this.options.ignoreFiltering) && (!hasSorting || !this.options.ignoreSorting);\n\n      if (skipOperations) {\n        data = islandGrid.filteredSortedData;\n      } else {\n        if (hasFiltering && !this.options.ignoreFiltering) {\n          const filteringState = {\n            expressionsTree: islandGrid.filteringExpressionsTree,\n            advancedExpressionsTree: islandGrid.advancedFilteringExpressionsTree,\n            strategy: islandGrid.filterStrategy\n          };\n          data = FilterUtil.filter(data, filteringState, islandGrid);\n        }\n\n        if (hasSorting && !this.options.ignoreSorting) {\n          this._sort = cloneValue(islandGrid.sortingExpressions[0]);\n          data = DataUtil.sort(data, islandGrid.sortingExpressions, islandGrid.sortStrategy, islandGrid);\n        }\n      }\n    } else {\n      const hasFiltering = island.filteringExpressionsTree && island.filteringExpressionsTree.filteringOperands.length > 0 || island.advancedFilteringExpressionsTree && island.advancedFilteringExpressionsTree.filteringOperands.length > 0;\n      const hasSorting = island.sortingExpressions && island.sortingExpressions.length > 0;\n      const skipOperations = (!hasFiltering || this.options.ignoreFiltering) && (!hasSorting || this.options.ignoreSorting);\n\n      if (!skipOperations) {\n        if (hasFiltering && !this.options.ignoreFiltering) {\n          const filteringState = {\n            expressionsTree: island.filteringExpressionsTree,\n            advancedExpressionsTree: island.advancedFilteringExpressionsTree,\n            strategy: island.filterStrategy\n          };\n          data = FilterUtil.filter(data, filteringState, island);\n        }\n\n        if (hasSorting && !this.options.ignoreSorting) {\n          this._sort = cloneValue(island.sortingExpressions[0]);\n          data = DataUtil.sort(data, island.sortingExpressions, island.sortStrategy, island);\n        }\n      }\n    }\n\n    return data;\n  }\n\n  getAllChildColumnsAndData(island, childData, expansionStateVal, grid) {\n    const columnList = this._ownersMap.get(island).columns;\n\n    const columnHeader = columnList.filter(col => col.headerType === HeaderType.ColumnHeader).map(col => col.header ? col.header : col.field);\n    const headerRecord = {\n      data: columnHeader,\n      level: island.level,\n      type: ExportRecordType.HeaderRecord,\n      owner: island,\n      hidden: !expansionStateVal\n    };\n\n    if (childData && childData.length > 0) {\n      this.flatRecords.push(headerRecord);\n\n      for (const rec of childData) {\n        const exportRecord = {\n          data: rec,\n          level: island.level,\n          type: ExportRecordType.HierarchicalGridRecord,\n          owner: island,\n          hidden: !expansionStateVal\n        };\n        this.flatRecords.push(exportRecord);\n\n        if (island.children.length > 0) {\n          const islandExpansionStateVal = grid === undefined ? false : grid.expansionStates.has(rec) ? grid.expansionStates.get(rec) : false;\n\n          for (const childIsland of island.children) {\n            const path = {\n              rowID: childIsland.primaryKey ? rec[childIsland.primaryKey] : rec,\n              rowIslandKey: childIsland.key\n            };\n            const childIslandGrid = grid === null || grid === void 0 ? void 0 : grid.gridAPI.getChildGrid([path]);\n            const keyRecordData = this.prepareIslandData(island, childIslandGrid, rec[childIsland.key]) || [];\n            this.getAllChildColumnsAndData(childIsland, keyRecordData, islandExpansionStateVal, childIslandGrid);\n          }\n        }\n      }\n    }\n  }\n\n  prepareGridData(grid, hasFiltering, hasSorting) {\n    const groupedGridGroupingState = {\n      expressions: grid.groupingExpressions,\n      expansion: grid.groupingExpansionState,\n      defaultExpanded: grid.groupsExpanded\n    };\n    const hasGrouping = grid.groupingExpressions && grid.groupingExpressions.length > 0;\n    const skipOperations = (!hasFiltering || !this.options.ignoreFiltering) && (!hasSorting || !this.options.ignoreSorting) && (!hasGrouping || !this.options.ignoreGrouping);\n\n    if (skipOperations) {\n      if (hasGrouping) {\n        this.addGroupedData(grid, grid.groupsRecords, groupedGridGroupingState);\n      } else {\n        this.addFlatData(grid.filteredSortedData);\n      }\n    } else {\n      let gridData = grid.data;\n\n      if (hasFiltering && !this.options.ignoreFiltering) {\n        const filteringState = {\n          expressionsTree: grid.filteringExpressionsTree,\n          advancedExpressionsTree: grid.advancedFilteringExpressionsTree,\n          strategy: grid.filterStrategy\n        };\n        gridData = FilterUtil.filter(gridData, filteringState, grid);\n      }\n\n      if (hasSorting && !this.options.ignoreSorting) {\n        // TODO: We should drop support for this since in a grouped grid it doesn't make sense\n        // this._sort = !isGroupedGrid ?\n        //     cloneValue(grid.sortingExpressions[0]) :\n        //     grid.sortingExpressions.length > 1 ?\n        //         cloneValue(grid.sortingExpressions[1]) :\n        //         cloneValue(grid.sortingExpressions[0]);\n        gridData = DataUtil.sort(gridData, grid.sortingExpressions, grid.sortStrategy, grid);\n      }\n\n      if (hasGrouping && !this.options.ignoreGrouping) {\n        const groupsRecords = [];\n        DataUtil.group(cloneArray(gridData), groupedGridGroupingState, grid.groupStrategy, grid, groupsRecords);\n        gridData = groupsRecords;\n      }\n\n      if (hasGrouping && !this.options.ignoreGrouping) {\n        this.addGroupedData(grid, gridData, groupedGridGroupingState);\n      } else {\n        this.addFlatData(gridData);\n      }\n    }\n  }\n\n  prepareTreeGridData(grid, hasFiltering, hasSorting) {\n    const skipOperations = (!hasFiltering || !this.options.ignoreFiltering) && (!hasSorting || !this.options.ignoreSorting);\n\n    if (skipOperations) {\n      this.addTreeGridData(grid.processedRootRecords);\n    } else {\n      let gridData = grid.rootRecords;\n\n      if (hasFiltering && !this.options.ignoreFiltering) {\n        const filteringState = {\n          expressionsTree: grid.filteringExpressionsTree,\n          advancedExpressionsTree: grid.advancedFilteringExpressionsTree,\n          strategy: grid.filterStrategy ? grid.filterStrategy : new TreeGridFilteringStrategy()\n        };\n        gridData = filteringState.strategy.filter(gridData, filteringState.expressionsTree, filteringState.advancedExpressionsTree);\n      }\n\n      if (hasSorting && !this.options.ignoreSorting) {\n        this._sort = cloneValue(grid.sortingExpressions[0]);\n        gridData = DataUtil.treeGridSort(gridData, grid.sortingExpressions, grid.sortStrategy);\n      }\n\n      this.addTreeGridData(gridData);\n    }\n  }\n\n  addTreeGridData(records, parentExpanded = true) {\n    if (!records) {\n      return;\n    }\n\n    for (const record of records) {\n      const hierarchicalRecord = {\n        data: record.data,\n        level: record.level,\n        hidden: !parentExpanded,\n        type: ExportRecordType.TreeGridRecord\n      };\n      this.flatRecords.push(hierarchicalRecord);\n      this.addTreeGridData(record.children, parentExpanded && record.expanded);\n    }\n  }\n\n  addFlatData(records) {\n    if (!records) {\n      return;\n    }\n\n    for (const record of records) {\n      const data = {\n        data: record,\n        type: ExportRecordType.DataRecord,\n        level: 0\n      };\n      this.flatRecords.push(data);\n    }\n  }\n\n  addGroupedData(grid, records, groupingState, parentExpanded = true) {\n    if (!records) {\n      return;\n    }\n\n    const firstCol = this._ownersMap.get(DEFAULT_OWNER).columns[0].field;\n\n    for (const record of records) {\n      let recordVal = record.value;\n      const hierarchy = getHierarchy(record);\n      const expandState = groupingState.expansion.find(s => isHierarchyMatch(s.hierarchy || [{\n        fieldName: record.expression.fieldName,\n        value: recordVal\n      }], hierarchy));\n      const expanded = expandState ? expandState.expanded : groupingState.defaultExpanded;\n      const isDate = recordVal instanceof Date;\n\n      if (isDate) {\n        const timeZoneOffset = recordVal.getTimezoneOffset() * 60000;\n        const isoString = new Date(recordVal - timeZoneOffset).toISOString();\n        const pipe = new DatePipe(grid.locale);\n        recordVal = pipe.transform(isoString);\n      }\n\n      const groupExpressionName = record.column && record.column.header ? record.column.header : record.expression.fieldName;\n      recordVal = recordVal !== null ? recordVal : '';\n      const groupExpression = {\n        data: {\n          [firstCol]: `${groupExpressionName}: ${recordVal} (${record.records.length})`\n        },\n        level: record.level,\n        hidden: !parentExpanded,\n        type: ExportRecordType.GroupedRecord\n      };\n      this.flatRecords.push(groupExpression);\n\n      if (record.groups.length > 0) {\n        this.addGroupedData(grid, record.groups, groupingState, expanded && parentExpanded);\n      } else {\n        const rowRecords = record.records;\n\n        for (const rowRecord of rowRecords) {\n          const currentRecord = {\n            data: rowRecord,\n            level: record.level + 1,\n            hidden: !(expanded && parentExpanded),\n            type: ExportRecordType.DataRecord\n          };\n          this.flatRecords.push(currentRecord);\n        }\n      }\n    }\n  }\n\n  getColumns(columns) {\n    const colList = [];\n    const colWidthList = [];\n    const hiddenColumns = [];\n    let indexOfLastPinnedColumn = -1;\n    let lastVisibleColumnIndex = -1;\n    let maxLevel = 0;\n    columns.forEach(column => {\n      var _a;\n\n      const columnHeader = !ExportUtilities.isNullOrWhitespaces(column.header) ? column.header : column.field;\n      const exportColumn = !column.hidden || this.options.ignoreColumnsVisibility;\n      const index = this.options.ignoreColumnsOrder || this.options.ignoreColumnsVisibility ? column.index : column.visibleIndex;\n      const columnWidth = Number((_a = column.width) === null || _a === void 0 ? void 0 : _a.slice(0, -2)) || DEFAULT_COLUMN_WIDTH;\n      const columnLevel = !this.options.ignoreMultiColumnHeaders ? column.level : 0;\n      const isMultiColHeader = column.columnGroup;\n      const colSpan = isMultiColHeader ? column.allChildren.filter(ch => !ch.columnGroup && (!this.options.ignoreColumnsVisibility ? !ch.hidden : true)).length : 1;\n      const columnInfo = {\n        header: columnHeader,\n        dataType: column.dataType,\n        field: column.field,\n        skip: !exportColumn,\n        formatter: column.formatter,\n        skipFormatter: false,\n        headerType: isMultiColHeader ? HeaderType.MultiColumnHeader : HeaderType.ColumnHeader,\n        columnSpan: colSpan,\n        level: columnLevel,\n        startIndex: index,\n        pinnedIndex: !column.pinned ? Number.MAX_VALUE : !column.hidden ? column.grid.pinnedColumns.indexOf(column) : NaN,\n        columnGroupParent: column.parent ? column.parent : null,\n        columnGroup: isMultiColHeader ? column : null\n      };\n\n      if (this.options.ignoreColumnsOrder) {\n        if (columnInfo.startIndex !== columnInfo.pinnedIndex) {\n          columnInfo.pinnedIndex = Number.MAX_VALUE;\n        }\n      }\n\n      if (column.level > maxLevel && !this.options.ignoreMultiColumnHeaders) {\n        maxLevel = column.level;\n      }\n\n      if (index !== -1) {\n        colList.push(columnInfo);\n        colWidthList.push(columnWidth);\n        lastVisibleColumnIndex = Math.max(lastVisibleColumnIndex, colList.indexOf(columnInfo));\n      } else {\n        hiddenColumns.push(columnInfo);\n      }\n\n      if (column.pinned && exportColumn && columnInfo.headerType === HeaderType.ColumnHeader) {\n        indexOfLastPinnedColumn++;\n      }\n    }); //Append the hidden columns to the end of the list\n\n    hiddenColumns.forEach(hiddenColumn => {\n      colList[++lastVisibleColumnIndex] = hiddenColumn;\n    });\n    const result = {\n      columns: colList,\n      columnWidths: colWidthList,\n      indexOfLastPinnedColumn,\n      maxLevel\n    };\n    return result;\n  }\n\n  mapHierarchicalGridColumns(island, gridData) {\n    let columnList;\n    let keyData;\n\n    if (island.autoGenerate) {\n      keyData = gridData[island.key];\n      const islandKeys = island.children.map(i => i.key);\n      const islandData = keyData.map(i => {\n        const newItem = {};\n        Object.keys(i).map(k => {\n          if (!islandKeys.includes(k)) {\n            newItem[k] = i[k];\n          }\n        });\n        return newItem;\n      });\n      columnList = this.getAutoGeneratedColumns(islandData);\n    } else {\n      const islandColumnList = island.childColumns.toArray();\n      columnList = this.getColumns(islandColumnList);\n    }\n\n    this._ownersMap.set(island, columnList);\n\n    if (island.children.length > 0) {\n      for (const childIsland of island.children) {\n        const islandKeyData = keyData !== undefined ? keyData[0] : {};\n        this.mapHierarchicalGridColumns(childIsland, islandKeyData);\n      }\n    }\n  }\n\n  getAutoGeneratedColumns(data) {\n    const colList = [];\n    const colWidthList = [];\n    const keys = Object.keys(data[0]);\n    keys.forEach((colKey, i) => {\n      const columnInfo = {\n        header: colKey,\n        field: colKey,\n        dataType: 'string',\n        skip: false,\n        headerType: HeaderType.ColumnHeader,\n        columnSpan: 1,\n        level: 0,\n        startIndex: i,\n        pinnedIndex: Number.MAX_VALUE\n      };\n      colList.push(columnInfo);\n      colWidthList.push(DEFAULT_COLUMN_WIDTH);\n    });\n    const result = {\n      columns: colList,\n      columnWidths: colWidthList,\n      indexOfLastPinnedColumn: -1,\n      maxLevel: 0\n    };\n    return result;\n  }\n\n  resetDefaults() {\n    this._sort = null;\n    this.flatRecords = [];\n    this.options = {};\n\n    this._ownersMap.clear();\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass CharSeparatedValueData {\n  constructor(_data, valueDelimiter, columns = []) {\n    this._data = _data;\n    this.columns = columns;\n    this._headerRecord = '';\n    this._dataRecords = '';\n    this._eor = '\\r\\n';\n    this._escapeCharacters = ['\\r', '\\n', '\\r\\n'];\n    this._delimiterLength = 1;\n    this._isSpecialData = false;\n    this.setDelimiter(valueDelimiter);\n  }\n\n  prepareData(key) {\n    if (!this._data || this._data.length === 0) {\n      return '';\n    }\n\n    let keys = [];\n\n    if (key) {\n      keys = key;\n    } else {\n      keys = ExportUtilities.getKeysFromData(this._data);\n    }\n\n    if (keys.length === 0) {\n      return '';\n    }\n\n    this._isSpecialData = ExportUtilities.isSpecialData(this._data[0]);\n\n    this._escapeCharacters.push(this._delimiter);\n\n    this._headerRecord = this.processHeaderRecord(keys);\n    this._dataRecords = this.processDataRecords(this._data, keys);\n    return this._headerRecord + this._dataRecords;\n  }\n\n  prepareDataAsync(done) {\n    var _a;\n\n    if (!this._data || this._data.length === 0) {\n      done('');\n    }\n\n    const columns = (_a = this.columns) === null || _a === void 0 ? void 0 : _a.filter(c => !c.skip).sort((a, b) => a.startIndex - b.startIndex).sort((a, b) => a.pinnedIndex - b.pinnedIndex);\n    const keys = columns && columns.length ? columns.map(c => c.field) : ExportUtilities.getKeysFromData(this._data);\n\n    if (keys.length === 0) {\n      done('');\n    }\n\n    this._isSpecialData = ExportUtilities.isSpecialData(this._data[0]);\n\n    this._escapeCharacters.push(this._delimiter);\n\n    const headers = columns && columns.length ? columns.map(c => {\n      var _a;\n\n      return (_a = c.header) !== null && _a !== void 0 ? _a : c.field;\n    }) : keys;\n    this._headerRecord = this.processHeaderRecord(headers);\n    this.processDataRecordsAsync(this._data, keys, dr => {\n      done(this._headerRecord + dr);\n    });\n  }\n\n  processField(value, escapeChars) {\n    let safeValue = ExportUtilities.hasValue(value) ? String(value) : '';\n\n    if (escapeChars.some(v => safeValue.includes(v))) {\n      safeValue = `\"${safeValue}\"`;\n    }\n\n    return safeValue + this._delimiter;\n  }\n\n  processHeaderRecord(keys) {\n    let recordData = '';\n\n    for (const keyName of keys) {\n      recordData += this.processField(keyName, this._escapeCharacters);\n    }\n\n    return recordData.slice(0, -this._delimiterLength) + this._eor;\n  }\n\n  processRecord(record, keys) {\n    const recordData = new Array(keys.length);\n\n    for (let index = 0; index < keys.length; index++) {\n      const value = record[keys[index]] !== undefined ? record[keys[index]] : this._isSpecialData ? record : '';\n      recordData[index] = this.processField(value, this._escapeCharacters);\n    }\n\n    return recordData.join('').slice(0, -this._delimiterLength) + this._eor;\n  }\n\n  processDataRecords(currentData, keys) {\n    const dataRecords = new Array(currentData.length);\n\n    for (let i = 0; i < currentData.length; i++) {\n      const row = currentData[i];\n      dataRecords[i] = this.processRecord(row, keys);\n    }\n\n    return dataRecords.join('');\n  }\n\n  processDataRecordsAsync(currentData, keys, done) {\n    const dataRecords = new Array(currentData.length);\n    yieldingLoop(currentData.length, 1000, i => {\n      const row = currentData[i];\n      dataRecords[i] = this.processRecord(row, keys);\n    }, () => {\n      done(dataRecords.join(''));\n    });\n  }\n\n  setDelimiter(value) {\n    this._delimiter = value;\n    this._delimiterLength = value.length;\n  }\n\n}\n\nclass IgxExporterOptionsBase {\n  constructor(fileName, _fileExtension) {\n    this._fileExtension = _fileExtension;\n    /**\n     * Specifies whether hidden columns should be exported.\n     * ```typescript\n     * let ignoreColumnsVisibility = this.exportOptions.ignoreColumnsVisibility;\n     * this.exportOptions.ignoreColumnsVisibility = true;\n     * ```\n     *\n     * @memberof IgxExporterOptionsBase\n     */\n\n    this.ignoreColumnsVisibility = false;\n    /**\n     * Specifies whether filtered out rows should be exported.\n     * ```typescript\n     * let ignoreFiltering = this.exportOptions.ignoreFiltering;\n     * this.exportOptions.ignoreFiltering = true;\n     * ```\n     *\n     * @memberof IgxExporterOptionsBase\n     */\n\n    this.ignoreFiltering = false;\n    /**\n     * Specifies if the exporter should ignore the current column order in the IgxGrid.\n     * ```typescript\n     * let ignoreColumnsOrder = this.exportOptions.ignoreColumnsOrder;\n     * this.exportOptions.ignoreColumnsOrder = true;\n     * ```\n     *\n     * @memberof IgxExporterOptionsBase\n     */\n\n    this.ignoreColumnsOrder = false;\n    /**\n     * Specifies whether the exported data should be sorted as in the provided IgxGrid.\n     * When you export grouped data, setting ignoreSorting to true will cause\n     * the grouping to fail because it relies on the sorting of the records.\n     * ```typescript\n     * let ignoreSorting = this.exportOptions.ignoreSorting;\n     * this.exportOptions.ignoreSorting = true;\n     * ```\n     *\n     * @memberof IgxExporterOptionsBase\n     */\n\n    this.ignoreSorting = false;\n    /**\n     * Specifies whether the exported data should be grouped as in the provided IgxGrid.\n     * ```typescript\n     * let ignoreGrouping = this.exportOptions.ignoreGrouping;\n     * this.exportOptions.ignoreGrouping = true;\n     * ```\n     *\n     * @memberof IgxExporterOptionsBase\n     */\n\n    this.ignoreGrouping = false;\n    /**\n     * Specifies whether the exported data should include multi column headers as in the provided IgxGrid.\n     * ```typescript\n     * let ignoreMultiColumnHeaders = this.exportOptions.ignoreMultiColumnHeaders;\n     * this.exportOptions.ignoreMultiColumnHeaders = true;\n     * ```\n     *\n     * @memberof IgxExporterOptionsBase\n     */\n\n    this.ignoreMultiColumnHeaders = false;\n    /**\n     * Specifies whether the exported data should have frozen headers.\n     * ```typescript\n     * let freezeHeaders = this.exportOptions.freezeHeaders;\n     * this.exportOptions.freezeHeaders = true;\n     * ```\n     *\n     * @memberof IgxExporterOptionsBase\n     */\n\n    this.freezeHeaders = false;\n    /**\n     * Specifies whether the headers should be exported if there is no data.\n     * ```typescript\n     * let alwaysExportHeaders = this.exportOptions.alwaysExportHeaders;\n     * this.exportOptions.alwaysExportHeaders = false;\n     * ```\n     *\n     * @memberof IgxExporterOptionsBase\n     */\n\n    this.alwaysExportHeaders = true;\n    this.setFileName(fileName);\n  }\n\n  setFileName(fileName) {\n    this._fileName = fileName + (fileName.endsWith(this._fileExtension) === false ? this._fileExtension : '');\n  }\n  /**\n   * Gets the file name which will be used for the exporting operation.\n   * ```typescript\n   * let fileName = this.exportOptions.fileName;\n   * ```\n   *\n   * @memberof IgxExporterOptionsBase\n   */\n\n\n  get fileName() {\n    return this._fileName;\n  }\n  /**\n   * Sets the file name which will be used for the exporting operation.\n   * ```typescript\n   * this.exportOptions.fileName = 'exportedData01';\n   * ```\n   *\n   * @memberof IgxExporterOptionsBase\n   */\n\n\n  set fileName(value) {\n    this.setFileName(value);\n  }\n\n}\n/**\n * Objects of this class are used to configure the CSV exporting process.\n */\n\n\nclass IgxCsvExporterOptions extends IgxExporterOptionsBase {\n  constructor(fileName, fileType) {\n    super(fileName, IgxCsvExporterOptions.getExtensionFromFileType(fileType));\n    this.setFileType(fileType);\n    this.setDelimiter();\n  }\n\n  static getExtensionFromFileType(fType) {\n    let extension = '';\n\n    switch (fType) {\n      case CsvFileTypes.CSV:\n        extension = '.csv';\n        break;\n\n      case CsvFileTypes.TSV:\n        extension = '.tsv';\n        break;\n\n      case CsvFileTypes.TAB:\n        extension = '.tab';\n        break;\n\n      default:\n        throw Error('Unsupported CSV file type!');\n    }\n\n    return extension;\n  }\n  /**\n   * Gets the value delimiter which will be used for the exporting operation.\n   * ```typescript\n   * let delimiter = this.exportOptions.valueDelimiter;\n   * ```\n   *\n   * @memberof IgxCsvExporterOptions\n   */\n\n\n  get valueDelimiter() {\n    return this._valueDelimiter;\n  }\n  /**\n   * Sets a value delimiter which will overwrite the default delimiter of the selected export format.\n   * ```typescript\n   * this.exportOptions.valueDelimiter = '|';\n   * ```\n   *\n   * @memberof IgxCsvExporterOptions\n   */\n\n\n  set valueDelimiter(value) {\n    this.setDelimiter(value);\n  }\n  /**\n   * Gets the CSV export format.\n   * ```typescript\n   * let filetype = this.exportOptions.fileType;\n   * ```\n   *\n   * @memberof IgxCsvExporterOptions\n   */\n\n\n  get fileType() {\n    return this._fileType;\n  }\n  /**\n   * Sets the CSV export format.\n   * ```typescript\n   * this.exportOptions.fileType = CsvFileTypes.TAB;\n   * ```\n   *\n   * @memberof IgxCsvExporterOptions\n   */\n\n\n  set fileType(value) {\n    this.setFileType(value);\n  }\n\n  setFileType(value) {\n    if (value !== undefined && value !== null && value !== this._fileType) {\n      this._fileType = value;\n      const extension = IgxCsvExporterOptions.getExtensionFromFileType(value);\n\n      if (!this.fileName.endsWith(extension)) {\n        const oldExt = '.' + this.fileName.split('.').pop();\n        const newName = this.fileName.replace(oldExt, extension);\n        this._fileExtension = extension;\n        this.fileName = newName;\n      }\n    }\n  }\n\n  setDelimiter(value) {\n    if (value !== undefined && value !== '' && value !== null) {\n      this._valueDelimiter = value;\n    } else {\n      switch (this.fileType) {\n        case CsvFileTypes.CSV:\n          this._valueDelimiter = ',';\n          break;\n\n        case CsvFileTypes.TSV:\n        case CsvFileTypes.TAB:\n          this._valueDelimiter = '\\t';\n          break;\n      }\n    }\n  }\n\n}\n/**\n * This enumeration is used to configure the default value separator\n * as well as the default file extension used when performing CSV exporting.\n */\n\n\nvar CsvFileTypes = /*#__PURE__*/(() => {\n  (function (CsvFileTypes) {\n    /**\n     * Character Separated Values, default separator is \"comma\", default file extension is .csv\n     */\n    CsvFileTypes[CsvFileTypes[\"CSV\"] = 0] = \"CSV\";\n    /**\n     * Tab Separated Values, default separator is tab, default file extension is .tsv\n     */\n\n    CsvFileTypes[CsvFileTypes[\"TSV\"] = 1] = \"TSV\";\n    /**\n     * Tab Separated Values, default separator is tab, default file extension is .tab\n     */\n\n    CsvFileTypes[CsvFileTypes[\"TAB\"] = 2] = \"TAB\";\n  })(CsvFileTypes || (CsvFileTypes = {}));\n\n  return CsvFileTypes;\n})();\n\n/**\n * **Ignite UI for Angular CSV Exporter Service** -\n * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/exporter-csv)\n *\n * The Ignite UI for Angular CSV Exporter service can export data in a Character Separated Values format from\n * both raw data (array) or from an `IgxGrid`.\n *\n * Example:\n * ```typescript\n * public localData = [\n *   { Name: \"Eric Ridley\", Age: \"26\" },\n *   { Name: \"Alanis Brook\", Age: \"22\" },\n *   { Name: \"Jonathan Morris\", Age: \"23\" }\n * ];\n *\n * constructor(private csvExportService: IgxCsvExporterService) {\n * }\n *\n * const opt: IgxCsvExporterOptions = new IgxCsvExporterOptions(\"FileName\", CsvFileTypes.CSV);\n * this.csvExportService.exportData(this.localData, opt);\n * ```\n */\nlet IgxCsvExporterService = /*#__PURE__*/(() => {\n  class IgxCsvExporterService extends IgxBaseExporter {\n    constructor() {\n      super(...arguments);\n      /**\n       * This event is emitted when the export process finishes.\n       * ```typescript\n       * this.exporterService.exportEnded.subscribe((args: ICsvExportEndedEventArgs) => {\n       * // put event handler code here\n       * });\n       * ```\n       *\n       * @memberof IgxCsvExporterService\n       */\n\n      this.exportEnded = new EventEmitter();\n    }\n\n    exportDataImplementation(data, options, done) {\n      data = data.map(item => item.data);\n\n      const columnList = this._ownersMap.get(DEFAULT_OWNER);\n\n      const csvData = new CharSeparatedValueData(data, options.valueDelimiter, columnList === null || columnList === void 0 ? void 0 : columnList.columns);\n      csvData.prepareDataAsync(r => {\n        this._stringData = r;\n        this.saveFile(options);\n        this.exportEnded.emit({\n          csvData: this._stringData\n        });\n        done();\n      });\n    }\n\n    saveFile(options) {\n      switch (options.fileType) {\n        case CsvFileTypes.CSV:\n          this.exportFile(this._stringData, options.fileName, 'text/csv;charset=utf-8;');\n          break;\n\n        case CsvFileTypes.TSV:\n        case CsvFileTypes.TAB:\n          this.exportFile(this._stringData, options.fileName, 'text/tab-separated-values;charset=utf-8;');\n          break;\n      }\n    }\n\n    exportFile(data, fileName, fileType) {\n      const blob = new Blob(['\\ufeff', data], {\n        type: fileType\n      });\n      ExportUtilities.saveBlobToFile(blob, fileName);\n    }\n\n  }\n\n  IgxCsvExporterService.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxCsvExporterService_BaseFactory;\n    return function IgxCsvExporterService_Factory(t) {\n      return (ɵIgxCsvExporterService_BaseFactory || (ɵIgxCsvExporterService_BaseFactory = i0.ɵɵgetInheritedFactory(IgxCsvExporterService)))(t || IgxCsvExporterService);\n    };\n  }();\n\n  IgxCsvExporterService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxCsvExporterService,\n    factory: IgxCsvExporterService.ɵfac,\n    providedIn: 'root'\n  });\n  return IgxCsvExporterService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nvar ExcelFolderTypes = /*#__PURE__*/(() => {\n  (function (ExcelFolderTypes) {\n    ExcelFolderTypes[ExcelFolderTypes[\"RootExcelFolder\"] = 0] = \"RootExcelFolder\";\n    ExcelFolderTypes[ExcelFolderTypes[\"RootRelsExcelFolder\"] = 1] = \"RootRelsExcelFolder\";\n    ExcelFolderTypes[ExcelFolderTypes[\"DocPropsExcelFolder\"] = 2] = \"DocPropsExcelFolder\";\n    ExcelFolderTypes[ExcelFolderTypes[\"XLExcelFolder\"] = 3] = \"XLExcelFolder\";\n    ExcelFolderTypes[ExcelFolderTypes[\"XLRelsExcelFolder\"] = 4] = \"XLRelsExcelFolder\";\n    ExcelFolderTypes[ExcelFolderTypes[\"ThemeExcelFolder\"] = 5] = \"ThemeExcelFolder\";\n    ExcelFolderTypes[ExcelFolderTypes[\"WorksheetsExcelFolder\"] = 6] = \"WorksheetsExcelFolder\";\n    ExcelFolderTypes[ExcelFolderTypes[\"WorksheetsRelsExcelFolder\"] = 7] = \"WorksheetsRelsExcelFolder\";\n    ExcelFolderTypes[ExcelFolderTypes[\"TablesExcelFolder\"] = 8] = \"TablesExcelFolder\";\n  })(ExcelFolderTypes || (ExcelFolderTypes = {}));\n\n  return ExcelFolderTypes;\n})();\n\n/**\n * @hidden\n */\nvar ExcelFileTypes = /*#__PURE__*/(() => {\n  (function (ExcelFileTypes) {\n    ExcelFileTypes[ExcelFileTypes[\"RootRelsFile\"] = 0] = \"RootRelsFile\";\n    ExcelFileTypes[ExcelFileTypes[\"AppFile\"] = 1] = \"AppFile\";\n    ExcelFileTypes[ExcelFileTypes[\"CoreFile\"] = 2] = \"CoreFile\";\n    ExcelFileTypes[ExcelFileTypes[\"WorkbookRelsFile\"] = 3] = \"WorkbookRelsFile\";\n    ExcelFileTypes[ExcelFileTypes[\"ThemeFile\"] = 4] = \"ThemeFile\";\n    ExcelFileTypes[ExcelFileTypes[\"WorksheetFile\"] = 5] = \"WorksheetFile\";\n    ExcelFileTypes[ExcelFileTypes[\"StyleFile\"] = 6] = \"StyleFile\";\n    ExcelFileTypes[ExcelFileTypes[\"WorkbookFile\"] = 7] = \"WorkbookFile\";\n    ExcelFileTypes[ExcelFileTypes[\"ContentTypesFile\"] = 8] = \"ContentTypesFile\";\n    ExcelFileTypes[ExcelFileTypes[\"SharedStringsFile\"] = 9] = \"SharedStringsFile\";\n    ExcelFileTypes[ExcelFileTypes[\"WorksheetRelsFile\"] = 10] = \"WorksheetRelsFile\";\n    ExcelFileTypes[ExcelFileTypes[\"TablesFile\"] = 11] = \"TablesFile\";\n  })(ExcelFileTypes || (ExcelFileTypes = {}));\n\n  return ExcelFileTypes;\n})();\n\n/** @hidden */\nlet ExcelStrings = /*#__PURE__*/(() => {\n  class ExcelStrings {\n    static getRels() {\n      return ExcelStrings.XML_STRING + '<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\"><Relationship Id=\"rId3\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties\" Target=\"docProps/app.xml\"/><Relationship Id=\"rId2\" Type=\"http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties\" Target=\"docProps/core.xml\"/><Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\" Target=\"xl/workbook.xml\"/></Relationships>';\n    }\n\n    static getApp(worksheetName) {\n      return ExcelStrings.XML_STRING + `<Properties xmlns=\"http://schemas.openxmlformats.org/officeDocument/2006/extended-properties\" xmlns:vt=\"http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes\"><Application>Microsoft Excel</Application><DocSecurity>0</DocSecurity><ScaleCrop>false</ScaleCrop><HeadingPairs><vt:vector size=\"2\" baseType=\"variant\"><vt:variant><vt:lpstr>Worksheets</vt:lpstr></vt:variant><vt:variant><vt:i4>1</vt:i4></vt:variant></vt:vector></HeadingPairs><TitlesOfParts><vt:vector size=\"1\" baseType=\"lpstr\"><vt:lpstr>${worksheetName}</vt:lpstr></vt:vector></TitlesOfParts><Company></Company><LinksUpToDate>false</LinksUpToDate><SharedDoc>false</SharedDoc><HyperlinksChanged>false</HyperlinksChanged><AppVersion>16.0300</AppVersion></Properties>`;\n    }\n\n    static getCore() {\n      return ExcelStrings.XML_STRING + '<cp:coreProperties xmlns:cp=\"http://schemas.openxmlformats.org/package/2006/metadata/core-properties\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:dcterms=\"http://purl.org/dc/terms/\" xmlns:dcmitype=\"http://purl.org/dc/dcmitype/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><dc:creator></dc:creator><cp:lastModifiedBy></cp:lastModifiedBy><dcterms:created xsi:type=\"dcterms:W3CDTF\">2015-06-05T18:17:20Z</dcterms:created><dcterms:modified xsi:type=\"dcterms:W3CDTF\">2015-06-05T18:17:26Z</dcterms:modified></cp:coreProperties>';\n    }\n\n    static getTheme() {\n      return ExcelStrings.XML_STRING + '<a:theme xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" name=\"Office Theme\"><a:themeElements><a:clrScheme name=\"Office\"><a:dk1><a:sysClr val=\"windowText\" lastClr=\"000000\"/></a:dk1><a:lt1><a:sysClr val=\"window\" lastClr=\"FFFFFF\"/></a:lt1><a:dk2><a:srgbClr val=\"44546A\"/></a:dk2><a:lt2><a:srgbClr val=\"E7E6E6\"/></a:lt2><a:accent1><a:srgbClr val=\"5B9BD5\"/></a:accent1><a:accent2><a:srgbClr val=\"ED7D31\"/></a:accent2><a:accent3><a:srgbClr val=\"A5A5A5\"/></a:accent3><a:accent4><a:srgbClr val=\"FFC000\"/></a:accent4><a:accent5><a:srgbClr val=\"4472C4\"/></a:accent5><a:accent6><a:srgbClr val=\"70AD47\"/></a:accent6><a:hlink><a:srgbClr val=\"0563C1\"/></a:hlink><a:folHlink><a:srgbClr val=\"954F72\"/></a:folHlink></a:clrScheme><a:fontScheme name=\"Office\"><a:majorFont><a:latin typeface=\"Calibri Light\" panose=\"020F0302020204030204\"/><a:ea typeface=\"\"/><a:cs typeface=\"\"/><a:font script=\"Jpan\" typeface=\"游ゴシック Light\"/><a:font script=\"Hang\" typeface=\"맑은 고딕\"/><a:font script=\"Hans\" typeface=\"等线 Light\"/><a:font script=\"Hant\" typeface=\"新細明體\"/><a:font script=\"Arab\" typeface=\"Times New Roman\"/><a:font script=\"Hebr\" typeface=\"Times New Roman\"/><a:font script=\"Thai\" typeface=\"Tahoma\"/><a:font script=\"Ethi\" typeface=\"Nyala\"/><a:font script=\"Beng\" typeface=\"Vrinda\"/><a:font script=\"Gujr\" typeface=\"Shruti\"/><a:font script=\"Khmr\" typeface=\"MoolBoran\"/><a:font script=\"Knda\" typeface=\"Tunga\"/><a:font script=\"Guru\" typeface=\"Raavi\"/><a:font script=\"Cans\" typeface=\"Euphemia\"/><a:font script=\"Cher\" typeface=\"Plantagenet Cherokee\"/><a:font script=\"Yiii\" typeface=\"Microsoft Yi Baiti\"/><a:font script=\"Tibt\" typeface=\"Microsoft Himalaya\"/><a:font script=\"Thaa\" typeface=\"MV Boli\"/><a:font script=\"Deva\" typeface=\"Mangal\"/><a:font script=\"Telu\" typeface=\"Gautami\"/><a:font script=\"Taml\" typeface=\"Latha\"/><a:font script=\"Syrc\" typeface=\"Estrangelo Edessa\"/><a:font script=\"Orya\" typeface=\"Kalinga\"/><a:font script=\"Mlym\" typeface=\"Kartika\"/><a:font script=\"Laoo\" typeface=\"DokChampa\"/><a:font script=\"Sinh\" typeface=\"Iskoola Pota\"/><a:font script=\"Mong\" typeface=\"Mongolian Baiti\"/><a:font script=\"Viet\" typeface=\"Times New Roman\"/><a:font script=\"Uigh\" typeface=\"Microsoft Uighur\"/><a:font script=\"Geor\" typeface=\"Sylfaen\"/></a:majorFont><a:minorFont><a:latin typeface=\"Calibri\" panose=\"020F0502020204030204\"/><a:ea typeface=\"\"/><a:cs typeface=\"\"/><a:font script=\"Jpan\" typeface=\"游ゴシック\"/><a:font script=\"Hang\" typeface=\"맑은 고딕\"/><a:font script=\"Hans\" typeface=\"等线\"/><a:font script=\"Hant\" typeface=\"新細明體\"/><a:font script=\"Arab\" typeface=\"Arial\"/><a:font script=\"Hebr\" typeface=\"Arial\"/><a:font script=\"Thai\" typeface=\"Tahoma\"/><a:font script=\"Ethi\" typeface=\"Nyala\"/><a:font script=\"Beng\" typeface=\"Vrinda\"/><a:font script=\"Gujr\" typeface=\"Shruti\"/><a:font script=\"Khmr\" typeface=\"DaunPenh\"/><a:font script=\"Knda\" typeface=\"Tunga\"/><a:font script=\"Guru\" typeface=\"Raavi\"/><a:font script=\"Cans\" typeface=\"Euphemia\"/><a:font script=\"Cher\" typeface=\"Plantagenet Cherokee\"/><a:font script=\"Yiii\" typeface=\"Microsoft Yi Baiti\"/><a:font script=\"Tibt\" typeface=\"Microsoft Himalaya\"/><a:font script=\"Thaa\" typeface=\"MV Boli\"/><a:font script=\"Deva\" typeface=\"Mangal\"/><a:font script=\"Telu\" typeface=\"Gautami\"/><a:font script=\"Taml\" typeface=\"Latha\"/><a:font script=\"Syrc\" typeface=\"Estrangelo Edessa\"/><a:font script=\"Orya\" typeface=\"Kalinga\"/><a:font script=\"Mlym\" typeface=\"Kartika\"/><a:font script=\"Laoo\" typeface=\"DokChampa\"/><a:font script=\"Sinh\" typeface=\"Iskoola Pota\"/><a:font script=\"Mong\" typeface=\"Mongolian Baiti\"/><a:font script=\"Viet\" typeface=\"Arial\"/><a:font script=\"Uigh\" typeface=\"Microsoft Uighur\"/><a:font script=\"Geor\" typeface=\"Sylfaen\"/></a:minorFont></a:fontScheme><a:fmtScheme name=\"Office\"><a:fillStyleLst><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:gradFill rotWithShape=\"1\"><a:gsLst><a:gs pos=\"0\"><a:schemeClr val=\"phClr\"><a:lumMod val=\"110000\"/><a:satMod val=\"105000\"/><a:tint val=\"67000\"/></a:schemeClr></a:gs><a:gs pos=\"50000\"><a:schemeClr val=\"phClr\"><a:lumMod val=\"105000\"/><a:satMod val=\"103000\"/><a:tint val=\"73000\"/></a:schemeClr></a:gs><a:gs pos=\"100000\"><a:schemeClr val=\"phClr\"><a:lumMod val=\"105000\"/><a:satMod val=\"109000\"/><a:tint val=\"81000\"/></a:schemeClr></a:gs></a:gsLst><a:lin ang=\"5400000\" scaled=\"0\"/></a:gradFill><a:gradFill rotWithShape=\"1\"><a:gsLst><a:gs pos=\"0\"><a:schemeClr val=\"phClr\"><a:satMod val=\"103000\"/><a:lumMod val=\"102000\"/><a:tint val=\"94000\"/></a:schemeClr></a:gs><a:gs pos=\"50000\"><a:schemeClr val=\"phClr\"><a:satMod val=\"110000\"/><a:lumMod val=\"100000\"/><a:shade val=\"100000\"/></a:schemeClr></a:gs><a:gs pos=\"100000\"><a:schemeClr val=\"phClr\"><a:lumMod val=\"99000\"/><a:satMod val=\"120000\"/><a:shade val=\"78000\"/></a:schemeClr></a:gs></a:gsLst><a:lin ang=\"5400000\" scaled=\"0\"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w=\"6350\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:prstDash val=\"solid\"/><a:miter lim=\"800000\"/></a:ln><a:ln w=\"12700\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:prstDash val=\"solid\"/><a:miter lim=\"800000\"/></a:ln><a:ln w=\"19050\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:prstDash val=\"solid\"/><a:miter lim=\"800000\"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad=\"57150\" dist=\"19050\" dir=\"5400000\" algn=\"ctr\" rotWithShape=\"0\"><a:srgbClr val=\"000000\"><a:alpha val=\"63000\"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:solidFill><a:schemeClr val=\"phClr\"><a:tint val=\"95000\"/><a:satMod val=\"170000\"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape=\"1\"><a:gsLst><a:gs pos=\"0\"><a:schemeClr val=\"phClr\"><a:tint val=\"93000\"/><a:satMod val=\"150000\"/><a:shade val=\"98000\"/><a:lumMod val=\"102000\"/></a:schemeClr></a:gs><a:gs pos=\"50000\"><a:schemeClr val=\"phClr\"><a:tint val=\"98000\"/><a:satMod val=\"130000\"/><a:shade val=\"90000\"/><a:lumMod val=\"103000\"/></a:schemeClr></a:gs><a:gs pos=\"100000\"><a:schemeClr val=\"phClr\"><a:shade val=\"63000\"/><a:satMod val=\"120000\"/></a:schemeClr></a:gs></a:gsLst><a:lin ang=\"5400000\" scaled=\"0\"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri=\"{05A4C25C-085E-4340-85A3-A5531E510DB2}\"><thm15:themeFamily xmlns:thm15=\"http://schemas.microsoft.com/office/thememl/2012/main\" name=\"Office Theme\" id=\"{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}\" vid=\"{4A3C46E8-61CC-4603-A589-7422A47A8E4A}\"/></a:ext></a:extLst></a:theme>';\n    }\n\n    static getStyles() {\n      return ExcelStrings.XML_STRING + '<styleSheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x14ac x16r2\" xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\" xmlns:x16r2=\"http://schemas.microsoft.com/office/spreadsheetml/2015/02/main\"><fonts count=\"2\" x14ac:knownFonts=\"1\"><font><sz val=\"11\"/><color theme=\"1\"/><name val=\"Calibri\"/><family val=\"2\"/><scheme val=\"minor\"/></font><font><sz val=\"11\"/><color rgb=\"FFB7B7B7\"/><name val=\"Calibri\"/><family val=\"2\"/><scheme val=\"minor\"/></font></fonts><fills count=\"3\"><fill><patternFill patternType=\"none\"/></fill><fill><patternFill patternType=\"gray125\"/></fill><fill><patternFill patternType=\"solid\"><fgColor rgb=\"FF0D1822\"/><bgColor indexed=\"64\"/></patternFill></fill></fills><borders count=\"1\"><border><left/><right/><top/><bottom/><diagonal/></border></borders><cellStyleXfs count=\"1\"><xf numFmtId=\"0\" fontId=\"0\" fillId=\"0\" borderId=\"0\"/></cellStyleXfs><cellXfs count=\"4\"><xf numFmtId=\"0\" fontId=\"0\" fillId=\"0\" borderId=\"0\" xfId=\"0\"/><xf numFmtId=\"0\" fontId=\"0\" fillId=\"0\" borderId=\"0\" xfId=\"0\" applyNumberFormat=\"1\"/> <xf numFmtId=\"14\" fontId=\"0\" fillId=\"0\" borderId=\"0\" xfId=\"0\" applyNumberFormat=\"1\"/> <xf numFmtId=\"0\" fontId=\"1\" fillId=\"2\" borderId=\"0\" xfId=\"0\"/></cellXfs><cellStyles count=\"1\"><cellStyle name=\"Normal\" xfId=\"0\" builtinId=\"0\"/></cellStyles><dxfs count=\"0\"/><tableStyles count=\"0\" defaultTableStyle=\"TableStyleMedium2\" defaultPivotStyle=\"PivotStyleLight16\"/><extLst><ext uri=\"{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}\" xmlns:x14=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/main\"><x14:slicerStyles defaultSlicerStyle=\"SlicerStyleLight1\"/></ext><ext uri=\"{9260A510-F301-46a8-8635-F512D64BE5F5}\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\"><x15:timelineStyles defaultTimelineStyle=\"TimeSlicerStyleLight1\"/></ext></extLst></styleSheet>';\n    }\n\n    static getWorkbook(worksheetName) {\n      return ExcelStrings.XML_STRING + `<workbook xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x15\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\"><fileVersion appName=\"xl\" lastEdited=\"6\" lowestEdited=\"6\" rupBuild=\"14420\"/><workbookPr filterPrivacy=\"1\" defaultThemeVersion=\"164011\"/><bookViews><workbookView xWindow=\"0\" yWindow=\"0\" windowWidth=\"22260\" windowHeight=\"12645\"/></bookViews><sheets><sheet name=\"${worksheetName}\" sheetId=\"1\" r:id=\"rId1\"/></sheets><calcPr calcId=\"162913\"/><extLst><ext uri=\"{140A7094-0E35-4892-8432-C4D2E57EDEB5}\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\"><x15:workbookPr chartTrackingRefBase=\"1\"/></ext></extLst></workbook>`;\n    }\n\n    static getWorksheetRels() {\n      return ExcelStrings.XML_STRING + `<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\"><Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/table\" Target=\"../tables/table1.xml\"/></Relationships>`;\n    }\n\n    static getWorkbookRels(hasSharedStrings) {\n      let retVal = ExcelStrings.XML_STRING + `<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\"><Relationship Id=\"rId3\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles\" Target=\"styles.xml\"/><Relationship Id=\"rId2\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme\" Target=\"theme/theme1.xml\"/><Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet\" Target=\"worksheets/sheet1.xml\"/>`;\n\n      if (hasSharedStrings) {\n        retVal += ExcelStrings.SHARED_STRING_RELATIONSHIP;\n      }\n\n      retVal += '</Relationships>';\n      return retVal;\n    }\n\n    static getSheetXML(dimension, freezePane, cols, sheetData, hasTable, outlineLevel = 0, isHierarchical) {\n      const hasOutline = outlineLevel > 0;\n      const tableParts = hasTable ? '<tableParts count=\"1\"><tablePart r:id=\"rId1\"/></tableParts>' : '';\n      const sheetOutlineProp = hasOutline ? '<sheetPr><outlinePr summaryBelow=\"0\"/></sheetPr>' : '';\n      const sOutlineLevel = hasOutline ? `outlineLevelRow=\"${outlineLevel}\"` : '';\n      const dimensions = isHierarchical ? '' : `<dimension ref=\"${dimension}\"/>`; // return ExcelStrings.XML_STRING +\n      //     '<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x14ac\" xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\"><dimension ref=\"' + dimension + '\"/><sheetViews><sheetView tabSelected=\"1\" workbookViewId=\"0\">' + freezePane + '</sheetView></sheetViews><sheetFormatPr defaultRowHeight=\"15\" x14ac:dyDescent=\"0.25\"/>' + cols + sheetData + '<pageMargins left=\"0.7\" right=\"0.7\" top=\"0.75\" bottom=\"0.75\" header=\"0.3\" footer=\"0.3\"/>' + tableParts + '</worksheet>';\n\n      return `${ExcelStrings.XML_STRING}\n<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x14ac\" xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\">\n${sheetOutlineProp}\n${dimensions}\n<sheetViews><sheetView tabSelected=\"1\" workbookViewId=\"0\">${freezePane}</sheetView></sheetViews>\n<sheetFormatPr defaultRowHeight=\"15\" ${sOutlineLevel} x14ac:dyDescent=\"0.25\"/>\n${cols}\n${sheetData}\n<pageMargins left=\"0.7\" right=\"0.7\" top=\"0.75\" bottom=\"0.75\" header=\"0.3\" footer=\"0.3\"/>\n${tableParts}</worksheet>`;\n    }\n\n    static getSharedStringXML(count, uniqueCount, table) {\n      return ExcelStrings.XML_STRING + '<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"' + count + '\" uniqueCount=\"' + uniqueCount + '\">' + table + '</sst>';\n    }\n\n    static getContentTypesXML(hasSharedStrings, hasTable) {\n      let contentTypes = ExcelStrings.XML_STRING + `<Types xmlns=\"http://schemas.openxmlformats.org/package/2006/content-types\\\">\n            <Default Extension=\"rels\" ContentType=\"application/vnd.openxmlformats-package.relationships+xml\"/>\n            <Default Extension=\"xml\" ContentType=\"application/xml\"/>\n            <Override PartName=\"/xl/workbook.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\"/>\n            <Override PartName=\"/xl/worksheets/sheet1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\"/>\n            <Override PartName=\"/xl/theme/theme1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.theme+xml\"/>\n            <Override PartName=\"/xl/styles.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml\"/>\n            <Override PartName=\"/docProps/core.xml\" ContentType=\"application/vnd.openxmlformats-package.core-properties+xml\"/>\n            <Override PartName=\"/docProps/app.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.extended-properties+xml\"/>`;\n      contentTypes += hasSharedStrings ? `\t<Override PartName=\"/xl/sharedStrings.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\"/>` : '';\n      contentTypes += hasTable ? `<Override PartName=\"/xl/tables/table1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml\"/>` : '';\n      contentTypes += `</Types>`;\n      return contentTypes;\n    }\n\n    static getTablesXML(autoFilterDimension, tableDimension, tableColumns, sort) {\n      return `${ExcelStrings.XML_STRING}<table xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" id=\"1\" name=\"Table1\" displayName=\"Table1\" ref=\"${tableDimension}\" totalsRowShown=\"0\">\n    <autoFilter ref=\"${autoFilterDimension}\"/>${sort}${tableColumns}<tableStyleInfo name=\"TableStyleMedium2\" showFirstColumn=\"0\" showLastColumn=\"0\" showRowStripes=\"1\" showColumnStripes=\"0\"/>\n</table>`;\n    }\n    /* eslint-enable  max-len */\n\n\n    static getExcelColumn(index) {\n      // Returns the excel column name for given 0-based index\n      // For example 27 should return \"AB\"\n      let returnString = '';\n\n      while (index >= 0) {\n        const char = index % 26;\n        returnString = String.fromCharCode(65 + char) + returnString;\n        index = Math.floor(index / 26) - 1;\n      }\n\n      return returnString;\n    }\n\n  }\n\n  /* eslint-disable  max-len */\n  ExcelStrings.XML_STRING = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\r\\n';\n  ExcelStrings.SHARED_STRING_RELATIONSHIP = '<Relationship Id=\"rId4\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings\" Target=\"sharedStrings.xml\" />';\n  /**\n   * @hidden\n   */\n\n  return ExcelStrings;\n})();\n\nclass RootRelsFile {\n  writeElement(folder) {\n    folder.file('.rels', ExcelStrings.getRels());\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass AppFile {\n  writeElement(folder, worksheetData) {\n    folder.file('app.xml', ExcelStrings.getApp(worksheetData.options.worksheetName));\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass CoreFile {\n  writeElement(folder) {\n    folder.file('core.xml', ExcelStrings.getCore());\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass WorkbookRelsFile {\n  writeElement(folder, worksheetData) {\n    const hasSharedStrings = !worksheetData.isEmpty || worksheetData.options.alwaysExportHeaders;\n    folder.file('workbook.xml.rels', ExcelStrings.getWorkbookRels(hasSharedStrings));\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass ThemeFile {\n  writeElement(folder) {\n    folder.file('theme1.xml', ExcelStrings.getTheme());\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet WorksheetFile = /*#__PURE__*/(() => {\n  class WorksheetFile {\n    constructor() {\n      this.maxOutlineLevel = 0;\n      this.dimension = '';\n      this.freezePane = '';\n      this.rowHeight = '';\n      this.mergeCellStr = '';\n      this.mergeCellsCounter = 0;\n      this.rowIndex = 0;\n    }\n\n    writeElement() {}\n\n    writeElementAsync(folder, worksheetData) {\n      return __awaiter(this, void 0, void 0, function* () {\n        return new Promise(resolve => {\n          this.prepareDataAsync(worksheetData, (cols, rows) => {\n            const hasTable = (!worksheetData.isEmpty || worksheetData.options.alwaysExportHeaders) && worksheetData.options.exportAsTable;\n            folder.file('sheet1.xml', ExcelStrings.getSheetXML(this.dimension, this.freezePane, cols, rows, hasTable, this.maxOutlineLevel, worksheetData.isHierarchical));\n            resolve();\n          });\n        });\n      });\n    }\n\n    prepareDataAsync(worksheetData, done) {\n      let sheetData = '';\n      let cols = '';\n      const dictionary = worksheetData.dataDictionary;\n      this.rowIndex = 0;\n\n      if (worksheetData.isEmpty && (!worksheetData.options.alwaysExportHeaders || worksheetData.owner.columns.length === 0)) {\n        sheetData += '<sheetData/>';\n        this.dimension = 'A1';\n        done('', sheetData);\n      } else {\n        const owner = worksheetData.owner;\n        const isHierarchicalGrid = worksheetData.isHierarchical;\n        const hasMultiColumnHeader = worksheetData.hasMultiColumnHeader;\n        const hasUserSetIndex = owner.columns.some(col => col.exportIndex !== undefined);\n        const height = worksheetData.options.rowHeight;\n        const rowStyle = isHierarchicalGrid ? ' s=\"3\"' : '';\n        this.rowHeight = height ? ` ht=\"${height}\" customHeight=\"1\"` : '';\n        sheetData += `<sheetData>`;\n\n        for (let i = 0; i <= owner.maxLevel; i++) {\n          this.rowIndex++;\n          sheetData += `<row r=\"${this.rowIndex}\"${this.rowHeight}>`;\n          const headersForLevel = hasMultiColumnHeader ? owner.columns.filter(c => (c.level < i && c.headerType !== HeaderType.MultiColumnHeader || c.level === i) && c.columnSpan > 0 && !c.skip).sort((a, b) => a.startIndex - b.startIndex).sort((a, b) => a.pinnedIndex - b.pinnedIndex) : hasUserSetIndex ? owner.columns.filter(c => !c.skip) : owner.columns.filter(c => !c.skip).sort((a, b) => a.startIndex - b.startIndex).sort((a, b) => a.pinnedIndex - b.pinnedIndex);\n          let startValue = 0;\n\n          for (const currentCol of headersForLevel) {\n            if (currentCol.level === i) {\n              let columnCoordinate;\n              columnCoordinate = ExcelStrings.getExcelColumn(startValue) + this.rowIndex;\n              const columnValue = dictionary.saveValue(currentCol.header, true);\n              sheetData += `<c r=\"${columnCoordinate}\"${rowStyle} t=\"s\"><v>${columnValue}</v></c>`;\n\n              if (i !== owner.maxLevel) {\n                this.mergeCellsCounter++;\n                this.mergeCellStr += ` <mergeCell ref=\"${columnCoordinate}:`;\n\n                if (currentCol.headerType === HeaderType.ColumnHeader) {\n                  columnCoordinate = ExcelStrings.getExcelColumn(startValue) + (owner.maxLevel + 1);\n                } else {\n                  for (let k = 1; k < currentCol.columnSpan; k++) {\n                    columnCoordinate = ExcelStrings.getExcelColumn(startValue + k) + this.rowIndex;\n                    sheetData += `<c r=\"${columnCoordinate}\"${rowStyle} />`;\n                  }\n                }\n\n                this.mergeCellStr += `${columnCoordinate}\" />`;\n              }\n            }\n\n            startValue += currentCol.columnSpan;\n          }\n\n          sheetData += `</row>`;\n        }\n\n        const multiColumnHeaderLevel = worksheetData.options.ignoreMultiColumnHeaders ? 0 : owner.maxLevel;\n        const freezeHeaders = worksheetData.options.freezeHeaders ? 2 + multiColumnHeaderLevel : 1;\n\n        if (!isHierarchicalGrid) {\n          this.dimension = 'A1:' + ExcelStrings.getExcelColumn(worksheetData.columnCount - 1) + (worksheetData.rowCount + owner.maxLevel);\n          cols += '<cols>';\n\n          if (!hasMultiColumnHeader) {\n            for (let j = 0; j < worksheetData.columnCount; j++) {\n              const width = dictionary.columnWidths[j]; // Use the width provided in the options if it exists\n\n              let widthInTwips = worksheetData.options.columnWidth !== undefined ? worksheetData.options.columnWidth : Math.max(width / 96 * 14.4, WorksheetFile.MIN_WIDTH);\n\n              if (!(widthInTwips > 0)) {\n                widthInTwips = WorksheetFile.MIN_WIDTH;\n              }\n\n              cols += `<col min=\"${j + 1}\" max=\"${j + 1}\" width=\"${widthInTwips}\" customWidth=\"1\"/>`;\n            }\n          } else {\n            cols += `<col min=\"1\" max=\"${worksheetData.columnCount}\" width=\"15\" customWidth=\"1\"/>`;\n          }\n\n          cols += '</cols>';\n          const indexOfLastPinnedColumn = worksheetData.indexOfLastPinnedColumn;\n          const frozenColumnCount = indexOfLastPinnedColumn + 1;\n          let firstCell = ExcelStrings.getExcelColumn(frozenColumnCount) + freezeHeaders;\n\n          if (indexOfLastPinnedColumn !== undefined && indexOfLastPinnedColumn !== -1 && !worksheetData.options.ignorePinning && !worksheetData.options.ignoreColumnsOrder) {\n            this.freezePane = `<pane xSplit=\"${frozenColumnCount}\" ySplit=\"${freezeHeaders - 1}\"\n                         topLeftCell=\"${firstCell}\" activePane=\"topRight\" state=\"frozen\"/>`;\n          } else if (worksheetData.options.freezeHeaders) {\n            firstCell = ExcelStrings.getExcelColumn(0) + freezeHeaders;\n            this.freezePane = `<pane xSplit=\"0\" ySplit=\"${freezeHeaders - 1}\"\n                         topLeftCell=\"${firstCell}\" activePane=\"topRight\" state=\"frozen\"/>`;\n          }\n        } else {\n          const columnWidth = worksheetData.options.columnWidth ? worksheetData.options.columnWidth : 20;\n          cols += `<cols><col min=\"1\" max=\"${worksheetData.columnCount}\" width=\"${columnWidth}\" customWidth=\"1\"/></cols>`;\n\n          if (worksheetData.options.freezeHeaders) {\n            const firstCell = ExcelStrings.getExcelColumn(0) + freezeHeaders;\n            this.freezePane = `<pane xSplit=\"0\" ySplit=\"${freezeHeaders - 1}\"\n                         topLeftCell=\"${firstCell}\" activePane=\"topRight\" state=\"frozen\"/>`;\n          }\n        }\n\n        this.processDataRecordsAsync(worksheetData, rows => {\n          sheetData += rows;\n          sheetData += '</sheetData>';\n\n          if (hasMultiColumnHeader && this.mergeCellsCounter > 0) {\n            sheetData += `<mergeCells count=\"${this.mergeCellsCounter}\">${this.mergeCellStr}</mergeCells>`;\n          }\n\n          done(cols, sheetData);\n        });\n      }\n    }\n\n    processDataRecordsAsync(worksheetData, done) {\n      const rowDataArr = [];\n      const height = worksheetData.options.rowHeight;\n      this.rowHeight = height ? ' ht=\"' + height + '\" customHeight=\"1\"' : '';\n      const isHierarchicalGrid = worksheetData.isHierarchical;\n      const hasUserSetIndex = worksheetData.owner.columns.some(c => c.exportIndex !== undefined);\n      let recordHeaders = [];\n      yieldingLoop(worksheetData.rowCount - 1, 1000, i => {\n        if (!worksheetData.isEmpty) {\n          if (!isHierarchicalGrid) {\n            if (hasUserSetIndex) {\n              recordHeaders = worksheetData.rootKeys;\n            } else {\n              recordHeaders = worksheetData.owner.columns.filter(c => c.headerType !== HeaderType.MultiColumnHeader && !c.skip).sort((a, b) => a.startIndex - b.startIndex).sort((a, b) => a.pinnedIndex - b.pinnedIndex).map(c => c.field);\n            }\n          } else {\n            const record = worksheetData.data[i];\n\n            if (record.type === ExportRecordType.HeaderRecord) {\n              const recordOwner = worksheetData.owners.get(record.owner);\n              const hasMultiColumnHeaders = recordOwner.columns.some(c => !c.skip && c.headerType === HeaderType.MultiColumnHeader);\n\n              if (hasMultiColumnHeaders) {\n                this.hGridPrintMultiColHeaders(worksheetData, rowDataArr, record, recordOwner);\n              }\n            }\n\n            recordHeaders = Object.keys(worksheetData.data[i].data);\n          }\n\n          rowDataArr.push(this.processRow(worksheetData, i, recordHeaders, isHierarchicalGrid));\n        }\n      }, () => {\n        done(rowDataArr.join(''));\n      });\n    }\n\n    hGridPrintMultiColHeaders(worksheetData, rowDataArr, record, owner) {\n      for (let j = 0; j < owner.maxLevel; j++) {\n        const recordLevel = record.level;\n        const outlineLevel = recordLevel > 0 ? ` outlineLevel=\"${recordLevel}\"` : '';\n        this.maxOutlineLevel = this.maxOutlineLevel < recordLevel ? recordLevel : this.maxOutlineLevel;\n        const sHidden = record.hidden ? ` hidden=\"1\"` : '';\n        this.rowIndex++;\n        let row = `<row r=\"${this.rowIndex}\"${this.rowHeight}${outlineLevel}${sHidden}>`;\n        const headersForLevel = owner.columns.filter(c => (c.level < j && c.headerType !== HeaderType.MultiColumnHeader || c.level === j) && c.columnSpan > 0 && !c.skip).sort((a, b) => a.startIndex - b.startIndex).sort((a, b) => a.pinnedIndex - b.pinnedIndex);\n        let startValue = 0 + record.level;\n\n        for (const currentCol of headersForLevel) {\n          if (currentCol.level === j) {\n            let columnCoordinate;\n            columnCoordinate = ExcelStrings.getExcelColumn(startValue) + this.rowIndex;\n            const columnValue = worksheetData.dataDictionary.saveValue(currentCol.header, true);\n            row += `<c r=\"${columnCoordinate}\" s=\"3\" t=\"s\"><v>${columnValue}</v></c>`;\n\n            if (j !== owner.maxLevel) {\n              this.mergeCellsCounter++;\n              this.mergeCellStr += ` <mergeCell ref=\"${columnCoordinate}:`;\n\n              if (currentCol.headerType === HeaderType.ColumnHeader) {\n                columnCoordinate = ExcelStrings.getExcelColumn(startValue) + (this.rowIndex + owner.maxLevel - currentCol.level);\n              } else {\n                for (let k = 1; k < currentCol.columnSpan; k++) {\n                  columnCoordinate = ExcelStrings.getExcelColumn(startValue + k) + this.rowIndex;\n                  row += `<c r=\"${columnCoordinate}\" s=\"3\" />`;\n                }\n              }\n\n              this.mergeCellStr += `${columnCoordinate}\" />`;\n            }\n          }\n\n          startValue += currentCol.columnSpan;\n        }\n\n        row += `</row>`;\n        rowDataArr.push(row);\n      }\n    }\n\n    processRow(worksheetData, i, headersForLevel, isHierarchicalGrid) {\n      const record = worksheetData.data[i];\n      const rowData = new Array(worksheetData.columnCount + 2);\n      const rowLevel = record.level;\n      const outlineLevel = rowLevel > 0 ? ` outlineLevel=\"${rowLevel}\"` : '';\n      this.maxOutlineLevel = this.maxOutlineLevel < rowLevel ? rowLevel : this.maxOutlineLevel;\n      const sHidden = record.hidden ? ` hidden=\"1\"` : '';\n      this.rowIndex++;\n      rowData[0] = `<row r=\"${this.rowIndex}\"${this.rowHeight}${outlineLevel}${sHidden}>`;\n      const keys = worksheetData.isSpecialData ? [record.data] : headersForLevel;\n\n      for (let j = 0; j < keys.length; j++) {\n        const col = j + (isHierarchicalGrid ? rowLevel : 0);\n        const cellData = this.getCellData(worksheetData, i, col, keys[j]);\n        rowData[j + 1] = cellData;\n      }\n\n      rowData[keys.length + 1] = '</row>';\n      return rowData.join('');\n    }\n\n    getCellData(worksheetData, row, column, key) {\n      const dictionary = worksheetData.dataDictionary;\n      const columnName = ExcelStrings.getExcelColumn(column) + this.rowIndex;\n      const fullRow = worksheetData.data[row];\n      const isHeaderRecord = fullRow.type === ExportRecordType.HeaderRecord;\n      const cellValue = worksheetData.isSpecialData ? fullRow.data : fullRow.data[key];\n\n      if (cellValue === undefined || cellValue === null) {\n        return `<c r=\"${columnName}\" s=\"1\"/>`;\n      } else {\n        const savedValue = dictionary.saveValue(cellValue, isHeaderRecord);\n        const isSavedAsString = savedValue !== -1;\n        const isSavedAsDate = !isSavedAsString && cellValue instanceof Date;\n        let value = isSavedAsString ? savedValue : cellValue;\n\n        if (isSavedAsDate) {\n          const timeZoneOffset = value.getTimezoneOffset() * 60000;\n          const isoString = new Date(value - timeZoneOffset).toISOString();\n          value = isoString.substring(0, isoString.indexOf('.'));\n        }\n\n        const type = isSavedAsString ? ` t=\"s\"` : isSavedAsDate ? ` t=\"d\"` : '';\n        const format = isHeaderRecord ? ` s=\"3\"` : isSavedAsString ? '' : isSavedAsDate ? ` s=\"2\"` : ` s=\"1\"`;\n        return `<c r=\"${columnName}\"${type}${format}><v>${value}</v></c>`;\n      }\n    }\n\n  }\n\n  WorksheetFile.MIN_WIDTH = 8.43;\n  /**\n   * @hidden\n   */\n\n  return WorksheetFile;\n})();\n\nclass StyleFile {\n  writeElement(folder) {\n    folder.file('styles.xml', ExcelStrings.getStyles());\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass WorkbookFile {\n  writeElement(folder, worksheetData) {\n    folder.file('workbook.xml', ExcelStrings.getWorkbook(worksheetData.options.worksheetName));\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass ContentTypesFile {\n  writeElement(folder, worksheetData) {\n    const hasSharedStrings = !worksheetData.isEmpty || worksheetData.options.alwaysExportHeaders;\n    folder.file('[Content_Types].xml', ExcelStrings.getContentTypesXML(hasSharedStrings, worksheetData.options.exportAsTable));\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass SharedStringsFile {\n  writeElement(folder, worksheetData) {\n    const dict = worksheetData.dataDictionary;\n    const sortedValues = dict.getKeys();\n    const sharedStrings = new Array(sortedValues.length);\n\n    for (const value of sortedValues) {\n      sharedStrings[dict.getSanitizedValue(value)] = '<si><t>' + value + '</t></si>';\n    }\n\n    folder.file('sharedStrings.xml', ExcelStrings.getSharedStringXML(dict.stringsCount, sortedValues.length, sharedStrings.join('')));\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass TablesFile {\n  writeElement(folder, worksheetData) {\n    const columnCount = worksheetData.columnCount;\n    const lastColumn = ExcelStrings.getExcelColumn(columnCount - 1) + worksheetData.rowCount;\n    const autoFilterDimension = 'A1:' + lastColumn;\n    const tableDimension = worksheetData.isEmpty ? 'A1:' + ExcelStrings.getExcelColumn(columnCount - 1) + (worksheetData.rowCount + 1) : autoFilterDimension;\n    const hasUserSetIndex = worksheetData.owner.columns.some(c => c.exportIndex !== undefined);\n    const values = hasUserSetIndex ? worksheetData.rootKeys : worksheetData.owner.columns.filter(c => !c.skip).sort((a, b) => a.startIndex - b.startIndex).sort((a, b) => a.pinnedIndex - b.pinnedIndex).map(c => c.header);\n    let sortString = '';\n    let tableColumns = '<tableColumns count=\"' + columnCount + '\">';\n\n    for (let i = 0; i < columnCount; i++) {\n      const value = values[i];\n      tableColumns += '<tableColumn id=\"' + (i + 1) + '\" name=\"' + value + '\"/>';\n    }\n\n    tableColumns += '</tableColumns>';\n\n    if (worksheetData.sort) {\n      const sortingExpression = worksheetData.sort;\n      const sc = ExcelStrings.getExcelColumn(values.indexOf(sortingExpression.fieldName));\n      const dir = sortingExpression.dir - 1;\n      sortString = `<sortState ref=\"A2:${lastColumn}\"><sortCondition descending=\"${dir}\" ref=\"${sc}1:${sc}15\"/></sortState>`;\n    }\n\n    folder.file('table1.xml', ExcelStrings.getTablesXML(autoFilterDimension, tableDimension, tableColumns, sortString));\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass WorksheetRelsFile {\n  writeElement(folder) {\n    folder.file('sheet1.xml.rels', ExcelStrings.getWorksheetRels());\n  }\n\n}\n/** @hidden */\n\n\nclass RootExcelFolder {\n  get folderName() {\n    return '';\n  }\n\n  childFiles() {\n    return [ExcelFileTypes.ContentTypesFile];\n  }\n\n  childFolders() {\n    return [ExcelFolderTypes.RootRelsExcelFolder, ExcelFolderTypes.DocPropsExcelFolder, ExcelFolderTypes.XLExcelFolder];\n  }\n\n}\n/** @hidden */\n\n\nclass RootRelsExcelFolder {\n  get folderName() {\n    return '_rels';\n  }\n\n  childFiles() {\n    return [ExcelFileTypes.RootRelsFile];\n  }\n\n  childFolders() {\n    return [];\n  }\n\n}\n/** @hidden */\n\n\nclass DocPropsExcelFolder {\n  get folderName() {\n    return 'docProps';\n  }\n\n  childFiles() {\n    return [ExcelFileTypes.AppFile, ExcelFileTypes.CoreFile];\n  }\n\n  childFolders() {\n    return [];\n  }\n\n}\n/** @hidden */\n\n\nclass XLExcelFolder {\n  get folderName() {\n    return 'xl';\n  }\n\n  childFiles(data) {\n    const retVal = [ExcelFileTypes.StyleFile, ExcelFileTypes.WorkbookFile];\n\n    if (!data.isEmpty || data.options.alwaysExportHeaders) {\n      retVal.push(ExcelFileTypes.SharedStringsFile);\n    }\n\n    return retVal;\n  }\n\n  childFolders(data) {\n    const retVal = [ExcelFolderTypes.XLRelsExcelFolder, ExcelFolderTypes.ThemeExcelFolder, ExcelFolderTypes.WorksheetsExcelFolder];\n\n    if ((!data.isEmpty || data.options.alwaysExportHeaders) && data.options.exportAsTable) {\n      retVal.push(ExcelFolderTypes.TablesExcelFolder);\n    }\n\n    return retVal;\n  }\n\n}\n/** @hidden */\n\n\nclass XLRelsExcelFolder {\n  get folderName() {\n    return '_rels';\n  }\n\n  childFiles() {\n    return [ExcelFileTypes.WorkbookRelsFile];\n  }\n\n  childFolders() {\n    return [];\n  }\n\n}\n/** @hidden */\n\n\nclass ThemeExcelFolder {\n  get folderName() {\n    return 'theme';\n  }\n\n  childFiles() {\n    return [ExcelFileTypes.ThemeFile];\n  }\n\n  childFolders() {\n    return [];\n  }\n\n}\n/** @hidden */\n\n\nclass WorksheetsExcelFolder {\n  get folderName() {\n    return 'worksheets';\n  }\n\n  childFiles() {\n    return [ExcelFileTypes.WorksheetFile];\n  }\n\n  childFolders(data) {\n    return data.isEmpty && !data.options.alwaysExportHeaders || !data.options.exportAsTable ? [] : [ExcelFolderTypes.WorksheetsRelsExcelFolder];\n  }\n\n}\n/** @hidden */\n\n\nclass TablesExcelFolder {\n  get folderName() {\n    return 'tables';\n  }\n\n  childFiles() {\n    return [ExcelFileTypes.TablesFile];\n  }\n\n  childFolders() {\n    return [];\n  }\n\n}\n/** @hidden */\n\n\nclass WorksheetsRelsExcelFolder {\n  get folderName() {\n    return '_rels';\n  }\n\n  childFiles() {\n    return [ExcelFileTypes.WorksheetRelsFile];\n  }\n\n  childFolders() {\n    return [];\n  }\n\n}\n/** @hidden */\n\n\nclass ExcelElementsFactory {\n  static getExcelFolder(type) {\n    switch (type) {\n      case ExcelFolderTypes.RootExcelFolder:\n        return new RootExcelFolder();\n\n      case ExcelFolderTypes.RootRelsExcelFolder:\n        return new RootRelsExcelFolder();\n\n      case ExcelFolderTypes.DocPropsExcelFolder:\n        return new DocPropsExcelFolder();\n\n      case ExcelFolderTypes.XLExcelFolder:\n        return new XLExcelFolder();\n\n      case ExcelFolderTypes.XLRelsExcelFolder:\n        return new XLRelsExcelFolder();\n\n      case ExcelFolderTypes.ThemeExcelFolder:\n        return new ThemeExcelFolder();\n\n      case ExcelFolderTypes.WorksheetsExcelFolder:\n        return new WorksheetsExcelFolder();\n\n      case ExcelFolderTypes.WorksheetsRelsExcelFolder:\n        return new WorksheetsRelsExcelFolder();\n\n      case ExcelFolderTypes.TablesExcelFolder:\n        return new TablesExcelFolder();\n\n      default:\n        throw new Error('Unknown excel folder type!');\n    }\n  }\n\n  static getExcelFile(type) {\n    switch (type) {\n      case ExcelFileTypes.RootRelsFile:\n        return new RootRelsFile();\n\n      case ExcelFileTypes.AppFile:\n        return new AppFile();\n\n      case ExcelFileTypes.CoreFile:\n        return new CoreFile();\n\n      case ExcelFileTypes.WorkbookRelsFile:\n        return new WorkbookRelsFile();\n\n      case ExcelFileTypes.ThemeFile:\n        return new ThemeFile();\n\n      case ExcelFileTypes.WorksheetFile:\n        return new WorksheetFile();\n\n      case ExcelFileTypes.StyleFile:\n        return new StyleFile();\n\n      case ExcelFileTypes.WorkbookFile:\n        return new WorkbookFile();\n\n      case ExcelFileTypes.ContentTypesFile:\n        return new ContentTypesFile();\n\n      case ExcelFileTypes.SharedStringsFile:\n        return new SharedStringsFile();\n\n      case ExcelFileTypes.WorksheetRelsFile:\n        return new WorksheetRelsFile();\n\n      case ExcelFileTypes.TablesFile:\n        return new TablesFile();\n\n      default:\n        throw Error('Unknown excel file type!');\n    }\n  }\n\n}\n/** @hidden */\n\n\nlet WorksheetDataDictionary = /*#__PURE__*/(() => {\n  class WorksheetDataDictionary {\n    constructor(columnCount, columnWidth, columnWidthsList) {\n      this.hasNumberValues = false;\n      this.hasDateValues = false;\n      this._dictionary = {};\n      this._widthsDictionary = {};\n      this._counter = 0;\n      this.dirtyKeyCollections();\n      this._columnWidths = new Array(columnCount);\n\n      if (columnWidth) {\n        this._columnWidths.fill(columnWidth);\n      } else {\n        this._columnWidths = columnWidthsList;\n      }\n\n      this.stringsCount = 0;\n    }\n\n    get columnWidths() {\n      return this._columnWidths;\n    }\n\n    saveValue(value, isHeader) {\n      let sanitizedValue = '';\n      const isDate = value instanceof Date;\n      const isSavedAsString = isHeader || typeof value !== 'number' && value !== Number(value) && !Number.isFinite(value) && !isDate;\n\n      if (isSavedAsString) {\n        sanitizedValue = this.sanitizeValue(value);\n\n        if (this._dictionary[sanitizedValue] === undefined) {\n          this._dictionary[sanitizedValue] = this._counter++;\n          this.dirtyKeyCollections();\n        }\n\n        this.stringsCount++;\n      } else if (isDate) {\n        this.hasDateValues = true;\n      } else {\n        this.hasNumberValues = true;\n      }\n\n      return isSavedAsString ? this.getSanitizedValue(sanitizedValue) : -1;\n    }\n\n    getValue(value) {\n      return this.getSanitizedValue(this.sanitizeValue(value));\n    }\n\n    getSanitizedValue(sanitizedValue) {\n      return this._dictionary[sanitizedValue];\n    }\n\n    getKeys() {\n      if (!this._keysAreValid) {\n        this._keys = Object.keys(this._dictionary);\n        this._keysAreValid = true;\n      }\n\n      return this._keys;\n    }\n\n    getTextWidth(value) {\n      if (this._widthsDictionary[value] === undefined) {\n        const context = this.getContext();\n        const metrics = context.measureText(value);\n        this._widthsDictionary[value] = metrics.width + WorksheetDataDictionary.TEXT_PADDING;\n      }\n\n      return this._widthsDictionary[value];\n    }\n\n    getContext() {\n      if (!this._context) {\n        const canvas = document.createElement('canvas');\n        this._context = canvas.getContext('2d');\n        this._context.font = WorksheetDataDictionary.DEFAULT_FONT;\n      }\n\n      return this._context;\n    }\n\n    sanitizeValue(value) {\n      if (ExportUtilities.hasValue(value) === false) {\n        return '';\n      } else {\n        const stringValue = String(value);\n        return stringValue.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&apos;');\n      }\n    }\n\n    dirtyKeyCollections() {\n      this._keysAreValid = false;\n    }\n\n  }\n\n  WorksheetDataDictionary.DEFAULT_FONT = '11pt Calibri';\n  WorksheetDataDictionary.TEXT_PADDING = 5;\n  /** @hidden */\n\n  return WorksheetDataDictionary;\n})();\n\nclass WorksheetData {\n  constructor(_data, options, sort, columnCount, rootKeys, indexOfLastPinnedColumn, columnWidths, owner, owners) {\n    this._data = _data;\n    this.options = options;\n    this.sort = sort;\n    this.columnCount = columnCount;\n    this.rootKeys = rootKeys;\n    this.indexOfLastPinnedColumn = indexOfLastPinnedColumn;\n    this.columnWidths = columnWidths;\n    this.owner = owner;\n    this.owners = owners;\n    this.initializeData();\n  }\n\n  get data() {\n    return this._data;\n  }\n\n  get rowCount() {\n    return this._rowCount;\n  }\n\n  get isEmpty() {\n    return !this.rowCount || this.rowCount === this.owner.maxLevel + 1 || !this.columnCount || this.owner.columns.every(c => c.skip);\n  }\n\n  get isSpecialData() {\n    return this._isSpecialData;\n  }\n\n  get dataDictionary() {\n    return this._dataDictionary;\n  }\n\n  get hasMultiColumnHeader() {\n    return this._hasMultiColumnHeader;\n  }\n\n  get isHierarchical() {\n    return this._isHierarchical;\n  }\n\n  initializeData() {\n    var _a;\n\n    this._dataDictionary = new WorksheetDataDictionary(this.columnCount, this.options.columnWidth, this.columnWidths);\n    this._hasMultiColumnHeader = Array.from(this.owners.values()).some(o => o.columns.some(col => !col.skip && col.headerType === HeaderType.MultiColumnHeader));\n    this._isHierarchical = ((_a = this.data[0]) === null || _a === void 0 ? void 0 : _a.type) === ExportRecordType.HierarchicalGridRecord || !(typeof Array.from(this.owners.keys())[0] === 'string');\n\n    if (this._isHierarchical || this._hasMultiColumnHeader && !this.options.ignoreMultiColumnHeaders) {\n      this.options.exportAsTable = false;\n    }\n\n    if (!this._data || this._data.length === 0) {\n      if (!this._isHierarchical) {\n        this._rowCount = this.owner.maxLevel + 1;\n      }\n\n      return;\n    }\n\n    this._isSpecialData = ExportUtilities.isSpecialData(this._data[0].data);\n    this._rowCount = this._data.length + 1;\n  }\n\n}\n\nconst EXCEL_MAX_ROWS = 1048576;\nconst EXCEL_MAX_COLS = 16384;\n/**\n * **Ignite UI for Angular Excel Exporter Service** -\n * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/exporter_excel.html)\n *\n * The Ignite UI for Angular Excel Exporter service can export data in Microsoft® Excel® format from both raw data\n * (array) or from an `IgxGrid`.\n *\n * Example:\n * ```typescript\n * public localData = [\n *   { Name: \"Eric Ridley\", Age: \"26\" },\n *   { Name: \"Alanis Brook\", Age: \"22\" },\n *   { Name: \"Jonathan Morris\", Age: \"23\" }\n * ];\n *\n * constructor(private excelExportService: IgxExcelExporterService) {\n * }\n *\n * this.excelExportService.exportData(this.localData, new IgxExcelExporterOptions(\"FileName\"));\n * ```\n */\n\nlet IgxExcelExporterService = /*#__PURE__*/(() => {\n  class IgxExcelExporterService extends IgxBaseExporter {\n    constructor() {\n      super(...arguments);\n      /**\n       * This event is emitted when the export process finishes.\n       * ```typescript\n       * this.exporterService.exportEnded.subscribe((args: IExcelExportEndedEventArgs) => {\n       * // put event handler code here\n       * });\n       * ```\n       *\n       * @memberof IgxExcelExporterService\n       */\n\n      this.exportEnded = new EventEmitter();\n    }\n\n    static populateFolderAsync(folder, zip, worksheetData) {\n      return __awaiter(this, void 0, void 0, function* () {\n        for (const childFolder of folder.childFolders(worksheetData)) {\n          const folderInstance = ExcelElementsFactory.getExcelFolder(childFolder);\n          const zipFolder = zip.folder(folderInstance.folderName);\n          yield IgxExcelExporterService.populateFolderAsync(folderInstance, zipFolder, worksheetData);\n        }\n\n        for (const childFile of folder.childFiles(worksheetData)) {\n          const fileInstance = ExcelElementsFactory.getExcelFile(childFile);\n\n          if (fileInstance instanceof WorksheetFile) {\n            yield fileInstance.writeElementAsync(zip, worksheetData);\n          } else {\n            fileInstance.writeElement(zip, worksheetData);\n          }\n        }\n      });\n    }\n\n    exportDataImplementation(data, options, done) {\n      const firstDataElement = data[0];\n      const isHierarchicalGrid = (firstDataElement === null || firstDataElement === void 0 ? void 0 : firstDataElement.type) === ExportRecordType.HierarchicalGridRecord;\n      let rootKeys;\n      let columnCount;\n      let columnWidths;\n      let indexOfLastPinnedColumn;\n      let defaultOwner;\n      const columnsExceedLimit = typeof firstDataElement !== 'undefined' ? isHierarchicalGrid ? data.some(d => Object.keys(d.data).length > EXCEL_MAX_COLS) : Object.keys(firstDataElement.data).length > EXCEL_MAX_COLS : false;\n\n      if (data.length > EXCEL_MAX_ROWS || columnsExceedLimit) {\n        throw Error('The Excel file can contain up to 1,048,576 rows and 16,384 columns.');\n      }\n\n      if (typeof firstDataElement !== 'undefined') {\n        let maxLevel = 0;\n        data.forEach(r => {\n          maxLevel = Math.max(maxLevel, r.level);\n        });\n\n        if (maxLevel > 7) {\n          throw Error('Can create an outline of up to eight levels!');\n        }\n\n        if (isHierarchicalGrid) {\n          columnCount = data.map(a => this._ownersMap.get(a.owner).columns.filter(c => !c.skip).length + a.level).sort((a, b) => b - a)[0];\n          rootKeys = this._ownersMap.get(firstDataElement.owner).columns.filter(c => !c.skip).map(c => c.field);\n          defaultOwner = this._ownersMap.get(firstDataElement.owner);\n        } else {\n          defaultOwner = this._ownersMap.get(DEFAULT_OWNER);\n          const columns = defaultOwner.columns.filter(col => !col.skip && col.headerType === HeaderType.ColumnHeader);\n          columnWidths = defaultOwner.columnWidths;\n          indexOfLastPinnedColumn = defaultOwner.indexOfLastPinnedColumn;\n          columnCount = columns.length;\n          rootKeys = columns.map(c => c.field);\n        }\n      } else {\n        const ownersKeys = Array.from(this._ownersMap.keys());\n        defaultOwner = this._ownersMap.get(ownersKeys[0]);\n        columnWidths = defaultOwner.columnWidths;\n        columnCount = defaultOwner.columns.filter(col => !col.skip && col.headerType === HeaderType.ColumnHeader).length;\n      }\n\n      const worksheetData = new WorksheetData(data, options, this._sort, columnCount, rootKeys, indexOfLastPinnedColumn, columnWidths, defaultOwner, this._ownersMap);\n      this._xlsx = typeof JSZip.default === 'function' ? new JSZip.default() : new JSZip();\n      const rootFolder = ExcelElementsFactory.getExcelFolder(ExcelFolderTypes.RootExcelFolder);\n      IgxExcelExporterService.populateFolderAsync(rootFolder, this._xlsx, worksheetData).then(() => {\n        this._xlsx.generateAsync(IgxExcelExporterService.ZIP_OPTIONS).then(result => {\n          this.saveFile(result, options.fileName);\n          this.exportEnded.emit({\n            xlsx: this._xlsx\n          });\n          done();\n        });\n      });\n    }\n\n    saveFile(data, fileName) {\n      const blob = new Blob([ExportUtilities.stringToArrayBuffer(atob(data))], {\n        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n      });\n      ExportUtilities.saveBlobToFile(blob, fileName);\n    }\n\n  }\n\n  IgxExcelExporterService.ZIP_OPTIONS = {\n    compression: 'DEFLATE',\n    type: 'base64'\n  };\n\n  IgxExcelExporterService.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxExcelExporterService_BaseFactory;\n    return function IgxExcelExporterService_Factory(t) {\n      return (ɵIgxExcelExporterService_BaseFactory || (ɵIgxExcelExporterService_BaseFactory = i0.ɵɵgetInheritedFactory(IgxExcelExporterService)))(t || IgxExcelExporterService);\n    };\n  }();\n\n  IgxExcelExporterService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxExcelExporterService,\n    factory: IgxExcelExporterService.ɵfac,\n    providedIn: 'root'\n  });\n  return IgxExcelExporterService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Objects of this class are used to configure the Excel exporting process.\n */\n\n\nclass IgxExcelExporterOptions extends IgxExporterOptionsBase {\n  constructor(fileName) {\n    super(fileName, '.xlsx');\n    /**\n     * Specifies if column pinning should be ignored. If ignoreColumnsOrder is set to true,\n     * this option will always be considered as set to true.\n     * ```typescript\n     * let ignorePinning = this.exportOptions.ignorePinning;\n     * this.exportOptions.ignorePinning = true;\n     * ```\n     *\n     * @memberof IgxExcelExporterOptions\n     */\n\n    this.ignorePinning = false;\n    /**\n     * Specifies whether the exported data should be formatted as Excel table. (True by default)\n     * ```typescript\n     * let exportAsTable = this.exportOptions.exportAsTable;\n     * this.exportOptions.exportAsTable = false;\n     * ```\n     *\n     * @memberof IgxExcelExporterOptions\n     */\n\n    this.exportAsTable = true;\n  }\n  /**\n   * Gets the width of the columns in the exported excel file.\n   * ```typescript\n   * let width = this.exportOptions.columnWidth;\n   * ```\n   *\n   * @memberof IgxExcelExporterOptions\n   */\n\n\n  get columnWidth() {\n    return this._columnWidth;\n  }\n  /**\n   * Sets the width of the columns in the exported excel file. If left unspecified,\n   * the width of the column or the default width of the excel columns will be used.\n   * ```typescript\n   * this.exportOptions.columnWidth = 55;\n   * ```\n   *\n   * @memberof IgxExcelExporterOptions\n   */\n\n\n  set columnWidth(value) {\n    if (value < 0) {\n      throw Error('Invalid value for column width!');\n    }\n\n    this._columnWidth = value;\n  }\n  /**\n   * Gets the height of the rows in the exported excel file.\n   * ```typescript\n   * let height = this.exportOptions.rowHeight;\n   * ```\n   *\n   * @memberof IgxExcelExporterOptions\n   */\n\n\n  get rowHeight() {\n    return this._rowHeight;\n  }\n  /**\n   * Sets the height of the rows in the exported excel file. If left unspecified or 0,\n   * the default height of the excel rows will be used.\n   * ```typescript\n   * this.exportOptions.rowHeight = 25;\n   * ```\n   *\n   * @memberof IgxExcelExporterOptions\n   */\n\n\n  set rowHeight(value) {\n    if (value < 0) {\n      throw Error('Invalid value for row height!');\n    }\n\n    this._rowHeight = value;\n  }\n  /**\n   * Gets the name of the worksheet in the exported excel file.\n   * ```typescript\n   * let worksheetName = this.exportOptions.worksheetName;\n   * ```\n   *\n   * @memberof IgxExcelExporterOptions\n   */\n\n\n  get worksheetName() {\n    if (this._worksheetName === undefined || this._worksheetName === null) {\n      return 'Sheet1';\n    }\n\n    return this._worksheetName;\n  }\n  /**\n   * Sets the name of the worksheet in the exported excel file.\n   * ```typescript\n   * this.exportOptions.worksheetName = \"Worksheet\";\n   * ```\n   *\n   * @memberof IgxExcelExporterOptions\n   */\n\n\n  set worksheetName(value) {\n    this._worksheetName = value;\n  }\n\n}\n\nvar HorizontalAlignment = /*#__PURE__*/(() => {\n  (function (HorizontalAlignment) {\n    HorizontalAlignment[HorizontalAlignment[\"Left\"] = -1] = \"Left\";\n    HorizontalAlignment[HorizontalAlignment[\"Center\"] = -0.5] = \"Center\";\n    HorizontalAlignment[HorizontalAlignment[\"Right\"] = 0] = \"Right\";\n  })(HorizontalAlignment || (HorizontalAlignment = {}));\n\n  return HorizontalAlignment;\n})();\nvar VerticalAlignment = /*#__PURE__*/(() => {\n  (function (VerticalAlignment) {\n    VerticalAlignment[VerticalAlignment[\"Top\"] = -1] = \"Top\";\n    VerticalAlignment[VerticalAlignment[\"Middle\"] = -0.5] = \"Middle\";\n    VerticalAlignment[VerticalAlignment[\"Bottom\"] = 0] = \"Bottom\";\n  })(VerticalAlignment || (VerticalAlignment = {}));\n\n  return VerticalAlignment;\n})();\n\n/**\n * Defines the possible values of the overlays' position strategy.\n */\nvar RelativePositionStrategy = /*#__PURE__*/(() => {\n  (function (RelativePositionStrategy) {\n    RelativePositionStrategy[\"Connected\"] = \"connected\";\n    RelativePositionStrategy[\"Auto\"] = \"auto\";\n    RelativePositionStrategy[\"Elastic\"] = \"elastic\";\n  })(RelativePositionStrategy || (RelativePositionStrategy = {}));\n\n  return RelativePositionStrategy;\n})();\n\n/**\n * Defines the possible positions for the relative overlay settings presets.\n */\nvar RelativePosition = /*#__PURE__*/(() => {\n  (function (RelativePosition) {\n    RelativePosition[\"Above\"] = \"above\";\n    RelativePosition[\"Below\"] = \"below\";\n    RelativePosition[\"Before\"] = \"before\";\n    RelativePosition[\"After\"] = \"after\";\n    RelativePosition[\"Default\"] = \"default\";\n  })(RelativePosition || (RelativePosition = {}));\n\n  return RelativePosition;\n})();\n\n/**\n * Defines the possible positions for the absolute overlay settings presets.\n */\nvar AbsolutePosition = /*#__PURE__*/(() => {\n  (function (AbsolutePosition) {\n    AbsolutePosition[\"Bottom\"] = \"bottom\";\n    AbsolutePosition[\"Top\"] = \"top\";\n    AbsolutePosition[\"Center\"] = \"center\";\n  })(AbsolutePosition || (AbsolutePosition = {}));\n\n  return AbsolutePosition;\n})();\n\n// TODO: make this interface\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n}\n/** @hidden @internal */\n\n\nclass Util {\n  /**\n   * Calculates the rectangle of target for provided overlay settings. Defaults to 0,0,0,0,0,0 rectangle\n   * if no target is provided\n   *\n   * @param settings Overlay settings for which to calculate target rectangle\n   */\n  static getTargetRect(target) {\n    let targetRect = {\n      bottom: 0,\n      height: 0,\n      left: 0,\n      right: 0,\n      top: 0,\n      width: 0\n    };\n\n    if (target instanceof HTMLElement) {\n      targetRect = target.getBoundingClientRect();\n    } else if (target instanceof Point) {\n      const targetPoint = target;\n      targetRect = {\n        bottom: targetPoint.y,\n        height: 0,\n        left: targetPoint.x,\n        right: targetPoint.x,\n        top: targetPoint.y,\n        width: 0\n      };\n    }\n\n    return targetRect;\n  }\n\n  static getViewportRect(document) {\n    const width = document.documentElement.clientWidth;\n    const height = document.documentElement.clientHeight;\n    const scrollPosition = Util.getViewportScrollPosition(document);\n    return {\n      top: scrollPosition.y,\n      left: scrollPosition.x,\n      right: scrollPosition.x + width,\n      bottom: scrollPosition.y + height,\n      width,\n      height\n    };\n  }\n\n  static getViewportScrollPosition(document) {\n    const documentElement = document.documentElement;\n    const documentRect = documentElement.getBoundingClientRect();\n    const horizontalScrollPosition = -documentRect.left || document.body.scrollLeft || window.scrollX || documentElement.scrollLeft || 0;\n    const verticalScrollPosition = -documentRect.top || document.body.scrollTop || window.scrollY || documentElement.scrollTop || 0;\n    return new Point(horizontalScrollPosition, verticalScrollPosition);\n  }\n\n  static cloneInstance(object) {\n    const clonedObj = Object.assign(Object.create(Object.getPrototypeOf(object)), object);\n    clonedObj.settings = cloneValue(clonedObj.settings);\n    return clonedObj;\n  }\n\n}\n/**\n * Positions the element based on the directions and start point passed in trough PositionSettings.\n * It is possible to either pass a start point or an HTMLElement as a positioning base.\n */\n\n\nclass ConnectedPositioningStrategy {\n  constructor(settings) {\n    this._defaultSettings = {\n      horizontalDirection: HorizontalAlignment.Right,\n      verticalDirection: VerticalAlignment.Bottom,\n      horizontalStartPoint: HorizontalAlignment.Left,\n      verticalStartPoint: VerticalAlignment.Bottom,\n      openAnimation: scaleInVerTop,\n      closeAnimation: scaleOutVerTop,\n      minSize: {\n        width: 0,\n        height: 0\n      }\n    };\n    this.settings = Object.assign({}, this._defaultSettings, settings);\n  }\n  /** @inheritdoc */\n\n\n  position(contentElement, size, document, initialCall, target) {\n    const targetElement = target || this.settings.target;\n    const rects = this.calculateElementRectangles(contentElement, targetElement);\n    this.setStyle(contentElement, rects.targetRect, rects.elementRect, {});\n  }\n  /**\n   * @inheritdoc\n   * Creates clone of this position strategy\n   * @returns clone of this position strategy\n   */\n\n\n  clone() {\n    return Util.cloneInstance(this);\n  }\n  /**\n   * Obtains the DomRect objects for the required elements - target and element to position\n   *\n   * @returns target and element DomRect objects\n   */\n\n\n  calculateElementRectangles(contentElement, target) {\n    return {\n      targetRect: Util.getTargetRect(target),\n      elementRect: contentElement.getBoundingClientRect()\n    };\n  }\n  /**\n   * Sets element's style which effectively positions provided element according\n   * to provided position settings\n   *\n   * @param element Element to position\n   * @param targetRect Bounding rectangle of strategy target\n   * @param elementRect Bounding rectangle of the element\n   */\n\n\n  setStyle(element, targetRect, elementRect, connectedFit) {\n    const horizontalOffset = connectedFit.horizontalOffset ? connectedFit.horizontalOffset : 0;\n    const verticalOffset = connectedFit.verticalOffset ? connectedFit.verticalOffset : 0;\n    const startPoint = {\n      x: targetRect.right + targetRect.width * this.settings.horizontalStartPoint + horizontalOffset,\n      y: targetRect.bottom + targetRect.height * this.settings.verticalStartPoint + verticalOffset\n    };\n    const wrapperRect = element.parentElement.getBoundingClientRect(); //  clean up styles - if auto position strategy is chosen we may pass here several times\n\n    element.style.right = '';\n    element.style.left = '';\n    element.style.bottom = '';\n    element.style.top = '';\n\n    switch (this.settings.horizontalDirection) {\n      case HorizontalAlignment.Left:\n        element.style.right = `${Math.round(wrapperRect.right - startPoint.x)}px`;\n        break;\n\n      case HorizontalAlignment.Center:\n        element.style.left = `${Math.round(startPoint.x - wrapperRect.left - elementRect.width / 2)}px`;\n        break;\n\n      case HorizontalAlignment.Right:\n        element.style.left = `${Math.round(startPoint.x - wrapperRect.left)}px`;\n        break;\n    }\n\n    switch (this.settings.verticalDirection) {\n      case VerticalAlignment.Top:\n        element.style.bottom = `${Math.round(wrapperRect.bottom - startPoint.y)}px`;\n        break;\n\n      case VerticalAlignment.Middle:\n        element.style.top = `${Math.round(startPoint.y - wrapperRect.top - elementRect.height / 2)}px`;\n        break;\n\n      case VerticalAlignment.Bottom:\n        element.style.top = `${Math.round(startPoint.y - wrapperRect.top)}px`;\n        break;\n    }\n  }\n\n}\n\nclass BaseFitPositionStrategy extends ConnectedPositioningStrategy {\n  /** @inheritdoc */\n  position(contentElement, size, document, initialCall, target) {\n    const targetElement = target || this.settings.target;\n    const rects = super.calculateElementRectangles(contentElement, targetElement);\n    const connectedFit = {};\n\n    if (initialCall) {\n      connectedFit.targetRect = rects.targetRect;\n      connectedFit.contentElementRect = rects.elementRect;\n      this._initialSettings = this._initialSettings || Object.assign({}, this.settings);\n      this.settings = Object.assign({}, this._initialSettings);\n      connectedFit.viewPortRect = Util.getViewportRect(document);\n      this.updateViewPortFit(connectedFit);\n\n      if (this.shouldFitInViewPort(connectedFit)) {\n        this.fitInViewport(contentElement, connectedFit);\n      }\n    }\n\n    this.setStyle(contentElement, rects.targetRect, rects.elementRect, connectedFit);\n  }\n  /**\n   * Checks if element can fit in viewport and updates provided connectedFit\n   * with the result\n   *\n   * @param connectedFit connectedFit to update\n   */\n\n\n  updateViewPortFit(connectedFit) {\n    connectedFit.left = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, this.settings.horizontalStartPoint, this.settings.horizontalDirection, connectedFit.horizontalOffset ? connectedFit.horizontalOffset : 0);\n    connectedFit.right = connectedFit.left + connectedFit.contentElementRect.width;\n    connectedFit.fitHorizontal = {\n      back: Math.round(connectedFit.left),\n      forward: Math.round(connectedFit.viewPortRect.width - connectedFit.right)\n    };\n    connectedFit.top = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, this.settings.verticalStartPoint, this.settings.verticalDirection, connectedFit.verticalOffset ? connectedFit.verticalOffset : 0);\n    connectedFit.bottom = connectedFit.top + connectedFit.contentElementRect.height;\n    connectedFit.fitVertical = {\n      back: Math.round(connectedFit.top),\n      forward: Math.round(connectedFit.viewPortRect.height - connectedFit.bottom)\n    };\n  }\n  /**\n   * Calculates the position of the left border of the element if it gets positioned\n   * with provided start point and direction\n   *\n   * @param targetRect Rectangle of the target where element is attached\n   * @param elementRect Rectangle of the element\n   * @param startPoint Start point of the target\n   * @param direction Direction in which to show the element\n   */\n\n\n  calculateLeft(targetRect, elementRect, startPoint, direction, offset) {\n    return targetRect.right + targetRect.width * startPoint + elementRect.width * direction + offset;\n  }\n  /**\n   * Calculates the position of the top border of the element if it gets positioned\n   * with provided position settings related to the target\n   *\n   * @param targetRect Rectangle of the target where element is attached\n   * @param elementRect Rectangle of the element\n   * @param startPoint Start point of the target\n   * @param direction Direction in which to show the element\n   */\n\n\n  calculateTop(targetRect, elementRect, startPoint, direction, offset) {\n    return targetRect.bottom + targetRect.height * startPoint + elementRect.height * direction + offset;\n  }\n  /**\n   * Returns whether the element should fit in viewport\n   *\n   * @param connectedFit connectedFit object containing all necessary parameters\n   */\n\n\n  shouldFitInViewPort(connectedFit) {\n    return connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0 || connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0;\n  }\n\n}\n/**\n * Positions the element as in **Connected** positioning strategy and re-positions the element in\n * the view port (calculating a different start point) in case the element is partially getting out of view\n */\n\n\nclass AutoPositionStrategy extends BaseFitPositionStrategy {\n  /** @inheritdoc */\n  fitInViewport(element, connectedFit) {\n    const transformString = [];\n\n    if (connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0) {\n      if (this.canFlipHorizontal(connectedFit)) {\n        this.flipHorizontal();\n        this.flipAnimation(FlipDirection.Horizontal);\n      } else {\n        const horizontalPush = this.horizontalPush(connectedFit);\n        transformString.push(`translateX(${horizontalPush}px)`);\n      }\n    }\n\n    if (connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0) {\n      if (this.canFlipVertical(connectedFit)) {\n        this.flipVertical();\n        this.flipAnimation(FlipDirection.Vertical);\n      } else {\n        const verticalPush = this.verticalPush(connectedFit);\n        transformString.push(`translateY(${verticalPush}px)`);\n      }\n    }\n\n    element.style.transform = transformString.join(' ').trim();\n  }\n  /**\n   * Checks if element can be flipped without get off the viewport\n   *\n   * @param connectedFit connectedFit object containing all necessary parameters\n   * @returns true if element can be flipped and stain in viewport\n   */\n\n\n  canFlipHorizontal(connectedFit) {\n    //  HorizontalAlignment can be Left = -1; Center = -0.5 or Right = 0.\n    //  To virtually flip direction and start point (both are HorizontalAlignment) we can do this:\n    //  flippedAlignment = (-1) * (HorizontalAlignment + 1)\n    //  this way:\n    //  (-1) * (Left + 1) = 0 = Right\n    //  (-1) * (Center + 1) = -0.5 = Center\n    //  (-1) * (Right + 1) = -1 = Left\n    const flippedStartPoint = -1 * (this.settings.horizontalStartPoint + 1);\n    const flippedDirection = -1 * (this.settings.horizontalDirection + 1);\n    const leftBorder = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection, 0);\n    const rightBorder = leftBorder + connectedFit.contentElementRect.width;\n    return 0 < leftBorder && rightBorder < connectedFit.viewPortRect.width;\n  }\n  /**\n   * Checks if element can be flipped without get off the viewport\n   *\n   * @param connectedFit connectedFit object containing all necessary parameters\n   * @returns true if element can be flipped and stain in viewport\n   */\n\n\n  canFlipVertical(connectedFit) {\n    const flippedStartPoint = -1 * (this.settings.verticalStartPoint + 1);\n    const flippedDirection = -1 * (this.settings.verticalDirection + 1);\n    const topBorder = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection, 0);\n    const bottomBorder = topBorder + connectedFit.contentElementRect.height;\n    return 0 < topBorder && bottomBorder < connectedFit.viewPortRect.height;\n  }\n  /**\n   * Flips direction and start point of the position settings\n   */\n\n\n  flipHorizontal() {\n    switch (this.settings.horizontalDirection) {\n      case HorizontalAlignment.Left:\n        this.settings.horizontalDirection = HorizontalAlignment.Right;\n        break;\n\n      case HorizontalAlignment.Right:\n        this.settings.horizontalDirection = HorizontalAlignment.Left;\n        break;\n    }\n\n    switch (this.settings.horizontalStartPoint) {\n      case HorizontalAlignment.Left:\n        this.settings.horizontalStartPoint = HorizontalAlignment.Right;\n        break;\n\n      case HorizontalAlignment.Right:\n        this.settings.horizontalStartPoint = HorizontalAlignment.Left;\n        break;\n    }\n  }\n  /**\n   * Flips direction and start point of the position settings\n   */\n\n\n  flipVertical() {\n    switch (this.settings.verticalDirection) {\n      case VerticalAlignment.Top:\n        this.settings.verticalDirection = VerticalAlignment.Bottom;\n        break;\n\n      case VerticalAlignment.Bottom:\n        this.settings.verticalDirection = VerticalAlignment.Top;\n        break;\n    }\n\n    switch (this.settings.verticalStartPoint) {\n      case VerticalAlignment.Top:\n        this.settings.verticalStartPoint = VerticalAlignment.Bottom;\n        break;\n\n      case VerticalAlignment.Bottom:\n        this.settings.verticalStartPoint = VerticalAlignment.Top;\n        break;\n    }\n  }\n  /**\n   * Calculates necessary horizontal push according to provided connectedFit\n   *\n   * @param connectedFit connectedFit object containing all necessary parameters\n   * @returns amount of necessary translation which will push the element into viewport\n   */\n\n\n  horizontalPush(connectedFit) {\n    const leftExtend = connectedFit.left;\n    const rightExtend = connectedFit.right - connectedFit.viewPortRect.width; //  if leftExtend < 0 overlay goes beyond left end of the screen. We should push it back with exactly\n    //  as much as it is beyond the screen.\n    //  if rightExtend > 0 overlay goes beyond right end of the screen. We should push it back with the\n    //  extend but with amount not bigger than what left between left border of screen and left border of\n    //  overlay, e.g. leftExtend\n\n    if (leftExtend < 0) {\n      return Math.abs(leftExtend);\n    } else if (rightExtend > 0) {\n      return -Math.min(rightExtend, leftExtend);\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * Calculates necessary vertical push according to provided connectedFit\n   *\n   * @param connectedFit connectedFit object containing all necessary parameters\n   * @returns amount of necessary translation which will push the element into viewport\n   */\n\n\n  verticalPush(connectedFit) {\n    const topExtend = connectedFit.top;\n    const bottomExtend = connectedFit.bottom - connectedFit.viewPortRect.height;\n\n    if (topExtend < 0) {\n      return Math.abs(topExtend);\n    } else if (bottomExtend > 0) {\n      return -Math.min(bottomExtend, topExtend);\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * Changes open and close animation with reverse animation if one exists\n   *\n   * @param flipDirection direction for which to change the animations\n   */\n\n\n  flipAnimation(flipDirection) {\n    if (this.settings.openAnimation) {\n      this.settings.openAnimation = this.updateAnimation(this.settings.openAnimation, flipDirection);\n    }\n\n    if (this.settings.closeAnimation) {\n      this.settings.closeAnimation = this.updateAnimation(this.settings.closeAnimation, flipDirection);\n    }\n  }\n  /**\n   * Tries to find the reverse animation according to provided direction\n   *\n   * @param animation animation to update\n   * @param direction required animation direction\n   * @returns reverse animation in given direction if one exists\n   */\n\n\n  updateAnimation(animation, direction) {\n    switch (direction) {\n      case FlipDirection.Horizontal:\n        if (isHorizontalAnimation(animation)) {\n          return reverseAnimationResolver(animation);\n        }\n\n        break;\n\n      case FlipDirection.Vertical:\n        if (isVerticalAnimation(animation)) {\n          return reverseAnimationResolver(animation);\n        }\n\n        break;\n    }\n\n    return animation;\n  }\n\n}\n\nvar FlipDirection = /*#__PURE__*/(() => {\n  (function (FlipDirection) {\n    FlipDirection[FlipDirection[\"Horizontal\"] = 0] = \"Horizontal\";\n    FlipDirection[FlipDirection[\"Vertical\"] = 1] = \"Vertical\";\n  })(FlipDirection || (FlipDirection = {}));\n\n  return FlipDirection;\n})();\n\n/**\n * Positions the element based on the directions passed in trough PositionSettings.\n * These are Top/Middle/Bottom for verticalDirection and Left/Center/Right for horizontalDirection\n */\nclass GlobalPositionStrategy {\n  constructor(settings) {\n    this._defaultSettings = {\n      horizontalDirection: HorizontalAlignment.Center,\n      verticalDirection: VerticalAlignment.Middle,\n      horizontalStartPoint: HorizontalAlignment.Center,\n      verticalStartPoint: VerticalAlignment.Middle,\n      openAnimation: fadeIn,\n      closeAnimation: fadeOut,\n      minSize: {\n        width: 0,\n        height: 0\n      }\n    };\n    this.settings = Object.assign({}, this._defaultSettings, settings);\n  }\n  /** @inheritdoc */\n\n\n  position(contentElement) {\n    contentElement.classList.add('igx-overlay__content--relative');\n    contentElement.parentElement.classList.add('igx-overlay__wrapper--flex');\n    this.setPosition(contentElement);\n  }\n  /** @inheritdoc */\n\n\n  clone() {\n    return Util.cloneInstance(this);\n  }\n\n  setPosition(contentElement) {\n    switch (this.settings.horizontalDirection) {\n      case HorizontalAlignment.Left:\n        contentElement.parentElement.style.justifyContent = 'flex-start';\n        break;\n\n      case HorizontalAlignment.Center:\n        contentElement.parentElement.style.justifyContent = 'center';\n        break;\n\n      case HorizontalAlignment.Right:\n        contentElement.parentElement.style.justifyContent = 'flex-end';\n        break;\n\n      default:\n        break;\n    }\n\n    switch (this.settings.verticalDirection) {\n      case VerticalAlignment.Top:\n        contentElement.parentElement.style.alignItems = 'flex-start';\n        break;\n\n      case VerticalAlignment.Middle:\n        contentElement.parentElement.style.alignItems = 'center';\n        break;\n\n      case VerticalAlignment.Bottom:\n        contentElement.parentElement.style.alignItems = 'flex-end';\n        break;\n\n      default:\n        break;\n    }\n  }\n\n}\n/**\n * Positions the element inside the containing outlet based on the directions passed in trough PositionSettings.\n * These are Top/Middle/Bottom for verticalDirection and Left/Center/Right for horizontalDirection\n */\n\n\nclass ContainerPositionStrategy extends GlobalPositionStrategy {\n  constructor(settings) {\n    super(settings);\n  }\n  /** @inheritdoc */\n\n\n  position(contentElement) {\n    contentElement.classList.add('igx-overlay__content--relative');\n    contentElement.parentElement.classList.add('igx-overlay__wrapper--flex-container');\n    this.setPosition(contentElement);\n  }\n\n}\n/**\n * Positions the element as in **Connected** positioning strategy and resize the element\n * to fit in the view port in case the element is partially getting out of view\n */\n\n\nclass ElasticPositionStrategy extends BaseFitPositionStrategy {\n  /** @inheritdoc */\n  fitInViewport(element, connectedFit) {\n    element.classList.add('igx-overlay__content--elastic');\n    const transformString = [];\n\n    if (connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0) {\n      const maxReduction = Math.max(0, connectedFit.contentElementRect.width - this.settings.minSize.width);\n      const leftExtend = Math.max(0, -connectedFit.fitHorizontal.back);\n      const rightExtend = Math.max(0, -connectedFit.fitHorizontal.forward);\n      const reduction = Math.min(maxReduction, leftExtend + rightExtend);\n      element.style.width = `${connectedFit.contentElementRect.width - reduction}px`; //  if direction is center and element goes off the screen in left direction we should push the\n      //  element to the right. Prevents left still going out of view when normally positioned\n\n      if (this.settings.horizontalDirection === HorizontalAlignment.Center) {\n        //  the amount of translation depends on whether element goes off the screen to the left,\n        //  to the right or in both directions, as well as how much it goes of the screen and finally\n        //  on the minSize. The translation should be proportional between left and right extend\n        //  taken from the reduction\n        const translation = leftExtend * reduction / (leftExtend + rightExtend);\n\n        if (translation > 0) {\n          transformString.push(`translateX(${translation}px)`);\n        }\n      }\n    }\n\n    if (connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0) {\n      const maxReduction = Math.max(0, connectedFit.contentElementRect.height - this.settings.minSize.height);\n      const topExtend = Math.max(0, -connectedFit.fitVertical.back);\n      const bottomExtend = Math.max(0, -connectedFit.fitVertical.forward);\n      const reduction = Math.min(maxReduction, topExtend + bottomExtend);\n      element.style.height = `${connectedFit.contentElementRect.height - reduction}px`; //  if direction is middle and element goes off the screen in top direction we should push the\n      //  element to the bottom. Prevents top still going out of view when normally positioned\n\n      if (this.settings.verticalDirection === VerticalAlignment.Middle) {\n        //  the amount of translation depends on whether element goes off the screen to the top,\n        //  to the bottom or in both directions, as well as how much it goes of the screen and finally\n        //  on the minSize. The translation should be proportional between top and bottom extend\n        //  taken from the reduction\n        const translation = topExtend * reduction / (topExtend + bottomExtend);\n\n        if (translation > 0) {\n          transformString.push(`translateY(${translation}px)`);\n        }\n      }\n    }\n\n    element.style.transform = transformString.join(' ').trim();\n  }\n\n}\n\nclass ScrollStrategy {\n  constructor() {}\n\n}\n/**\n * Empty scroll strategy. Does nothing.\n */\n\n\nclass NoOpScrollStrategy extends ScrollStrategy {\n  constructor() {\n    super();\n  }\n  /** @inheritdoc */\n\n\n  initialize() {}\n  /** @inheritdoc */\n\n\n  attach() {}\n  /** @inheritdoc */\n\n\n  detach() {}\n\n}\n/**\n * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/overlay-main)\n * The overlay service allows users to show components on overlay div above all other elements in the page.\n */\n\n\nlet IgxOverlayService = /*#__PURE__*/(() => {\n  class IgxOverlayService {\n    constructor(_factoryResolver, _appRef, _injector, builder, document, _zone, platformUtil) {\n      this._factoryResolver = _factoryResolver;\n      this._appRef = _appRef;\n      this._injector = _injector;\n      this.builder = builder;\n      this.document = document;\n      this._zone = _zone;\n      this.platformUtil = platformUtil;\n      /**\n       * Emitted just before the overlay content starts to open.\n       * ```typescript\n       * opening(event: OverlayCancelableEventArgs){\n       *     const opening = event;\n       * }\n       * ```\n       */\n\n      this.opening = new EventEmitter();\n      /**\n       * Emitted after the overlay content is opened and all animations are finished.\n       * ```typescript\n       * opened(event: OverlayEventArgs){\n       *     const opened = event;\n       * }\n       * ```\n       */\n\n      this.opened = new EventEmitter();\n      /**\n       * Emitted just before the overlay content starts to close.\n       * ```typescript\n       * closing(event: OverlayCancelableEventArgs){\n       *     const closing = event;\n       * }\n       * ```\n       */\n\n      this.closing = new EventEmitter();\n      /**\n       * Emitted after the overlay content is closed and all animations are finished.\n       * ```typescript\n       * closed(event: OverlayEventArgs){\n       *     const closed = event;\n       * }\n       * ```\n       */\n\n      this.closed = new EventEmitter();\n      /**\n       * Emitted after the content is appended to the overlay, and before animations are started.\n       * ```typescript\n       * contentAppended(event: OverlayEventArgs){\n       *     const contentAppended = event;\n       * }\n       * ```\n       */\n\n      this.contentAppended = new EventEmitter();\n      /**\n       * Emitted just before the overlay animation start.\n       * ```typescript\n       * animationStarting(event: OverlayAnimationEventArgs){\n       *     const animationStarting = event;\n       * }\n       * ```\n       */\n\n      this.animationStarting = new EventEmitter();\n      this._componentId = 0;\n      this._overlayInfos = [];\n      this.destroy$ = new Subject();\n      this._cursorStyleIsSet = false;\n      this._defaultSettings = {\n        excludeFromOutsideClick: [],\n        positionStrategy: new GlobalPositionStrategy(),\n        scrollStrategy: new NoOpScrollStrategy(),\n        modal: true,\n        closeOnOutsideClick: true,\n        closeOnEscape: false\n      };\n      /** @hidden */\n\n      this.repositionAll = () => {\n        for (let i = this._overlayInfos.length; i--;) {\n          this.reposition(this._overlayInfos[i].id);\n        }\n      };\n\n      this.documentClicked = ev => {\n        //  if we get to modal overlay just return - we should not close anything under it\n        //  if we get to non-modal overlay do the next:\n        //   1. Check it has close on outside click. If not go on to next overlay;\n        //   2. If true check if click is on the element. If it is on the element we have closed\n        //  already all previous non-modal with close on outside click elements, so we return. If\n        //  not close the overlay and check next\n        for (let i = this._overlayInfos.length; i--;) {\n          const info = this._overlayInfos[i];\n\n          if (info.settings.modal) {\n            return;\n          }\n\n          if (info.settings.closeOnOutsideClick) {\n            const target = ev.composed ? ev.composedPath()[0] : ev.target;\n            const overlayElement = info.elementRef.nativeElement; // check if the click is on the overlay element or on an element from the exclusion list, and if so do not close the overlay\n\n            const excludeElements = info.settings.excludeFromOutsideClick ? [...info.settings.excludeFromOutsideClick, overlayElement] : [overlayElement];\n            const isInsideClick = excludeElements.some(e => e.contains(target));\n\n            if (isInsideClick) {\n              return; //  if the click is outside click, but close animation has started do nothing\n            } else if (!(info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted())) {\n              this._hide(info.id, ev);\n            }\n          }\n        }\n      };\n\n      this._document = this.document;\n    }\n    /**\n     * Creates overlay settings with global or container position strategy and preset position settings\n     *\n     * @param position Preset position settings. Default position is 'center'\n     * @param outlet The outlet container to attach the overlay to\n     * @returns Non-modal overlay settings based on Global or Container position strategy and the provided position.\n     */\n\n\n    static createAbsoluteOverlaySettings(position, outlet) {\n      const positionSettings = this.createAbsolutePositionSettings(position);\n      const strategy = outlet ? new ContainerPositionStrategy(positionSettings) : new GlobalPositionStrategy(positionSettings);\n      const overlaySettings = {\n        positionStrategy: strategy,\n        scrollStrategy: new NoOpScrollStrategy(),\n        modal: false,\n        closeOnOutsideClick: true,\n        outlet\n      };\n      return overlaySettings;\n    }\n    /**\n     * Creates overlay settings with auto, connected or elastic position strategy and preset position settings\n     *\n     * @param target Attaching target for the component to show\n     * @param strategy The relative position strategy to be applied to the overlay settings. Default is Auto positioning strategy.\n     * @param position Preset position settings. By default the element is positioned below the target, left aligned.\n     * @returns Non-modal overlay settings based on the provided target, strategy and position.\n     */\n\n\n    static createRelativeOverlaySettings(target, position, strategy) {\n      const positionSettings = this.createRelativePositionSettings(position);\n      const overlaySettings = {\n        target,\n        positionStrategy: this.createPositionStrategy(strategy, positionSettings),\n        scrollStrategy: new NoOpScrollStrategy(),\n        modal: false,\n        closeOnOutsideClick: true\n      };\n      return overlaySettings;\n    }\n\n    static createAbsolutePositionSettings(position) {\n      let positionSettings;\n\n      switch (position) {\n        case AbsolutePosition.Bottom:\n          positionSettings = {\n            horizontalDirection: HorizontalAlignment.Center,\n            verticalDirection: VerticalAlignment.Bottom,\n            openAnimation: slideInBottom,\n            closeAnimation: slideOutBottom\n          };\n          break;\n\n        case AbsolutePosition.Top:\n          positionSettings = {\n            horizontalDirection: HorizontalAlignment.Center,\n            verticalDirection: VerticalAlignment.Top,\n            openAnimation: slideInTop,\n            closeAnimation: slideOutTop\n          };\n          break;\n\n        case AbsolutePosition.Center:\n        default:\n          positionSettings = {\n            horizontalDirection: HorizontalAlignment.Center,\n            verticalDirection: VerticalAlignment.Middle,\n            openAnimation: fadeIn,\n            closeAnimation: fadeOut\n          };\n      }\n\n      return positionSettings;\n    }\n\n    static createRelativePositionSettings(position) {\n      let positionSettings;\n\n      switch (position) {\n        case RelativePosition.Above:\n          positionSettings = {\n            horizontalStartPoint: HorizontalAlignment.Center,\n            verticalStartPoint: VerticalAlignment.Top,\n            horizontalDirection: HorizontalAlignment.Center,\n            verticalDirection: VerticalAlignment.Top,\n            openAnimation: scaleInVerBottom,\n            closeAnimation: scaleOutVerBottom\n          };\n          break;\n\n        case RelativePosition.Below:\n          positionSettings = {\n            horizontalStartPoint: HorizontalAlignment.Center,\n            verticalStartPoint: VerticalAlignment.Bottom,\n            horizontalDirection: HorizontalAlignment.Center,\n            verticalDirection: VerticalAlignment.Bottom,\n            openAnimation: scaleInVerTop,\n            closeAnimation: scaleOutVerTop\n          };\n          break;\n\n        case RelativePosition.After:\n          positionSettings = {\n            horizontalStartPoint: HorizontalAlignment.Right,\n            verticalStartPoint: VerticalAlignment.Middle,\n            horizontalDirection: HorizontalAlignment.Right,\n            verticalDirection: VerticalAlignment.Middle,\n            openAnimation: scaleInHorLeft,\n            closeAnimation: scaleOutHorLeft\n          };\n          break;\n\n        case RelativePosition.Before:\n          positionSettings = {\n            horizontalStartPoint: HorizontalAlignment.Left,\n            verticalStartPoint: VerticalAlignment.Middle,\n            horizontalDirection: HorizontalAlignment.Left,\n            verticalDirection: VerticalAlignment.Middle,\n            openAnimation: scaleInHorRight,\n            closeAnimation: scaleOutHorRight\n          };\n          break;\n\n        case RelativePosition.Default:\n        default:\n          positionSettings = {\n            horizontalStartPoint: HorizontalAlignment.Left,\n            verticalStartPoint: VerticalAlignment.Bottom,\n            horizontalDirection: HorizontalAlignment.Right,\n            verticalDirection: VerticalAlignment.Bottom,\n            openAnimation: scaleInVerTop,\n            closeAnimation: scaleOutVerTop\n          };\n          break;\n      }\n\n      return positionSettings;\n    }\n\n    static createPositionStrategy(strategy, positionSettings) {\n      switch (strategy) {\n        case RelativePositionStrategy.Connected:\n          return new ConnectedPositioningStrategy(positionSettings);\n\n        case RelativePositionStrategy.Elastic:\n          return new ElasticPositionStrategy(positionSettings);\n\n        case RelativePositionStrategy.Auto:\n        default:\n          return new AutoPositionStrategy(positionSettings);\n      }\n    }\n\n    attach(component, settings, moduleRef) {\n      const info = this.getOverlayInfo(component, moduleRef);\n\n      if (!info) {\n        console.warn('Overlay was not able to attach provided component!');\n        return null;\n      }\n\n      info.id = (this._componentId++).toString();\n      info.visible = false;\n      settings = Object.assign({}, this._defaultSettings, settings);\n      info.settings = settings;\n\n      this._overlayInfos.push(info);\n\n      info.hook = this.placeElementHook(info.elementRef.nativeElement);\n      const elementRect = info.elementRef.nativeElement.getBoundingClientRect();\n      info.initialSize = {\n        width: elementRect.width,\n        height: elementRect.height\n      };\n      this.moveElementToOverlay(info);\n      this.contentAppended.emit({\n        id: info.id,\n        componentRef: info.componentRef\n      }); // TODO: why we had this check?\n      // if (this._overlayInfos.indexOf(info) === -1) {\n      //     this._overlayInfos.push(info);\n      // }\n\n      info.settings.scrollStrategy.initialize(this._document, this, info.id);\n      info.settings.scrollStrategy.attach();\n      this.addOutsideClickListener(info);\n      this.addResizeHandler();\n      this.addCloseOnEscapeListener(info);\n      this.buildAnimationPlayers(info);\n      return info.id;\n    }\n    /**\n     * Remove overlay with the provided id.\n     *\n     * @param id Id of the overlay to remove\n     * ```typescript\n     * this.overlay.detach(id);\n     * ```\n     */\n\n\n    detach(id) {\n      const info = this.getOverlayById(id);\n\n      if (!info) {\n        console.warn('igxOverlay.detach was called with wrong id: ', id);\n        return;\n      }\n\n      info.detached = true;\n      this.finishAnimations(info);\n      info.settings.scrollStrategy.detach();\n      this.removeOutsideClickListener(info);\n      this.removeResizeHandler();\n      this.cleanUp(info);\n    }\n    /**\n     * Remove all the overlays.\n     * ```typescript\n     * this.overlay.detachAll();\n     * ```\n     */\n\n\n    detachAll() {\n      for (let i = this._overlayInfos.length; i--;) {\n        this.detach(this._overlayInfos[i].id);\n      }\n    }\n    /**\n     * Shows the overlay for provided id.\n     *\n     * @param id Id to show overlay for\n     * @param settings Display settings for the overlay, such as positioning and scroll/close behavior.\n     */\n\n\n    show(id, settings) {\n      const info = this.getOverlayById(id);\n\n      if (!info) {\n        console.warn('igxOverlay.show was called with wrong id: ', id);\n        return;\n      }\n\n      const eventArgs = {\n        id,\n        componentRef: info.componentRef,\n        cancel: false\n      };\n      this.opening.emit(eventArgs);\n\n      if (eventArgs.cancel) {\n        return;\n      }\n\n      if (settings) {// TODO: update attach\n      }\n\n      this.updateSize(info);\n      info.settings.positionStrategy.position(info.elementRef.nativeElement.parentElement, {\n        width: info.initialSize.width,\n        height: info.initialSize.height\n      }, document, true, info.settings.target);\n      this.addModalClasses(info);\n\n      if (info.settings.positionStrategy.settings.openAnimation) {\n        this.playOpenAnimation(info);\n      } else {\n        //  to eliminate flickering show the element just before opened fires\n        info.wrapperElement.style.visibility = '';\n        info.visible = true;\n        this.opened.emit({\n          id: info.id,\n          componentRef: info.componentRef\n        });\n      }\n    }\n    /**\n     * Hides the component with the ID provided as a parameter.\n     * ```typescript\n     * this.overlay.hide(id);\n     * ```\n     */\n\n\n    hide(id, event) {\n      this._hide(id, event);\n    }\n    /**\n     * Hides all the components and the overlay.\n     * ```typescript\n     * this.overlay.hideAll();\n     * ```\n     */\n\n\n    hideAll() {\n      for (let i = this._overlayInfos.length; i--;) {\n        this.hide(this._overlayInfos[i].id);\n      }\n    }\n    /**\n     * Repositions the component with ID provided as a parameter.\n     *\n     * @param id Id to reposition overlay for\n     * ```typescript\n     * this.overlay.reposition(id);\n     * ```\n     */\n\n\n    reposition(id) {\n      const overlayInfo = this.getOverlayById(id);\n\n      if (!overlayInfo || !overlayInfo.settings) {\n        console.error('Wrong id provided in overlay.reposition method. Id: ' + id);\n        return;\n      }\n\n      if (!overlayInfo.visible) {\n        return;\n      }\n\n      const contentElement = overlayInfo.elementRef.nativeElement.parentElement;\n      const contentElementRect = contentElement.getBoundingClientRect();\n      overlayInfo.settings.positionStrategy.position(contentElement, {\n        width: contentElementRect.width,\n        height: contentElementRect.height\n      }, this._document, false, overlayInfo.settings.target);\n    }\n    /**\n     * Offsets the content along the corresponding axis by the provided amount\n     *\n     * @param id Id to offset overlay for\n     * @param deltaX Amount of offset in horizontal direction\n     * @param deltaY Amount of offset in vertical direction\n     * ```typescript\n     * this.overlay.setOffset(id, deltaX, deltaY);\n     * ```\n     */\n\n\n    setOffset(id, deltaX, deltaY) {\n      const info = this.getOverlayById(id);\n\n      if (!info) {\n        return;\n      }\n\n      info.transformX += deltaX;\n      info.transformY += deltaY;\n      const transformX = info.transformX;\n      const transformY = info.transformY;\n      const translate = `translate(${transformX}px, ${transformY}px)`;\n      info.elementRef.nativeElement.parentElement.style.transform = translate;\n    }\n    /** @hidden */\n\n\n    ngOnDestroy() {\n      this.destroy$.next(true);\n      this.destroy$.complete();\n    }\n    /** @hidden @internal */\n\n\n    getOverlayById(id) {\n      if (!id) {\n        return null;\n      }\n\n      const info = this._overlayInfos.find(e => e.id === id);\n\n      return info;\n    }\n\n    _hide(id, event) {\n      const info = this.getOverlayById(id);\n\n      if (!info) {\n        console.warn('igxOverlay.hide was called with wrong id: ', id);\n        return;\n      }\n\n      const eventArgs = {\n        id,\n        componentRef: info.componentRef,\n        cancel: false,\n        event\n      };\n      this.closing.emit(eventArgs);\n\n      if (eventArgs.cancel) {\n        return;\n      }\n\n      this.removeModalClasses(info);\n\n      if (info.settings.positionStrategy.settings.closeAnimation) {\n        this.playCloseAnimation(info, event);\n      } else {\n        this.closeDone(info);\n      }\n    }\n\n    getOverlayInfo(component, moduleRef) {\n      const info = {\n        ngZone: this._zone,\n        transformX: 0,\n        transformY: 0\n      };\n\n      if (component instanceof ElementRef) {\n        info.elementRef = component;\n      } else {\n        let dynamicFactory;\n        const factoryResolver = moduleRef ? moduleRef.componentFactoryResolver : this._factoryResolver;\n\n        try {\n          dynamicFactory = factoryResolver.resolveComponentFactory(component);\n        } catch (error) {\n          console.error(error);\n          return null;\n        }\n\n        const injector = moduleRef ? moduleRef.injector : this._injector;\n        const dynamicComponent = dynamicFactory.create(injector);\n\n        if (dynamicComponent.onDestroy) {\n          dynamicComponent.onDestroy(() => {\n            if (!info.detached && this._overlayInfos.indexOf(info) !== -1) {\n              this.detach(info.id);\n            }\n          });\n        }\n\n        this._appRef.attachView(dynamicComponent.hostView); // If the element is newly created from a Component, it is wrapped in 'ng-component' tag - we do not want that.\n\n\n        const element = dynamicComponent.location.nativeElement;\n        info.elementRef = {\n          nativeElement: element\n        };\n        info.componentRef = dynamicComponent;\n      }\n\n      return info;\n    }\n\n    placeElementHook(element) {\n      if (!element.parentElement) {\n        return null;\n      }\n\n      const hook = this._document.createElement('div');\n\n      hook.style.display = 'none';\n      element.parentElement.insertBefore(hook, element);\n      return hook;\n    }\n\n    moveElementToOverlay(info) {\n      info.wrapperElement = this.getWrapperElement();\n      const contentElement = this.getContentElement(info.wrapperElement, info.settings.modal);\n      this.getOverlayElement(info).appendChild(info.wrapperElement);\n      contentElement.appendChild(info.elementRef.nativeElement);\n    }\n\n    getWrapperElement() {\n      const wrapper = this._document.createElement('div');\n\n      wrapper.classList.add('igx-overlay__wrapper');\n      return wrapper;\n    }\n\n    getContentElement(wrapperElement, modal) {\n      const content = this._document.createElement('div');\n\n      if (modal) {\n        content.classList.add('igx-overlay__content--modal');\n        content.addEventListener('click', ev => {\n          ev.stopPropagation();\n        });\n      } else {\n        content.classList.add('igx-overlay__content');\n      }\n\n      content.addEventListener('scroll', ev => {\n        ev.stopPropagation();\n      }); //  hide element to eliminate flickering. Show the element exactly before animation starts\n\n      wrapperElement.style.visibility = 'hidden';\n      wrapperElement.appendChild(content);\n      return content;\n    }\n\n    getOverlayElement(info) {\n      if (info.settings.outlet) {\n        return info.settings.outlet.nativeElement || info.settings.outlet;\n      }\n\n      if (!this._overlayElement) {\n        this._overlayElement = this._document.createElement('div');\n\n        this._overlayElement.classList.add('igx-overlay');\n\n        this._document.body.appendChild(this._overlayElement);\n      }\n\n      return this._overlayElement;\n    }\n\n    updateSize(info) {\n      if (info.componentRef) {\n        //  if we are positioning component this is first time it gets visible\n        //  and we can finally get its size\n        info.componentRef.changeDetectorRef.detectChanges();\n        info.initialSize = info.elementRef.nativeElement.getBoundingClientRect();\n      } // set content div width only if element to show has width\n\n\n      if (info.initialSize.width !== 0) {\n        info.elementRef.nativeElement.parentElement.style.width = info.initialSize.width + 'px';\n      }\n    }\n\n    closeDone(info) {\n      info.visible = false;\n\n      if (info.wrapperElement) {\n        // to eliminate flickering show the element just before animation start\n        info.wrapperElement.style.visibility = 'hidden';\n      }\n\n      if (!info.closeAnimationDetaching) {\n        this.closed.emit({\n          id: info.id,\n          componentRef: info.componentRef,\n          event: info.event\n        });\n      }\n\n      delete info.event;\n    }\n\n    cleanUp(info) {\n      var _a, _b;\n\n      const child = info.elementRef.nativeElement;\n      const outlet = this.getOverlayElement(info); // if same element is shown in other overlay outlet will not contain\n      // the element and we should not remove it form outlet\n\n      if (outlet.contains(child)) {\n        outlet.removeChild(child.parentNode.parentNode);\n      }\n\n      if (info.componentRef) {\n        this._appRef.detachView(info.componentRef.hostView);\n\n        info.componentRef.destroy();\n        delete info.componentRef;\n      }\n\n      if (info.hook) {\n        info.hook.parentElement.insertBefore(info.elementRef.nativeElement, info.hook);\n        info.hook.parentElement.removeChild(info.hook);\n        delete info.hook;\n      }\n\n      const index = this._overlayInfos.indexOf(info);\n\n      this._overlayInfos.splice(index, 1); // this._overlayElement.parentElement check just for tests that manually delete the element\n\n\n      if (this._overlayInfos.length === 0) {\n        if (this._overlayElement && this._overlayElement.parentElement) {\n          this._overlayElement.parentElement.removeChild(this._overlayElement);\n\n          this._overlayElement = null;\n        }\n\n        this.removeCloseOnEscapeListener();\n      } // clean all the resources attached to info\n\n\n      delete info.elementRef;\n      delete info.settings;\n      delete info.initialSize;\n      info.openAnimationDetaching = true;\n      (_a = info.openAnimationPlayer) === null || _a === void 0 ? void 0 : _a.destroy();\n      delete info.openAnimationPlayer;\n      delete info.openAnimationInnerPlayer;\n      info.closeAnimationDetaching = true;\n      (_b = info.closeAnimationPlayer) === null || _b === void 0 ? void 0 : _b.destroy();\n      delete info.closeAnimationPlayer;\n      delete info.closeAnimationInnerPlayer;\n      delete info.ngZone;\n      delete info.wrapperElement;\n      info = null;\n    }\n\n    playOpenAnimation(info) {\n      var _a; //  if there is opening animation already started do nothing\n\n\n      if (info.openAnimationPlayer == null || info.openAnimationPlayer.hasStarted()) {\n        return;\n      } //  if there is closing animation already started start open animation from where close one has reached\n      //  and reset close animation\n\n\n      if ((_a = info.closeAnimationPlayer) === null || _a === void 0 ? void 0 : _a.hasStarted()) {\n        //  getPosition() returns what part of the animation is passed, e.g. 0.5 if half the animation\n        //  is done, 0.75 if 3/4 of the animation is done. As we need to start next animation from where\n        //  the previous has finished we need the amount up to 1, therefore we are subtracting what\n        //  getPosition() returns from one\n        const position = 1 - info.closeAnimationInnerPlayer.getPosition();\n        info.closeAnimationPlayer.reset(); // calling reset does not change hasStarted to false. This is why we are doing it her via internal field\n\n        info.closeAnimationPlayer._started = false;\n        info.openAnimationPlayer.init();\n        info.openAnimationPlayer.setPosition(position);\n      }\n\n      this.animationStarting.emit({\n        id: info.id,\n        animationPlayer: info.openAnimationPlayer,\n        animationType: 'open'\n      }); //  to eliminate flickering show the element just before animation start\n\n      info.wrapperElement.style.visibility = '';\n      info.visible = true;\n      info.openAnimationPlayer.play();\n    }\n\n    playCloseAnimation(info, event) {\n      var _a; //  if there is closing animation already started do nothing\n\n\n      if (info.closeAnimationPlayer == null || info.closeAnimationPlayer.hasStarted()) {\n        return;\n      } //  if there is opening animation already started start close animation from where open one has reached\n      //  and remove open animation\n\n\n      if ((_a = info.openAnimationPlayer) === null || _a === void 0 ? void 0 : _a.hasStarted()) {\n        //  getPosition() returns what part of the animation is passed, e.g. 0.5 if half the animation\n        //  is done, 0.75 if 3/4 of the animation is done. As we need to start next animation from where\n        //  the previous has finished we need the amount up to 1, therefore we are subtracting what\n        //  getPosition() returns from one\n        //  TODO: This assumes opening and closing animations are mirrored.\n        const position = 1 - info.openAnimationInnerPlayer.getPosition();\n        info.openAnimationPlayer.reset(); // calling reset does not change hasStarted to false. This is why we are doing it her via internal field\n\n        info.openAnimationPlayer._started = false;\n        info.closeAnimationPlayer.init();\n        info.closeAnimationPlayer.setPosition(position);\n      }\n\n      this.animationStarting.emit({\n        id: info.id,\n        animationPlayer: info.closeAnimationPlayer,\n        animationType: 'close'\n      });\n      info.event = event;\n      info.closeAnimationPlayer.play();\n    } //  TODO: check if applyAnimationParams will work with complex animations\n\n\n    applyAnimationParams(wrapperElement, animationOptions) {\n      if (!animationOptions) {\n        wrapperElement.style.transitionDuration = '0ms';\n        return;\n      }\n\n      if (!animationOptions.options || !animationOptions.options.params) {\n        return;\n      }\n\n      const params = animationOptions.options.params;\n\n      if (params.duration) {\n        wrapperElement.style.transitionDuration = params.duration;\n      }\n\n      if (params.easing) {\n        wrapperElement.style.transitionTimingFunction = params.easing;\n      }\n    }\n\n    addOutsideClickListener(info) {\n      if (info.settings.closeOnOutsideClick) {\n        if (info.settings.modal) {\n          fromEvent(info.elementRef.nativeElement.parentElement.parentElement, 'click').pipe(takeUntil(this.destroy$)).subscribe(e => this._hide(info.id, e));\n        } else if ( //  if all overlays minus closing overlays equals one add the handler\n        this._overlayInfos.filter(x => x.settings.closeOnOutsideClick && !x.settings.modal).length - this._overlayInfos.filter(x => x.settings.closeOnOutsideClick && !x.settings.modal && x.closeAnimationPlayer && x.closeAnimationPlayer.hasStarted()).length === 1) {\n          // click event is not fired on iOS. To make element \"clickable\" we are\n          // setting the cursor to pointer\n          if (this.platformUtil.isIOS && !this._cursorStyleIsSet) {\n            this._cursorOriginalValue = this._document.body.style.cursor;\n            this._document.body.style.cursor = 'pointer';\n            this._cursorStyleIsSet = true;\n          }\n\n          this._document.addEventListener('click', this.documentClicked, true);\n        }\n      }\n    }\n\n    removeOutsideClickListener(info) {\n      if (info.settings.modal === false) {\n        let shouldRemoveClickEventListener = true;\n\n        this._overlayInfos.forEach(o => {\n          if (o.settings.modal === false && o.id !== info.id) {\n            shouldRemoveClickEventListener = false;\n          }\n        });\n\n        if (shouldRemoveClickEventListener) {\n          if (this._cursorStyleIsSet) {\n            this._document.body.style.cursor = this._cursorOriginalValue;\n            this._cursorOriginalValue = '';\n            this._cursorStyleIsSet = false;\n          }\n\n          this._document.removeEventListener('click', this.documentClicked, true);\n        }\n      }\n    }\n\n    addResizeHandler() {\n      const closingOverlaysCount = this._overlayInfos.filter(o => o.closeAnimationPlayer && o.closeAnimationPlayer.hasStarted()).length;\n\n      if (this._overlayInfos.length - closingOverlaysCount === 1) {\n        this._document.defaultView.addEventListener('resize', this.repositionAll);\n      }\n    }\n\n    removeResizeHandler() {\n      const closingOverlaysCount = this._overlayInfos.filter(o => o.closeAnimationPlayer && o.closeAnimationPlayer.hasStarted()).length;\n\n      if (this._overlayInfos.length - closingOverlaysCount === 1) {\n        this._document.defaultView.removeEventListener('resize', this.repositionAll);\n      }\n    }\n\n    addCloseOnEscapeListener(info) {\n      if (info.settings.closeOnEscape && !this._keyPressEventListener) {\n        this._keyPressEventListener = fromEvent(this._document, 'keydown').pipe(filter(ev => ev.key === 'Escape' || ev.key === 'Esc')).subscribe(ev => {\n          const visibleOverlays = this._overlayInfos.filter(o => o.visible);\n\n          if (visibleOverlays.length < 1) {\n            return;\n          }\n\n          const targetOverlayInfo = visibleOverlays[visibleOverlays.length - 1];\n\n          if (targetOverlayInfo.visible && targetOverlayInfo.settings.closeOnEscape) {\n            this.hide(targetOverlayInfo.id, ev);\n          }\n        });\n      }\n    }\n\n    removeCloseOnEscapeListener() {\n      if (this._keyPressEventListener) {\n        this._keyPressEventListener.unsubscribe();\n\n        this._keyPressEventListener = null;\n      }\n    }\n\n    addModalClasses(info) {\n      if (info.settings.modal) {\n        const wrapperElement = info.elementRef.nativeElement.parentElement.parentElement;\n        wrapperElement.classList.remove('igx-overlay__wrapper');\n        this.applyAnimationParams(wrapperElement, info.settings.positionStrategy.settings.openAnimation);\n        requestAnimationFrame(() => {\n          wrapperElement.classList.add('igx-overlay__wrapper--modal');\n        });\n      }\n    }\n\n    removeModalClasses(info) {\n      if (info.settings.modal) {\n        const wrapperElement = info.elementRef.nativeElement.parentElement.parentElement;\n        this.applyAnimationParams(wrapperElement, info.settings.positionStrategy.settings.closeAnimation);\n        wrapperElement.classList.remove('igx-overlay__wrapper--modal');\n        wrapperElement.classList.add('igx-overlay__wrapper');\n      }\n    }\n\n    buildAnimationPlayers(info) {\n      if (info.settings.positionStrategy.settings.openAnimation) {\n        const animationBuilder = this.builder.build(info.settings.positionStrategy.settings.openAnimation);\n        info.openAnimationPlayer = animationBuilder.create(info.elementRef.nativeElement); //  AnimationPlayer.getPosition returns always 0. To workaround this we are getting inner WebAnimationPlayer\n        //  and then getting the positions from it.\n        //  This is logged in Angular here - https://github.com/angular/angular/issues/18891\n        //  As soon as this is resolved we can remove this hack\n\n        const innerRenderer = info.openAnimationPlayer._renderer;\n        info.openAnimationInnerPlayer = innerRenderer.engine.players[innerRenderer.engine.players.length - 1];\n        info.openAnimationPlayer.onDone(() => this.openAnimationDone(info));\n      }\n\n      if (info.settings.positionStrategy.settings.closeAnimation) {\n        const animationBuilder = this.builder.build(info.settings.positionStrategy.settings.closeAnimation);\n        info.closeAnimationPlayer = animationBuilder.create(info.elementRef.nativeElement); //  AnimationPlayer.getPosition returns always 0. To workaround this we are getting inner WebAnimationPlayer\n        //  and then getting the positions from it.\n        //  This is logged in Angular here - https://github.com/angular/angular/issues/18891\n        //  As soon as this is resolved we can remove this hack\n\n        const innerRenderer = info.closeAnimationPlayer._renderer;\n        info.closeAnimationInnerPlayer = innerRenderer.engine.players[innerRenderer.engine.players.length - 1];\n        info.closeAnimationPlayer.onDone(() => this.closeAnimationDone(info));\n      }\n    }\n\n    openAnimationDone(info) {\n      if (!info.openAnimationDetaching) {\n        this.opened.emit({\n          id: info.id,\n          componentRef: info.componentRef\n        });\n      }\n\n      if (info.openAnimationPlayer) {\n        info.openAnimationPlayer.reset(); // calling reset does not change hasStarted to false. This is why we are doing it here via internal field\n\n        info.openAnimationPlayer._started = false; // when animation finish angular deletes all onDone handlers so we need to add it again :(\n\n        info.openAnimationPlayer.onDone(() => this.openAnimationDone(info));\n      }\n\n      if (info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted()) {\n        info.closeAnimationPlayer.reset(); // calling reset does not change hasStarted to false. This is why we are doing it here via internal field\n\n        info.closeAnimationPlayer._started = false;\n      }\n    }\n\n    closeAnimationDone(info) {\n      if (info.closeAnimationPlayer) {\n        info.closeAnimationPlayer.reset(); // calling reset does not change hasStarted to false. This is why we are doing it here via internal field\n\n        info.closeAnimationPlayer._started = false; // when animation finish angular deletes all onDone handlers so we need to add it again :(\n\n        info.closeAnimationPlayer.onDone(() => this.closeAnimationDone(info));\n      }\n\n      if (info.openAnimationPlayer && info.openAnimationPlayer.hasStarted()) {\n        info.openAnimationPlayer.reset(); // calling reset does not change hasStarted to false. This is why we are doing it here via internal field\n\n        info.openAnimationPlayer._started = false;\n      }\n\n      this.closeDone(info);\n    }\n\n    finishAnimations(info) {\n      // TODO: should we emit here opened or closed events\n      if (info.openAnimationPlayer && info.openAnimationPlayer.hasStarted()) {\n        info.openAnimationPlayer.reset(); // calling reset does not change hasStarted to false. This is why we are doing it here via internal field\n\n        info.openAnimationPlayer._started = false;\n      }\n\n      if (info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted()) {\n        info.closeAnimationPlayer.reset(); // calling reset does not change hasStarted to false. This is why we are doing it here via internal field\n\n        info.closeAnimationPlayer._started = false;\n      }\n    }\n\n  }\n\n  IgxOverlayService.ɵfac = function IgxOverlayService_Factory(t) {\n    return new (t || IgxOverlayService)(i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(i0.ApplicationRef), i0.ɵɵinject(i0.Injector), i0.ɵɵinject(i1.AnimationBuilder), i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(PlatformUtil));\n  };\n\n  IgxOverlayService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxOverlayService,\n    factory: IgxOverlayService.ɵfac,\n    providedIn: 'root'\n  });\n  return IgxOverlayService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // Export position strategies\n\n/**\n * On scroll reposition the overlay content.\n */\n\n\nclass AbsoluteScrollStrategy extends ScrollStrategy {\n  constructor(scrollContainer) {\n    super();\n    this._initialized = false;\n\n    this.onScroll = e => {\n      const overlayInfo = this._overlayService.getOverlayById(this._id);\n\n      if (!overlayInfo) {\n        return;\n      }\n\n      if (!overlayInfo.elementRef.nativeElement.contains(e.target)) {\n        this._overlayService.reposition(this._id);\n      }\n    };\n\n    this._scrollContainer = scrollContainer;\n  }\n  /** @inheritdoc */\n\n\n  initialize(document, overlayService, id) {\n    if (this._initialized) {\n      return;\n    }\n\n    this._overlayService = overlayService;\n    this._id = id;\n    this._document = document;\n    this._zone = overlayService.getOverlayById(id).ngZone;\n    this._initialized = true;\n  }\n  /** @inheritdoc */\n\n\n  attach() {\n    if (this._zone) {\n      this._zone.runOutsideAngular(() => {\n        this.addScrollEventListener();\n      });\n    } else {\n      this.addScrollEventListener();\n    }\n  }\n  /** @inheritdoc */\n\n\n  detach() {\n    var _a;\n\n    if (this._scrollContainer) {\n      this._scrollContainer.removeEventListener('scroll', this.onScroll, true);\n    } else {\n      // Tired of this thing throwing every other time. Fix it ffs!\n      (_a = this._document) === null || _a === void 0 ? void 0 : _a.removeEventListener('scroll', this.onScroll, true);\n    }\n\n    this._initialized = false;\n  }\n\n  addScrollEventListener() {\n    if (this._scrollContainer) {\n      this._scrollContainer.addEventListener('scroll', this.onScroll, true);\n    } else {\n      this._document.addEventListener('scroll', this.onScroll, true);\n    }\n  }\n\n}\n/**\n * Prevents scrolling while the overlay content is shown.\n */\n\n\nclass BlockScrollStrategy extends ScrollStrategy {\n  constructor() {\n    super();\n    this._initialized = false;\n\n    this.onScroll = ev => {\n      ev.preventDefault();\n\n      if (!this._sourceElement || this._sourceElement !== ev.target) {\n        this._sourceElement = ev.target;\n        this._initialScrollTop = this._sourceElement.scrollTop;\n        this._initialScrollLeft = this._sourceElement.scrollLeft;\n      }\n\n      this._sourceElement.scrollTop = this._initialScrollTop;\n      this._sourceElement.scrollLeft = this._initialScrollLeft;\n    };\n  }\n  /** @inheritdoc */\n\n\n  initialize(document) {\n    if (this._initialized) {\n      return;\n    }\n\n    this._document = document;\n    this._initialized = true;\n  }\n  /** @inheritdoc */\n\n\n  attach() {\n    this._document.addEventListener('scroll', this.onScroll, true);\n  }\n  /** @inheritdoc */\n\n\n  detach() {\n    this._document.removeEventListener('scroll', this.onScroll, true);\n\n    this._sourceElement = null;\n    this._initialScrollTop = 0;\n    this._initialScrollLeft = 0;\n    this._initialized = false;\n  }\n\n}\n/**\n * Uses a tolerance and closes the shown component upon scrolling if the tolerance is exceeded\n */\n\n\nclass CloseScrollStrategy extends ScrollStrategy {\n  constructor(scrollContainer) {\n    super();\n    this._initialized = false;\n\n    this.onScroll = ev => {\n      if (!this._sourceElement) {\n        this._sourceElement = ev.target;\n        this.initialScrollTop = this._sourceElement.scrollTop;\n        this.initialScrollLeft = this._sourceElement.scrollLeft;\n      }\n\n      if (this._overlayInfo.elementRef.nativeElement.contains(this._sourceElement)) {\n        return;\n      }\n\n      if (Math.abs(this._sourceElement.scrollTop - this.initialScrollTop) > this._threshold || Math.abs(this._sourceElement.scrollLeft - this.initialScrollLeft) > this._threshold) {\n        this._overlayService.hide(this._id);\n      }\n    };\n\n    this._scrollContainer = scrollContainer;\n    this._threshold = 10;\n  }\n  /** @inheritdoc */\n\n\n  initialize(document, overlayService, id) {\n    if (this._initialized) {\n      return;\n    }\n\n    this._overlayService = overlayService;\n    this._id = id;\n    this._document = document;\n    this._initialized = true;\n    this._overlayInfo = overlayService.getOverlayById(id);\n  }\n  /** @inheritdoc */\n\n\n  attach() {\n    if (this._scrollContainer) {\n      this._scrollContainer.addEventListener('scroll', this.onScroll);\n\n      this._sourceElement = this._scrollContainer;\n    } else {\n      this._document.addEventListener('scroll', this.onScroll, true);\n    }\n  }\n  /** @inheritdoc */\n\n\n  detach() {\n    // TODO: check why event listener removes only on first call and remains on each next!!!\n    if (this._scrollContainer) {\n      this._scrollContainer.removeEventListener('scroll', this.onScroll);\n    } else {\n      this._document.removeEventListener('scroll', this.onScroll, true);\n    }\n\n    this._sourceElement = null;\n    this._initialized = false;\n  }\n\n} // Export scroll strategies\n\n\nclass IgxBaseTransactionService {\n  constructor() {\n    /**\n     * @inheritdoc\n     */\n    this.onStateUpdate = new EventEmitter();\n    this._isPending = false;\n    this._pendingTransactions = [];\n    this._pendingStates = new Map();\n    this._cloneStrategy = new DefaultDataCloneStrategy();\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  get cloneStrategy() {\n    return this._cloneStrategy;\n  }\n\n  set cloneStrategy(strategy) {\n    if (strategy) {\n      this._cloneStrategy = strategy;\n    }\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  get canRedo() {\n    return false;\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  get canUndo() {\n    return false;\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  get enabled() {\n    return this._isPending;\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  add(transaction, recordRef) {\n    if (this._isPending) {\n      this.updateState(this._pendingStates, transaction, recordRef);\n\n      this._pendingTransactions.push(transaction);\n    }\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  getTransactionLog(_id) {\n    return [];\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  undo() {}\n  /**\n   * @inheritdoc\n   */\n\n\n  redo() {}\n  /**\n   * @inheritdoc\n   */\n\n\n  getAggregatedChanges(mergeChanges) {\n    const result = [];\n\n    this._pendingStates.forEach((state, key) => {\n      const value = mergeChanges ? this.getAggregatedValue(key, mergeChanges) : state.value;\n      result.push({\n        id: key,\n        newValue: value,\n        type: state.type\n      });\n    });\n\n    return result;\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  getState(id) {\n    return this._pendingStates.get(id);\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  getAggregatedValue(id, mergeChanges) {\n    const state = this._pendingStates.get(id);\n\n    if (!state) {\n      return null;\n    }\n\n    if (mergeChanges && state.recordRef) {\n      return this.updateValue(state);\n    }\n\n    return state.value;\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  commit(_data, _id) {}\n  /**\n   * @inheritdoc\n   */\n\n\n  clear(_id) {\n    this._pendingStates.clear();\n\n    this._pendingTransactions = [];\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  startPending() {\n    this._isPending = true;\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  endPending(_commit) {\n    this._isPending = false;\n\n    this._pendingStates.clear();\n\n    this._pendingTransactions = [];\n  }\n  /**\n   * Updates the provided states collection according to passed transaction and recordRef\n   *\n   * @param states States collection to apply the update to\n   * @param transaction Transaction to apply to the current state\n   * @param recordRef Reference to the value of the record in data source, if any, where transaction should be applied\n   */\n\n\n  updateState(states, transaction, recordRef) {\n    let state = states.get(transaction.id);\n\n    if (state) {\n      if (isObject(state.value)) {\n        mergeObjects(state.value, transaction.newValue);\n      } else {\n        state.value = transaction.newValue;\n      }\n    } else {\n      state = {\n        value: this.cloneStrategy.clone(transaction.newValue),\n        recordRef,\n        type: transaction.type\n      };\n      states.set(transaction.id, state);\n    }\n  }\n  /**\n   * Updates the recordRef of the provided state with all the changes in the state. Accepts primitive and object value types\n   *\n   * @param state State to update value for\n   * @returns updated value including all the changes in provided state\n   */\n\n\n  updateValue(state) {\n    return this.mergeValues(state.recordRef, state.value);\n  }\n  /**\n   * Merges second values in first value and the result in empty object. If values are primitive type\n   * returns second value if exists, or first value.\n   *\n   * @param first Value to merge into\n   * @param second Value to merge\n   */\n\n\n  mergeValues(first, second) {\n    if (isObject(first) || isObject(second)) {\n      return mergeObjects(this.cloneStrategy.clone(first), second);\n    } else {\n      return second ? second : first;\n    }\n  }\n\n}\n\nclass IgxTransactionService extends IgxBaseTransactionService {\n  constructor() {\n    super(...arguments);\n    /**\n     * @inheritdoc\n     */\n\n    this.onStateUpdate = new EventEmitter();\n    this._transactions = [];\n    this._redoStack = [];\n    this._undoStack = [];\n    this._states = new Map();\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  get canUndo() {\n    return this._undoStack.length > 0;\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  get canRedo() {\n    return this._redoStack.length > 0;\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  add(transaction, recordRef) {\n    const states = this._isPending ? this._pendingStates : this._states;\n    this.verifyAddedTransaction(states, transaction, recordRef);\n    this.addTransaction(transaction, states, recordRef);\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  getTransactionLog(id) {\n    if (id !== undefined) {\n      return this._transactions.filter(t => t.id === id);\n    }\n\n    return [...this._transactions];\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  getAggregatedChanges(mergeChanges) {\n    const result = [];\n\n    this._states.forEach((state, key) => {\n      const value = mergeChanges ? this.mergeValues(state.recordRef, state.value) : state.value;\n      result.push({\n        id: key,\n        newValue: value,\n        type: state.type\n      });\n    });\n\n    return result;\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  getState(id, pending = false) {\n    return pending ? this._pendingStates.get(id) : this._states.get(id);\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  get enabled() {\n    return true;\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  getAggregatedValue(id, mergeChanges) {\n    const state = this._states.get(id);\n\n    const pendingState = super.getState(id); //  if there is no state and there is no pending state return null\n\n    if (!state && !pendingState) {\n      return null;\n    }\n\n    const pendingChange = super.getAggregatedValue(id, false);\n    const change = state && state.value;\n    let aggregatedValue = this.mergeValues(change, pendingChange);\n\n    if (mergeChanges) {\n      const originalValue = state ? state.recordRef : pendingState.recordRef;\n      aggregatedValue = this.mergeValues(originalValue, aggregatedValue);\n    }\n\n    return aggregatedValue;\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  endPending(commit) {\n    this._isPending = false;\n\n    if (commit) {\n      const actions = []; // don't use addTransaction due to custom undo handling\n\n      for (const transaction of this._pendingTransactions) {\n        const pendingState = this._pendingStates.get(transaction.id);\n\n        this._transactions.push(transaction);\n\n        this.updateState(this._states, transaction, pendingState.recordRef);\n        actions.push({\n          transaction,\n          recordRef: pendingState.recordRef\n        });\n      }\n\n      this._undoStack.push(actions);\n\n      this._redoStack = [];\n      this.onStateUpdate.emit({\n        origin: TransactionEventOrigin.END,\n        actions\n      });\n    }\n\n    super.endPending(commit);\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  commit(data, id) {\n    if (id !== undefined) {\n      const state = this.getState(id);\n\n      if (state) {\n        this.updateRecord(data, state);\n      }\n    } else {\n      this._states.forEach(s => {\n        this.updateRecord(data, s);\n      });\n    }\n\n    this.clear(id);\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  clear(id) {\n    if (id !== undefined) {\n      this._transactions = this._transactions.filter(t => t.id !== id);\n\n      this._states.delete(id); //  Undo stack is an array of actions. Each action is array of transaction like objects\n      //  We are going trough all the actions. For each action we are filtering out transactions\n      //  with provided id. Finally if any action ends up as empty array we are removing it from\n      //  undo stack\n\n\n      this._undoStack = this._undoStack.map(a => a.filter(t => t.transaction.id !== id)).filter(a => a.length > 0);\n    } else {\n      this._transactions = [];\n\n      this._states.clear();\n\n      this._undoStack = [];\n    }\n\n    this._redoStack = [];\n    this.onStateUpdate.emit({\n      origin: TransactionEventOrigin.CLEAR,\n      actions: []\n    });\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  undo() {\n    if (this._undoStack.length <= 0) {\n      return;\n    }\n\n    const lastActions = this._undoStack.pop();\n\n    this._transactions.splice(this._transactions.length - lastActions.length);\n\n    this._redoStack.push(lastActions);\n\n    this._states.clear();\n\n    for (const currentActions of this._undoStack) {\n      for (const transaction of currentActions) {\n        this.updateState(this._states, transaction.transaction, transaction.recordRef);\n      }\n    }\n\n    this.onStateUpdate.emit({\n      origin: TransactionEventOrigin.UNDO,\n      actions: lastActions\n    });\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  redo() {\n    if (this._redoStack.length > 0) {\n      const actions = this._redoStack.pop();\n\n      for (const action of actions) {\n        this.updateState(this._states, action.transaction, action.recordRef);\n\n        this._transactions.push(action.transaction);\n      }\n\n      this._undoStack.push(actions);\n\n      this.onStateUpdate.emit({\n        origin: TransactionEventOrigin.REDO,\n        actions\n      });\n    }\n  }\n\n  addTransaction(transaction, states, recordRef) {\n    this.updateState(states, transaction, recordRef);\n    const transactions = this._isPending ? this._pendingTransactions : this._transactions;\n    transactions.push(transaction);\n\n    if (!this._isPending) {\n      const actions = [{\n        transaction,\n        recordRef\n      }];\n\n      this._undoStack.push(actions);\n\n      this._redoStack = [];\n      this.onStateUpdate.emit({\n        origin: TransactionEventOrigin.ADD,\n        actions\n      });\n    }\n  }\n  /**\n   * Verifies if the passed transaction is correct. If not throws an exception.\n   *\n   * @param transaction Transaction to be verified\n   */\n\n\n  verifyAddedTransaction(states, transaction, recordRef) {\n    const state = states.get(transaction.id);\n\n    switch (transaction.type) {\n      case TransactionType.ADD:\n        if (state) {\n          //  cannot add same item twice\n          throw new Error(`Cannot add this transaction. Transaction with id: ${transaction.id} has been already added.`);\n        }\n\n        break;\n\n      case TransactionType.DELETE:\n      case TransactionType.UPDATE:\n        if (state && state.type === TransactionType.DELETE) {\n          //  cannot delete or update deleted items\n          throw new Error(`Cannot add this transaction. Transaction with id: ${transaction.id} has been already deleted.`);\n        }\n\n        if (!state && !recordRef && !this._isPending) {\n          //  cannot initially add transaction or delete item with no recordRef\n          throw new Error(`Cannot add this transaction. This is first transaction of type ${transaction.type} ` + `for id ${transaction.id}. For first transaction of this type recordRef is mandatory.`);\n        }\n\n        break;\n    }\n  }\n  /**\n   * Updates the provided states collection according to passed transaction and recordRef\n   *\n   * @param states States collection to apply the update to\n   * @param transaction Transaction to apply to the current state\n   * @param recordRef Reference to the value of the record in data source, if any, where transaction should be applied\n   */\n\n\n  updateState(states, transaction, recordRef) {\n    let state = states.get(transaction.id); //  if TransactionType is ADD simply add transaction to states;\n    //  if TransactionType is DELETE:\n    //    - if there is state with this id of type ADD remove it from the states;\n    //    - if there is state with this id of type UPDATE change its type to DELETE;\n    //    - if there is no state with this id add transaction to states;\n    //  if TransactionType is UPDATE:\n    //    - if there is state with this id of type ADD merge new value and state recordRef into state new value\n    //    - if there is state with this id of type UPDATE merge new value into state new value\n    //    - if there is state with this id and state type is DELETE change its type to UPDATE\n    //    - if there is no state with this id add transaction to states;\n\n    if (state) {\n      switch (transaction.type) {\n        case TransactionType.DELETE:\n          if (state.type === TransactionType.ADD) {\n            states.delete(transaction.id);\n          } else if (state.type === TransactionType.UPDATE) {\n            state.value = transaction.newValue;\n            state.type = TransactionType.DELETE;\n          }\n\n          break;\n\n        case TransactionType.UPDATE:\n          if (isObject(state.value)) {\n            if (state.type === TransactionType.ADD) {\n              state.value = this.mergeValues(state.value, transaction.newValue);\n            }\n\n            if (state.type === TransactionType.UPDATE) {\n              mergeObjects(state.value, transaction.newValue);\n            }\n          } else {\n            state.value = transaction.newValue;\n          }\n\n      }\n    } else {\n      state = {\n        value: this.cloneStrategy.clone(transaction.newValue),\n        recordRef,\n        type: transaction.type\n      };\n      states.set(transaction.id, state);\n    } //  should not clean pending state. This will happen automatically on endPending call\n\n\n    if (!this._isPending) {\n      this.cleanState(transaction.id, states);\n    }\n  }\n  /**\n   * Compares the state with recordRef and clears all duplicated values. If any state ends as\n   * empty object removes it from states.\n   *\n   * @param state State to clean\n   */\n\n\n  cleanState(id, states) {\n    const state = states.get(id); //  do nothing if\n    //  there is no state, or\n    //  there is no state value (e.g. DELETED transaction), or\n    //  there is no recordRef (e.g. ADDED transaction)\n\n    if (state && state.value && state.recordRef) {\n      //  if state's value is object compare each key with the ones in recordRef\n      //  if values in any key are the same delete it from state's value\n      //  if state's value is not object, simply compare with recordRef and remove\n      //  the state if they are equal\n      if (isObject(state.recordRef)) {\n        for (const key of Object.keys(state.value)) {\n          if (JSON.stringify(state.recordRef[key]) === JSON.stringify(state.value[key])) {\n            delete state.value[key];\n          }\n        } //  if state's value is empty remove the state from the states, only if state is not DELETE type\n\n\n        if (state.type !== TransactionType.DELETE && Object.keys(state.value).length === 0) {\n          states.delete(id);\n        }\n      } else {\n        if (state.recordRef === state.value) {\n          states.delete(id);\n        }\n      }\n    }\n  }\n  /**\n   * Updates state related record in the provided data\n   *\n   * @param data Data source to update\n   * @param state State to update data from\n   */\n\n\n  updateRecord(data, state) {\n    const index = data.findIndex(i => JSON.stringify(i) === JSON.stringify(state.recordRef || {}));\n\n    switch (state.type) {\n      case TransactionType.ADD:\n        data.push(state.value);\n        break;\n\n      case TransactionType.DELETE:\n        if (0 <= index && index < data.length) {\n          data.splice(index, 1);\n        }\n\n        break;\n\n      case TransactionType.UPDATE:\n        if (0 <= index && index < data.length) {\n          data[index] = this.updateValue(state);\n        }\n\n        break;\n    }\n  }\n\n}\n/** @experimental @hidden */\n\n\nclass IgxHierarchicalTransactionService extends IgxTransactionService {\n  getAggregatedChanges(mergeChanges) {\n    const result = [];\n\n    this._states.forEach((state, key) => {\n      const value = mergeChanges ? this.mergeValues(state.recordRef, state.value) : this.cloneStrategy.clone(state.value);\n      this.clearArraysFromObject(value);\n      result.push({\n        id: key,\n        path: state.path,\n        newValue: value,\n        type: state.type\n      });\n    });\n\n    return result;\n  }\n\n  commit(data, primaryKeyOrId, childDataKey, id) {\n    if (childDataKey !== undefined) {\n      let transactions = this.getAggregatedChanges(true);\n\n      if (id !== undefined) {\n        transactions = transactions.filter(t => t.id === id);\n      }\n\n      DataUtil.mergeHierarchicalTransactions(data, transactions, childDataKey, primaryKeyOrId, this.cloneStrategy, true);\n      this.clear(id);\n    } else {\n      super.commit(data, primaryKeyOrId);\n    }\n  }\n\n  updateState(states, transaction, recordRef) {\n    super.updateState(states, transaction, recordRef); //  if transaction has no path, e.g. flat data source, get out\n\n    if (!transaction.path) {\n      return;\n    }\n\n    const currentState = states.get(transaction.id);\n\n    if (currentState) {\n      currentState.path = transaction.path;\n    } //  if transaction has path, Hierarchical data source, and it is DELETE\n    //  type transaction for all child rows remove ADD states and update\n    //  transaction type and value of UPDATE states\n\n\n    if (transaction.type === TransactionType.DELETE) {\n      states.forEach((v, k) => {\n        if (v.path && v.path.indexOf(transaction.id) !== -1) {\n          switch (v.type) {\n            case TransactionType.ADD:\n              states.delete(k);\n              break;\n\n            case TransactionType.UPDATE:\n              states.get(k).type = TransactionType.DELETE;\n              states.get(k).value = null;\n          }\n        }\n      });\n    }\n  } //  TODO: remove this method. Force cloning to strip child arrays when needed instead\n\n\n  clearArraysFromObject(obj) {\n    if (obj) {\n      for (const prop of Object.keys(obj)) {\n        if (Array.isArray(obj[prop])) {\n          delete obj[prop];\n        }\n      }\n    }\n  }\n\n}\n/**\n * Factory service for instantiating TransactionServices\n */\n\n\nlet IgxFlatTransactionFactory = /*#__PURE__*/(() => {\n  class IgxFlatTransactionFactory {\n    /**\n     * Creates a new Transaction service instance depending on the specified type.\n     *\n     * @param type The type of the transaction\n     * @returns a new instance of TransactionService<Transaction, State>\n     */\n    create(type) {\n      switch (type) {\n        case \"Base\"\n        /* Base */\n        :\n          return new IgxTransactionService();\n\n        default:\n          return new IgxBaseTransactionService();\n      }\n    }\n\n  }\n\n  IgxFlatTransactionFactory.ɵfac = function IgxFlatTransactionFactory_Factory(t) {\n    return new (t || IgxFlatTransactionFactory)();\n  };\n\n  IgxFlatTransactionFactory.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxFlatTransactionFactory,\n    factory: IgxFlatTransactionFactory.ɵfac,\n    providedIn: 'root'\n  });\n  return IgxFlatTransactionFactory;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Factory service for instantiating HierarchicalTransactionServices\n */\n\n\nlet IgxHierarchicalTransactionFactory = /*#__PURE__*/(() => {\n  class IgxHierarchicalTransactionFactory extends IgxFlatTransactionFactory {\n    /**\n     * Creates a new HierarchialTransaction service instance depending on the specified type.\n     *\n     * @param type The type of the transaction\n     * @returns a new instance of HierarchialTransaction<HierarchialTransaction, HierarchialState>\n     */\n    create(type) {\n      switch (type) {\n        case \"Base\"\n        /* Base */\n        :\n          return new IgxHierarchicalTransactionService();\n          ;\n\n        default:\n          return new IgxBaseTransactionService();\n      }\n    }\n\n  }\n\n  IgxHierarchicalTransactionFactory.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxHierarchicalTransactionFactory_BaseFactory;\n    return function IgxHierarchicalTransactionFactory_Factory(t) {\n      return (ɵIgxHierarchicalTransactionFactory_BaseFactory || (ɵIgxHierarchicalTransactionFactory_BaseFactory = i0.ɵɵgetInheritedFactory(IgxHierarchicalTransactionFactory)))(t || IgxHierarchicalTransactionFactory);\n    };\n  }();\n\n  IgxHierarchicalTransactionFactory.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxHierarchicalTransactionFactory,\n    factory: IgxHierarchicalTransactionFactory.ɵfac,\n    providedIn: 'root'\n  });\n  return IgxHierarchicalTransactionFactory;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // Export services\n\n\nlet IgxToggleDirective = /*#__PURE__*/(() => {\n  class IgxToggleDirective {\n    /**\n     * @hidden\n     */\n    constructor(elementRef, cdr, overlayService, navigationService) {\n      this.elementRef = elementRef;\n      this.cdr = cdr;\n      this.overlayService = overlayService;\n      this.navigationService = navigationService;\n      /**\n       * Emits an event after the toggle container is opened.\n       *\n       * ```typescript\n       * onToggleOpened(event) {\n       *    alert(\"Toggle opened!\");\n       * }\n       * ```\n       *\n       * ```html\n       * <div\n       *   igxToggle\n       *   (onOpened)='onToggleOpened($event)'>\n       * </div>\n       * ```\n       */\n\n      this.opened = new EventEmitter();\n      /**\n       * Emits an event before the toggle container is opened.\n       *\n       * ```typescript\n       * onToggleOpening(event) {\n       *  alert(\"Toggle opening!\");\n       * }\n       * ```\n       *\n       * ```html\n       * <div\n       *   igxToggle\n       *   (onOpening)='onToggleOpening($event)'>\n       * </div>\n       * ```\n       */\n\n      this.opening = new EventEmitter();\n      /**\n       * Emits an event after the toggle container is closed.\n       *\n       * ```typescript\n       * onToggleClosed(event) {\n       *  alert(\"Toggle closed!\");\n       * }\n       * ```\n       *\n       * ```html\n       * <div\n       *   igxToggle\n       *   (onClosed)='onToggleClosed($event)'>\n       * </div>\n       * ```\n       */\n\n      this.closed = new EventEmitter();\n      /**\n       * Emits an event before the toggle container is closed.\n       *\n       * ```typescript\n       * onToggleClosing(event) {\n       *  alert(\"Toggle closing!\");\n       * }\n       * ```\n       *\n       * ```html\n       * <div\n       *  igxToggle\n       *  (closing)='onToggleClosing($event)'>\n       * </div>\n       * ```\n       */\n\n      this.closing = new EventEmitter();\n      /**\n       * Emits an event after the toggle element is appended to the overlay container.\n       *\n       * ```typescript\n       * onAppended() {\n       *  alert(\"Content appended!\");\n       * }\n       * ```\n       *\n       * ```html\n       * <div\n       *   igxToggle\n       *   (onAppended)='onToggleAppended()'>\n       * </div>\n       * ```\n       */\n\n      this.appended = new EventEmitter();\n      this._collapsed = true;\n      this.destroy$ = new Subject();\n      this._overlaySubFilter = [filter(x => x.id === this._overlayId), takeUntil(this.destroy$)];\n\n      this.overlayClosed = e => {\n        this._collapsed = true;\n        this.cdr.detectChanges();\n        this.unsubscribe();\n        this.overlayService.detach(this.overlayId);\n        const args = {\n          owner: this,\n          id: this._overlayId,\n          event: e.event\n        };\n        delete this._overlayId;\n        this.closed.emit(args);\n        this.cdr.markForCheck();\n      };\n    }\n    /**\n     * @hidden\n     */\n\n\n    get collapsed() {\n      return this._collapsed;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get element() {\n      return this.elementRef.nativeElement;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hiddenClass() {\n      return this.collapsed;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get defaultClass() {\n      return !this.collapsed;\n    }\n    /**\n     * Opens the toggle.\n     *\n     * ```typescript\n     * this.myToggle.open();\n     * ```\n     */\n\n\n    open(overlaySettings) {\n      var _a, _b, _c, _d; //  if there is open animation do nothing\n      //  if toggle is not collapsed and there is no close animation do nothing\n\n\n      const info = this.overlayService.getOverlayById(this._overlayId);\n      const openAnimationStarted = (_b = (_a = info === null || info === void 0 ? void 0 : info.openAnimationPlayer) === null || _a === void 0 ? void 0 : _a.hasStarted()) !== null && _b !== void 0 ? _b : false;\n      const closeAnimationStarted = (_d = (_c = info === null || info === void 0 ? void 0 : info.closeAnimationPlayer) === null || _c === void 0 ? void 0 : _c.hasStarted()) !== null && _d !== void 0 ? _d : false;\n\n      if (openAnimationStarted || !(this._collapsed || closeAnimationStarted)) {\n        return;\n      }\n\n      this._collapsed = false;\n      this.cdr.detectChanges();\n\n      if (!info) {\n        this.unsubscribe();\n        this.subscribe();\n        this._overlayId = this.overlayService.attach(this.elementRef, overlaySettings);\n      }\n\n      const args = {\n        cancel: false,\n        owner: this,\n        id: this._overlayId\n      };\n      this.opening.emit(args);\n\n      if (args.cancel) {\n        this.unsubscribe();\n        this.overlayService.detach(this._overlayId);\n        this._collapsed = true;\n        delete this._overlayId;\n        this.cdr.detectChanges();\n        return;\n      }\n\n      this.overlayService.show(this._overlayId, overlaySettings);\n    }\n    /**\n     * Closes the toggle.\n     *\n     * ```typescript\n     * this.myToggle.close();\n     * ```\n     */\n\n\n    close(event) {\n      var _a; //  if toggle is collapsed do nothing\n      //  if there is close animation do nothing, toggle will close anyway\n\n\n      const info = this.overlayService.getOverlayById(this._overlayId);\n      const closeAnimationStarted = ((_a = info === null || info === void 0 ? void 0 : info.closeAnimationPlayer) === null || _a === void 0 ? void 0 : _a.hasStarted()) || false;\n\n      if (this._collapsed || closeAnimationStarted) {\n        return;\n      }\n\n      this.overlayService.hide(this._overlayId, event);\n    }\n    /**\n     * Opens or closes the toggle, depending on its current state.\n     *\n     * ```typescript\n     * this.myToggle.toggle();\n     * ```\n     */\n\n\n    toggle(overlaySettings) {\n      //  if toggle is collapsed call open\n      //  if there is running close animation call open\n      if (this.collapsed || this.isClosing) {\n        this.open(overlaySettings);\n      } else {\n        this.close();\n      }\n    }\n    /** @hidden @internal */\n\n\n    get isClosing() {\n      var _a;\n\n      const info = this.overlayService.getOverlayById(this._overlayId);\n      return info ? (_a = info.closeAnimationPlayer) === null || _a === void 0 ? void 0 : _a.hasStarted() : false;\n    }\n    /**\n     * Returns the id of the overlay the content is rendered in.\n     * ```typescript\n     * this.myToggle.overlayId;\n     * ```\n     */\n\n\n    get overlayId() {\n      return this._overlayId;\n    }\n    /**\n     * Repositions the toggle.\n     * ```typescript\n     * this.myToggle.reposition();\n     * ```\n     */\n\n\n    reposition() {\n      this.overlayService.reposition(this._overlayId);\n    }\n    /**\n     * Offsets the content along the corresponding axis by the provided amount\n     */\n\n\n    setOffset(deltaX, deltaY) {\n      this.overlayService.setOffset(this._overlayId, deltaX, deltaY);\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      if (this.navigationService && this.id) {\n        this.navigationService.add(this.id, this);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      if (this.navigationService && this.id) {\n        this.navigationService.remove(this.id);\n      }\n\n      if (this._overlayId) {\n        this.overlayService.detach(this._overlayId);\n      }\n\n      this.unsubscribe();\n      this.destroy$.next(true);\n      this.destroy$.complete();\n    }\n\n    subscribe() {\n      this._overlayContentAppendedSub = this.overlayService.contentAppended.pipe(first$1(), takeUntil(this.destroy$)).subscribe(() => {\n        const args = {\n          owner: this,\n          id: this._overlayId\n        };\n        this.appended.emit(args);\n      });\n      this._overlayOpenedSub = this.overlayService.opened.pipe(...this._overlaySubFilter).subscribe(() => {\n        const args = {\n          owner: this,\n          id: this._overlayId\n        };\n        this.opened.emit(args);\n      });\n      this._overlayClosingSub = this.overlayService.closing.pipe(...this._overlaySubFilter).subscribe(e => {\n        const args = {\n          cancel: false,\n          event: e.event,\n          owner: this,\n          id: this._overlayId\n        };\n        this.closing.emit(args);\n        e.cancel = args.cancel; //  in case event is not canceled this will close the toggle and we need to unsubscribe.\n        //  Otherwise if for some reason, e.g. close on outside click, close() gets called before\n        //  onClosed was fired we will end with calling onClosing more than once\n\n        if (!e.cancel) {\n          this.clearSubscription(this._overlayClosingSub);\n        }\n      });\n      this._overlayClosedSub = this.overlayService.closed.pipe(...this._overlaySubFilter).subscribe(this.overlayClosed);\n    }\n\n    unsubscribe() {\n      this.clearSubscription(this._overlayOpenedSub);\n      this.clearSubscription(this._overlayClosingSub);\n      this.clearSubscription(this._overlayClosedSub);\n      this.clearSubscription(this._overlayContentAppendedSub);\n    }\n\n    clearSubscription(subscription) {\n      if (subscription && !subscription.closed) {\n        subscription.unsubscribe();\n      }\n    }\n\n  }\n\n  IgxToggleDirective.ɵfac = function IgxToggleDirective_Factory(t) {\n    return new (t || IgxToggleDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(IgxOverlayService), i0.ɵɵdirectiveInject(IgxNavigationService, 8));\n  };\n\n  IgxToggleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxToggleDirective,\n    selectors: [[\"\", \"igxToggle\", \"\"]],\n    hostVars: 5,\n    hostBindings: function IgxToggleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-hidden\", ctx.hiddenClass);\n        i0.ɵɵclassProp(\"igx-toggle--hidden\", ctx.hiddenClass)(\"igx-toggle\", ctx.defaultClass);\n      }\n    },\n    inputs: {\n      id: \"id\"\n    },\n    outputs: {\n      opened: \"opened\",\n      opening: \"opening\",\n      closed: \"closed\",\n      closing: \"closing\",\n      appended: \"appended\"\n    },\n    exportAs: [\"toggle\"]\n  });\n  return IgxToggleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxToggleActionDirective = /*#__PURE__*/(() => {\n  class IgxToggleActionDirective {\n    constructor(element, navigationService) {\n      this.element = element;\n      this.navigationService = navigationService;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set target(target) {\n      if (target !== null && target !== '') {\n        this._target = target;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get target() {\n      if (typeof this._target === 'string') {\n        return this.navigationService.get(this._target);\n      }\n\n      return this._target;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onClick() {\n      if (this.outlet) {\n        this._overlayDefaults.outlet = this.outlet;\n      }\n\n      const clonedSettings = Object.assign({}, this._overlayDefaults, this.overlaySettings);\n      this.updateOverlaySettings(clonedSettings);\n      this.target.toggle(clonedSettings);\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      const targetElement = this.element.nativeElement;\n      this._overlayDefaults = {\n        target: targetElement,\n        positionStrategy: new ConnectedPositioningStrategy(),\n        scrollStrategy: new AbsoluteScrollStrategy(),\n        closeOnOutsideClick: true,\n        modal: false,\n        excludeFromOutsideClick: [targetElement]\n      };\n    }\n    /**\n     * Updates provided overlay settings\n     *\n     * @param settings settings to update\n     * @returns returns updated copy of provided overlay settings\n     */\n\n\n    updateOverlaySettings(settings) {\n      if (settings && settings.positionStrategy) {\n        const positionStrategyClone = settings.positionStrategy.clone();\n        settings.target = this.element.nativeElement;\n        settings.positionStrategy = positionStrategyClone;\n      }\n\n      return settings;\n    }\n\n  }\n\n  IgxToggleActionDirective.ɵfac = function IgxToggleActionDirective_Factory(t) {\n    return new (t || IgxToggleActionDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(IgxNavigationService, 8));\n  };\n\n  IgxToggleActionDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxToggleActionDirective,\n    selectors: [[\"\", \"igxToggleAction\", \"\"]],\n    hostBindings: function IgxToggleActionDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function IgxToggleActionDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n    },\n    inputs: {\n      overlaySettings: \"overlaySettings\",\n      outlet: [\"igxToggleOutlet\", \"outlet\"],\n      target: [\"igxToggleAction\", \"target\"]\n    },\n    exportAs: [\"toggle-action\"]\n  });\n  return IgxToggleActionDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Mark an element as an igxOverlay outlet container.\n * Directive instance is exported as `overlay-outlet` to be assigned to templates variables:\n * ```html\n * <div igxOverlayOutlet #outlet=\"overlay-outlet\"></div>\n * ```\n */\n\n\nlet IgxOverlayOutletDirective = /*#__PURE__*/(() => {\n  class IgxOverlayOutletDirective {\n    constructor(element) {\n      this.element = element;\n    }\n    /** @hidden */\n\n\n    get nativeElement() {\n      return this.element.nativeElement;\n    }\n\n  }\n\n  IgxOverlayOutletDirective.ɵfac = function IgxOverlayOutletDirective_Factory(t) {\n    return new (t || IgxOverlayOutletDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxOverlayOutletDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxOverlayOutletDirective,\n    selectors: [[\"\", \"igxOverlayOutlet\", \"\"]],\n    exportAs: [\"overlay-outlet\"]\n  });\n  return IgxOverlayOutletDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxToggleModule = /*#__PURE__*/(() => {\n  class IgxToggleModule {}\n\n  IgxToggleModule.ɵfac = function IgxToggleModule_Factory(t) {\n    return new (t || IgxToggleModule)();\n  };\n\n  IgxToggleModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxToggleModule\n  });\n  IgxToggleModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IgxNavigationService]\n  });\n  return IgxToggleModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nvar Navigate = /*#__PURE__*/(() => {\n  (function (Navigate) {\n    Navigate[Navigate[\"Up\"] = -1] = \"Up\";\n    Navigate[Navigate[\"Down\"] = 1] = \"Down\";\n  })(Navigate || (Navigate = {}));\n\n  return Navigate;\n})();\n\n/** Key actions that have designated handlers in IgxDropDownComponent */\nconst DropDownActionKey = mkenum({\n  ESCAPE: 'escape',\n  ENTER: 'enter',\n  SPACE: 'space'\n});\nconst IGX_DROPDOWN_BASE = new InjectionToken('IgxDropDownBaseToken');\n/** @hidden */\n\nlet IgxSelectionAPIService = /*#__PURE__*/(() => {\n  class IgxSelectionAPIService {\n    constructor() {\n      /**\n       * If primaryKey is defined, then multiple selection is based on the primaryKey, and it is array of numbers, strings, etc.\n       * If the primaryKey is omitted, then selection is based on the item data\n       */\n      this.selection = new Map();\n    }\n    /**\n     * Get current component selection.\n     *\n     * @param componentID ID of the component.\n     */\n\n\n    get(componentID) {\n      return this.selection.get(componentID);\n    }\n    /**\n     * Set new component selection.\n     *\n     * @param componentID ID of the component.\n     * @param newSelection The new component selection to be set.\n     */\n\n\n    set(componentID, newSelection) {\n      if (!componentID) {\n        throw Error('Invalid value for component id!');\n      }\n\n      this.selection.set(componentID, newSelection);\n    }\n    /**\n     * Clears selection for component.\n     *\n     * @param componentID ID of the component.\n     */\n\n\n    clear(componentID) {\n      this.selection.set(componentID, this.get_empty());\n    }\n    /**\n     * Get current component selection length.\n     *\n     * @param componentID ID of the component.\n     */\n\n\n    size(componentID) {\n      const sel = this.get(componentID);\n      return sel ? sel.size : 0;\n    }\n    /**\n     * Creates new selection that consist of the new item added to the current component selection.\n     * The returned collection is new Set,\n     * therefore if you want to update component selection you need to call in addition the set_selection() method\n     * or instead use the select_item() one.\n     *\n     * @param componentID ID of the component, which we add new item to.\n     * @param itemID ID of the item to add to component selection.\n     * @param sel Used internally only by the selection (add_items method) to accumulate selection for multiple items.\n     *\n     * @returns Selection after the new item is added.\n     */\n\n\n    add_item(componentID, itemID, sel) {\n      if (!sel) {\n        sel = new Set(this.get(componentID));\n      }\n\n      if (sel === undefined) {\n        sel = this.get_empty();\n      }\n\n      if (!itemID && itemID !== 0) {\n        throw Error('Invalid value for item id!');\n      }\n\n      sel.add(itemID);\n      return sel;\n    }\n    /**\n     * Creates new selection that consist of the new items added to the current component selection.\n     * The returned collection is new Set,\n     * therefore if you want to update component selection you need to call in addition the set_selection() method\n     * or instead use the select_items() one.\n     *\n     * @param componentID ID of the component, which we add new items to.\n     * @param itemIDs Array of IDs of the items to add to component selection.\n     * @param clearSelection If true it will clear previous selection.\n     *\n     * @returns Selection after the new items are added.\n     */\n\n\n    add_items(componentID, itemIDs, clearSelection) {\n      let selection;\n\n      if (clearSelection) {\n        selection = this.get_empty();\n      } else if (itemIDs && itemIDs.length === 0) {\n        selection = new Set(this.get(componentID));\n      }\n\n      itemIDs.forEach(item => selection = this.add_item(componentID, item, selection));\n      return selection;\n    }\n    /**\n     * Add item to the current component selection.\n     *\n     * @param componentID ID of the component, which we add new item to.\n     * @param itemID ID of the item to add to component selection.\n     * @param sel Used internally only by the selection (select_items method) to accumulate selection for multiple items.\n     */\n\n\n    select_item(componentID, itemID, sel) {\n      this.set(componentID, this.add_item(componentID, itemID, sel));\n    }\n    /**\n     * Add items to the current component selection.\n     *\n     * @param componentID ID of the component, which we add new items to.\n     * @param itemIDs Array of IDs of the items to add to component selection.\n     * @param clearSelection If true it will clear previous selection.\n     */\n\n\n    select_items(componentID, itemID, clearSelection) {\n      this.set(componentID, this.add_items(componentID, itemID, clearSelection));\n    }\n    /**\n     * Creates new selection that consist of the new items excluded from the current component selection.\n     * The returned collection is new Set,\n     * therefore if you want to update component selection you need to call in addition the set_selection() method\n     * or instead use the deselect_item() one.\n     *\n     * @param componentID ID of the component, which we remove items from.\n     * @param itemID ID of the item to remove from component selection.\n     * @param sel Used internally only by the selection (delete_items method) to accumulate deselected items.\n     *\n     * @returns Selection after the item is removed.\n     */\n\n\n    delete_item(componentID, itemID, sel) {\n      if (!sel) {\n        sel = new Set(this.get(componentID));\n      }\n\n      if (sel === undefined) {\n        return;\n      }\n\n      sel.delete(itemID);\n      return sel;\n    }\n    /**\n     * Creates new selection that consist of the new items removed to the current component selection.\n     * The returned collection is new Set,\n     * therefore if you want to update component selection you need to call in addition the set_selection() method\n     * or instead use the deselect_items() one.\n     *\n     * @param componentID ID of the component, which we remove items from.\n     * @param itemID ID of the items to remove from component selection.\n     *\n     * @returns Selection after the items are removed.\n     */\n\n\n    delete_items(componentID, itemIDs) {\n      let selection;\n      itemIDs.forEach(deselectedItem => selection = this.delete_item(componentID, deselectedItem, selection));\n      return selection;\n    }\n    /**\n     * Remove item from the current component selection.\n     *\n     * @param componentID ID of the component, which we remove item from.\n     * @param itemID ID of the item to remove from component selection.\n     * @param sel Used internally only by the selection (deselect_items method) to accumulate selection for multiple items.\n     */\n\n\n    deselect_item(componentID, itemID, sel) {\n      this.set(componentID, this.delete_item(componentID, itemID, sel));\n    }\n    /**\n     * Remove items to the current component selection.\n     *\n     * @param componentID ID of the component, which we add new items to.\n     * @param itemIDs Array of IDs of the items to add to component selection.\n     */\n\n\n    deselect_items(componentID, itemID, clearSelection) {\n      this.set(componentID, this.delete_items(componentID, itemID));\n    }\n    /**\n     * Check if the item is selected in the component selection.\n     *\n     * @param componentID ID of the component.\n     * @param itemID ID of the item to search.\n     *\n     * @returns If item is selected.\n     */\n\n\n    is_item_selected(componentID, itemID) {\n      const sel = this.get(componentID);\n\n      if (!sel) {\n        return false;\n      }\n\n      return sel.has(itemID);\n    }\n    /**\n     * Get first element in the selection.\n     * This is correct when we have only one item in the collection (for single selection purposes)\n     * and the method returns that item.\n     *\n     * @param componentID ID of the component.\n     *\n     * @returns First element in the set.\n     */\n\n\n    first_item(componentID) {\n      const sel = this.get(componentID);\n\n      if (sel && sel.size > 0) {\n        return sel.values().next().value;\n      }\n    }\n    /**\n     * Returns whether all items are selected.\n     *\n     * @param componentID ID of the component.\n     * @param dataCount: number Number of items in the data.\n     *\n     * @returns If all items are selected.\n     */\n\n\n    are_all_selected(componentID, dataCount) {\n      return dataCount > 0 && dataCount === this.size(componentID);\n    }\n    /**\n     * Returns whether any of the items is selected.\n     *\n     * @param componentID ID of the component.\n     * @param data Entire data array.\n     *\n     * @returns If there is any item selected.\n     */\n\n\n    are_none_selected(componentID) {\n      return this.size(componentID) === 0;\n    }\n    /**\n     * Get all primary key values from a data array. If there isn't a primary key defined that the entire data is returned instead.\n     *\n     * @param data Entire data array.\n     * @param primaryKey Data primary key.\n     *\n     * @returns Array of identifiers, either primary key values or the entire data array.\n     */\n\n\n    get_all_ids(data, primaryKey) {\n      // If primaryKey is 0, this should still map to the property\n      return primaryKey !== undefined && primaryKey !== null ? data.map(x => x[primaryKey]) : data;\n    }\n    /**\n     * Returns empty selection collection.\n     *\n     * @returns empty set.\n     */\n\n\n    get_empty() {\n      return new Set();\n    }\n\n  }\n\n  IgxSelectionAPIService.ɵfac = function IgxSelectionAPIService_Factory(t) {\n    return new (t || IgxSelectionAPIService)();\n  };\n\n  IgxSelectionAPIService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxSelectionAPIService,\n    factory: IgxSelectionAPIService.ɵfac,\n    providedIn: 'root'\n  });\n  return IgxSelectionAPIService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$v = 0;\n/**\n * The `<igx-drop-down-item>` is a container intended for row items in\n * a `<igx-drop-down>` container.\n */\n\nlet IgxDropDownGroupComponent = /*#__PURE__*/(() => {\n  class IgxDropDownGroupComponent {\n    constructor() {\n      /**\n       * @hidden @internal\n       */\n      this.role = 'group';\n      /** @hidden @internal */\n\n      this.groupClass = true;\n      /**\n       * Sets/gets if the item group is disabled\n       *\n       * ```typescript\n       * const myDropDownGroup: IgxDropDownGroupComponent = this.dropdownGroup;\n       * // get\n       * ...\n       * const groupState: boolean = myDropDownGroup.disabled;\n       * ...\n       * //set\n       * ...\n       * myDropDownGroup,disabled = false;\n       * ...\n       * ```\n       *\n       * ```html\n       * <igx-drop-down-item-group [label]=\"'My Items'\" [disabled]=\"true\">\n       *     <igx-drop-down-item *ngFor=\"let item of items[index]\" [value]=\"item.value\">\n       *         {{ item.text }}\n       *     </igx-drop-down-item>\n       * </igx-drop-down-item-group>\n       * ```\n       *\n       * **NOTE:** All items inside of a disabled drop down group will be treated as disabled\n       */\n\n      this.disabled = false;\n      this._id = NEXT_ID$v++;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get labelId() {\n      return `igx-item-group-label-${this._id}`;\n    }\n\n    get labelledBy() {\n      return this.labelId;\n    }\n\n  }\n\n  IgxDropDownGroupComponent.ɵfac = function IgxDropDownGroupComponent_Factory(t) {\n    return new (t || IgxDropDownGroupComponent)();\n  };\n\n  IgxDropDownGroupComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxDropDownGroupComponent,\n    selectors: [[\"igx-drop-down-item-group\"]],\n    hostVars: 7,\n    hostBindings: function IgxDropDownGroupComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-labelledby\", ctx.labelledBy)(\"role\", ctx.role)(\"aria-disabled\", ctx.disabled);\n        i0.ɵɵclassProp(\"igx-drop-down__group\", ctx.groupClass)(\"igx-drop-down__group--disabled\", ctx.disabled);\n      }\n    },\n    inputs: {\n      disabled: \"disabled\",\n      label: \"label\"\n    },\n    ngContentSelectors: _c1,\n    decls: 3,\n    vars: 2,\n    consts: [[3, \"id\"]],\n    template: function IgxDropDownGroupComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c0);\n        i0.ɵɵelementStart(0, \"label\", 0);\n        i0.ɵɵtext(1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵprojection(2);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵpropertyInterpolate(\"id\", ctx.labelId);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx.label);\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxDropDownGroupComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$u = 0;\n/**\n * An abstract class defining a drop-down item:\n * With properties / styles for selection, highlight, height\n * Bindable property for passing data (`value: any`)\n * Parent component (has to be used under a parent with type `IDropDownBase`)\n * Method for handling click on Host()\n */\n\nlet IgxDropDownItemBaseDirective = /*#__PURE__*/(() => {\n  class IgxDropDownItemBaseDirective {\n    constructor(dropDown, elementRef, group, selection) {\n      this.dropDown = dropDown;\n      this.elementRef = elementRef;\n      this.group = group;\n      this.selection = selection;\n      /**\n       * Sets/gets the `id` of the item.\n       * ```html\n       * <igx-drop-down-item [id] = 'igx-drop-down-item-0'></igx-drop-down-item>\n       * ```\n       * ```typescript\n       * let itemId =  this.item.id;\n       * ```\n       *\n       * @memberof IgxSelectItemComponent\n       */\n\n      this.id = `igx-drop-down-item-${NEXT_ID$u++}`;\n      /**\n       * @hidden\n       */\n\n      this.selectedChange = new EventEmitter();\n      /**\n       * Gets/sets the `role` attribute of the item. Default is 'option'.\n       *\n       * ```html\n       *  <igx-drop-down-item [role]=\"customRole\"></igx-drop-down-item>\n       * ```\n       */\n\n      this.role = 'option';\n      /**\n       * @hidden\n       */\n\n      this._focused = false;\n      this._selected = false;\n      this._index = null;\n      this._disabled = false;\n    }\n\n    get ariaLabel() {\n      return this.value ? this.value : this.id;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get itemID() {\n      return this;\n    }\n    /**\n     * The data index of the dropdown item.\n     *\n     * ```typescript\n     * // get the data index of the selected dropdown item\n     * let selectedItemIndex = this.dropdown.selectedItem.index\n     * ```\n     */\n\n\n    get index() {\n      if (this._index === null) {\n        return this.itemIndex;\n      }\n\n      return this._index;\n    }\n\n    set index(value) {\n      this._index = value;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get itemStyle() {\n      return !this.isHeader;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get itemStyleCosy() {\n      return this.dropDown.displayDensity === 'cosy' && !this.isHeader;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get itemStyleCompact() {\n      return this.dropDown.displayDensity === 'compact' && !this.isHeader;\n    }\n    /**\n     * Sets/Gets if the item is the currently selected one in the dropdown\n     *\n     * ```typescript\n     *  let mySelectedItem = this.dropdown.selectedItem;\n     *  let isMyItemSelected = mySelectedItem.selected; // true\n     * ```\n     *\n     * Two-way data binding\n     * ```html\n     * <igx-drop-down-item [(selected)]='model.isSelected'></igx-drop-down-item>\n     * ```\n     */\n\n\n    get selected() {\n      return this._selected;\n    }\n\n    set selected(value) {\n      if (this.isHeader) {\n        return;\n      }\n\n      this._selected = value;\n      this.selectedChange.emit(this._selected);\n    }\n    /**\n     * Sets/gets if the given item is focused\n     * ```typescript\n     *  let mySelectedItem = this.dropdown.selectedItem;\n     *  let isMyItemFocused = mySelectedItem.focused;\n     * ```\n     */\n\n\n    get focused() {\n      return this.isSelectable && this._focused;\n    }\n    /**\n     * ```html\n     *  <igx-drop-down-item *ngFor=\"let item of items\" focused={{!item.focused}}>\n     *      <div>\n     *          {{item.field}}\n     *      </div>\n     *  </igx-drop-down-item>\n     * ```\n     */\n\n\n    set focused(value) {\n      this._focused = value;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get headerClassCosy() {\n      return this.isHeader && this.dropDown.displayDensity === 'cosy';\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get headerClassCompact() {\n      return this.isHeader && this.dropDown.displayDensity === 'compact';\n    }\n    /**\n     * Sets/gets if the given item is disabled\n     *\n     * ```typescript\n     *  // get\n     *  let mySelectedItem = this.dropdown.selectedItem;\n     *  let myItemIsDisabled = mySelectedItem.disabled;\n     * ```\n     *\n     * ```html\n     *  <igx-drop-down-item *ngFor=\"let item of items\" disabled={{!item.disabled}}>\n     *      <div>\n     *          {{item.field}}\n     *      </div>\n     *  </igx-drop-down-item>\n     * ```\n     * **NOTE:** Drop-down items inside of a disabled `IgxDropDownGroup` will always count as disabled\n     */\n\n\n    get disabled() {\n      return this.group ? this.group.disabled || this._disabled : this._disabled;\n    }\n\n    set disabled(value) {\n      this._disabled = value;\n    }\n    /**\n     * Gets item index\n     *\n     * @hidden @internal\n     */\n\n\n    get itemIndex() {\n      return this.dropDown.items.indexOf(this);\n    }\n    /**\n     * Gets item element height\n     *\n     * @hidden @internal\n     */\n\n\n    get elementHeight() {\n      return this.elementRef.nativeElement.clientHeight;\n    }\n    /**\n     * Get item html element\n     *\n     * @hidden @internal\n     */\n\n\n    get element() {\n      return this.elementRef;\n    }\n\n    get hasIndex() {\n      return this._index !== null && this._index !== undefined;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    clicked(event) {}\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    handleMousedown(event) {\n      if (!this.dropDown.allowItemsFocus) {\n        event.preventDefault();\n      }\n    }\n\n    ngDoCheck() {\n      if (this._selected) {\n        const dropDownSelectedItem = this.dropDown.selectedItem;\n\n        if (!dropDownSelectedItem) {\n          this.dropDown.selectItem(this);\n        } else if (this.hasIndex ? this._index !== dropDownSelectedItem.index || this.value !== dropDownSelectedItem.value : this !== dropDownSelectedItem) {\n          this.dropDown.selectItem(this);\n        }\n      }\n    }\n    /** Returns true if the items is not a header or disabled  */\n\n\n    get isSelectable() {\n      return !(this.disabled || this.isHeader);\n    }\n    /** If `allowItemsFocus` is enabled, keep the browser focus on the active item */\n\n\n    ensureItemFocus() {\n      if (this.dropDown.allowItemsFocus) {\n        const focusedItem = this.dropDown.items.find(item => item.focused);\n\n        if (!focusedItem) {\n          return;\n        }\n\n        focusedItem.element.nativeElement.focus({\n          preventScroll: true\n        });\n      }\n    }\n\n  }\n\n  IgxDropDownItemBaseDirective.ɵfac = function IgxDropDownItemBaseDirective_Factory(t) {\n    return new (t || IgxDropDownItemBaseDirective)(i0.ɵɵdirectiveInject(IGX_DROPDOWN_BASE), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(IgxDropDownGroupComponent, 8), i0.ɵɵdirectiveInject(IgxSelectionAPIService, 8));\n  };\n\n  IgxDropDownItemBaseDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxDropDownItemBaseDirective,\n    selectors: [[\"\", \"igxDropDownItemBase\", \"\"]],\n    hostVars: 23,\n    hostBindings: function IgxDropDownItemBaseDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function IgxDropDownItemBaseDirective_click_HostBindingHandler($event) {\n          return ctx.clicked($event);\n        })(\"mousedown\", function IgxDropDownItemBaseDirective_mousedown_HostBindingHandler($event) {\n          return ctx.handleMousedown($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id)(\"aria-label\", ctx.ariaLabel)(\"aria-selected\", ctx.selected)(\"aria-disabled\", ctx.disabled)(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"igx-drop-down__item\", ctx.itemStyle)(\"igx-drop-down__item--cosy\", ctx.itemStyleCosy)(\"igx-drop-down__item--compact\", ctx.itemStyleCompact)(\"igx-drop-down__item--selected\", ctx.selected)(\"igx-drop-down__item--focused\", ctx.focused)(\"igx-drop-down__header\", ctx.isHeader)(\"igx-drop-down__header--cosy\", ctx.headerClassCosy)(\"igx-drop-down__header--compact\", ctx.headerClassCompact)(\"igx-drop-down__item--disabled\", ctx.disabled);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      ariaLabel: \"ariaLabel\",\n      index: \"index\",\n      value: \"value\",\n      selected: \"selected\",\n      isHeader: \"isHeader\",\n      disabled: \"disabled\",\n      role: \"role\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\"\n    }\n  });\n  return IgxDropDownItemBaseDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The `<igx-drop-down-item>` is a container intended for row items in\n * a `<igx-drop-down>` container.\n */\n\n\nlet IgxDropDownItemComponent = /*#__PURE__*/(() => {\n  class IgxDropDownItemComponent extends IgxDropDownItemBaseDirective {\n    /**\n     * @inheritdoc\n     */\n    get focused() {\n      let focusedState = this._focused;\n\n      if (this.hasIndex) {\n        const focusedItem = this.selection.first_item(`${this.dropDown.id}-active`);\n        const focusedIndex = focusedItem ? focusedItem.index : -1;\n        focusedState = this._index === focusedIndex;\n      }\n\n      return this.isSelectable && focusedState;\n    }\n    /**\n     * @inheritdoc\n     */\n\n\n    set focused(value) {\n      this._focused = value;\n    }\n    /**\n     * @inheritdoc\n     */\n\n\n    get selected() {\n      if (this.hasIndex) {\n        const item = this.selection.first_item(`${this.dropDown.id}`);\n        return item ? item.index === this._index && item.value === this.value : false;\n      }\n\n      return this._selected;\n    }\n    /**\n     * @inheritdoc\n     */\n\n\n    set selected(value) {\n      if (this.isHeader) {\n        return;\n      }\n\n      this._selected = value;\n      this.selectedChange.emit(this._selected);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get setTabIndex() {\n      const shouldSetTabIndex = this.dropDown.allowItemsFocus && this.isSelectable;\n\n      if (shouldSetTabIndex) {\n        return 0;\n      } else {\n        return null;\n      }\n    }\n    /**\n     * @inheritdoc\n     */\n\n\n    clicked(event) {\n      if (!this.isSelectable) {\n        this.ensureItemFocus();\n        return;\n      }\n\n      if (this.selection) {\n        this.dropDown.selectItem(this, event);\n      }\n    }\n\n  }\n\n  IgxDropDownItemComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxDropDownItemComponent_BaseFactory;\n    return function IgxDropDownItemComponent_Factory(t) {\n      return (ɵIgxDropDownItemComponent_BaseFactory || (ɵIgxDropDownItemComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxDropDownItemComponent)))(t || IgxDropDownItemComponent);\n    };\n  }();\n\n  IgxDropDownItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxDropDownItemComponent,\n    selectors: [[\"igx-drop-down-item\"]],\n    hostVars: 1,\n    hostBindings: function IgxDropDownItemComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabindex\", ctx.setTabIndex);\n      }\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c3,\n    decls: 6,\n    vars: 0,\n    consts: [[1, \"igx-drop-down__content\"], [1, \"igx-drop-down__inner\"]],\n    template: function IgxDropDownItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c2);\n        i0.ɵɵelementStart(0, \"span\", 0);\n        i0.ɵɵprojection(1);\n        i0.ɵɵelementStart(2, \"span\", 1);\n        i0.ɵɵprojection(3, 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵprojection(4, 2);\n        i0.ɵɵprojection(5, 3);\n        i0.ɵɵelementEnd();\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxDropDownItemComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Defines the possible values of the components' display density.\n */\n\n\nconst DisplayDensity = mkenum({\n  comfortable: 'comfortable',\n  cosy: 'cosy',\n  compact: 'compact'\n});\n/**\n * Defines the DisplayDensity DI token.\n */\n\nconst DisplayDensityToken = new InjectionToken('DisplayDensity');\n/**\n * Base class containing all logic required for implementing DisplayDensity.\n */\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\n\nlet DisplayDensityBase = /*#__PURE__*/(() => {\n  class DisplayDensityBase {\n    constructor(displayDensityOptions) {\n      this.displayDensityOptions = displayDensityOptions;\n      this.onDensityChanged = new EventEmitter();\n      this.oldDisplayDensityOptions = {\n        displayDensity: DisplayDensity.comfortable\n      };\n      Object.assign(this.oldDisplayDensityOptions, displayDensityOptions);\n    }\n    /**\n     * Returns the theme of the component.\n     * The default theme is `comfortable`.\n     * Available options are `comfortable`, `cosy`, `compact`.\n     * ```typescript\n     * let componentTheme = this.component.displayDensity;\n     * ```\n     */\n\n\n    get displayDensity() {\n      return this._displayDensity || this.displayDensityOptions && this.displayDensityOptions.displayDensity || DisplayDensity.comfortable;\n    }\n    /**\n     * Sets the theme of the component.\n     */\n\n\n    set displayDensity(val) {\n      const currentDisplayDensity = this._displayDensity;\n      this._displayDensity = val;\n\n      if (currentDisplayDensity !== this._displayDensity) {\n        const densityChangedArgs = {\n          oldDensity: currentDisplayDensity,\n          newDensity: this._displayDensity\n        };\n        this.onDensityChanged.emit(densityChangedArgs);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      this.initialDensity = this._displayDensity;\n    }\n\n    ngDoCheck() {\n      if (!this._displayDensity && this.displayDensityOptions && this.oldDisplayDensityOptions.displayDensity !== this.displayDensityOptions.displayDensity) {\n        const densityChangedArgs = {\n          oldDensity: this.oldDisplayDensityOptions.displayDensity,\n          newDensity: this.displayDensityOptions.displayDensity\n        };\n        this.onDensityChanged.emit(densityChangedArgs);\n        this.oldDisplayDensityOptions = Object.assign(this.oldDisplayDensityOptions, this.displayDensityOptions);\n      }\n    }\n    /**\n     * Given a style class of a component/element returns the modified version of it based\n     * on the current display density.\n     */\n\n\n    getComponentDensityClass(baseStyleClass) {\n      switch (this.displayDensity) {\n        case DisplayDensity.cosy:\n          return `${baseStyleClass}--${DisplayDensity.cosy}`;\n\n        case DisplayDensity.compact:\n          return `${baseStyleClass}--${DisplayDensity.compact}`;\n\n        default:\n          return baseStyleClass;\n      }\n    }\n\n  }\n\n  DisplayDensityBase.ɵfac = function DisplayDensityBase_Factory(t) {\n    return new (t || DisplayDensityBase)(i0.ɵɵdirectiveInject(DisplayDensityToken, 8));\n  };\n\n  DisplayDensityBase.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DisplayDensityBase,\n    selectors: [[\"\", \"igxDisplayDensityBase\", \"\"]],\n    inputs: {\n      displayDensity: \"displayDensity\"\n    },\n    outputs: {\n      onDensityChanged: \"onDensityChanged\"\n    }\n  });\n  return DisplayDensityBase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxDisplayDensityModule = /*#__PURE__*/(() => {\n  class IgxDisplayDensityModule {}\n\n  IgxDisplayDensityModule.ɵfac = function IgxDisplayDensityModule_Factory(t) {\n    return new (t || IgxDisplayDensityModule)();\n  };\n\n  IgxDisplayDensityModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxDisplayDensityModule\n  });\n  IgxDisplayDensityModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return IgxDisplayDensityModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$t = 0;\n/**\n * An abstract class, defining a drop-down component, with:\n * Properties for display styles and classes\n * A collection items of type `IgxDropDownItemBaseDirective`\n * Properties and methods for navigating (highlighting/focusing) items from the collection\n * Properties and methods for selecting items from the collection\n */\n\nlet IgxDropDownBaseDirective = /*#__PURE__*/(() => {\n  class IgxDropDownBaseDirective extends DisplayDensityBase {\n    constructor(elementRef, cdr, _displayDensityOptions) {\n      super(_displayDensityOptions);\n      this.elementRef = elementRef;\n      this.cdr = cdr;\n      this._displayDensityOptions = _displayDensityOptions;\n      /**\n       * Emitted when item selection is changing, before the selection completes\n       *\n       * ```html\n       * <igx-drop-down (selectionChanging)='handleSelection()'></igx-drop-down>\n       * ```\n       */\n\n      this.selectionChanging = new EventEmitter();\n      /**\n       * Gets/Sets the drop down's container max height.\n       *\n       * ```typescript\n       * // get\n       * let maxHeight = this.dropdown.maxHeight;\n       * ```\n       * ```html\n       * <!--set-->\n       * <igx-drop-down [maxHeight]='200px'></igx-drop-down>\n       * ```\n       */\n\n      this.maxHeight = null;\n      /**\n       * @hidden @internal\n       */\n\n      this.cssClass = true;\n      this._focusedItem = null;\n      this._id = `igx-drop-down-${NEXT_ID$t++}`;\n    }\n    /**\n     * Gets/Sets the drop down's id\n     *\n     * ```typescript\n     * // get\n     * let myDropDownCurrentId = this.dropdown.id;\n     * ```\n     * ```html\n     * <!--set-->\n     * <igx-drop-down [id]='newDropDownId'></igx-drop-down>\n     * ```\n     */\n\n\n    get id() {\n      return this._id;\n    }\n\n    set id(value) {\n      this._id = value;\n    }\n    /**\n     * Get all non-header items\n     *\n     * ```typescript\n     * let myDropDownItems = this.dropdown.items;\n     * ```\n     */\n\n\n    get items() {\n      const items = [];\n\n      if (this.children !== undefined) {\n        for (const child of this.children.toArray()) {\n          if (!child.isHeader) {\n            items.push(child);\n          }\n        }\n      }\n\n      return items;\n    }\n    /**\n     * Get all header items\n     *\n     * ```typescript\n     * let myDropDownHeaderItems = this.dropdown.headers;\n     * ```\n     */\n\n\n    get headers() {\n      const headers = [];\n\n      if (this.children !== undefined) {\n        for (const child of this.children.toArray()) {\n          if (child.isHeader) {\n            headers.push(child);\n          }\n        }\n      }\n\n      return headers;\n    }\n    /**\n     * Get dropdown html element\n     *\n     * ```typescript\n     * let myDropDownElement = this.dropdown.element;\n     * ```\n     */\n\n\n    get element() {\n      return this.elementRef.nativeElement;\n    }\n    /**\n     * @hidden @internal\n     * Get dropdown's html element of its scroll container\n     */\n\n\n    get scrollContainer() {\n      return this.element;\n    }\n    /** Keydown Handler */\n\n\n    onItemActionKey(key, event) {\n      switch (key) {\n        case DropDownActionKey.ENTER:\n        case DropDownActionKey.SPACE:\n          this.selectItem(this.focusedItem, event);\n          break;\n\n        case DropDownActionKey.ESCAPE:\n      }\n    }\n    /**\n     * Emits selectionChanging with the target item & event\n     *\n     * @hidden @internal\n     * @param newSelection the item selected\n     * @param event the event that triggered the call\n     */\n\n\n    selectItem(newSelection, event) {\n      this.selectionChanging.emit({\n        newSelection,\n        oldSelection: null,\n        cancel: false\n      });\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get focusedItem() {\n      return this._focusedItem;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    set focusedItem(item) {\n      this._focusedItem = item;\n    }\n    /**\n     * Navigates to the item on the specified index\n     *\n     * @param newIndex number - the index of the item in the `items` collection\n     */\n\n\n    navigateItem(newIndex) {\n      if (newIndex !== -1) {\n        const oldItem = this._focusedItem;\n        const newItem = this.items[newIndex];\n\n        if (oldItem) {\n          oldItem.focused = false;\n        }\n\n        this.focusedItem = newItem;\n        this.scrollToHiddenItem(newItem);\n        this.focusedItem.focused = true;\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    navigateFirst() {\n      this.navigate(Navigate.Down, -1);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    navigateLast() {\n      this.navigate(Navigate.Up, this.items.length);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    navigateNext() {\n      this.navigate(Navigate.Down);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    navigatePrev() {\n      this.navigate(Navigate.Up);\n    }\n\n    scrollToHiddenItem(newItem) {\n      const elementRect = newItem.element.nativeElement.getBoundingClientRect();\n      const parentRect = this.scrollContainer.getBoundingClientRect();\n\n      if (parentRect.top > elementRect.top) {\n        this.scrollContainer.scrollTop -= parentRect.top - elementRect.top;\n      }\n\n      if (parentRect.bottom < elementRect.bottom) {\n        this.scrollContainer.scrollTop += elementRect.bottom - parentRect.bottom;\n      }\n    }\n\n    navigate(direction, currentIndex) {\n      let index = -1;\n\n      if (this._focusedItem) {\n        index = currentIndex ? currentIndex : this.focusedItem.itemIndex;\n      }\n\n      const newIndex = this.getNearestSiblingFocusableItemIndex(index, direction);\n      this.navigateItem(newIndex);\n    }\n\n    getNearestSiblingFocusableItemIndex(startIndex, direction) {\n      let index = startIndex;\n      const items = this.items;\n\n      while (items[index + direction] && items[index + direction].disabled) {\n        index += direction;\n      }\n\n      index += direction;\n\n      if (index >= 0 && index < items.length) {\n        return index;\n      } else {\n        return -1;\n      }\n    }\n\n  }\n\n  IgxDropDownBaseDirective.ɵfac = function IgxDropDownBaseDirective_Factory(t) {\n    return new (t || IgxDropDownBaseDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(DisplayDensityToken, 8));\n  };\n\n  IgxDropDownBaseDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxDropDownBaseDirective,\n    hostVars: 4,\n    hostBindings: function IgxDropDownBaseDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"max-height\", ctx.maxHeight);\n        i0.ɵɵclassProp(\"igx-drop-down\", ctx.cssClass);\n      }\n    },\n    inputs: {\n      width: \"width\",\n      height: \"height\",\n      id: \"id\",\n      maxHeight: \"maxHeight\"\n    },\n    outputs: {\n      selectionChanging: \"selectionChanging\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return IgxDropDownBaseDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxScrollInertiaDirective = /*#__PURE__*/(() => {\n  class IgxScrollInertiaDirective {\n    constructor(element, _zone) {\n      this.element = element;\n      this._zone = _zone;\n      this.wheelStep = 50;\n      this.inertiaStep = 1.5;\n      this.smoothingStep = 1.5;\n      this.smoothingDuration = 0.5;\n      this.swipeToleranceX = 20;\n      this.inertiaDeltaY = 3;\n      this.inertiaDeltaX = 2;\n      this.inertiaDuration = 0.5;\n      this._savedSpeedsX = [];\n      this.baseDeltaMultiplier = 1 / 120;\n      this.firefoxDeltaMultiplier = 1 / 30;\n    }\n\n    ngOnInit() {\n      this._zone.runOutsideAngular(() => {\n        this.parentElement = this.element.nativeElement.parentElement || this.element.nativeElement.parentNode;\n\n        if (!this.parentElement) {\n          return;\n        }\n\n        const targetElem = this.parentElement;\n        targetElem.addEventListener('wheel', this.onWheel.bind(this));\n        targetElem.addEventListener('touchstart', this.onTouchStart.bind(this));\n        targetElem.addEventListener('touchmove', this.onTouchMove.bind(this));\n        targetElem.addEventListener('touchend', this.onTouchEnd.bind(this));\n      });\n    }\n\n    ngOnDestroy() {\n      this._zone.runOutsideAngular(() => {\n        const targetElem = this.parentElement;\n\n        if (!targetElem) {\n          return;\n        }\n\n        targetElem.removeEventListener('wheel', this.onWheel);\n        targetElem.removeEventListener('touchstart', this.onTouchStart);\n        targetElem.removeEventListener('touchmove', this.onTouchMove);\n        targetElem.removeEventListener('touchend', this.onTouchEnd);\n      });\n    }\n    /**\n     * @hidden\n     * Function that is called when scrolling with the mouse wheel or using touchpad\n     */\n\n\n    onWheel(evt) {\n      // if no scrollbar return\n      if (!this.IgxScrollInertiaScrollContainer) {\n        return;\n      } // if ctrl key is pressed and the user want to zoom in/out the page\n\n\n      if (evt.ctrlKey) {\n        return;\n      }\n\n      let scrollDeltaX;\n      let scrollDeltaY;\n      const scrollStep = this.wheelStep;\n      const minWheelStep = 1 / this.wheelStep;\n      const smoothing = this.smoothingDuration !== 0;\n      this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;\n      this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;\n\n      if (evt.wheelDeltaX) {\n        /* Option supported on Chrome, Safari, Opera.\n        /* 120 is default for mousewheel on these browsers. Other values are for trackpads */\n        scrollDeltaX = -evt.wheelDeltaX * this.baseDeltaMultiplier;\n\n        if (-minWheelStep < scrollDeltaX && scrollDeltaX < minWheelStep) {\n          scrollDeltaX = Math.sign(scrollDeltaX) * minWheelStep;\n        }\n      } else if (evt.deltaX) {\n        /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */\n        const deltaScaledX = evt.deltaX * (evt.deltaMode === 0 ? this.firefoxDeltaMultiplier : 1);\n        scrollDeltaX = this.calcAxisCoords(deltaScaledX, -1, 1);\n      }\n      /** Get delta for the Y axis */\n\n\n      if (evt.wheelDeltaY) {\n        /* Option supported on Chrome, Safari, Opera.\n        /* 120 is default for mousewheel on these browsers. Other values are for trackpads */\n        scrollDeltaY = -evt.wheelDeltaY * this.baseDeltaMultiplier;\n\n        if (-minWheelStep < scrollDeltaY && scrollDeltaY < minWheelStep) {\n          scrollDeltaY = Math.sign(scrollDeltaY) * minWheelStep;\n        }\n      } else if (evt.deltaY) {\n        /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */\n        const deltaScaledY = evt.deltaY * (evt.deltaMode === 0 ? this.firefoxDeltaMultiplier : 1);\n        scrollDeltaY = this.calcAxisCoords(deltaScaledY, -1, 1);\n      }\n\n      if (evt.composedPath && this.didChildScroll(evt, scrollDeltaX, scrollDeltaY)) {\n        return;\n      }\n\n      if (scrollDeltaX && this.IgxScrollInertiaDirection === 'horizontal') {\n        const nextLeft = this._startX + scrollDeltaX * scrollStep;\n\n        if (!smoothing) {\n          this._scrollToX(nextLeft);\n        } else {\n          this._smoothWheelScroll(scrollDeltaX);\n        }\n\n        const maxScrollLeft = parseInt(this.IgxScrollInertiaScrollContainer.children[0].style.width, 10);\n\n        if (0 < nextLeft && nextLeft < maxScrollLeft) {\n          // Prevent navigating through pages when scrolling on Mac\n          evt.preventDefault();\n        }\n      } else if (evt.shiftKey && scrollDeltaY && this.IgxScrollInertiaDirection === 'horizontal') {\n        if (!smoothing) {\n          const step = this._startX + scrollDeltaY * scrollStep;\n\n          this._scrollToX(step);\n        } else {\n          this._smoothWheelScroll(scrollDeltaY);\n        }\n      } else if (!evt.shiftKey && scrollDeltaY && this.IgxScrollInertiaDirection === 'vertical') {\n        const nextTop = this._startY + scrollDeltaY * scrollStep;\n\n        if (!smoothing) {\n          this._scrollToY(nextTop);\n        } else {\n          this._smoothWheelScroll(scrollDeltaY);\n        }\n\n        this.preventParentScroll(evt, true, nextTop);\n      }\n    }\n    /**\n     * @hidden\n     * When there is still room to scroll up/down prevent the parent elements from scrolling too.\n     */\n\n\n    preventParentScroll(evt, preventDefault, nextTop = 0) {\n      const curScrollTop = nextTop === 0 ? this.IgxScrollInertiaScrollContainer.scrollTop : nextTop;\n      const maxScrollTop = this.IgxScrollInertiaScrollContainer.children[0].scrollHeight - this.IgxScrollInertiaScrollContainer.offsetHeight;\n\n      if (0 < curScrollTop && curScrollTop < maxScrollTop) {\n        if (preventDefault) {\n          evt.preventDefault();\n        }\n\n        if (evt.stopPropagation) {\n          evt.stopPropagation();\n        }\n      }\n    }\n    /**\n     * @hidden\n     * Checks if the wheel event would have scrolled an element under the display container\n     * in DOM tree so that it can correctly be ignored until that element can no longer be scrolled.\n     */\n\n\n    didChildScroll(evt, scrollDeltaX, scrollDeltaY) {\n      const path = evt.composedPath();\n      let i = 0;\n\n      while (i < path.length && path[i].localName !== 'igx-display-container') {\n        const e = path[i++];\n\n        if (e.scrollHeight > e.clientHeight) {\n          const overflowY = window.getComputedStyle(e)['overflow-y'];\n\n          if (overflowY === 'auto' || overflowY === 'scroll') {\n            if (scrollDeltaY > 0 && e.scrollHeight - Math.abs(Math.round(e.scrollTop)) !== e.clientHeight) {\n              return true;\n            }\n\n            if (scrollDeltaY < 0 && e.scrollTop !== 0) {\n              return true;\n            }\n          }\n        }\n\n        if (e.scrollWidth > e.clientWidth) {\n          const overflowX = window.getComputedStyle(e)['overflow-x'];\n\n          if (overflowX === 'auto' || overflowX === 'scroll') {\n            if (scrollDeltaX > 0 && e.scrollWidth - Math.abs(Math.round(e.scrollLeft)) !== e.clientWidth) {\n              return true;\n            }\n\n            if (scrollDeltaX < 0 && e.scrollLeft !== 0) {\n              return true;\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n    /**\n     * @hidden\n     * Function that is called the first moment we start interacting with the content on a touch device\n     */\n\n\n    onTouchStart(event) {\n      if (!this.IgxScrollInertiaScrollContainer) {\n        return false;\n      } // stops any current ongoing inertia\n\n\n      cancelAnimationFrame(this._touchInertiaAnimID);\n      const touch = event.touches[0];\n      this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;\n      this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;\n      this._touchStartX = touch.pageX;\n      this._touchStartY = touch.pageY;\n      this._lastTouchEnd = new Date().getTime();\n      this._lastTouchX = touch.pageX;\n      this._lastTouchY = touch.pageY;\n      this._savedSpeedsX = [];\n      this._savedSpeedsY = []; // Vars regarding swipe offset\n\n      this._totalMovedX = 0;\n      this._offsetRecorded = false;\n      this._offsetDirection = 0;\n\n      if (this.IgxScrollInertiaDirection === 'vertical') {\n        this.preventParentScroll(event, false);\n      }\n    }\n    /**\n     * @hidden\n     * Function that is called when we need to scroll the content based on touch interactions\n     */\n\n\n    onTouchMove(event) {\n      if (!this.IgxScrollInertiaScrollContainer) {\n        return;\n      }\n\n      const touch = event.touches[0];\n      const destX = this._startX + (this._touchStartX - touch.pageX) * Math.sign(this.inertiaStep);\n      const destY = this._startY + (this._touchStartY - touch.pageY) * Math.sign(this.inertiaStep);\n      /* Handle complex touchmoves when swipe stops but the toch doesn't end and then a swipe is initiated again */\n\n      /* **********************************************************/\n\n      const timeFromLastTouch = new Date().getTime() - this._lastTouchEnd;\n\n      if (timeFromLastTouch !== 0 && timeFromLastTouch < 100) {\n        const speedX = (this._lastTouchX - touch.pageX) / timeFromLastTouch;\n        const speedY = (this._lastTouchY - touch.pageY) / timeFromLastTouch; // Save the last 5 speeds between two touchmoves on X axis\n\n        if (this._savedSpeedsX.length < 5) {\n          this._savedSpeedsX.push(speedX);\n        } else {\n          this._savedSpeedsX.shift();\n\n          this._savedSpeedsX.push(speedX);\n        } // Save the last 5 speeds between two touchmoves on Y axis\n\n\n        if (this._savedSpeedsY.length < 5) {\n          this._savedSpeedsY.push(speedY);\n        } else {\n          this._savedSpeedsY.shift();\n\n          this._savedSpeedsY.push(speedY);\n        }\n      }\n\n      this._lastTouchEnd = new Date().getTime();\n      this._lastMovedX = this._lastTouchX - touch.pageX;\n      this._lastMovedY = this._lastTouchY - touch.pageY;\n      this._lastTouchX = touch.pageX;\n      this._lastTouchY = touch.pageY;\n      this._totalMovedX += this._lastMovedX;\n      /*\tDo not scroll using touch untill out of the swipeToleranceX bounds */\n\n      if (Math.abs(this._totalMovedX) < this.swipeToleranceX && !this._offsetRecorded) {\n        this._scrollTo(this._startX, destY);\n      } else {\n        /*\tRecord the direction the first time we are out of the swipeToleranceX bounds.\n        *\tThat way we know which direction we apply the offset so it doesn't hickup when moving out of the swipeToleranceX bounds */\n        if (!this._offsetRecorded) {\n          this._offsetDirection = Math.sign(destX - this._startX);\n          this._offsetRecorded = true;\n        }\n        /*\tScroll with offset ammout of swipeToleranceX in the direction we have exited the bounds and\n        don't change it after that ever until touchend and again touchstart */\n\n\n        this._scrollTo(destX - this._offsetDirection * this.swipeToleranceX, destY);\n      } // On Safari preventing the touchmove would prevent default page scroll behaviour even if there is the element doesn't have overflow\n\n\n      if (this.IgxScrollInertiaDirection === 'vertical') {\n        this.preventParentScroll(event, true);\n      }\n    }\n\n    onTouchEnd(event) {\n      let speedX = 0;\n      let speedY = 0; // savedSpeedsX and savedSpeedsY have same length\n\n      for (let i = 0; i < this._savedSpeedsX.length; i++) {\n        speedX += this._savedSpeedsX[i];\n        speedY += this._savedSpeedsY[i];\n      }\n\n      speedX = this._savedSpeedsX.length ? speedX / this._savedSpeedsX.length : 0;\n      speedY = this._savedSpeedsX.length ? speedY / this._savedSpeedsY.length : 0; // Use the lastMovedX and lastMovedY to determine if the swipe stops without lifting the finger so we don't start inertia\n\n      if ((Math.abs(speedX) > 0.1 || Math.abs(speedY) > 0.1) && (Math.abs(this._lastMovedX) > 2 || Math.abs(this._lastMovedY) > 2)) {\n        this._inertiaInit(speedX, speedY);\n      }\n\n      if (this.IgxScrollInertiaDirection === 'vertical') {\n        this.preventParentScroll(event, false);\n      }\n    }\n\n    _smoothWheelScroll(delta) {\n      this._nextY = this.IgxScrollInertiaScrollContainer.scrollTop;\n      this._nextX = this.IgxScrollInertiaScrollContainer.scrollLeft;\n      let x = -1;\n      let wheelInertialAnimation = null;\n\n      const inertiaWheelStep = () => {\n        if (x > 1) {\n          cancelAnimationFrame(wheelInertialAnimation);\n          return;\n        }\n\n        const nextScroll = (-3 * x * x + 3) * delta * 2 * this.smoothingStep;\n\n        if (this.IgxScrollInertiaDirection === 'vertical') {\n          this._nextY += nextScroll;\n\n          this._scrollToY(this._nextY);\n        } else {\n          this._nextX += nextScroll;\n\n          this._scrollToX(this._nextX);\n        } //continue the inertia\n\n\n        x += 0.08 * (1 / this.smoothingDuration);\n        wheelInertialAnimation = requestAnimationFrame(inertiaWheelStep);\n      };\n\n      wheelInertialAnimation = requestAnimationFrame(inertiaWheelStep);\n    }\n\n    _inertiaInit(speedX, speedY) {\n      const stepModifer = this.inertiaStep;\n      const inertiaDuration = this.inertiaDuration;\n      let x = 0;\n      this._nextX = this.IgxScrollInertiaScrollContainer.scrollLeft;\n      this._nextY = this.IgxScrollInertiaScrollContainer.scrollTop; // Sets timeout until executing next movement iteration of the inertia\n\n      const inertiaStep = () => {\n        if (x > 6) {\n          cancelAnimationFrame(this._touchInertiaAnimID);\n          return;\n        }\n\n        if (Math.abs(speedX) > Math.abs(speedY)) {\n          x += 0.05 / (1 * inertiaDuration);\n        } else {\n          x += 0.05 / (1 * inertiaDuration);\n        }\n\n        if (x <= 1) {\n          // We use constant quation to determine the offset without speed falloff befor x reaches 1\n          if (Math.abs(speedY) <= Math.abs(speedX) * this.inertiaDeltaY) {\n            this._nextX += 1 * speedX * 15 * stepModifer;\n          }\n\n          if (Math.abs(speedY) >= Math.abs(speedX) * this.inertiaDeltaX) {\n            this._nextY += 1 * speedY * 15 * stepModifer;\n          }\n        } else {\n          // We use the quation \"y = 2 / (x + 0.55) - 0.3\" to determine the offset\n          if (Math.abs(speedY) <= Math.abs(speedX) * this.inertiaDeltaY) {\n            this._nextX += Math.abs(2 / (x + 0.55) - 0.3) * speedX * 15 * stepModifer;\n          }\n\n          if (Math.abs(speedY) >= Math.abs(speedX) * this.inertiaDeltaX) {\n            this._nextY += Math.abs(2 / (x + 0.55) - 0.3) * speedY * 15 * stepModifer;\n          }\n        } // If we have mixed environment we use the default behaviour. i.e. touchscreen + mouse\n\n\n        this._scrollTo(this._nextX, this._nextY);\n\n        this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);\n      }; // Start inertia and continue it recursively\n\n\n      this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);\n    }\n\n    calcAxisCoords(target, min, max) {\n      if (target === undefined || target < min) {\n        target = min;\n      } else if (target > max) {\n        target = max;\n      }\n\n      return target;\n    }\n\n    _scrollTo(destX, destY) {\n      // TODO Trigger scrolling event?\n      const scrolledX = this._scrollToX(destX);\n\n      const scrolledY = this._scrollToY(destY);\n\n      return {\n        x: scrolledX,\n        y: scrolledY\n      };\n    }\n\n    _scrollToX(dest) {\n      this.IgxScrollInertiaScrollContainer.scrollLeft = dest;\n    }\n\n    _scrollToY(dest) {\n      this.IgxScrollInertiaScrollContainer.scrollTop = dest;\n    }\n\n  }\n\n  IgxScrollInertiaDirective.ɵfac = function IgxScrollInertiaDirective_Factory(t) {\n    return new (t || IgxScrollInertiaDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  IgxScrollInertiaDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxScrollInertiaDirective,\n    selectors: [[\"\", \"igxScrollInertia\", \"\"]],\n    inputs: {\n      IgxScrollInertiaDirection: \"IgxScrollInertiaDirection\",\n      IgxScrollInertiaScrollContainer: \"IgxScrollInertiaScrollContainer\",\n      wheelStep: \"wheelStep\",\n      inertiaStep: \"inertiaStep\",\n      smoothingStep: \"smoothingStep\",\n      smoothingDuration: \"smoothingDuration\",\n      swipeToleranceX: \"swipeToleranceX\",\n      inertiaDeltaY: \"inertiaDeltaY\",\n      inertiaDeltaX: \"inertiaDeltaX\",\n      inertiaDuration: \"inertiaDuration\"\n    }\n  });\n  return IgxScrollInertiaDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxScrollInertiaModule = /*#__PURE__*/(() => {\n  class IgxScrollInertiaModule {}\n\n  IgxScrollInertiaModule.ɵfac = function IgxScrollInertiaModule_Factory(t) {\n    return new (t || IgxScrollInertiaModule)();\n  };\n\n  IgxScrollInertiaModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxScrollInertiaModule\n  });\n  IgxScrollInertiaModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return IgxScrollInertiaModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DisplayContainerComponent = /*#__PURE__*/(() => {\n  class DisplayContainerComponent {\n    constructor(cdr, _viewContainer) {\n      this.cdr = cdr;\n      this._viewContainer = _viewContainer;\n      this.cssClass = 'igx-display-container';\n      this.notVirtual = true;\n    }\n\n  }\n\n  DisplayContainerComponent.ɵfac = function DisplayContainerComponent_Factory(t) {\n    return new (t || DisplayContainerComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  };\n\n  DisplayContainerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DisplayContainerComponent,\n    selectors: [[\"igx-display-container\"]],\n    viewQuery: function DisplayContainerComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c4, 7, ViewContainerRef);\n        i0.ɵɵviewQuery(_c4, 7, IgxScrollInertiaDirective);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._vcr = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._scrollInertia = _t.first);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function DisplayContainerComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.cssClass);\n        i0.ɵɵclassProp(\"igx-display-container--inactive\", ctx.notVirtual);\n      }\n    },\n    decls: 2,\n    vars: 2,\n    consts: [[\"igxScrollInertia\", \"\", 3, \"IgxScrollInertiaScrollContainer\", \"IgxScrollInertiaDirection\"], [\"display_container\", \"\"]],\n    template: function DisplayContainerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, DisplayContainerComponent_ng_template_0_Template, 0, 0, \"ng-template\", 0, 1, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"IgxScrollInertiaScrollContainer\", ctx.scrollContainer)(\"IgxScrollInertiaDirection\", ctx.scrollDirection);\n      }\n    },\n    directives: [IgxScrollInertiaDirective],\n    encapsulation: 2\n  });\n  return DisplayContainerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VirtualHelperBaseDirective = /*#__PURE__*/(() => {\n  class VirtualHelperBaseDirective {\n    constructor(elementRef, cdr, _zone, document, platformUtil) {\n      this.elementRef = elementRef;\n      this.cdr = cdr;\n      this._zone = _zone;\n      this.document = document;\n      this.platformUtil = platformUtil;\n      this.scrollAmount = 0;\n      this._size = 0;\n      this.destroy$ = new Subject();\n      this._afterViewInit = false;\n      this._detached = false;\n      this._scrollNativeSize = this.calculateScrollNativeSize();\n    }\n\n    onScroll(event) {\n      this.scrollAmount = event.target.scrollTop || event.target.scrollLeft;\n    }\n\n    ngAfterViewInit() {\n      this._afterViewInit = true;\n\n      if (!this.platformUtil.isBrowser) {\n        return;\n      }\n\n      const delayTime = 0;\n\n      this._zone.runOutsideAngular(() => {\n        resizeObservable(this.nativeElement).pipe(throttleTime(delayTime), takeUntil(this.destroy$)).subscribe(event => this.handleMutations(event));\n      });\n    }\n\n    get nativeElement() {\n      return this.elementRef.nativeElement;\n    }\n\n    ngOnDestroy() {\n      this.destroyed = true;\n      this.destroy$.next(true);\n      this.destroy$.complete();\n    }\n\n    calculateScrollNativeSize() {\n      const div = this.document.createElement('div');\n      const style = div.style;\n      style.width = '100px';\n      style.height = '100px';\n      style.position = 'absolute';\n      style.top = '-10000px';\n      style.top = '-10000px';\n      style.overflow = 'scroll';\n      this.document.body.appendChild(div);\n      const scrollWidth = div.offsetWidth - div.clientWidth;\n      this.document.body.removeChild(div);\n      return scrollWidth ? scrollWidth + 1 : 1;\n    }\n\n    set size(value) {\n      if (this.destroyed) {\n        return;\n      }\n\n      this._size = value;\n\n      if (this._afterViewInit) {\n        this.cdr.detectChanges();\n      }\n    }\n\n    get size() {\n      return this._size;\n    }\n\n    get scrollNativeSize() {\n      return this._scrollNativeSize;\n    }\n\n    get isAttachedToDom() {\n      return this.document.body.contains(this.nativeElement);\n    }\n\n    handleMutations(event) {\n      const hasSize = !(event[0].contentRect.height === 0 && event[0].contentRect.width === 0);\n\n      if (!hasSize && !this.isAttachedToDom) {\n        // scroll bar detached from DOM\n        this._detached = true;\n      } else if (this._detached && hasSize && this.isAttachedToDom) {\n        // attached back now.\n        this.restoreScroll();\n      }\n    }\n\n    restoreScroll() {}\n\n  }\n\n  VirtualHelperBaseDirective.ɵfac = function VirtualHelperBaseDirective_Factory(t) {\n    return new (t || VirtualHelperBaseDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  VirtualHelperBaseDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: VirtualHelperBaseDirective,\n    selectors: [[\"\", \"igxVirtualHelperBase\", \"\"]],\n    hostBindings: function VirtualHelperBaseDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"scroll\", function VirtualHelperBaseDirective_scroll_HostBindingHandler($event) {\n          return ctx.onScroll($event);\n        });\n      }\n    }\n  });\n  return VirtualHelperBaseDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet HVirtualHelperComponent = /*#__PURE__*/(() => {\n  class HVirtualHelperComponent extends VirtualHelperBaseDirective {\n    constructor(elementRef, cdr, zone, document, platformUtil) {\n      super(elementRef, cdr, zone, document, platformUtil);\n      this.cssClasses = 'igx-vhelper--horizontal';\n    }\n\n    restoreScroll() {\n      this.nativeElement.scrollLeft = this.scrollAmount;\n    }\n\n  }\n\n  HVirtualHelperComponent.ɵfac = function HVirtualHelperComponent_Factory(t) {\n    return new (t || HVirtualHelperComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  HVirtualHelperComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: HVirtualHelperComponent,\n    selectors: [[\"igx-horizontal-virtual-helper\"]],\n    viewQuery: function HVirtualHelperComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c5, 7, ViewContainerRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._vcr = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function HVirtualHelperComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.cssClasses);\n      }\n    },\n    inputs: {\n      width: \"width\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 2,\n    vars: 2,\n    consts: [[1, \"igx-vhelper__placeholder-content\"], [\"horizontal_container\", \"\"]],\n    template: function HVirtualHelperComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0, 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"width\", ctx.size, \"px\");\n      }\n    },\n    encapsulation: 2\n  });\n  return HVirtualHelperComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VirtualHelperComponent = /*#__PURE__*/(() => {\n  class VirtualHelperComponent extends VirtualHelperBaseDirective {\n    constructor(elementRef, cdr, zone, document, platformUtil) {\n      super(elementRef, cdr, zone, document, platformUtil);\n      this.cssClasses = 'igx-vhelper--vertical';\n    }\n\n    ngOnInit() {\n      this.scrollWidth = this.scrollNativeSize;\n    }\n\n    restoreScroll() {\n      this.nativeElement.scrollTop = this.scrollAmount;\n    }\n\n  }\n\n  VirtualHelperComponent.ɵfac = function VirtualHelperComponent_Factory(t) {\n    return new (t || VirtualHelperComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  VirtualHelperComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: VirtualHelperComponent,\n    selectors: [[\"igx-virtual-helper\"]],\n    viewQuery: function VirtualHelperComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c6, 7, ViewContainerRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._vcr = _t.first);\n      }\n    },\n    hostVars: 5,\n    hostBindings: function VirtualHelperComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵhostProperty(\"scrollTop\", ctx.scrollTop);\n        i0.ɵɵclassMap(ctx.cssClasses);\n        i0.ɵɵstyleProp(\"width\", ctx.scrollWidth, \"px\");\n      }\n    },\n    inputs: {\n      itemsLength: \"itemsLength\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 2,\n    vars: 2,\n    consts: [[1, \"igx-vhelper__placeholder-content\"], [\"container\", \"\"]],\n    template: function VirtualHelperComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0, 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"height\", ctx.size, \"px\");\n      }\n    },\n    encapsulation: 2\n  });\n  return VirtualHelperComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxForOfSyncService = /*#__PURE__*/(() => {\n  class IgxForOfSyncService {\n    constructor() {\n      this._master = new Map();\n    }\n    /**\n     * @hidden\n     */\n\n\n    isMaster(directive) {\n      return this._master.get(directive.igxForScrollOrientation) === directive;\n    }\n    /**\n     * @hidden\n     */\n\n\n    setMaster(directive, forced = false) {\n      const orientation = directive.igxForScrollOrientation;\n\n      if (orientation && (forced || !this._master.has(orientation))) {\n        this._master.set(orientation, directive);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    resetMaster() {\n      this._master.clear();\n    }\n    /**\n     * @hidden\n     */\n\n\n    sizesCache(dir) {\n      return this._master.get(dir).sizesCache;\n    }\n    /**\n     * @hidden\n     */\n\n\n    chunkSize(dir) {\n      return this._master.get(dir).state.chunkSize;\n    }\n\n  }\n\n  IgxForOfSyncService.ɵfac = function IgxForOfSyncService_Factory(t) {\n    return new (t || IgxForOfSyncService)();\n  };\n\n  IgxForOfSyncService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxForOfSyncService,\n    factory: IgxForOfSyncService.ɵfac,\n    providedIn: 'root'\n  });\n  return IgxForOfSyncService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxForOfScrollSyncService = /*#__PURE__*/(() => {\n  class IgxForOfScrollSyncService {\n    constructor() {\n      this._masterScroll = new Map();\n    }\n\n    setScrollMaster(dir, scroll) {\n      this._masterScroll.set(dir, scroll);\n    }\n\n    getScrollMaster(dir) {\n      return this._masterScroll.get(dir);\n    }\n\n  }\n\n  IgxForOfScrollSyncService.ɵfac = function IgxForOfScrollSyncService_Factory(t) {\n    return new (t || IgxForOfScrollSyncService)();\n  };\n\n  IgxForOfScrollSyncService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxForOfScrollSyncService,\n    factory: IgxForOfScrollSyncService.ɵfac,\n    providedIn: 'root'\n  });\n  return IgxForOfScrollSyncService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/* eslint-disable @angular-eslint/no-conflicting-lifecycle */\n\n\nconst MAX_PERF_SCROLL_DIFF = 4;\n/**\n *  @publicApi\n */\n\nclass IgxForOfContext {\n  constructor($implicit, index, count) {\n    this.$implicit = $implicit;\n    this.index = index;\n    this.count = count;\n  }\n  /**\n   * A function that returns whether the element is the first or not\n   */\n\n\n  get first() {\n    return this.index === 0;\n  }\n  /**\n   * A function that returns whether the element is the last or not\n   */\n\n\n  get last() {\n    return this.index === this.count - 1;\n  }\n  /**\n   * A function that returns whether the element is even or not\n   */\n\n\n  get even() {\n    return this.index % 2 === 0;\n  }\n  /**\n   * A function that returns whether the element is odd or not\n   */\n\n\n  get odd() {\n    return !this.even;\n  }\n\n} // eslint-disable @angular-eslint/no-conflicting-lifecycle\n\n\nlet IgxForOfDirective = /*#__PURE__*/(() => {\n  class IgxForOfDirective {\n    constructor(_viewContainer, _template, _differs, cdr, _zone, syncScrollService, platformUtil, document) {\n      this._viewContainer = _viewContainer;\n      this._template = _template;\n      this._differs = _differs;\n      this.cdr = cdr;\n      this._zone = _zone;\n      this.syncScrollService = syncScrollService;\n      this.platformUtil = platformUtil;\n      this.document = document;\n      /**\n       * An @Input property that specifies the scroll orientation.\n       * Scroll orientation can be \"vertical\" or \"horizontal\".\n       * ```html\n       * <ng-template igxFor let-item [igxForOf]=\"data\" [igxForScrollOrientation]=\"'horizontal'\"></ng-template>\n       * ```\n       */\n\n      this.igxForScrollOrientation = 'vertical';\n      /**\n       * An event that is emitted after a new chunk has been loaded.\n       * ```html\n       * <ng-template igxFor [igxForOf]=\"data\" [igxForScrollOrientation]=\"'horizontal'\" (chunkLoad)=\"loadChunk($event)\"></ng-template>\n       * ```\n       * ```typescript\n       * loadChunk(e){\n       * alert(\"chunk loaded!\");\n       * }\n       * ```\n       */\n\n      this.chunkLoad = new EventEmitter();\n      /**\n       * @hidden @internal\n       * An event that is emitted when scrollbar visibility has changed.\n       */\n\n      this.scrollbarVisibilityChanged = new EventEmitter();\n      /**\n       * An event that is emitted after the rendered content size of the igxForOf has been changed.\n       */\n\n      this.contentSizeChange = new EventEmitter();\n      /**\n       * An event that is emitted after data has been changed.\n       * ```html\n       * <ng-template igxFor [igxForOf]=\"data\" [igxForScrollOrientation]=\"'horizontal'\" (dataChanged)=\"dataChanged($event)\"></ng-template>\n       * ```\n       * ```typescript\n       * dataChanged(e){\n       * alert(\"data changed!\");\n       * }\n       * ```\n       */\n\n      this.dataChanged = new EventEmitter();\n      this.beforeViewDestroyed = new EventEmitter();\n      /**\n       * An event that is emitted on chunk loading to emit the current state information - startIndex, endIndex, totalCount.\n       * Can be used for implementing remote load on demand for the igxFor data.\n       * ```html\n       * <ng-template igxFor [igxForOf]=\"data\" [igxForScrollOrientation]=\"'horizontal'\" (chunkPreload)=\"chunkPreload($event)\"></ng-template>\n       * ```\n       * ```typescript\n       * chunkPreload(e){\n       * alert(\"chunk is loading!\");\n       * }\n       * ```\n       */\n\n      this.chunkPreload = new EventEmitter();\n      /**\n       * The current state of the directive. It contains `startIndex` and `chunkSize`.\n       * state.startIndex - The index of the item at which the current visible chunk begins.\n       * state.chunkSize - The number of items the current visible chunk holds.\n       * These options can be used when implementing remote virtualization as they provide the necessary state information.\n       * ```typescript\n       * const gridState = this.parentVirtDir.state;\n       * ```\n       */\n\n      this.state = {\n        startIndex: 0,\n        chunkSize: 0\n      };\n      this._sizesCache = [];\n      this._differ = null;\n      this.heightCache = [];\n      /** Internal track for scroll top that is being virtualized */\n\n      this._virtScrollTop = 0;\n      /** If the next onScroll event is triggered due to internal setting of scrollTop */\n\n      this._bScrollInternal = false; // End properties related to virtual height handling\n\n      this._embeddedViews = [];\n      this.contentResizeNotify = new Subject();\n      /** Height that is being virtualized. */\n\n      this._virtHeight = 0;\n      /**\n       * @hidden\n       */\n\n      this.destroy$ = new Subject();\n      this._totalItemCount = null;\n      /**\n       * Ratio for height that's being virtualizaed and the one visible\n       * If _virtHeightRatio = 1, the visible height and the virtualized are the same, also _maxHeight > _virtHeight.\n       */\n\n      this._virtHeightRatio = 1;\n    }\n    /**\n     * The total count of the virtual data items, when using remote service.\n     * Similar to the property totalItemCount, but this will allow setting the data count into the template.\n     * ```html\n     * <ng-template igxFor let-item [igxForOf]=\"data | async\" [igxForTotalItemCount]=\"count | async\"\n     *  [igxForContainerSize]=\"'500px'\" [igxForItemSize]=\"'50px'\"></ng-template>\n     * ```\n     */\n\n\n    get igxForTotalItemCount() {\n      return this.totalItemCount;\n    }\n\n    set igxForTotalItemCount(value) {\n      this.totalItemCount = value;\n    }\n    /**\n     * The total count of the virtual data items, when using remote service.\n     * ```typescript\n     * this.parentVirtDir.totalItemCount = data.Count;\n     * ```\n     */\n\n\n    get totalItemCount() {\n      return this._totalItemCount;\n    }\n\n    set totalItemCount(val) {\n      if (this._totalItemCount !== val) {\n        this._totalItemCount = val; // update sizes in case total count changes.\n\n        const newSize = this.initSizesCache(this.igxForOf);\n        const sizeDiff = this.scrollComponent.size - newSize;\n        this.scrollComponent.size = newSize;\n        const lastChunkExceeded = this.state.startIndex + this.state.chunkSize > val;\n\n        if (lastChunkExceeded) {\n          this.state.startIndex = val - this.state.chunkSize;\n        }\n\n        this._adjustScrollPositionAfterSizeChange(sizeDiff);\n      }\n    }\n\n    get displayContainer() {\n      var _a, _b, _c, _d;\n\n      return (_d = (_c = (_b = (_a = this.dc) === null || _a === void 0 ? void 0 : _a.instance) === null || _b === void 0 ? void 0 : _b._viewContainer) === null || _c === void 0 ? void 0 : _c.element) === null || _d === void 0 ? void 0 : _d.nativeElement;\n    }\n\n    get virtualHelper() {\n      return this.scrollComponent.nativeElement;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isRemote() {\n      return this.totalItemCount !== null;\n    }\n    /**\n     *\n     * Gets/Sets the scroll position.\n     * ```typescript\n     * const position = directive.scrollPosition;\n     * directive.scrollPosition = value;\n     * ```\n     */\n\n\n    get scrollPosition() {\n      return this.scrollComponent.scrollAmount;\n    }\n\n    set scrollPosition(val) {\n      if (val === this.scrollComponent.scrollAmount) {\n        return;\n      }\n\n      if (this.igxForScrollOrientation === 'horizontal' && this.scrollComponent) {\n        this.scrollComponent.nativeElement.scrollLeft = val;\n      } else if (this.scrollComponent) {\n        this.scrollComponent.nativeElement.scrollTop = val;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isRTL() {\n      const dir = window.getComputedStyle(this.dc.instance._viewContainer.element.nativeElement).getPropertyValue('direction');\n      return dir === 'rtl';\n    }\n\n    get sizesCache() {\n      return this._sizesCache;\n    }\n\n    set sizesCache(value) {\n      this._sizesCache = value;\n    }\n\n    get _isScrolledToBottom() {\n      if (!this.getScroll()) {\n        return true;\n      }\n\n      const scrollHeight = this.getScroll().scrollHeight; // Use === and not >= because `scrollTop + container size` can't be bigger than `scrollHeight`, unless something isn't updated.\n      // Also use Math.round because Chrome has some inconsistencies and `scrollTop + container` can be float when zooming the page.\n\n      return Math.round(this.getScroll().scrollTop + this.igxForContainerSize) === scrollHeight;\n    }\n\n    get _isAtBottomIndex() {\n      return this.igxForOf && this.state.startIndex + this.state.chunkSize > this.igxForOf.length;\n    }\n\n    verticalScrollHandler(event) {\n      this.onScroll(event);\n    }\n\n    isScrollable() {\n      return this.scrollComponent.size > parseInt(this.igxForContainerSize, 10);\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      let totalSize = 0;\n      const vc = this.igxForScrollContainer ? this.igxForScrollContainer._viewContainer : this._viewContainer;\n      this.igxForSizePropName = this.igxForSizePropName || 'width';\n      this.dc = this._viewContainer.createComponent(DisplayContainerComponent, {\n        index: 0\n      });\n      this.dc.instance.scrollDirection = this.igxForScrollOrientation;\n\n      if (this.igxForOf && this.igxForOf.length) {\n        totalSize = this.initSizesCache(this.igxForOf);\n        this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);\n        this.state.chunkSize = this._calculateChunkSize();\n        this.dc.instance.notVirtual = !(this.igxForContainerSize && this.state.chunkSize < this.igxForOf.length);\n\n        if (this.scrollComponent && !this.scrollComponent.destroyed) {\n          this.state.startIndex = Math.min(this.getIndexAt(this.scrollPosition, this.sizesCache), this.igxForOf.length - this.state.chunkSize);\n        }\n\n        for (let i = this.state.startIndex; i < this.state.startIndex + this.state.chunkSize && this.igxForOf[i] !== undefined; i++) {\n          const input = this.igxForOf[i];\n\n          const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));\n\n          this._embeddedViews.push(embeddedView);\n        }\n      }\n\n      if (this.igxForScrollOrientation === 'vertical') {\n        this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';\n        this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);\n\n        if (!this.scrollComponent || this.scrollComponent.destroyed) {\n          this.scrollComponent = vc.createComponent(VirtualHelperComponent).instance;\n        }\n\n        this._maxHeight = this._calcMaxBrowserHeight();\n        this.scrollComponent.size = this.igxForOf ? this._calcHeight() : 0;\n        this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);\n\n        this._zone.runOutsideAngular(() => {\n          this.verticalScrollHandler = this.verticalScrollHandler.bind(this);\n          this.scrollComponent.nativeElement.addEventListener('scroll', this.verticalScrollHandler);\n          this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;\n        });\n\n        const destructor = takeUntil(this.destroy$);\n        this.contentResizeNotify.pipe(filter(() => this.igxForContainerSize && this.igxForOf && this.igxForOf.length > 0), throttleTime(40, undefined, {\n          leading: true,\n          trailing: true\n        }), destructor).subscribe(() => this._zone.runTask(() => this.updateSizes()));\n      }\n\n      if (this.igxForScrollOrientation === 'horizontal') {\n        this.func = evt => this.onHScroll(evt);\n\n        this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);\n\n        if (!this.scrollComponent) {\n          this.scrollComponent = vc.createComponent(HVirtualHelperComponent).instance;\n          this.scrollComponent.size = totalSize;\n          this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);\n\n          this._zone.runOutsideAngular(() => {\n            this.scrollComponent.nativeElement.addEventListener('scroll', this.func);\n            this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;\n          });\n        } else {\n          this._zone.runOutsideAngular(() => {\n            this.scrollComponent.nativeElement.addEventListener('scroll', this.func);\n            this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;\n          });\n        }\n\n        this._updateHScrollOffset();\n      }\n    }\n\n    ngAfterViewInit() {\n      if (this.igxForScrollOrientation === 'vertical') {\n        this._zone.runOutsideAngular(() => {\n          this.contentObserver = new (getResizeObserver())(() => this.contentResizeNotify.next());\n          this.contentObserver.observe(this.dc.instance._viewContainer.element.nativeElement);\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      this.removeScrollEventListeners();\n      this.destroy$.next(true);\n      this.destroy$.complete();\n\n      if (this.contentObserver) {\n        this.contentObserver.disconnect();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnChanges(changes) {\n      const forOf = 'igxForOf';\n\n      if (forOf in changes) {\n        const value = changes[forOf].currentValue;\n\n        if (!this._differ && value) {\n          try {\n            this._differ = this._differs.find(value).create(this.igxForTrackBy);\n          } catch (e) {\n            throw new Error(`Cannot find a differ supporting object \"${value}\" of type \"${getTypeNameForDebugging(value)}\".\n                     NgFor only supports binding to Iterables such as Arrays.`);\n          }\n        }\n      }\n\n      const defaultItemSize = 'igxForItemSize';\n\n      if (defaultItemSize in changes && !changes[defaultItemSize].firstChange && this.igxForScrollOrientation === 'vertical' && this.igxForOf) {\n        // handle default item size changed.\n        this.initSizesCache(this.igxForOf);\n\n        this._applyChanges();\n      }\n\n      const containerSize = 'igxForContainerSize';\n\n      if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {\n        this._recalcOnContainerChange();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngDoCheck() {\n      if (this._differ) {\n        const changes = this._differ.diff(this.igxForOf);\n\n        if (changes) {\n          //  re-init cache.\n          if (!this.igxForOf) {\n            this.igxForOf = [];\n          }\n\n          this._updateSizeCache();\n\n          this._zone.run(() => {\n            this._applyChanges();\n\n            this.cdr.markForCheck();\n\n            this._updateScrollOffset();\n\n            this.dataChanged.emit();\n          });\n        }\n      }\n    }\n    /**\n     * Shifts the scroll thumb position.\n     * ```typescript\n     * this.parentVirtDir.addScrollTop(5);\n     * ```\n     *\n     * @param addTop negative value to scroll up and positive to scroll down;\n     */\n\n\n    addScrollTop(addTop) {\n      if (addTop === 0 && this.igxForScrollOrientation === 'horizontal') {\n        return false;\n      }\n\n      const originalVirtScrollTop = this._virtScrollTop;\n      const containerSize = parseInt(this.igxForContainerSize, 10);\n      const maxVirtScrollTop = this._virtHeight - containerSize;\n      this._bScrollInternal = true;\n      this._virtScrollTop += addTop;\n      this._virtScrollTop = this._virtScrollTop > 0 ? this._virtScrollTop < maxVirtScrollTop ? this._virtScrollTop : maxVirtScrollTop : 0;\n      this.scrollPosition += addTop / this._virtHeightRatio;\n\n      if (Math.abs(addTop / this._virtHeightRatio) < 1) {\n        // Actual scroll delta that was added is smaller than 1 and onScroll handler doesn't trigger when scrolling < 1px\n        const scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop); // scrollOffset = scrollOffset !== parseInt(this.igxForItemSize, 10) ? scrollOffset : 0;\n\n        this.dc.instance._viewContainer.element.nativeElement.style.top = -scrollOffset + 'px';\n      }\n\n      const maxRealScrollTop = this.scrollComponent.nativeElement.scrollHeight - containerSize;\n\n      if (this._virtScrollTop > 0 && this.scrollPosition === 0 || this._virtScrollTop < maxVirtScrollTop && this.scrollPosition === maxRealScrollTop) {\n        // Actual scroll position is at the top or bottom, but virtual one is not at the top or bottom (there's more to scroll)\n        // Recalculate actual scroll position based on the virtual scroll.\n        this.scrollPosition = this._virtScrollTop / this._virtHeightRatio;\n      } else if (this._virtScrollTop === 0 && this.scrollPosition > 0) {\n        // Actual scroll position is not at the top, but virtual scroll is. Just update the actual scroll\n        this.scrollPosition = 0;\n      } else if (this._virtScrollTop === maxVirtScrollTop && this.scrollPosition < maxRealScrollTop) {\n        // Actual scroll position is not at the bottom, but virtual scroll is. Just update the acual scroll\n        this.scrollPosition = maxRealScrollTop;\n      }\n\n      return this._virtScrollTop !== originalVirtScrollTop;\n    }\n    /**\n     * Scrolls to the specified index.\n     * ```typescript\n     * this.parentVirtDir.scrollTo(5);\n     * ```\n     *\n     * @param index\n     */\n\n\n    scrollTo(index) {\n      if (index < 0 || index > (this.isRemote ? this.totalItemCount : this.igxForOf.length) - 1) {\n        return;\n      }\n\n      const containerSize = parseInt(this.igxForContainerSize, 10);\n      const isPrevItem = index < this.state.startIndex || this.scrollPosition > this.sizesCache[index];\n      let nextScroll = isPrevItem ? this.sizesCache[index] : this.sizesCache[index + 1] - containerSize;\n\n      if (nextScroll < 0) {\n        return;\n      }\n\n      if (this.igxForScrollOrientation === 'horizontal') {\n        this.scrollPosition = this.isRTL ? -nextScroll : nextScroll;\n      } else {\n        const maxVirtScrollTop = this._virtHeight - containerSize;\n\n        if (nextScroll > maxVirtScrollTop) {\n          nextScroll = maxVirtScrollTop;\n        }\n\n        this._bScrollInternal = true;\n        this._virtScrollTop = nextScroll;\n        this.scrollPosition = this._virtScrollTop / this._virtHeightRatio;\n        this._adjustToIndex = !isPrevItem ? index : null;\n      }\n    }\n    /**\n     * Scrolls by one item into the appropriate next direction.\n     * For \"horizontal\" orientation that will be the right column and for \"vertical\" that is the lower row.\n     * ```typescript\n     * this.parentVirtDir.scrollNext();\n     * ```\n     */\n\n\n    scrollNext() {\n      const scr = Math.abs(Math.ceil(this.scrollPosition));\n      const endIndex = this.getIndexAt(scr + parseInt(this.igxForContainerSize, 10), this.sizesCache);\n      this.scrollTo(endIndex);\n    }\n    /**\n     * Scrolls by one item into the appropriate previous direction.\n     * For \"horizontal\" orientation that will be the left column and for \"vertical\" that is the upper row.\n     * ```typescript\n     * this.parentVirtDir.scrollPrev();\n     * ```\n     */\n\n\n    scrollPrev() {\n      this.scrollTo(this.state.startIndex - 1);\n    }\n    /**\n     * Scrolls by one page into the appropriate next direction.\n     * For \"horizontal\" orientation that will be one view to the right and for \"vertical\" that is one view to the bottom.\n     * ```typescript\n     * this.parentVirtDir.scrollNextPage();\n     * ```\n     */\n\n\n    scrollNextPage() {\n      if (this.igxForScrollOrientation === 'horizontal') {\n        this.scrollPosition += this.isRTL ? -parseInt(this.igxForContainerSize, 10) : parseInt(this.igxForContainerSize, 10);\n      } else {\n        this.addScrollTop(parseInt(this.igxForContainerSize, 10));\n      }\n    }\n    /**\n     * Scrolls by one page into the appropriate previous direction.\n     * For \"horizontal\" orientation that will be one view to the left and for \"vertical\" that is one view to the top.\n     * ```typescript\n     * this.parentVirtDir.scrollPrevPage();\n     * ```\n     */\n\n\n    scrollPrevPage() {\n      if (this.igxForScrollOrientation === 'horizontal') {\n        this.scrollPosition -= this.isRTL ? -parseInt(this.igxForContainerSize, 10) : parseInt(this.igxForContainerSize, 10);\n      } else {\n        const containerSize = parseInt(this.igxForContainerSize, 10);\n        this.addScrollTop(-containerSize);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    getColumnScrollLeft(colIndex) {\n      return this.sizesCache[colIndex];\n    }\n    /**\n     * Returns the total number of items that are fully visible.\n     * ```typescript\n     * this.parentVirtDir.getItemCountInView();\n     * ```\n     */\n\n\n    getItemCountInView() {\n      let startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache);\n\n      if (this.scrollPosition - this.sizesCache[startIndex] > 0) {\n        // fisrt item is not fully in view\n        startIndex++;\n      }\n\n      const endIndex = this.getIndexAt(this.scrollPosition + parseInt(this.igxForContainerSize, 10), this.sizesCache);\n      return endIndex - startIndex;\n    }\n    /**\n     * Returns a reference to the scrollbar DOM element.\n     * This is either a vertical or horizontal scrollbar depending on the specified igxForScrollOrientation.\n     * ```typescript\n     * dir.getScroll();\n     * ```\n     */\n\n\n    getScroll() {\n      var _a;\n\n      return (_a = this.scrollComponent) === null || _a === void 0 ? void 0 : _a.nativeElement;\n    }\n    /**\n     * Returns the size of the element at the specified index.\n     * ```typescript\n     * this.parentVirtDir.getSizeAt(1);\n     * ```\n     */\n\n\n    getSizeAt(index) {\n      return this.sizesCache[index + 1] - this.sizesCache[index];\n    }\n    /**\n     * @hidden\n     * Function that is called to get the native scrollbar size that the browsers renders.\n     */\n\n\n    getScrollNativeSize() {\n      return this.scrollComponent ? this.scrollComponent.scrollNativeSize : 0;\n    }\n    /**\n     * Returns the scroll offset of the element at the specified index.\n     * ```typescript\n     * this.parentVirtDir.getScrollForIndex(1);\n     * ```\n     */\n\n\n    getScrollForIndex(index, bottom) {\n      const containerSize = parseInt(this.igxForContainerSize, 10);\n      const scroll = bottom ? Math.max(0, this.sizesCache[index + 1] - containerSize) : this.sizesCache[index];\n      return scroll;\n    }\n    /**\n     * Returns the index of the element at the specified offset.\n     * ```typescript\n     * this.parentVirtDir.getIndexAtScroll(100);\n     * ```\n     */\n\n\n    getIndexAtScroll(scrollOffset) {\n      return this.getIndexAt(scrollOffset, this.sizesCache);\n    }\n    /**\n     * Returns whether the target index is outside the view.\n     * ```typescript\n     * this.parentVirtDir.isIndexOutsideView(10);\n     * ```\n     */\n\n\n    isIndexOutsideView(index) {\n      const targetNode = index >= this.state.startIndex && index <= this.state.startIndex + this.state.chunkSize ? this._embeddedViews.map(view => view.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE) || view.rootNodes[0].nextElementSibling)[index - this.state.startIndex] : null;\n      const rowHeight = this.getSizeAt(index);\n      const containerSize = parseInt(this.igxForContainerSize, 10);\n      const containerOffset = -(this.scrollPosition - this.sizesCache[this.state.startIndex]);\n      const endTopOffset = targetNode ? targetNode.offsetTop + rowHeight + containerOffset : containerSize + rowHeight;\n      return !targetNode || targetNode.offsetTop < Math.abs(containerOffset) || containerSize && endTopOffset - containerSize > 5;\n    }\n    /**\n     * @hidden\n     * Function that recalculates and updates cache sizes.\n     */\n\n\n    recalcUpdateSizes() {\n      const dimension = this.igxForScrollOrientation === 'horizontal' ? this.igxForSizePropName : 'height';\n      const diffs = [];\n      let totalDiff = 0;\n      const l = this._embeddedViews.length;\n\n      const rNodes = this._embeddedViews.map(view => view.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE) || view.rootNodes[0].nextElementSibling);\n\n      for (let i = 0; i < l; i++) {\n        const rNode = rNodes[i];\n\n        if (rNode) {\n          const height = window.getComputedStyle(rNode).getPropertyValue('height');\n          const h = parseFloat(height) || parseInt(this.igxForItemSize, 10);\n          const index = this.state.startIndex + i;\n\n          if (!this.isRemote && !this.igxForOf[index]) {\n            continue;\n          }\n\n          const margin = this.getMargin(rNode, dimension);\n          const oldVal = dimension === 'height' ? this.heightCache[index] : this.igxForOf[index][dimension];\n          const newVal = (dimension === 'height' ? h : rNode.clientWidth) + margin;\n\n          if (dimension === 'height') {\n            this.heightCache[index] = newVal;\n          } else {\n            this.igxForOf[index][dimension] = newVal;\n          }\n\n          const currDiff = newVal - oldVal;\n          diffs.push(currDiff);\n          totalDiff += currDiff;\n          this.sizesCache[index + 1] += totalDiff;\n        }\n      } // update cache\n\n\n      if (Math.abs(totalDiff) > 0) {\n        for (let j = this.state.startIndex + this.state.chunkSize + 1; j < this.sizesCache.length; j++) {\n          this.sizesCache[j] += totalDiff;\n        } // update scrBar heights/widths\n\n\n        if (this.igxForScrollOrientation === 'horizontal') {\n          const firstScrollChild = this.scrollComponent.nativeElement.children.item(0);\n          const totalWidth = parseInt(firstScrollChild.style.width, 10) + totalDiff;\n          firstScrollChild.style.width = `${totalWidth}px`;\n        }\n\n        const reducer = (acc, val) => acc + val;\n\n        if (this.igxForScrollOrientation === 'vertical') {\n          const scrToBottom = this._isScrolledToBottom && !this.dc.instance.notVirtual;\n          const hSum = this.heightCache.reduce(reducer);\n\n          if (hSum > this._maxHeight) {\n            this._virtHeightRatio = hSum / this._maxHeight;\n          }\n\n          this.scrollComponent.size = Math.min(this.scrollComponent.size + totalDiff, this._maxHeight);\n          this._virtHeight = hSum;\n\n          if (!this.scrollComponent.destroyed) {\n            this.scrollComponent.cdr.detectChanges();\n          }\n\n          if (scrToBottom && !this._isAtBottomIndex) {\n            const containerSize = parseInt(this.igxForContainerSize, 10);\n            const maxVirtScrollTop = this._virtHeight - containerSize;\n            this._bScrollInternal = true;\n            this._virtScrollTop = maxVirtScrollTop;\n            this.scrollPosition = maxVirtScrollTop;\n            return;\n          }\n\n          if (this._adjustToIndex) {\n            // in case scrolled to specific index where after scroll heights are changed\n            // need to adjust the offsets so that item is last in view.\n            const updatesToIndex = this._adjustToIndex - this.state.startIndex + 1;\n            const sumDiffs = diffs.slice(0, updatesToIndex).reduce(reducer);\n\n            if (sumDiffs !== 0) {\n              this.addScrollTop(sumDiffs);\n            }\n\n            this._adjustToIndex = null;\n          }\n        }\n      }\n    }\n    /**\n     * @hidden\n     * Reset scroll position.\n     * Needed in case scrollbar is hidden/detached but we still need to reset it.\n     */\n\n\n    resetScrollPosition() {\n      this.scrollPosition = 0;\n      this.scrollComponent.scrollAmount = 0;\n      this.state.startIndex = 0;\n    }\n    /**\n     * @hidden\n     */\n\n\n    removeScrollEventListeners() {\n      if (this.igxForScrollOrientation === 'horizontal') {\n        this._zone.runOutsideAngular(() => {\n          var _a, _b;\n\n          return (_b = (_a = this.scrollComponent) === null || _a === void 0 ? void 0 : _a.nativeElement) === null || _b === void 0 ? void 0 : _b.removeEventListener('scroll', this.func);\n        });\n      } else {\n        this._zone.runOutsideAngular(() => {\n          var _a, _b;\n\n          return (_b = (_a = this.scrollComponent) === null || _a === void 0 ? void 0 : _a.nativeElement) === null || _b === void 0 ? void 0 : _b.removeEventListener('scroll', this.verticalScrollHandler);\n        });\n      }\n    }\n    /**\n     * @hidden\n     * Function that is called when scrolling vertically\n     */\n\n\n    onScroll(event) {\n      /* in certain situations this may be called when no scrollbar is visible */\n      if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {\n        return;\n      }\n\n      if (!this._bScrollInternal) {\n        this._calcVirtualScrollTop(event.target.scrollTop);\n      } else {\n        this._bScrollInternal = false;\n      }\n\n      const prevStartIndex = this.state.startIndex;\n      const scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);\n      this.dc.instance._viewContainer.element.nativeElement.style.top = -scrollOffset + 'px';\n\n      this._zone.onStable.pipe(first$1()).subscribe(this.recalcUpdateSizes.bind(this));\n\n      this.dc.changeDetectorRef.detectChanges();\n\n      if (prevStartIndex !== this.state.startIndex) {\n        this.chunkLoad.emit(this.state);\n      }\n    }\n\n    updateSizes() {\n      const scrollable = this.isScrollable();\n      this.recalcUpdateSizes();\n\n      this._applyChanges();\n\n      this._updateScrollOffset();\n\n      if (scrollable !== this.isScrollable()) {\n        this.scrollbarVisibilityChanged.emit();\n      } else {\n        this.contentSizeChange.emit();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    fixedUpdateAllElements(inScrollTop) {\n      const count = this.isRemote ? this.totalItemCount : this.igxForOf.length;\n      let newStart = this.getIndexAt(inScrollTop, this.sizesCache);\n\n      if (newStart + this.state.chunkSize > count) {\n        newStart = count - this.state.chunkSize;\n      }\n\n      const prevStart = this.state.startIndex;\n      const diff = newStart - this.state.startIndex;\n      this.state.startIndex = newStart;\n\n      if (diff) {\n        this.chunkPreload.emit(this.state);\n\n        if (!this.isRemote) {\n          // recalculate and apply page size.\n          if (diff && Math.abs(diff) <= MAX_PERF_SCROLL_DIFF) {\n            if (diff > 0) {\n              this.moveApplyScrollNext(prevStart);\n            } else {\n              this.moveApplyScrollPrev(prevStart);\n            }\n          } else {\n            this.fixedApplyScroll();\n          }\n        }\n      }\n\n      return inScrollTop - this.sizesCache[this.state.startIndex];\n    }\n    /**\n     * @hidden\n     * The function applies an optimized state change for scrolling down/right employing context change with view rearrangement\n     */\n\n\n    moveApplyScrollNext(prevIndex) {\n      const start = prevIndex + this.state.chunkSize;\n      const end = start + this.state.startIndex - prevIndex;\n      const container = this.dc.instance._vcr;\n\n      for (let i = start; i < end && this.igxForOf[i] !== undefined; i++) {\n        const embView = this._embeddedViews.shift();\n\n        this.scrollFocus(embView.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE) || embView.rootNodes[0].nextElementSibling);\n        const view = container.detach(0);\n        this.updateTemplateContext(embView.context, i);\n        container.insert(view);\n\n        this._embeddedViews.push(embView);\n      }\n    }\n    /**\n     * @hidden\n     * The function applies an optimized state change for scrolling up/left employing context change with view rearrangement\n     */\n\n\n    moveApplyScrollPrev(prevIndex) {\n      const container = this.dc.instance._vcr;\n\n      for (let i = prevIndex - 1; i >= this.state.startIndex && this.igxForOf[i] !== undefined; i--) {\n        const embView = this._embeddedViews.pop();\n\n        this.scrollFocus(embView.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE) || embView.rootNodes[0].nextElementSibling);\n        const view = container.detach(container.length - 1);\n        this.updateTemplateContext(embView.context, i);\n        container.insert(view, 0);\n\n        this._embeddedViews.unshift(embView);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    getContextIndex(input) {\n      return this.isRemote ? this.state.startIndex + this.igxForOf.indexOf(input) : this.igxForOf.indexOf(input);\n    }\n    /**\n     * @hidden\n     * Function which updates the passed context of an embedded view with the provided index\n     * from the view container.\n     * Often, called while handling a scroll event.\n     */\n\n\n    updateTemplateContext(context, index = 0) {\n      context.$implicit = this.igxForOf[index];\n      context.index = this.getContextIndex(this.igxForOf[index]);\n      context.count = this.igxForOf.length;\n    }\n    /**\n     * @hidden\n     * The function applies an optimized state change through context change for each view\n     */\n\n\n    fixedApplyScroll() {\n      let j = 0;\n      const endIndex = this.state.startIndex + this.state.chunkSize;\n\n      for (let i = this.state.startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {\n        const embView = this._embeddedViews[j++];\n        this.updateTemplateContext(embView.context, i);\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     *\n     * Clears focus inside the virtualized container on small scroll swaps.\n     */\n\n\n    scrollFocus(node) {\n      const activeElement = this.document.activeElement; // Remove focus in case the the active element is inside the view container.\n      // Otherwise we hit an exception while doing the 'small' scrolls swapping.\n      // For more information:\n      //\n      // https://developer.mozilla.org/en-US/docs/Web/API/Node/removeChild\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=432392\n\n      if (node && node.contains(this.document.activeElement)) {\n        activeElement.blur();\n      }\n    }\n    /**\n     * @hidden\n     * Function that is called when scrolling horizontally\n     */\n\n\n    onHScroll(event) {\n      /* in certain situations this may be called when no scrollbar is visible */\n      const firstScrollChild = this.scrollComponent.nativeElement.children.item(0);\n\n      if (!parseInt(firstScrollChild.style.width, 10)) {\n        return;\n      }\n\n      const prevStartIndex = this.state.startIndex;\n      const scrLeft = event.target.scrollLeft; // Updating horizontal chunks\n\n      const scrollOffset = this.fixedUpdateAllElements(Math.abs(event.target.scrollLeft));\n\n      if (scrLeft < 0) {\n        // RTL\n        this.dc.instance._viewContainer.element.nativeElement.style.left = scrollOffset + 'px';\n      } else {\n        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';\n      }\n\n      this.dc.changeDetectorRef.detectChanges();\n\n      if (prevStartIndex !== this.state.startIndex) {\n        this.chunkLoad.emit(this.state);\n      }\n    }\n    /**\n     * Gets the function used to track changes in the items collection.\n     * By default the object references are compared. However this can be optimized if you have unique identifier\n     * value that can be used for the comparison instead of the object ref or if you have some other property values\n     * in the item object that should be tracked for changes.\n     * This option is similar to ngForTrackBy.\n     * ```typescript\n     * const trackFunc = this.parentVirtDir.igxForTrackBy;\n     * ```\n     */\n\n\n    get igxForTrackBy() {\n      return this._trackByFn;\n    }\n    /**\n     * Sets the function used to track changes in the items collection.\n     * This function can be set in scenarios where you want to optimize or\n     * customize the tracking of changes for the items in the collection.\n     * The igxForTrackBy function takes the index and the current item as arguments and needs to return the unique identifier for this item.\n     * ```typescript\n     * this.parentVirtDir.igxForTrackBy = (index, item) => {\n     *      return item.id + item.width;\n     * };\n     * ```\n     */\n\n\n    set igxForTrackBy(fn) {\n      this._trackByFn = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    _applyChanges() {\n      const prevChunkSize = this.state.chunkSize;\n      this.applyChunkSizeChange();\n\n      this._recalcScrollBarSize();\n\n      if (this.igxForOf && this.igxForOf.length && this.dc) {\n        const embeddedViewCopy = Object.assign([], this._embeddedViews);\n        let startIndex = this.state.startIndex;\n        let endIndex = this.state.chunkSize + this.state.startIndex;\n\n        if (this.isRemote) {\n          startIndex = 0;\n          endIndex = this.igxForOf.length;\n        }\n\n        for (let i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {\n          const embView = embeddedViewCopy.shift();\n          this.updateTemplateContext(embView.context, i);\n        }\n\n        if (prevChunkSize !== this.state.chunkSize) {\n          this.chunkLoad.emit(this.state);\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    _calcMaxBrowserHeight() {\n      if (!this.platformUtil.isBrowser) {\n        return 0;\n      }\n\n      const div = this.document.createElement('div');\n      const style = div.style;\n      style.position = 'absolute';\n      style.top = '9999999999999999px';\n      this.document.body.appendChild(div);\n      const size = Math.abs(div.getBoundingClientRect()['top']);\n      this.document.body.removeChild(div);\n      return size;\n    }\n    /**\n     * @hidden\n     * Recalculates the chunkSize based on current startIndex and returns the new size.\n     * This should be called after this.state.startIndex is updated, not before.\n     */\n\n\n    _calculateChunkSize() {\n      let chunkSize = 0;\n\n      if (this.igxForContainerSize !== null && this.igxForContainerSize !== undefined) {\n        if (!this.sizesCache) {\n          this.initSizesCache(this.igxForOf);\n        }\n\n        chunkSize = this._calcMaxChunkSize();\n\n        if (this.igxForOf && chunkSize > this.igxForOf.length) {\n          chunkSize = this.igxForOf.length;\n        }\n      } else {\n        if (this.igxForOf) {\n          chunkSize = this.igxForOf.length;\n        }\n      }\n\n      return chunkSize;\n    }\n    /**\n     * @hidden\n     */\n\n\n    getElement(viewref, nodeName) {\n      const elem = viewref.element.nativeElement.parentNode.getElementsByTagName(nodeName);\n      return elem.length > 0 ? elem[0] : null;\n    }\n    /**\n     * @hidden\n     */\n\n\n    initSizesCache(items) {\n      let totalSize = 0;\n      let size = 0;\n      const dimension = this.igxForSizePropName || 'height';\n      let i = 0;\n      this.sizesCache = [];\n      this.heightCache = [];\n      this.sizesCache.push(0);\n      const count = this.isRemote ? this.totalItemCount : items.length;\n\n      for (i; i < count; i++) {\n        size = this._getItemSize(items[i], dimension);\n\n        if (this.igxForScrollOrientation === 'vertical') {\n          this.heightCache.push(size);\n        }\n\n        totalSize += size;\n        this.sizesCache.push(totalSize);\n      }\n\n      return totalSize;\n    }\n\n    _updateSizeCache() {\n      if (this.igxForScrollOrientation === 'horizontal') {\n        this.initSizesCache(this.igxForOf);\n        return;\n      }\n\n      const oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce((acc, val) => acc + val) : 0;\n      const newHeight = this.initSizesCache(this.igxForOf);\n      const diff = oldHeight - newHeight;\n\n      this._adjustScrollPositionAfterSizeChange(diff);\n    }\n    /**\n     * @hidden\n     */\n\n\n    _calcMaxChunkSize() {\n      let i = 0;\n      let length = 0;\n      let maxLength = 0;\n      const arr = [];\n      let sum = 0;\n      const availableSize = parseInt(this.igxForContainerSize, 10);\n\n      if (!availableSize) {\n        return 0;\n      }\n\n      const dimension = this.igxForScrollOrientation === 'horizontal' ? this.igxForSizePropName : 'height';\n\n      const reducer = (accumulator, currentItem) => accumulator + this._getItemSize(currentItem, dimension);\n\n      for (i; i < this.igxForOf.length; i++) {\n        let item = this.igxForOf[i];\n\n        if (dimension === 'height') {\n          item = {\n            value: this.igxForOf[i],\n            height: this.heightCache[i]\n          };\n        }\n\n        const size = dimension === 'height' ? this.heightCache[i] : this._getItemSize(item, dimension);\n        sum = arr.reduce(reducer, size);\n\n        if (sum < availableSize) {\n          arr.push(item);\n          length = arr.length;\n\n          if (i === this.igxForOf.length - 1) {\n            // reached end without exceeding\n            // include prev items until size is filled or first item is reached.\n            let curItem = dimension === 'height' ? arr[0].value : arr[0];\n            let prevIndex = this.igxForOf.indexOf(curItem) - 1;\n\n            while (prevIndex >= 0 && sum <= availableSize) {\n              curItem = dimension === 'height' ? arr[0].value : arr[0];\n              prevIndex = this.igxForOf.indexOf(curItem) - 1;\n              const prevItem = this.igxForOf[prevIndex];\n              const prevSize = dimension === 'height' ? this.heightCache[prevIndex] : parseInt(prevItem[dimension], 10);\n              sum = arr.reduce(reducer, prevSize);\n              arr.unshift(prevItem);\n              length = arr.length;\n            }\n          }\n        } else {\n          arr.push(item);\n          length = arr.length + 1;\n          arr.shift();\n        }\n\n        if (length > maxLength) {\n          maxLength = length;\n        }\n      }\n\n      return maxLength;\n    }\n    /**\n     * @hidden\n     */\n\n\n    getIndexAt(left, set) {\n      let start = 0;\n      let end = set.length - 1;\n\n      if (left === 0) {\n        return 0;\n      }\n\n      while (start <= end) {\n        const midIdx = Math.floor((start + end) / 2);\n        const midLeft = set[midIdx];\n        const cmp = left - midLeft;\n\n        if (cmp > 0) {\n          start = midIdx + 1;\n        } else if (cmp < 0) {\n          end = midIdx - 1;\n        } else {\n          return midIdx;\n        }\n      }\n\n      return end;\n    }\n\n    _recalcScrollBarSize() {\n      const count = this.isRemote ? this.totalItemCount : this.igxForOf ? this.igxForOf.length : 0;\n      this.dc.instance.notVirtual = !(this.igxForContainerSize && this.dc && this.state.chunkSize < count);\n      const scrollable = this.isScrollable();\n\n      if (this.igxForScrollOrientation === 'horizontal') {\n        const totalWidth = this.igxForContainerSize ? this.initSizesCache(this.igxForOf) : 0;\n        this.scrollComponent.nativeElement.style.width = this.igxForContainerSize + 'px';\n        this.scrollComponent.size = totalWidth;\n\n        if (totalWidth <= parseInt(this.igxForContainerSize, 10)) {\n          this.resetScrollPosition();\n        }\n      }\n\n      if (this.igxForScrollOrientation === 'vertical') {\n        this.scrollComponent.nativeElement.style.height = parseInt(this.igxForContainerSize, 10) + 'px';\n        this.scrollComponent.size = this._calcHeight();\n\n        if (this.scrollComponent.size <= parseInt(this.igxForContainerSize, 10)) {\n          this.resetScrollPosition();\n        }\n      }\n\n      if (scrollable !== this.isScrollable()) {\n        // scrollbar visibility has changed\n        this.scrollbarVisibilityChanged.emit();\n      }\n    }\n\n    _calcHeight() {\n      let height;\n\n      if (this.heightCache) {\n        height = this.heightCache.reduce((acc, val) => acc + val, 0);\n      } else {\n        height = this.initSizesCache(this.igxForOf);\n      }\n\n      this._virtHeight = height;\n\n      if (height > this._maxHeight) {\n        this._virtHeightRatio = height / this._maxHeight;\n        height = this._maxHeight;\n      }\n\n      return height;\n    }\n\n    _recalcOnContainerChange() {\n      this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';\n      this.dc.instance._viewContainer.element.nativeElement.style.left = '0px';\n      const prevChunkSize = this.state.chunkSize;\n      this.applyChunkSizeChange();\n\n      this._recalcScrollBarSize();\n\n      if (prevChunkSize !== this.state.chunkSize) {\n        this.chunkLoad.emit(this.state);\n      }\n\n      if (this.sizesCache && this.igxForScrollOrientation === 'horizontal') {\n        // Updating horizontal chunks and offsets based on the new scrollLeft\n        const scrollOffset = this.fixedUpdateAllElements(this.scrollPosition);\n        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';\n      }\n    }\n    /**\n     * @hidden\n     * Removes an element from the embedded views and updates chunkSize.\n     */\n\n\n    removeLastElem() {\n      const oldElem = this._embeddedViews.pop();\n\n      this.beforeViewDestroyed.emit(oldElem); // also detach from ViewContainerRef to make absolutely sure this is removed from the view container.\n\n      this.dc.instance._vcr.detach(this.dc.instance._vcr.length - 1);\n\n      oldElem.destroy();\n      this.state.chunkSize--;\n    }\n    /**\n     * @hidden\n     * If there exists an element that we can create embedded view for creates it, appends it and updates chunkSize\n     */\n\n\n    addLastElem() {\n      let elemIndex = this.state.startIndex + this.state.chunkSize;\n\n      if (!this.isRemote && !this.igxForOf) {\n        return;\n      }\n\n      if (elemIndex >= this.igxForOf.length) {\n        elemIndex = this.igxForOf.length - this.state.chunkSize;\n      }\n\n      const input = this.igxForOf[elemIndex];\n\n      const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));\n\n      this._embeddedViews.push(embeddedView);\n\n      this.state.chunkSize++;\n\n      this._zone.run(() => this.cdr.markForCheck());\n    }\n    /**\n     * Recalculates chunkSize and adds/removes elements if need due to the change.\n     * this.state.chunkSize is updated in @addLastElem() or @removeLastElem()\n     */\n\n\n    applyChunkSizeChange() {\n      const chunkSize = this.isRemote ? this.igxForOf ? this.igxForOf.length : 0 : this._calculateChunkSize();\n\n      if (chunkSize > this.state.chunkSize) {\n        const diff = chunkSize - this.state.chunkSize;\n\n        for (let i = 0; i < diff; i++) {\n          this.addLastElem();\n        }\n      } else if (chunkSize < this.state.chunkSize) {\n        const diff = this.state.chunkSize - chunkSize;\n\n        for (let i = 0; i < diff; i++) {\n          this.removeLastElem();\n        }\n      }\n    }\n\n    _updateScrollOffset() {\n      if (this.igxForScrollOrientation === 'horizontal') {\n        this._updateHScrollOffset();\n      } else {\n        this._updateVScrollOffset();\n      }\n    }\n\n    _calcVirtualScrollTop(scrollTop) {\n      const containerSize = parseInt(this.igxForContainerSize, 10);\n      const maxRealScrollTop = this.scrollComponent.size - containerSize;\n      const realPercentScrolled = maxRealScrollTop !== 0 ? scrollTop / maxRealScrollTop : 0;\n      const maxVirtScrollTop = this._virtHeight - containerSize;\n      this._virtScrollTop = realPercentScrolled * maxVirtScrollTop;\n    }\n\n    _getItemSize(item, dimension) {\n      const dim = item ? item[dimension] : null;\n      return typeof dim === 'number' ? dim : parseInt(this.igxForItemSize, 10) || 0;\n    }\n\n    _updateVScrollOffset() {\n      let scrollOffset = 0;\n      let currentScrollTop = this.scrollPosition;\n\n      if (this._virtHeightRatio !== 1) {\n        this._calcVirtualScrollTop(this.scrollPosition);\n\n        currentScrollTop = this._virtScrollTop;\n      }\n\n      const vScroll = this.scrollComponent.nativeElement;\n      scrollOffset = vScroll && this.scrollComponent.size ? currentScrollTop - this.sizesCache[this.state.startIndex] : 0;\n      this.dc.instance._viewContainer.element.nativeElement.style.top = -scrollOffset + 'px';\n    }\n\n    _updateHScrollOffset() {\n      let scrollOffset = 0;\n      scrollOffset = this.scrollComponent.nativeElement && this.scrollComponent.size ? this.scrollPosition - this.sizesCache[this.state.startIndex] : 0;\n      this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';\n    }\n\n    _adjustScrollPositionAfterSizeChange(sizeDiff) {\n      // if data has been changed while container is scrolled\n      // should update scroll top/left according to change so that same startIndex is in view\n      if (Math.abs(sizeDiff) > 0 && this.scrollPosition > 0) {\n        this.recalcUpdateSizes();\n        const offset = this.igxForScrollOrientation === 'horizontal' ? parseInt(this.dc.instance._viewContainer.element.nativeElement.style.left, 10) : parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);\n        const newSize = this.sizesCache[this.state.startIndex] - offset;\n        this.scrollPosition = newSize;\n\n        if (this.scrollPosition !== newSize) {\n          this.scrollComponent.scrollAmount = newSize;\n        }\n      }\n    }\n\n    getMargin(node, dimension) {\n      const styles = window.getComputedStyle(node);\n\n      if (dimension === 'height') {\n        return parseFloat(styles['marginTop']) + parseFloat(styles['marginBottom']) || 0;\n      }\n\n      return parseFloat(styles['marginLeft']) + parseFloat(styles['marginRight']) || 0;\n    }\n\n  }\n\n  IgxForOfDirective.ɵfac = function IgxForOfDirective_Factory(t) {\n    return new (t || IgxForOfDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(IgxForOfScrollSyncService), i0.ɵɵdirectiveInject(PlatformUtil), i0.ɵɵdirectiveInject(DOCUMENT));\n  };\n\n  IgxForOfDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxForOfDirective,\n    selectors: [[\"\", \"igxFor\", \"\", \"igxForOf\", \"\"]],\n    inputs: {\n      igxForOf: \"igxForOf\",\n      igxForSizePropName: \"igxForSizePropName\",\n      igxForScrollOrientation: \"igxForScrollOrientation\",\n      igxForScrollContainer: \"igxForScrollContainer\",\n      igxForContainerSize: \"igxForContainerSize\",\n      igxForItemSize: \"igxForItemSize\",\n      igxForTotalItemCount: \"igxForTotalItemCount\",\n      igxForTrackBy: \"igxForTrackBy\"\n    },\n    outputs: {\n      chunkLoad: \"chunkLoad\",\n      scrollbarVisibilityChanged: \"scrollbarVisibilityChanged\",\n      contentSizeChange: \"contentSizeChange\",\n      dataChanged: \"dataChanged\",\n      beforeViewDestroyed: \"beforeViewDestroyed\",\n      chunkPreload: \"chunkPreload\"\n    },\n    features: [i0.ɵɵProvidersFeature([IgxForOfScrollSyncService]), i0.ɵɵNgOnChangesFeature]\n  });\n  return IgxForOfDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst getTypeNameForDebugging = type => type.name || typeof type;\n\nlet IgxGridForOfDirective = /*#__PURE__*/(() => {\n  class IgxGridForOfDirective extends IgxForOfDirective {\n    constructor(_viewContainer, _template, _differs, cdr, _zone, _platformUtil, _document, syncScrollService, syncService) {\n      super(_viewContainer, _template, _differs, cdr, _zone, syncScrollService, _platformUtil, _document);\n      this.syncScrollService = syncScrollService;\n      this.syncService = syncService;\n      this.igxGridForOfUniqueSizeCache = false;\n      this.igxGridForOfVariableSizes = true;\n      /**\n       * @hidden @internal\n       * An event that is emitted after data has been changed but before the view is refreshed\n       */\n\n      this.dataChanging = new EventEmitter();\n    }\n\n    set igxGridForOf(value) {\n      this.igxForOf = value;\n    }\n\n    get igxGridForOf() {\n      return this.igxForOf;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get sizesCache() {\n      if (this.igxForScrollOrientation === 'horizontal') {\n        if (this.igxGridForOfUniqueSizeCache || this.syncService.isMaster(this)) {\n          return this._sizesCache;\n        }\n\n        return this.syncService.sizesCache(this.igxForScrollOrientation);\n      } else {\n        return this._sizesCache;\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    set sizesCache(value) {\n      this._sizesCache = value;\n    }\n\n    get itemsDimension() {\n      return this.igxForSizePropName || 'height';\n    }\n\n    recalcUpdateSizes() {\n      if (this.igxGridForOfVariableSizes) {\n        super.recalcUpdateSizes();\n      }\n    }\n\n    ngOnInit() {\n      this.syncService.setMaster(this);\n      super.ngOnInit();\n      this.removeScrollEventListeners();\n    }\n\n    ngOnChanges(changes) {\n      const forOf = 'igxGridForOf';\n      this.syncService.setMaster(this);\n\n      if (forOf in changes) {\n        const value = changes[forOf].currentValue;\n\n        if (!this._differ && value) {\n          try {\n            this._differ = this._differs.find(value).create(this.igxForTrackBy);\n          } catch (e) {\n            throw new Error(`Cannot find a differ supporting object \"${value}\" of type \"${getTypeNameForDebugging(value)}\".\n                     NgFor only supports binding to Iterables such as Arrays.`);\n          }\n        }\n\n        if (this.igxForScrollOrientation === 'horizontal') {\n          // in case collection has changes, reset sync service\n          this.syncService.setMaster(this, true);\n        }\n      }\n\n      const defaultItemSize = 'igxForItemSize';\n\n      if (defaultItemSize in changes && !changes[defaultItemSize].firstChange && this.igxForScrollOrientation === 'vertical' && this.igxForOf) {\n        // handle default item size changed.\n        this.initSizesCache(this.igxForOf);\n      }\n\n      const containerSize = 'igxForContainerSize';\n\n      if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {\n        this._recalcOnContainerChange();\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    assumeMaster() {\n      this._sizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);\n      this.syncService.setMaster(this, true);\n    }\n\n    ngDoCheck() {\n      if (this._differ) {\n        const changes = this._differ.diff(this.igxForOf);\n\n        if (changes) {\n          const args = {\n            containerSize: this.igxForContainerSize\n          };\n          this.dataChanging.emit(args); //  re-init cache.\n\n          if (!this.igxForOf) {\n            this.igxForOf = [];\n          }\n          /* we need to reset the master dir if all rows are removed\n          (e.g. because of filtering); if all columns are hidden, rows are\n          still rendered empty, so we should not reset master */\n\n\n          if (!this.igxForOf.length && this.igxForScrollOrientation === 'vertical') {\n            this.syncService.resetMaster();\n          }\n\n          this.syncService.setMaster(this);\n          this.igxForContainerSize = args.containerSize;\n\n          const sizeDiff = this._updateSizeCache(changes);\n\n          this._applyChanges();\n\n          if (sizeDiff) {\n            this._adjustScrollPositionAfterSizeChange(sizeDiff);\n          }\n\n          this._updateScrollOffset();\n\n          this.dataChanged.emit();\n        }\n      }\n    }\n\n    onScroll(event) {\n      if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {\n        return;\n      }\n\n      if (!this._bScrollInternal) {\n        this._calcVirtualScrollTop(event.target.scrollTop);\n      } else {\n        this._bScrollInternal = false;\n      }\n\n      const scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);\n      this.dc.instance._viewContainer.element.nativeElement.style.top = -scrollOffset + 'px';\n\n      this._zone.onStable.pipe(first$1()).subscribe(this.recalcUpdateSizes.bind(this));\n\n      this.cdr.markForCheck();\n    }\n\n    onHScroll(scrollAmount) {\n      /* in certain situations this may be called when no scrollbar is visible */\n      const firstScrollChild = this.scrollComponent.nativeElement.children.item(0);\n\n      if (!this.scrollComponent || !parseInt(firstScrollChild.style.width, 10)) {\n        return;\n      } // Updating horizontal chunks\n\n\n      const scrollOffset = this.fixedUpdateAllElements(Math.abs(scrollAmount));\n\n      if (scrollAmount < 0) {\n        // RTL\n        this.dc.instance._viewContainer.element.nativeElement.style.left = scrollOffset + 'px';\n      } else {\n        // LTR\n        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';\n      }\n    }\n\n    getItemSize(item) {\n      let size = 0;\n      const dimension = this.igxForSizePropName || 'height';\n\n      if (this.igxForScrollOrientation === 'vertical') {\n        size = this._getItemSize(item, dimension);\n\n        if (item && item.summaries) {\n          size = item.max;\n        } else if (item && item.groups && item.height) {\n          size = item.height;\n        }\n      } else {\n        size = parseInt(item[dimension], 10) || 0;\n      }\n\n      return size;\n    }\n\n    initSizesCache(items) {\n      if (!this.syncService.isMaster(this) && this.igxForScrollOrientation === 'horizontal') {\n        const masterSizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);\n        return masterSizesCache[masterSizesCache.length - 1];\n      }\n\n      let totalSize = 0;\n      let size = 0;\n      let i = 0;\n      this.sizesCache = [];\n      this.heightCache = [];\n      this.sizesCache.push(0);\n      const count = this.isRemote ? this.totalItemCount : items.length;\n\n      for (i; i < count; i++) {\n        size = this.getItemSize(items[i]);\n\n        if (this.igxForScrollOrientation === 'vertical') {\n          this.heightCache.push(size);\n        }\n\n        totalSize += size;\n        this.sizesCache.push(totalSize);\n      }\n\n      return totalSize;\n    }\n\n    _updateSizeCache(changes = null) {\n      if (this.igxForScrollOrientation === 'horizontal') {\n        const oldSize = this.sizesCache[this.sizesCache.length - 1];\n        const newSize = this.initSizesCache(this.igxForOf);\n        const diff = oldSize - newSize;\n        return diff;\n      }\n\n      const oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce((acc, val) => acc + val) : 0;\n      let newHeight = oldHeight;\n\n      if (changes && !this.isRemote) {\n        newHeight = this.handleCacheChanges(changes);\n      } else {\n        return;\n      }\n\n      const diff = oldHeight - newHeight; // if data has been changed while container is scrolled\n      // should update scroll top/left according to change so that same startIndex is in view\n\n      if (Math.abs(diff) > 0 && this.platformUtil.isBrowser) {\n        // TODO: This code can be removed. However tests need to be rewritten in a way that they wait for ResizeObserved to complete.\n        // So leaving as is for the moment.\n        requestAnimationFrame(() => {\n          this.recalcUpdateSizes();\n          const offset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);\n\n          if (this.scrollPosition !== 0) {\n            this.scrollPosition = this.sizesCache[this.state.startIndex] - offset;\n          } else {\n            this._updateScrollOffset();\n          }\n        });\n      }\n\n      return diff;\n    }\n\n    handleCacheChanges(changes) {\n      const identityChanges = [];\n      const newHeightCache = [];\n      const newSizesCache = [];\n      newSizesCache.push(0);\n      let newHeight = 0; // When there are more than one removed items the changes are not reliable so those with identity change should be default size.\n\n      let numRemovedItems = 0;\n      changes.forEachRemovedItem(() => numRemovedItems++); // Get the identity changes to determine later if those that have changed their indexes should be assigned default item size.\n\n      changes.forEachIdentityChange(item => {\n        if (item.currentIndex !== item.previousIndex) {\n          // Filter out ones that have not changed their index.\n          identityChanges[item.currentIndex] = item;\n        }\n      }); // Processing each item that is passed to the igxForOf so far seem to be most reliable. We parse the updated list of items.\n\n      changes.forEachItem(item => {\n        if (item.previousIndex !== null && (numRemovedItems < 2 || !identityChanges.length || identityChanges[item.currentIndex])) {\n          // Reuse cache on those who have previousIndex.\n          // When there are more than one removed items currently the changes are not readable so ones with identity change\n          // should be racalculated.\n          newHeightCache[item.currentIndex] = this.heightCache[item.previousIndex];\n        } else {\n          // Assign default item size.\n          newHeightCache[item.currentIndex] = this.getItemSize(item.item);\n        }\n\n        newSizesCache[item.currentIndex + 1] = newSizesCache[item.currentIndex] + newHeightCache[item.currentIndex];\n        newHeight += newHeightCache[item.currentIndex];\n      });\n      this.heightCache = newHeightCache;\n      this.sizesCache = newSizesCache;\n      return newHeight;\n    }\n\n    addLastElem() {\n      let elemIndex = this.state.startIndex + this.state.chunkSize;\n\n      if (!this.isRemote && !this.igxForOf) {\n        return;\n      }\n\n      if (elemIndex >= this.igxForOf.length) {\n        elemIndex = this.igxForOf.length - this.state.chunkSize;\n      }\n\n      const input = this.igxForOf[elemIndex];\n\n      const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));\n\n      this._embeddedViews.push(embeddedView);\n\n      this.state.chunkSize++;\n    }\n\n    _updateViews(prevChunkSize) {\n      if (this.igxForOf && this.igxForOf.length && this.dc) {\n        const embeddedViewCopy = Object.assign([], this._embeddedViews);\n        let startIndex;\n        let endIndex;\n\n        if (this.isRemote) {\n          startIndex = 0;\n          endIndex = this.igxForOf.length;\n        } else {\n          startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache);\n\n          if (startIndex + this.state.chunkSize > this.igxForOf.length) {\n            startIndex = this.igxForOf.length - this.state.chunkSize;\n          }\n\n          this.state.startIndex = startIndex;\n          endIndex = this.state.chunkSize + this.state.startIndex;\n        }\n\n        for (let i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {\n          const embView = embeddedViewCopy.shift();\n          this.updateTemplateContext(embView.context, i);\n        }\n\n        if (prevChunkSize !== this.state.chunkSize) {\n          this.chunkLoad.emit(this.state);\n        }\n      }\n    }\n\n    _applyChanges() {\n      const prevChunkSize = this.state.chunkSize;\n      this.applyChunkSizeChange();\n\n      this._recalcScrollBarSize();\n\n      this._updateViews(prevChunkSize);\n    }\n    /**\n     * @hidden\n     */\n\n\n    _calcMaxChunkSize() {\n      if (this.igxForScrollOrientation === 'horizontal') {\n        if (this.syncService.isMaster(this)) {\n          return super._calcMaxChunkSize();\n        }\n\n        return this.syncService.chunkSize(this.igxForScrollOrientation);\n      } else {\n        return super._calcMaxChunkSize();\n      }\n    }\n\n  }\n\n  IgxGridForOfDirective.ɵfac = function IgxGridForOfDirective_Factory(t) {\n    return new (t || IgxGridForOfDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(PlatformUtil), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(IgxForOfScrollSyncService), i0.ɵɵdirectiveInject(IgxForOfSyncService));\n  };\n\n  IgxGridForOfDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxGridForOfDirective,\n    selectors: [[\"\", \"igxGridFor\", \"\", \"igxGridForOf\", \"\"]],\n    inputs: {\n      igxGridForOf: \"igxGridForOf\",\n      igxGridForOfUniqueSizeCache: \"igxGridForOfUniqueSizeCache\",\n      igxGridForOfVariableSizes: \"igxGridForOfVariableSizes\"\n    },\n    outputs: {\n      dataChanging: \"dataChanging\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  });\n  return IgxGridForOfDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxForOfModule = /*#__PURE__*/(() => {\n  class IgxForOfModule {}\n\n  IgxForOfModule.ɵfac = function IgxForOfModule_Factory(t) {\n    return new (t || IgxForOfModule)();\n  };\n\n  IgxForOfModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxForOfModule\n  });\n  IgxForOfModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[IgxScrollInertiaModule, CommonModule]]\n  });\n  return IgxForOfModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * **Ignite UI for Angular DropDown** -\n * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/drop-down)\n *\n * The Ignite UI for Angular Drop Down displays a scrollable list of items which may be visually grouped and\n * supports selection of a single item. Clicking or tapping an item selects it and closes the Drop Down\n *\n * Example:\n * ```html\n * <igx-drop-down>\n *   <igx-drop-down-item *ngFor=\"let item of items\" disabled={{item.disabled}} isHeader={{item.header}}>\n *     {{ item.value }}\n *   </igx-drop-down-item>\n * </igx-drop-down>\n * ```\n */\n\n\nlet IgxDropDownComponent = /*#__PURE__*/(() => {\n  class IgxDropDownComponent extends IgxDropDownBaseDirective {\n    constructor(elementRef, cdr, selection, _displayDensityOptions) {\n      super(elementRef, cdr, _displayDensityOptions);\n      this.elementRef = elementRef;\n      this.cdr = cdr;\n      this.selection = selection;\n      this._displayDensityOptions = _displayDensityOptions;\n      /**\n       * Emitted before the dropdown is opened\n       *\n       * ```html\n       * <igx-drop-down (opening)='handleOpening($event)'></igx-drop-down>\n       * ```\n       */\n\n      this.opening = new EventEmitter();\n      /**\n       * Emitted after the dropdown is opened\n       *\n       * ```html\n       * <igx-drop-down (opened)='handleOpened($event)'></igx-drop-down>\n       * ```\n       */\n\n      this.opened = new EventEmitter();\n      /**\n       * Emitted before the dropdown is closed\n       *\n       * ```html\n       * <igx-drop-down (closing)='handleClosing($event)'></igx-drop-down>\n       * ```\n       */\n\n      this.closing = new EventEmitter();\n      /**\n       * Emitted after the dropdown is closed\n       *\n       * ```html\n       * <igx-drop-down (closed)='handleClosed($event)'></igx-drop-down>\n       * ```\n       */\n\n      this.closed = new EventEmitter();\n      /**\n       * Gets/sets whether items take focus. Disabled by default.\n       * When enabled, drop down items gain tab index and are focused when active -\n       * this includes activating the selected item when opening the drop down and moving with keyboard navigation.\n       *\n       * Note: Keep that focus shift in mind when using the igxDropDownItemNavigation directive\n       * and ensure it's placed either on each focusable item or a common ancestor to allow it to handle keyboard events.\n       *\n       * ```typescript\n       * // get\n       * let dropDownAllowsItemFocus = this.dropdown.allowItemsFocus;\n       * ```\n       *\n       * ```html\n       * <!--set-->\n       * <igx-drop-down [allowItemsFocus]='true'></igx-drop-down>\n       * ```\n       */\n\n      this.allowItemsFocus = false;\n      this.destroy$ = new Subject();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get focusedItem() {\n      if (this.virtDir) {\n        return this._focusedItem && this._focusedItem.index !== -1 ? this.children.find(e => e.index === this._focusedItem.index) || null : null;\n      }\n\n      return this._focusedItem;\n    }\n\n    set focusedItem(value) {\n      if (!value) {\n        this.selection.clear(`${this.id}-active`);\n        this._focusedItem = null;\n        return;\n      }\n\n      this._focusedItem = value;\n\n      if (this.virtDir) {\n        this._focusedItem = {\n          value: value.value,\n          index: value.index\n        };\n      }\n\n      this.selection.set(`${this.id}-active`, new Set([this._focusedItem]));\n    }\n\n    get id() {\n      return this._id;\n    }\n\n    set id(value) {\n      this.selection.set(value, this.selection.get(this.id));\n      this.selection.clear(this.id);\n      this.selection.set(value, this.selection.get(`${this.id}-active`));\n      this.selection.clear(`${this.id}-active`);\n      this._id = value;\n    }\n    /** Id of the internal listbox of the drop down */\n\n\n    get listId() {\n      return this.id + '-list';\n    }\n    /**\n     * Get currently selected item\n     *\n     * ```typescript\n     * let currentItem = this.dropdown.selectedItem;\n     * ```\n     */\n\n\n    get selectedItem() {\n      const selectedItem = this.selection.first_item(this.id);\n\n      if (selectedItem) {\n        return selectedItem;\n      }\n\n      return null;\n    }\n    /**\n     * Gets if the dropdown is collapsed\n     *\n     * ```typescript\n     * let isCollapsed = this.dropdown.collapsed;\n     * ```\n     */\n\n\n    get collapsed() {\n      return this.toggleDirective.collapsed;\n    }\n    /** @hidden @internal */\n\n\n    get scrollContainer() {\n      return this.scrollContainerRef.nativeElement;\n    }\n\n    get collectionLength() {\n      if (this.virtDir) {\n        return this.virtDir.totalItemCount || this.virtDir.igxForOf.length;\n      }\n    }\n    /**\n     * Opens the dropdown\n     *\n     * ```typescript\n     * this.dropdown.open();\n     * ```\n     */\n\n\n    open(overlaySettings) {\n      this.toggleDirective.open(overlaySettings);\n      this.updateScrollPosition();\n    }\n    /**\n     * Closes the dropdown\n     *\n     * ```typescript\n     * this.dropdown.close();\n     * ```\n     */\n\n\n    close(event) {\n      this.toggleDirective.close(event);\n    }\n    /**\n     * Toggles the dropdown\n     *\n     * ```typescript\n     * this.dropdown.toggle();\n     * ```\n     */\n\n\n    toggle(overlaySettings) {\n      if (this.collapsed || this.toggleDirective.isClosing) {\n        this.open(overlaySettings);\n      } else {\n        this.close();\n      }\n    }\n    /**\n     * Select an item by index\n     *\n     * @param index of the item to select; If the drop down uses *igxFor, pass the index in data\n     */\n\n\n    setSelectedItem(index) {\n      if (index < 0 || index >= this.items.length) {\n        return;\n      }\n\n      let newSelection;\n\n      if (this.virtDir) {\n        newSelection = {\n          value: this.virtDir.igxForOf[index],\n          index\n        };\n      } else {\n        newSelection = this.items[index];\n      }\n\n      this.selectItem(newSelection);\n    }\n    /**\n     * Navigates to the item on the specified index\n     * If the data in the drop-down is virtualized, pass the index of the item in the virtualized data.\n     *\n     * @param newIndex number\n     */\n\n\n    navigateItem(index) {\n      if (this.virtDir) {\n        if (index === -1 || index >= this.collectionLength) {\n          return;\n        }\n\n        const direction = index > (this.focusedItem ? this.focusedItem.index : -1) ? Navigate.Down : Navigate.Up;\n        const subRequired = this.isIndexOutOfBounds(index, direction);\n        this.focusedItem = {\n          value: this.virtDir.igxForOf[index],\n          index\n        };\n\n        if (subRequired) {\n          this.virtDir.scrollTo(index);\n        }\n\n        if (subRequired) {\n          this.virtDir.chunkLoad.pipe(take(1)).subscribe(() => {\n            this.skipHeader(direction);\n          });\n        } else {\n          this.skipHeader(direction);\n        }\n      } else {\n        super.navigateItem(index);\n      }\n\n      if (this.allowItemsFocus && this.focusedItem) {\n        this.focusedItem.element.nativeElement.focus();\n        this.cdr.markForCheck();\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    updateScrollPosition() {\n      if (!this.virtDir) {\n        return;\n      }\n\n      if (!this.selectedItem) {\n        this.virtDir.scrollTo(0);\n        return;\n      }\n\n      let targetScroll = this.virtDir.getScrollForIndex(this.selectedItem.index);\n      const itemsInView = this.virtDir.igxForContainerSize / this.virtDir.igxForItemSize;\n      targetScroll -= (itemsInView / 2 - 1) * this.virtDir.igxForItemSize;\n      this.virtDir.getScroll().scrollTop = targetScroll;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onToggleOpening(e) {\n      const args = {\n        owner: this,\n        event: e.event,\n        cancel: false\n      };\n      this.opening.emit(args);\n      e.cancel = args.cancel;\n\n      if (e.cancel) {\n        return;\n      }\n\n      if (this.virtDir) {\n        this.virtDir.scrollPosition = this._scrollPosition;\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onToggleContentAppended(_event) {\n      if (!this.virtDir && this.selectedItem) {\n        this.scrollToItem(this.selectedItem);\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onToggleOpened() {\n      this.updateItemFocus();\n      this.opened.emit({\n        owner: this\n      });\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onToggleClosing(e) {\n      const args = {\n        owner: this,\n        event: e.event,\n        cancel: false\n      };\n      this.closing.emit(args);\n      e.cancel = args.cancel;\n\n      if (e.cancel) {\n        return;\n      }\n\n      if (this.virtDir) {\n        this._scrollPosition = this.virtDir.scrollPosition;\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onToggleClosed() {\n      this.focusItem(false);\n      this.closed.emit({\n        owner: this\n      });\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    ngOnDestroy() {\n      this.destroy$.next(true);\n      this.destroy$.complete();\n      this.selection.clear(this.id);\n      this.selection.clear(`${this.id}-active`);\n    }\n    /** @hidden @internal */\n\n\n    calculateScrollPosition(item) {\n      if (!item) {\n        return 0;\n      }\n\n      const elementRect = item.element.nativeElement.getBoundingClientRect();\n      const parentRect = this.scrollContainer.getBoundingClientRect();\n      const scrollDelta = parentRect.top - elementRect.top;\n      let scrollPosition = this.scrollContainer.scrollTop - scrollDelta;\n      const dropDownHeight = this.scrollContainer.clientHeight;\n      scrollPosition -= dropDownHeight / 2;\n      scrollPosition += item.elementHeight / 2;\n      return Math.floor(scrollPosition);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    ngOnChanges(changes) {\n      if (changes.id) {\n        // temp workaround until fix --> https://github.com/angular/angular/issues/34992\n        this.toggleDirective.id = changes.id.currentValue;\n      }\n    }\n\n    ngAfterViewInit() {\n      if (this.virtDir) {\n        this.virtDir.igxForItemSize = 28;\n      }\n    }\n    /** Keydown Handler */\n\n\n    onItemActionKey(key, event) {\n      super.onItemActionKey(key, event);\n      this.close(event);\n    }\n    /**\n     * Virtual scroll implementation\n     *\n     * @hidden @internal\n     */\n\n\n    navigateFirst() {\n      if (this.virtDir) {\n        this.navigateItem(0);\n      } else {\n        super.navigateFirst();\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    navigateLast() {\n      if (this.virtDir) {\n        this.navigateItem(this.virtDir.totalItemCount ? this.virtDir.totalItemCount - 1 : this.virtDir.igxForOf.length - 1);\n      } else {\n        super.navigateLast();\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    navigateNext() {\n      if (this.virtDir) {\n        this.navigateItem(this._focusedItem ? this._focusedItem.index + 1 : 0);\n      } else {\n        super.navigateNext();\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    navigatePrev() {\n      if (this.virtDir) {\n        this.navigateItem(this._focusedItem ? this._focusedItem.index - 1 : 0);\n      } else {\n        super.navigatePrev();\n      }\n    }\n    /**\n     * Handles the `selectionChanging` emit and the drop down toggle when selection changes\n     *\n     * @hidden\n     * @internal\n     * @param newSelection\n     * @param event\n     */\n\n\n    selectItem(newSelection, event) {\n      const oldSelection = this.selectedItem;\n\n      if (!newSelection) {\n        newSelection = this.focusedItem;\n      }\n\n      if (newSelection === null) {\n        return;\n      }\n\n      if (newSelection instanceof IgxDropDownItemBaseDirective && newSelection.isHeader) {\n        return;\n      }\n\n      if (this.virtDir) {\n        newSelection = {\n          value: newSelection.value,\n          index: newSelection.index\n        };\n      }\n\n      const args = {\n        oldSelection,\n        newSelection,\n        cancel: false\n      };\n      this.selectionChanging.emit(args);\n\n      if (!args.cancel) {\n        if (this.isSelectionValid(args.newSelection)) {\n          this.selection.set(this.id, new Set([args.newSelection]));\n\n          if (!this.virtDir) {\n            if (oldSelection) {\n              oldSelection.selected = false;\n            }\n\n            if (args.newSelection) {\n              args.newSelection.selected = true;\n            }\n          }\n\n          if (event) {\n            this.toggleDirective.close(event);\n          }\n        } else {\n          throw new Error('Please provide a valid drop-down item for the selection!');\n        }\n      }\n    }\n    /**\n     * Clears the selection of the dropdown\n     * ```typescript\n     * this.dropdown.clearSelection();\n     * ```\n     */\n\n\n    clearSelection() {\n      const oldSelection = this.selectedItem;\n      const newSelection = null;\n      const args = {\n        oldSelection,\n        newSelection,\n        cancel: false\n      };\n      this.selectionChanging.emit(args);\n\n      if (this.selectedItem && !args.cancel) {\n        this.selectedItem.selected = false;\n        this.selection.clear(this.id);\n      }\n    }\n    /**\n     * Checks whether the selection is valid\n     * `null` - the selection should be emptied\n     * Virtual? - the selection should at least have and `index` and `value` property\n     * Non-virtual? - the selection should be a valid drop-down item and **not** be a header\n     */\n\n\n    isSelectionValid(selection) {\n      return selection === null || this.virtDir && selection.hasOwnProperty('value') && selection.hasOwnProperty('index') || selection instanceof IgxDropDownItemComponent && !selection.isHeader;\n    }\n\n    scrollToItem(item) {\n      this.scrollContainer.scrollTop = this.calculateScrollPosition(item);\n    }\n\n    focusItem(value) {\n      if (value || this._focusedItem) {\n        this._focusedItem.focused = value;\n      }\n    }\n\n    updateItemFocus() {\n      if (this.selectedItem) {\n        this.focusedItem = this.selectedItem;\n        this.focusItem(true);\n      } else if (this.allowItemsFocus) {\n        this.navigateFirst();\n      }\n    }\n\n    skipHeader(direction) {\n      if (!this.focusedItem) {\n        return;\n      }\n\n      if (this.focusedItem.isHeader || this.focusedItem.disabled) {\n        if (direction === Navigate.Up) {\n          this.navigatePrev();\n        } else {\n          this.navigateNext();\n        }\n      }\n    }\n\n    isIndexOutOfBounds(index, direction) {\n      const virtState = this.virtDir.state;\n      const currentPosition = this.virtDir.getScroll().scrollTop;\n      const itemPosition = this.virtDir.getScrollForIndex(index, direction === Navigate.Down);\n      const indexOutOfChunk = index < virtState.startIndex || index > virtState.chunkSize + virtState.startIndex;\n      const scrollNeeded = direction === Navigate.Down ? currentPosition < itemPosition : currentPosition > itemPosition;\n      const subRequired = indexOutOfChunk || scrollNeeded;\n      return subRequired;\n    }\n\n  }\n\n  IgxDropDownComponent.ɵfac = function IgxDropDownComponent_Factory(t) {\n    return new (t || IgxDropDownComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(IgxSelectionAPIService), i0.ɵɵdirectiveInject(DisplayDensityToken, 8));\n  };\n\n  IgxDropDownComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxDropDownComponent,\n    selectors: [[\"igx-drop-down\"]],\n    contentQueries: function IgxDropDownComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxForOfDirective, 5, IgxForOfDirective);\n        i0.ɵɵcontentQuery(dirIndex, IgxDropDownItemComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.virtDir = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.children = _t);\n      }\n    },\n    viewQuery: function IgxDropDownComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxToggleDirective, 7);\n        i0.ɵɵviewQuery(_c7, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toggleDirective = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.scrollContainerRef = _t.first);\n      }\n    },\n    inputs: {\n      allowItemsFocus: \"allowItemsFocus\"\n    },\n    outputs: {\n      opening: \"opening\",\n      opened: \"opened\",\n      closing: \"closing\",\n      closed: \"closed\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IGX_DROPDOWN_BASE,\n      useExisting: IgxDropDownComponent\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c8,\n    decls: 4,\n    vars: 9,\n    consts: [[\"igxToggle\", \"\", 1, \"igx-drop-down__list\", 3, \"appended\", \"opening\", \"opened\", \"closing\", \"closed\"], [\"role\", \"listbox\", 1, \"igx-drop-down__list-scroll\"], [\"scrollContainer\", \"\"], [4, \"ngIf\"]],\n    template: function IgxDropDownComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵlistener(\"appended\", function IgxDropDownComponent_Template_div_appended_0_listener($event) {\n          return ctx.onToggleContentAppended($event);\n        })(\"opening\", function IgxDropDownComponent_Template_div_opening_0_listener($event) {\n          return ctx.onToggleOpening($event);\n        })(\"opened\", function IgxDropDownComponent_Template_div_opened_0_listener() {\n          return ctx.onToggleOpened();\n        })(\"closing\", function IgxDropDownComponent_Template_div_closing_0_listener($event) {\n          return ctx.onToggleClosing($event);\n        })(\"closed\", function IgxDropDownComponent_Template_div_closed_0_listener() {\n          return ctx.onToggleClosed();\n        });\n        i0.ɵɵelementStart(1, \"div\", 1, 2);\n        i0.ɵɵtemplate(3, IgxDropDownComponent_ng_container_3_Template, 2, 0, \"ng-container\", 3);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"width\", ctx.width);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"height\", ctx.height)(\"max-height\", ctx.maxHeight);\n        i0.ɵɵattribute(\"id\", ctx.listId)(\"aria-label\", ctx.listId);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", !ctx.collapsed);\n      }\n    },\n    directives: [IgxToggleDirective, i4.NgIf],\n    encapsulation: 2\n  });\n  return IgxDropDownComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Navigation Directive that handles keyboard events on its host and controls a targeted IgxDropDownBaseDirective component\n */\n\n\nlet IgxDropDownItemNavigationDirective = /*#__PURE__*/(() => {\n  class IgxDropDownItemNavigationDirective {\n    constructor(dropdown) {\n      this.dropdown = dropdown;\n      this._target = null;\n    }\n    /**\n     * Gets the target of the navigation directive;\n     *\n     * ```typescript\n     * // Get\n     * export class MyComponent {\n     *  ...\n     *  @ContentChild(IgxDropDownNavigationDirective)\n     *  navDirective: IgxDropDownNavigationDirective = null\n     *  ...\n     *  const navTarget: IgxDropDownBaseDirective = navDirective.navTarget\n     * }\n     * ```\n     */\n\n\n    get target() {\n      return this._target;\n    }\n    /**\n     * Sets the target of the navigation directive;\n     * If no valid target is passed, it falls back to the drop down context\n     *\n     * ```html\n     * <!-- Set -->\n     * <input [igxDropDownItemNavigation]=\"dropdown\" />\n     * ...\n     * <igx-drop-down #dropdown>\n     * ...\n     * </igx-drop-down>\n     * ```\n     */\n\n\n    set target(target) {\n      this._target = target ? target : this.dropdown;\n    }\n    /**\n     * Captures keydown events and calls the appropriate handlers on the target component\n     */\n\n\n    handleKeyDown(event) {\n      if (event) {\n        const key = event.key.toLowerCase();\n\n        if (!this.target.collapsed) {\n          // If dropdown is opened\n          const navKeys = ['esc', 'escape', 'enter', 'space', 'spacebar', ' ', 'arrowup', 'up', 'arrowdown', 'down', 'home', 'end'];\n\n          if (navKeys.indexOf(key) === -1) {\n            // If key has appropriate function in DD\n            return;\n          }\n\n          event.preventDefault();\n          event.stopPropagation();\n        } else {\n          // If dropdown is closed, do nothing\n          return;\n        }\n\n        switch (key) {\n          case 'esc':\n          case 'escape':\n            this.target.onItemActionKey(DropDownActionKey.ESCAPE, event);\n            break;\n\n          case 'enter':\n            this.target.onItemActionKey(DropDownActionKey.ENTER, event);\n            break;\n\n          case 'space':\n          case 'spacebar':\n          case ' ':\n            this.target.onItemActionKey(DropDownActionKey.SPACE, event);\n            break;\n\n          case 'arrowup':\n          case 'up':\n            this.onArrowUpKeyDown();\n            break;\n\n          case 'arrowdown':\n          case 'down':\n            this.onArrowDownKeyDown();\n            break;\n\n          case 'home':\n            this.onHomeKeyDown();\n            break;\n\n          case 'end':\n            this.onEndKeyDown();\n            break;\n\n          default:\n            return;\n        }\n      }\n    }\n    /**\n     * Navigates to previous item\n     */\n\n\n    onArrowDownKeyDown() {\n      this.target.navigateNext();\n    }\n    /**\n     * Navigates to previous item\n     */\n\n\n    onArrowUpKeyDown() {\n      this.target.navigatePrev();\n    }\n    /**\n     * Navigates to target's last item\n     */\n\n\n    onEndKeyDown() {\n      this.target.navigateLast();\n    }\n    /**\n     * Navigates to target's first item\n     */\n\n\n    onHomeKeyDown() {\n      this.target.navigateFirst();\n    }\n\n  }\n\n  IgxDropDownItemNavigationDirective.ɵfac = function IgxDropDownItemNavigationDirective_Factory(t) {\n    return new (t || IgxDropDownItemNavigationDirective)(i0.ɵɵdirectiveInject(IGX_DROPDOWN_BASE, 10));\n  };\n\n  IgxDropDownItemNavigationDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxDropDownItemNavigationDirective,\n    selectors: [[\"\", \"igxDropDownItemNavigation\", \"\"]],\n    hostBindings: function IgxDropDownItemNavigationDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function IgxDropDownItemNavigationDirective_keydown_HostBindingHandler($event) {\n          return ctx.handleKeyDown($event);\n        });\n      }\n    },\n    inputs: {\n      target: [\"igxDropDownItemNavigation\", \"target\"]\n    }\n  });\n  return IgxDropDownItemNavigationDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxDropDownModule = /*#__PURE__*/(() => {\n  class IgxDropDownModule {}\n\n  IgxDropDownModule.ɵfac = function IgxDropDownModule_Factory(t) {\n    return new (t || IgxDropDownModule)();\n  };\n\n  IgxDropDownModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxDropDownModule\n  });\n  IgxDropDownModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, IgxToggleModule]]\n  });\n  return IgxDropDownModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DatePickerResourceStringsEN = {\n  igx_date_picker_change_date: 'Change Date',\n  igx_date_picker_choose_date: 'Choose Date'\n};\nconst DateRangePickerResourceStringsEN = {\n  igx_date_range_picker_date_separator: 'to',\n  igx_date_range_picker_done_button: 'Done'\n};\nconst GridResourceStringsEN = {\n  igx_grid_groupByArea_message: 'Drag a column header and drop it here to group by that column.',\n  igx_grid_groupByArea_select_message: 'Select all rows in the group with field name {0} and value {1}.',\n  igx_grid_groupByArea_deselect_message: 'Deselect all rows in the group with field name {0} and value {1}.',\n  igx_grid_emptyFilteredGrid_message: 'No records found.',\n  igx_grid_emptyGrid_message: 'Grid has no data.',\n  igx_grid_filter: 'Filter',\n  igx_grid_filter_row_close: 'Close',\n  igx_grid_filter_row_reset: 'Reset',\n  igx_grid_filter_row_placeholder: 'Add filter value',\n  igx_grid_filter_row_boolean_placeholder: 'All',\n  igx_grid_filter_row_date_placeholder: 'Pick up date',\n  igx_grid_filter_row_time_placeholder: 'Pick up time',\n  igx_grid_filter_operator_and: 'And',\n  igx_grid_filter_operator_or: 'Or',\n  igx_grid_complex_filter: 'Complex Filter',\n  igx_grid_filter_contains: 'Contains',\n  igx_grid_filter_doesNotContain: 'Does Not Contain',\n  igx_grid_filter_startsWith: 'Starts With',\n  igx_grid_filter_endsWith: 'Ends With',\n  igx_grid_filter_equals: 'Equals',\n  igx_grid_filter_doesNotEqual: 'Does Not Equal',\n  igx_grid_filter_empty: 'Empty',\n  igx_grid_filter_notEmpty: 'Not Empty',\n  igx_grid_filter_null: 'Null',\n  igx_grid_filter_notNull: 'Not Null',\n  igx_grid_filter_before: 'Before',\n  igx_grid_filter_after: 'After',\n  igx_grid_filter_at: 'At',\n  igx_grid_filter_not_at: 'Not At',\n  igx_grid_filter_at_before: 'At or Before',\n  igx_grid_filter_at_after: 'At or After',\n  igx_grid_filter_today: 'Today',\n  igx_grid_filter_yesterday: 'Yesterday',\n  igx_grid_filter_thisMonth: 'This Month',\n  igx_grid_filter_lastMonth: 'Last Month',\n  igx_grid_filter_nextMonth: 'Next Month',\n  igx_grid_filter_thisYear: 'This Year',\n  igx_grid_filter_lastYear: 'Last Year',\n  igx_grid_filter_nextYear: 'Next Year',\n  igx_grid_filter_greaterThan: 'Greater Than',\n  igx_grid_filter_lessThan: 'Less Than',\n  igx_grid_filter_greaterThanOrEqualTo: 'Greater Than Or Equal To',\n  igx_grid_filter_lessThanOrEqualTo: 'Less Than Or Equal To',\n  igx_grid_filter_true: 'True',\n  igx_grid_filter_false: 'False',\n  igx_grid_filter_all: 'All',\n  igx_grid_filter_condition_placeholder: 'Select filter',\n  igx_grid_summary_count: 'Count',\n  igx_grid_summary_min: 'Min',\n  igx_grid_summary_max: 'Max',\n  igx_grid_summary_sum: 'Sum',\n  igx_grid_summary_average: 'Avg',\n  igx_grid_summary_earliest: 'Earliest',\n  igx_grid_summary_latest: 'Latest',\n  igx_grid_excel_filter_moving_left: 'move left',\n  igx_grid_excel_filter_moving_left_short: 'left',\n  igx_grid_excel_filter_moving_right: 'move right',\n  igx_grid_excel_filter_moving_right_short: 'right',\n  igx_grid_excel_filter_moving_header: 'move',\n  igx_grid_excel_filter_sorting_asc: 'ascending',\n  igx_grid_excel_filter_sorting_asc_short: 'asc',\n  igx_grid_excel_filter_sorting_desc: 'descending',\n  igx_grid_excel_filter_sorting_desc_short: 'desc',\n  igx_grid_excel_filter_sorting_header: 'sort',\n  igx_grid_excel_filter_clear: 'Clear column filters',\n  igx_grid_excel_custom_dialog_add: 'add filter',\n  igx_grid_excel_custom_dialog_clear: 'Clear filter',\n  igx_grid_excel_custom_dialog_header: 'Custom auto-filter on column: ',\n  igx_grid_excel_cancel: 'cancel',\n  igx_grid_excel_apply: 'apply',\n  igx_grid_excel_search_placeholder: 'Search',\n  igx_grid_excel_select_all: 'Select All',\n  igx_grid_excel_select_all_search_results: 'Select all search results',\n  igx_grid_excel_add_to_filter: 'Add current selection to filter',\n  igx_grid_excel_blanks: '(Blanks)',\n  igx_grid_excel_hide: 'Hide column',\n  igx_grid_excel_show: 'Show column',\n  igx_grid_excel_pin: 'Pin column',\n  igx_grid_excel_unpin: 'Unpin column',\n  igx_grid_excel_select: 'Select column',\n  igx_grid_excel_deselect: 'Deselect column',\n  igx_grid_excel_text_filter: 'Text filter',\n  igx_grid_excel_number_filter: 'Number filter',\n  igx_grid_excel_date_filter: 'Date filter',\n  igx_grid_excel_boolean_filter: 'Boolean filter',\n  igx_grid_excel_currency_filter: 'Currency filter',\n  igx_grid_excel_custom_filter: 'Custom filter...',\n  igx_grid_excel_no_matches: 'No matches',\n  igx_grid_advanced_filter_title: 'Advanced Filtering',\n  igx_grid_advanced_filter_and_group: '\"And\" Group',\n  igx_grid_advanced_filter_or_group: '\"Or\" Group',\n  igx_grid_advanced_filter_end_group: 'End Group',\n  igx_grid_advanced_filter_create_and_group: 'Create \"And\" Group',\n  igx_grid_advanced_filter_create_or_group: 'Create \"Or\" Group',\n  igx_grid_advanced_filter_and_label: 'and',\n  igx_grid_advanced_filter_or_label: 'or',\n  igx_grid_advanced_filter_add_condition: 'Condition',\n  igx_grid_advanced_filter_ungroup: 'Ungroup',\n  igx_grid_advanced_filter_delete: 'Delete',\n  igx_grid_advanced_filter_delete_filters: 'Delete filters',\n  igx_grid_advanced_filter_initial_text: 'Start with creating a group of conditions linked with \"And\" or \"Or\"',\n  igx_grid_advanced_filter_column_placeholder: 'Select column',\n  igx_grid_advanced_filter_value_placeholder: 'Value',\n  igx_grid_pinned_row_indicator: 'Pinned',\n  igx_grid_hiding_check_all_label: 'Show All',\n  igx_grid_hiding_uncheck_all_label: 'Hide All',\n  igx_grid_pinning_check_all_label: 'Pin All',\n  igx_grid_pinning_uncheck_all_label: 'Unpin All',\n  igx_grid_row_edit_btn_done: 'Done',\n  igx_grid_row_edit_btn_cancel: 'Cancel',\n  igx_grid_toolbar_actions_filter_prompt: 'Filter columns list ...',\n  igx_grid_toolbar_pinning_button_tooltip: 'Open column pinning dropdown',\n  igx_grid_toolbar_hiding_button_tooltip: 'Open column hiding dropdown',\n  igx_grid_toolbar_pinning_title: 'Pinned columns',\n  igx_grid_toolbar_hiding_title: 'Visible columns',\n  igx_grid_toolbar_advanced_filtering_button_tooltip: 'Open advanced filtering dialog',\n  igx_grid_toolbar_advanced_filtering_button_label: 'Advanced filtering',\n  igx_grid_toolbar_exporter_button_tooltip: 'Open exporter dropdown',\n  igx_grid_toolbar_exporter_button_label: 'Export',\n  igx_grid_toolbar_exporter_excel_entry_text: 'Export to Excel',\n  igx_grid_toolbar_exporter_csv_entry_text: 'Export to CSV',\n  igx_grid_snackbar_addrow_label: 'Row added',\n  igx_grid_snackbar_addrow_actiontext: 'SHOW',\n  igx_grid_actions_edit_label: 'Edit',\n  igx_grid_actions_add_label: 'Add',\n  igx_grid_add_row_label: 'ADD ROW',\n  igx_grid_actions_add_child_label: 'Add Child',\n  igx_grid_actions_delete_label: 'Delete',\n  igx_grid_actions_pin_label: 'Pin',\n  igx_grid_actions_unpin_label: 'Unpin',\n  igx_grid_actions_jumpUp_label: 'Jump up',\n  igx_grid_actions_jumpDown_label: 'Jump down',\n  igx_grid_pivot_date_dimension_total: 'All Periods',\n  igx_grid_pivot_aggregate_count: 'Count',\n  igx_grid_pivot_aggregate_min: 'Minimum',\n  igx_grid_pivot_aggregate_max: 'Maximum',\n  igx_grid_pivot_aggregate_sum: 'Sum',\n  igx_grid_pivot_aggregate_avg: 'Average',\n  igx_grid_pivot_aggregate_date_latest: 'Latest Date',\n  igx_grid_pivot_aggregate_date_earliest: 'Earliest Date',\n  igx_grid_pivot_aggregate_time_latest: 'Latest Time',\n  igx_grid_pivot_aggregate_time_earliest: 'Earliest Time',\n  igx_grid_pivot_empty_row_drop_area: 'Drop Row Fields here.',\n  igx_grid_pivot_empty_column_drop_area: 'Drop Column Fields here.',\n  igx_grid_pivot_empty_filter_drop_area: 'Drop Filter Fields here.',\n  igx_grid_pivot_empty_value_drop_area: 'Drop Value Fields here.',\n  igx_grid_pivot_row_drop_chip: 'Drop here to use as row',\n  igx_grid_pivot_column_drop_chip: 'Drop here to use as column',\n  igx_grid_pivot_filter_drop_chip: 'Drop here to use as filter',\n  igx_grid_pivot_value_drop_chip: 'Drop here to use as value',\n  igx_grid_pivot_empty_message: 'Pivot grid has no dimensions and values.',\n  igx_grid_pivot_selector_filters: 'Filters',\n  igx_grid_pivot_selector_rows: 'Rows',\n  igx_grid_pivot_selector_columns: 'Columns',\n  igx_grid_pivot_selector_values: 'Values',\n  igx_grid_pivot_selector_panel_empty: 'Drop Items Here'\n};\nconst TimePickerResourceStringsEN = {\n  igx_time_picker_ok: 'OK',\n  igx_time_picker_cancel: 'Cancel',\n  igx_time_picker_change_time: 'Change Time',\n  igx_time_picker_choose_time: 'Choose Time'\n};\nconst PaginatorResourceStringsEN = {\n  igx_paginator_label: 'Items per page',\n  igx_paginator_pager_text: 'of',\n  igx_paginator_first_page_button_text: 'Go to first page',\n  igx_paginator_previous_page_button_text: 'Previous page',\n  igx_paginator_last_page_button_text: 'Go to last page',\n  igx_paginator_next_page_button_text: 'Next page'\n};\nconst CarouselResourceStringsEN = {\n  igx_carousel_of: 'of',\n  igx_carousel_slide: 'slide',\n  igx_carousel_previous_slide: 'previous slide',\n  igx_carousel_next_slide: 'next slide'\n};\nconst ChipResourceStringsEN = {\n  igx_chip_remove: 'remove chip',\n  igx_chip_select: 'select chip'\n};\nconst ListResourceStringsEN = {\n  igx_list_no_items: 'There are no items in the list.',\n  igx_list_loading: 'Loading data from the server...'\n};\nconst CalendarResourceStringsEN = {\n  igx_calendar_previous_month: 'Previous Month',\n  igx_calendar_next_month: 'Next Month',\n  igx_calendar_select_month: 'Select Month',\n  igx_calendar_select_year: 'Select Year',\n  igx_calendar_range_start: 'Range start',\n  igx_calendar_range_end: 'Range end',\n  igx_calendar_selected_month_is: 'Selected month is ',\n  igx_calendar_first_picker_of: 'First picker of {0} starts from',\n  igx_calendar_multi_selection: 'Multi selection calendar with {0} date pickers',\n  igx_calendar_range_selection: 'Range selection calendar with {0} date pickers',\n  igx_calendar_single_selection: 'Calendar with {0} date pickers',\n  igx_calendar_singular_multi_selection: 'Multi selection calendar',\n  igx_calendar_singular_range_selection: 'Range selection calendar',\n  igx_calendar_singular_single_selection: 'Calendar'\n};\nconst InputResourceStringsEN = {\n  igx_input_upload_button: 'Upload File',\n  igx_input_clear_button: 'clear',\n  igx_input_file_placeholder: 'No file chosen'\n};\nconst TreeResourceStringsEN = {\n  igx_expand: 'Expand',\n  igx_collapse: 'Collapse'\n};\nconst ActionStripResourceStringsEN = {\n  igx_action_strip_button_more_title: 'More'\n};\n/**\n * @hidden\n * IF YOU EDIT THIS OBJECT, DO NOT FORGET TO UPDATE\n * projects/igniteui-angular-i18n as well (create the appropriately named files,\n * containing the new/updated component string keys and EN strings for values + create a separate issue + pending-localization label)\n *\n * TODO Add automation tests:\n * 1) each of the folders/languages under \\projects\\igniteui-angular-i18n\\src\\ contain resources.ts file with matching components count.\n *    \\projects\\igniteui-angular-i18n\\src\\BG\\resources.ts contains IgxResourceStringsBG.count matching this.CurrentResourceStrings.count\n * 2) \\igniteui-angular\\projects\\igniteui-angular\\src\\public_api.ts --> Check if the new interface is added\n *    to IInputResourceStrings (just a proxy as it is later on imported in the angular-i18n package)\n */\n\nconst CurrentResourceStrings = {\n  GridResStrings: cloneValue(GridResourceStringsEN),\n  PaginatorResStrings: cloneValue(PaginatorResourceStringsEN),\n  TimePickerResStrings: cloneValue(TimePickerResourceStringsEN),\n  CalendarResStrings: cloneValue(CalendarResourceStringsEN),\n  ChipResStrings: cloneValue(ChipResourceStringsEN),\n  DatePickerResourceStrings: cloneValue(DatePickerResourceStringsEN),\n  DateRangePickerResStrings: cloneValue(DateRangePickerResourceStringsEN),\n  CarouselResStrings: cloneValue(CarouselResourceStringsEN),\n  ListResStrings: cloneValue(ListResourceStringsEN),\n  InputResStrings: cloneValue(InputResourceStringsEN),\n  TreeResStrings: cloneValue(TreeResourceStringsEN),\n  ActionStripResourceStrings: cloneValue(ActionStripResourceStringsEN)\n};\n\nconst updateResourceStrings = (currentStrings, newStrings) => {\n  for (const key of Object.keys(newStrings)) {\n    if (key in currentStrings) {\n      currentStrings[key] = newStrings[key];\n    }\n  }\n};\n/**\n * Changes the resource strings for all components in the application\n * ```\n * @param resourceStrings to be applied\n */\n\n\nconst changei18n = resourceStrings => {\n  for (const key of Object.keys(CurrentResourceStrings)) {\n    updateResourceStrings(CurrentResourceStrings[key], resourceStrings);\n  }\n};\n/**\n * Returns current resource strings for all components\n */\n\n\nconst getCurrentResourceStrings = () => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, CurrentResourceStrings.CalendarResStrings), CurrentResourceStrings.CarouselResStrings), CurrentResourceStrings.ChipResStrings), CurrentResourceStrings.DatePickerResourceStrings), CurrentResourceStrings.DateRangePickerResStrings), CurrentResourceStrings.GridResStrings), CurrentResourceStrings.InputResStrings), CurrentResourceStrings.ListResStrings), CurrentResourceStrings.PaginatorResStrings), CurrentResourceStrings.TimePickerResStrings), CurrentResourceStrings.TreeResStrings), CurrentResourceStrings.ActionStripResourceStrings);\n\nconst IgxButtonType = mkenum({\n  Flat: 'flat',\n  Raised: 'raised',\n  Outlined: 'outlined',\n  Icon: 'icon',\n  FAB: 'fab'\n});\n/**\n * The Button directive provides the Ignite UI Button functionality to every component that's intended to be used as a button.\n *\n * @igxModule IgxButtonModule\n *\n * @igxParent Data Entry & Display\n *\n * @igxTheme igx-button-theme\n *\n * @igxKeywords button, span, div, click\n *\n * @remarks\n * The Ignite UI Button directive is intended to be used by any button, span or div and turn it into a fully functional button.\n *\n * @example\n * ```html\n * <button igxButton=\"outlined\">A Button</button>\n * ```\n */\n\nlet IgxButtonDirective = /*#__PURE__*/(() => {\n  class IgxButtonDirective extends DisplayDensityBase {\n    constructor(element, _renderer, _displayDensityOptions) {\n      super(_displayDensityOptions);\n      this.element = element;\n      this._renderer = _renderer;\n      this._displayDensityOptions = _displayDensityOptions;\n      /**\n       * Called when the button is clicked.\n       */\n\n      this.buttonClick = new EventEmitter();\n      /**\n       * Called when the button is selected.\n       */\n\n      this.buttonSelected = new EventEmitter();\n      /**\n       * Sets/gets the `role` attribute.\n       *\n       * @example\n       * ```typescript\n       * this.button.role = 'navbutton';\n       * let buttonRole = this.button.role;\n       * ```\n       */\n\n      this.role = 'button';\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this._cssClass = 'igx-button';\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this._disabled = false;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this._selected = false;\n    }\n    /**\n     * Gets or sets whether the button is selected.\n     * Mainly used in the IgxButtonGroup component and it will have no effect if set separately.\n     *\n     * @example\n     * ```html\n     * <button igxButton=\"flat\" [selected]=\"button.selected\"></button>\n     * ```\n     */\n\n\n    set selected(value) {\n      if (this._selected !== value) {\n        if (!this._selected) {\n          this.buttonSelected.emit({\n            button: this\n          });\n        }\n\n        this._selected = value;\n      }\n    }\n\n    get selected() {\n      return this._selected;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onClick(ev) {\n      this.buttonClick.emit(ev);\n    }\n    /**\n     * Returns the underlying DOM element.\n     */\n\n\n    get nativeElement() {\n      return this.element.nativeElement;\n    }\n    /**\n     * Sets the type of the button.\n     *\n     * @example\n     * ```html\n     * <button igxButton=\"icon\"></button>\n     * ```\n     */\n\n\n    set type(type) {\n      const t = type ? type : IgxButtonType.Flat;\n\n      if (this._type !== t) {\n        this._type = t;\n      }\n    }\n    /**\n     * Sets the button text color.\n     *\n     * @example\n     * ```html\n     * <button igxButton igxButtonColor=\"orange\"></button>\n     * ```\n     */\n\n\n    set color(value) {\n      this._color = value || this.nativeElement.style.color;\n\n      this._renderer.setStyle(this.nativeElement, 'color', this._color);\n    }\n    /**\n     * Sets the background color of the button.\n     *\n     * @example\n     *  ```html\n     * <button igxButton igxButtonBackground=\"red\"></button>\n     * ```\n     */\n\n\n    set background(value) {\n      this._backgroundColor = value || this._backgroundColor;\n\n      this._renderer.setStyle(this.nativeElement, 'background', this._backgroundColor);\n    }\n    /**\n     * Sets the `aria-label` attribute.\n     *\n     * @example\n     *  ```html\n     * <button igxButton=\"flat\" igxLabel=\"Label\"></button>\n     * ```\n     */\n\n\n    set label(value) {\n      this._label = value || this._label;\n\n      this._renderer.setAttribute(this.nativeElement, 'aria-label', this._label);\n    }\n    /**\n     * Get the disabled state of the button;\n     *\n     * @example\n     * ```typescript\n     * const disabled = this.button.disabled;\n     * ```\n     */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n    /**\n     * Enables/disables the button.\n     *\n     * @example\n     * ```html\n     * <button igxButton= \"fab\" [disabled]=\"true\"></button>\n     * ```\n     */\n\n\n    set disabled(val) {\n      this._disabled = val === '' || val;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get flat() {\n      return this._type === IgxButtonType.Flat;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get raised() {\n      return this._type === IgxButtonType.Raised;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get outlined() {\n      return this._type === IgxButtonType.Outlined;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get icon() {\n      return this._type === IgxButtonType.Icon;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get fab() {\n      return this._type === IgxButtonType.FAB;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get cosy() {\n      return this.displayDensity === DisplayDensity.cosy;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get compact() {\n      return this.displayDensity === DisplayDensity.compact;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get disabledAttribute() {\n      return this._disabled ? this._disabled : null;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    select() {\n      this.selected = true;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    deselect() {\n      this._selected = false;\n    }\n\n  }\n\n  IgxButtonDirective.ɵfac = function IgxButtonDirective_Factory(t) {\n    return new (t || IgxButtonDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DisplayDensityToken, 8));\n  };\n\n  IgxButtonDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxButtonDirective,\n    selectors: [[\"\", \"igxButton\", \"\"]],\n    hostVars: 20,\n    hostBindings: function IgxButtonDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function IgxButtonDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"disabled\", ctx.disabledAttribute);\n        i0.ɵɵclassProp(\"igx-button\", ctx._cssClass)(\"igx-button--disabled\", ctx.disabled)(\"igx-button--flat\", ctx.flat)(\"igx-button--raised\", ctx.raised)(\"igx-button--outlined\", ctx.outlined)(\"igx-button--icon\", ctx.icon)(\"igx-button--fab\", ctx.fab)(\"igx-button--cosy\", ctx.cosy)(\"igx-button--compact\", ctx.compact);\n      }\n    },\n    inputs: {\n      selected: \"selected\",\n      type: [\"igxButton\", \"type\"],\n      color: [\"igxButtonColor\", \"color\"],\n      background: [\"igxButtonBackground\", \"background\"],\n      label: [\"igxLabel\", \"label\"],\n      disabled: \"disabled\"\n    },\n    outputs: {\n      buttonClick: \"buttonClick\",\n      buttonSelected: \"buttonSelected\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return IgxButtonDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n *\n * @hidden\n */\n\n\nlet IgxButtonModule = /*#__PURE__*/(() => {\n  class IgxButtonModule {}\n\n  IgxButtonModule.ɵfac = function IgxButtonModule_Factory(t) {\n    return new (t || IgxButtonModule)();\n  };\n\n  IgxButtonModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxButtonModule\n  });\n  IgxButtonModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return IgxButtonModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IgxHintPosition = /*#__PURE__*/(() => {\n  (function (IgxHintPosition) {\n    IgxHintPosition[IgxHintPosition[\"START\"] = 0] = \"START\";\n    IgxHintPosition[IgxHintPosition[\"END\"] = 1] = \"END\";\n  })(IgxHintPosition || (IgxHintPosition = {}));\n\n  return IgxHintPosition;\n})();\nlet IgxHintDirective = /*#__PURE__*/(() => {\n  class IgxHintDirective {\n    constructor() {\n      /**\n       * Sets/gets whether the hint position is at the start.\n       * Default value is `false`.\n       * ```typescript\n       * @ViewChild('hint', {read: IgxHintDirective})\n       * public igxHint: IgxHintDirective;\n       * this.igxHint.isPositionStart = true;\n       * ```\n       * ```typescript\n       * let isHintPositionStart = this.igxHint.isPositionStart;\n       * ```\n       *\n       * @memberof IgxHintDirective\n       */\n      this.isPositionStart = false;\n      /**\n       * Sets/gets whether the hint position is at the end.\n       * Default value is `false`.\n       * ```typescript\n       * @ViewChild('hint', {read: IgxHintDirective})\n       * public igxHint: IgxHintDirective;\n       * this.igxHint.isPositionEnd = true;\n       * ```\n       * ```typescript\n       * let isHintPositionEnd = this.igxHint.isPositionEnd;\n       * ```\n       *\n       * @memberof IgxHintDirective\n       */\n\n      this.isPositionEnd = false;\n      this._position = IgxHintPosition.START;\n    }\n    /**\n     * Sets the position of the hint.\n     * ```html\n     * <igx-input-group>\n     *  <input igxInput type=\"text\"/>\n     *  <igx-hint #hint [position]=\"'start'\">IgxHint displayed at the start</igx-hint>\n     * </igx-input-group>\n     * ```\n     *\n     * @memberof IgxHintDirective\n     */\n\n\n    set position(value) {\n      const position = IgxHintPosition[value.toUpperCase()];\n\n      if (position !== undefined) {\n        this._position = position;\n\n        this._applyPosition(this._position);\n      }\n    }\n    /**\n     * Gets the position of the hint.\n     * ```typescript\n     * @ViewChild('hint', {read: IgxHintDirective})\n     * public igxHint: IgxHintDirective;\n     * let hintPosition =  this.igxHint.position;\n     * ```\n     *\n     * @memberof IgxHintDirective\n     */\n\n\n    get position() {\n      return this._position.toString();\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      this._applyPosition(this._position);\n    }\n\n    _applyPosition(position) {\n      this.isPositionStart = this.isPositionEnd = false;\n\n      switch (position) {\n        case IgxHintPosition.START:\n          this.isPositionStart = true;\n          break;\n\n        case IgxHintPosition.END:\n          this.isPositionEnd = true;\n          break;\n\n        default:\n          break;\n      }\n    }\n\n  }\n\n  IgxHintDirective.ɵfac = function IgxHintDirective_Factory(t) {\n    return new (t || IgxHintDirective)();\n  };\n\n  IgxHintDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxHintDirective,\n    selectors: [[\"igx-hint\"], [\"\", \"igxHint\", \"\"]],\n    hostVars: 4,\n    hostBindings: function IgxHintDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-input-group__hint-item--start\", ctx.isPositionStart)(\"igx-input-group__hint-item--end\", ctx.isPositionEnd);\n      }\n    },\n    inputs: {\n      position: \"position\"\n    }\n  });\n  return IgxHintDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nclass IgxInputGroupBase {}\n\nconst nativeValidationAttributes = ['required', 'pattern', 'minlength', 'maxlength', 'min', 'max', 'step'];\nvar IgxInputState = /*#__PURE__*/(() => {\n  (function (IgxInputState) {\n    IgxInputState[IgxInputState[\"INITIAL\"] = 0] = \"INITIAL\";\n    IgxInputState[IgxInputState[\"VALID\"] = 1] = \"VALID\";\n    IgxInputState[IgxInputState[\"INVALID\"] = 2] = \"INVALID\";\n  })(IgxInputState || (IgxInputState = {}));\n\n  return IgxInputState;\n})();\n\n/**\n * The `igxInput` directive creates single- or multiline text elements, covering common scenarios when dealing with form inputs.\n *\n * @igxModule IgxInputGroupModule\n *\n * @igxParent Data Entry & Display\n *\n * @igxTheme igx-input-group-theme\n *\n * @igxKeywords input, input group, form, field, validation\n *\n * @igxGroup presentation\n *\n * @example\n * ```html\n * <input-group>\n *  <label for=\"address\">Address</label>\n *  <input igxInput name=\"address\" type=\"text\" [(ngModel)]=\"customer.address\">\n * </input-group>\n * ```\n */\nlet IgxInputDirective = /*#__PURE__*/(() => {\n  class IgxInputDirective {\n    constructor(inputGroup, ngModel, formControl, element, cdr, renderer) {\n      this.inputGroup = inputGroup;\n      this.ngModel = ngModel;\n      this.formControl = formControl;\n      this.element = element;\n      this.cdr = cdr;\n      this.renderer = renderer;\n      /**\n       * Sets/gets whether the `\"igx-input-group__input\"` class is added to the host element.\n       * Default value is `false`.\n       *\n       * @example\n       * ```typescript\n       * this.igxInput.isInput = true;\n       * ```\n       *\n       * @example\n       * ```typescript\n       * let isCLassAdded = this.igxInput.isInput;\n       * ```\n       */\n\n      this.isInput = false;\n      /**\n       * Sets/gets whether the `\"class.igx-input-group__textarea\"` class is added to the host element.\n       * Default value is `false`.\n       *\n       * @example\n       * ```typescript\n       * this.igxInput.isTextArea = true;\n       * ```\n       *\n       * @example\n       * ```typescript\n       * let isCLassAdded = this.igxInput.isTextArea;\n       * ```\n       */\n\n      this.isTextArea = false;\n      this._valid = IgxInputState.INITIAL;\n      this._disabled = false;\n    }\n\n    get ngControl() {\n      return this.ngModel ? this.ngModel : this.formControl;\n    }\n    /**\n     * Sets the `value` property.\n     *\n     * @example\n     * ```html\n     * <input-group>\n     *  <input igxInput #igxInput [value]=\"'IgxInput Value'\">\n     * </input-group>\n     * ```\n     */\n\n\n    set value(value) {\n      this.nativeElement.value = value !== null && value !== void 0 ? value : '';\n      this.updateValidityState();\n    }\n    /**\n     * Gets the `value` property.\n     *\n     * @example\n     * ```typescript\n     * @ViewChild('igxInput', {read: IgxInputDirective})\n     *  public igxInput: IgxInputDirective;\n     * let inputValue = this.igxInput.value;\n     * ```\n     */\n\n\n    get value() {\n      return this.nativeElement.value;\n    }\n    /**\n     * Sets the `disabled` property.\n     *\n     * @example\n     * ```html\n     * <input-group>\n     *  <input igxInput #igxInput [disabled]=\"true\">\n     * </input-group>\n     * ```\n     */\n\n\n    set disabled(value) {\n      this._disabled = this.inputGroup.disabled = !!(value === '' || value);\n\n      if (this.focused && this._disabled) {\n        // Browser focus may not fire in good time and mess with change detection, adjust here in advance:\n        this.inputGroup.isFocused = false;\n      }\n    }\n    /**\n     * Gets the `disabled` property\n     *\n     * @example\n     * ```typescript\n     * @ViewChild('igxInput', {read: IgxInputDirective})\n     *  public igxInput: IgxInputDirective;\n     * let isDisabled = this.igxInput.disabled;\n     * ```\n     */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n    /**\n     * Sets the `required` property.\n     *\n     * @example\n     * ```html\n     * <input-group>\n     *  <input igxInput #igxInput required>\n     * </input-group>\n     * ```\n     */\n\n\n    set required(value) {\n      this.nativeElement.required = this.inputGroup.isRequired = value === '' || value;\n    }\n    /**\n     * Gets whether the igxInput is required.\n     *\n     * @example\n     * ```typescript\n     * let isRequired = this.igxInput.required;\n     * ```\n     */\n\n\n    get required() {\n      let validation;\n\n      if (this.ngControl && (this.ngControl.control.validator || this.ngControl.control.asyncValidator)) {\n        validation = this.ngControl.control.validator({});\n      }\n\n      return validation && validation.required || this.nativeElement.hasAttribute('required');\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onFocus() {\n      this.inputGroup.isFocused = true;\n    }\n    /**\n     * @param event The event to invoke the handler\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    onBlur() {\n      this.inputGroup.isFocused = false;\n      this.updateValidityState();\n    }\n    /** @hidden @internal */\n\n\n    onInput() {\n      this.checkNativeValidity();\n    }\n    /** @hidden @internal */\n\n\n    change(event) {\n      if (this.type === 'file') {\n        const fileList = event.target.files;\n        const fileArray = [];\n\n        if (fileList) {\n          for (const file of Array.from(fileList)) {\n            fileArray.push(file);\n          }\n        }\n\n        this._fileNames = (fileArray || []).map(f => f.name).join(', ');\n\n        if (this.required && (fileList === null || fileList === void 0 ? void 0 : fileList.length) > 0) {\n          this._valid = IgxInputState.INITIAL;\n        }\n      }\n    }\n    /** @hidden @internal */\n\n\n    get fileNames() {\n      return this._fileNames;\n    }\n    /** @hidden @internal */\n\n\n    clear() {\n      var _a, _b;\n\n      (_b = (_a = this.ngControl) === null || _a === void 0 ? void 0 : _a.control) === null || _b === void 0 ? void 0 : _b.setValue('');\n      this.nativeElement.value = null;\n      this._fileNames = '';\n    }\n    /** @hidden @internal */\n\n\n    ngAfterViewInit() {\n      this.inputGroup.hasPlaceholder = this.nativeElement.hasAttribute('placeholder');\n\n      if (this.ngControl && this.ngControl.disabled !== null) {\n        this.disabled = this.ngControl.disabled;\n      }\n\n      this.inputGroup.disabled = this.inputGroup.disabled || this.nativeElement.hasAttribute('disabled');\n      this.inputGroup.isRequired = this.nativeElement.hasAttribute('required'); // Make sure we do not invalidate the input on init\n\n      if (!this.ngControl) {\n        this._valid = IgxInputState.INITIAL;\n      } // Also check the control's validators for required\n\n\n      if (this.required && !this.inputGroup.isRequired) {\n        this.inputGroup.isRequired = this.required;\n      }\n\n      this.renderer.setAttribute(this.nativeElement, 'aria-required', this.required.toString());\n      const elTag = this.nativeElement.tagName.toLowerCase();\n\n      if (elTag === 'textarea') {\n        this.isTextArea = true;\n      } else {\n        this.isInput = true;\n      }\n\n      if (this.ngControl) {\n        this._statusChanges$ = this.ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));\n      }\n\n      this.cdr.detectChanges();\n    }\n    /** @hidden @internal */\n\n\n    ngOnDestroy() {\n      if (this._statusChanges$) {\n        this._statusChanges$.unsubscribe();\n      }\n    }\n    /**\n     * Sets a focus on the igxInput.\n     *\n     * @example\n     * ```typescript\n     * this.igxInput.focus();\n     * ```\n     */\n\n\n    focus() {\n      this.nativeElement.focus();\n    }\n    /**\n     * Gets the `nativeElement` of the igxInput.\n     *\n     * @example\n     * ```typescript\n     * let igxInputNativeElement = this.igxInput.nativeElement;\n     * ```\n     */\n\n\n    get nativeElement() {\n      return this.element.nativeElement;\n    }\n    /** @hidden @internal */\n\n\n    onStatusChanged() {\n      // Enable/Disable control based on ngControl #7086\n      if (this.disabled !== this.ngControl.disabled) {\n        this.disabled = this.ngControl.disabled;\n      }\n\n      this.updateValidityState();\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    updateValidityState() {\n      if (this.ngControl) {\n        if (this.ngControl.control.validator || this.ngControl.control.asyncValidator) {\n          // Run the validation with empty object to check if required is enabled.\n          const error = this.ngControl.control.validator({});\n          this.inputGroup.isRequired = error && error.required;\n\n          if (!this.disabled && (this.ngControl.control.touched || this.ngControl.control.dirty)) {\n            // the control is not disabled and is touched or dirty\n            this._valid = this.ngControl.invalid ? IgxInputState.INVALID : this.focused ? IgxInputState.VALID : IgxInputState.INITIAL;\n          } else {\n            //  if control is untouched, pristine, or disabled its state is initial. This is when user did not interact\n            //  with the input or when form/control is reset\n            this._valid = IgxInputState.INITIAL;\n          }\n        } else {\n          // If validator is dynamically cleared, reset label's required class(asterisk) and IgxInputState #10010\n          this._valid = IgxInputState.INITIAL;\n          this.inputGroup.isRequired = false;\n        }\n\n        this.renderer.setAttribute(this.nativeElement, 'aria-required', this.required.toString());\n        const ariaInvalid = this.valid === IgxInputState.INVALID;\n        this.renderer.setAttribute(this.nativeElement, 'aria-invalid', ariaInvalid.toString());\n      } else {\n        this.checkNativeValidity();\n      }\n    }\n    /**\n     * Gets whether the igxInput has a placeholder.\n     *\n     * @example\n     * ```typescript\n     * let hasPlaceholder = this.igxInput.hasPlaceholder;\n     * ```\n     */\n\n\n    get hasPlaceholder() {\n      return this.nativeElement.hasAttribute('placeholder');\n    }\n    /**\n     * Gets the placeholder element of the igxInput.\n     *\n     * @example\n     * ```typescript\n     * let igxInputPlaceholder = this.igxInput.placeholder;\n     * ```\n     */\n\n\n    get placeholder() {\n      return this.nativeElement.placeholder;\n    }\n    /**\n     * @returns An indicator of whether the input has validator attributes or not\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    _hasValidators() {\n      for (const nativeValidationAttribute of nativeValidationAttributes) {\n        if (this.nativeElement.hasAttribute(nativeValidationAttribute)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Gets whether the igxInput is focused.\n     *\n     * @example\n     * ```typescript\n     * let isFocused = this.igxInput.focused;\n     * ```\n     */\n\n\n    get focused() {\n      return this.inputGroup.isFocused;\n    }\n    /**\n     * Gets the state of the igxInput.\n     *\n     * @example\n     * ```typescript\n     * let igxInputState = this.igxInput.valid;\n     * ```\n     */\n\n\n    get valid() {\n      return this._valid;\n    }\n    /**\n     * Sets the state of the igxInput.\n     *\n     * @example\n     * ```typescript\n     * this.igxInput.valid = IgxInputState.INVALID;\n     * ```\n     */\n\n\n    set valid(value) {\n      this._valid = value;\n    }\n    /**\n     * Gets whether the igxInput is valid.\n     *\n     * @example\n     * ```typescript\n     * let valid = this.igxInput.isValid;\n     * ```\n     */\n\n\n    get isValid() {\n      return this.valid !== IgxInputState.INVALID;\n    }\n    /**\n     * A function to assign a native validity property of an input.\n     * This should be used when there's no ngControl\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    checkNativeValidity() {\n      if (!this.disabled && this._hasValidators()) {\n        this._valid = this.nativeElement.checkValidity() ? this.focused ? IgxInputState.VALID : IgxInputState.INITIAL : IgxInputState.INVALID;\n      }\n    }\n    /**\n     * Returns the input type.\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    get type() {\n      return this.nativeElement.type;\n    }\n\n  }\n\n  IgxInputDirective.ɵfac = function IgxInputDirective_Factory(t) {\n    return new (t || IgxInputDirective)(i0.ɵɵdirectiveInject(IgxInputGroupBase), i0.ɵɵdirectiveInject(NgModel, 10), i0.ɵɵdirectiveInject(FormControlName, 10), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  IgxInputDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxInputDirective,\n    selectors: [[\"\", \"igxInput\", \"\"]],\n    hostVars: 5,\n    hostBindings: function IgxInputDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focus\", function IgxInputDirective_focus_HostBindingHandler() {\n          return ctx.onFocus();\n        })(\"blur\", function IgxInputDirective_blur_HostBindingHandler() {\n          return ctx.onBlur();\n        })(\"input\", function IgxInputDirective_input_HostBindingHandler() {\n          return ctx.onInput();\n        })(\"change\", function IgxInputDirective_change_HostBindingHandler($event) {\n          return ctx.change($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵhostProperty(\"disabled\", ctx.disabled);\n        i0.ɵɵclassProp(\"igx-input-group__input\", ctx.isInput)(\"igx-input-group__textarea\", ctx.isTextArea);\n      }\n    },\n    inputs: {\n      value: \"value\",\n      disabled: \"disabled\",\n      required: \"required\"\n    },\n    exportAs: [\"igxInput\"]\n  });\n  return IgxInputDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$s = 0;\nlet IgxLabelDirective = /*#__PURE__*/(() => {\n  class IgxLabelDirective {\n    constructor() {\n      this.defaultClass = true;\n      /**\n       * @hidden\n       */\n\n      this.id = `igx-label-${NEXT_ID$s++}`;\n    }\n\n  }\n\n  IgxLabelDirective.ɵfac = function IgxLabelDirective_Factory(t) {\n    return new (t || IgxLabelDirective)();\n  };\n\n  IgxLabelDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxLabelDirective,\n    selectors: [[\"\", \"igxLabel\", \"\"]],\n    hostVars: 3,\n    hostBindings: function IgxLabelDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id);\n        i0.ɵɵclassProp(\"igx-input-group__label\", ctx.defaultClass);\n      }\n    },\n    inputs: {\n      id: \"id\"\n    }\n  });\n  return IgxLabelDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxPrefixDirective = /*#__PURE__*/(() => {\n  class IgxPrefixDirective {}\n\n  IgxPrefixDirective.ɵfac = function IgxPrefixDirective_Factory(t) {\n    return new (t || IgxPrefixDirective)();\n  };\n\n  IgxPrefixDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxPrefixDirective,\n    selectors: [[\"igx-prefix\"], [\"\", \"igxPrefix\", \"\"]]\n  });\n  return IgxPrefixDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxPrefixModule = /*#__PURE__*/(() => {\n  class IgxPrefixModule {}\n\n  IgxPrefixModule.ɵfac = function IgxPrefixModule_Factory(t) {\n    return new (t || IgxPrefixModule)();\n  };\n\n  IgxPrefixModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxPrefixModule\n  });\n  IgxPrefixModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return IgxPrefixModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxSuffixDirective = /*#__PURE__*/(() => {\n  class IgxSuffixDirective {}\n\n  IgxSuffixDirective.ɵfac = function IgxSuffixDirective_Factory(t) {\n    return new (t || IgxSuffixDirective)();\n  };\n\n  IgxSuffixDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxSuffixDirective,\n    selectors: [[\"igx-suffix\"], [\"\", \"igxSuffix\", \"\"]]\n  });\n  return IgxSuffixDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxSuffixModule = /*#__PURE__*/(() => {\n  class IgxSuffixModule {}\n\n  IgxSuffixModule.ɵfac = function IgxSuffixModule_Factory(t) {\n    return new (t || IgxSuffixModule)();\n  };\n\n  IgxSuffixModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxSuffixModule\n  });\n  IgxSuffixModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return IgxSuffixModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * **Ignite UI for Angular Icon Service** -\n *\n * The Ignite UI Icon Service makes it easy for developers to include custom SVG images and use them with IgxIconComponent.\n * In addition it could be used to associate a custom class to be applied on IgxIconComponent according to given font-family.\n *\n * Example:\n * ```typescript\n * this.iconService.registerFamilyAlias('material', 'material-icons');\n * this.iconService.addSvgIcon('aruba', '/assets/svg/country_flags/aruba.svg', 'svg-flags');\n * ```\n */\n\n\nlet IgxIconService = /*#__PURE__*/(() => {\n  class IgxIconService {\n    constructor(_sanitizer, _httpClient, _platformUtil, _document) {\n      var _a;\n\n      this._sanitizer = _sanitizer;\n      this._httpClient = _httpClient;\n      this._platformUtil = _platformUtil;\n      this._document = _document;\n      this._family = 'material-icons';\n      this._familyAliases = new Map();\n      this._cachedSvgIcons = new Map();\n      this._iconLoaded = new Subject();\n      this.iconLoaded = this._iconLoaded.asObservable();\n\n      if ((_a = this._platformUtil) === null || _a === void 0 ? void 0 : _a.isBrowser) {\n        this._domParser = new DOMParser();\n      }\n    }\n    /**\n     *  Returns the default font-family.\n     * ```typescript\n     *   const defaultFamily = this.iconService.defaultFamily;\n     * ```\n     */\n\n\n    get defaultFamily() {\n      return this._family;\n    }\n    /**\n     *  Sets the default font-family.\n     * ```typescript\n     *   this.iconService.defaultFamily = 'svg-flags';\n     * ```\n     */\n\n\n    set defaultFamily(className) {\n      this._family = className;\n    }\n    /**\n     *  Registers a custom class to be applied to IgxIconComponent for a given font-family.\n     * ```typescript\n     *   this.iconService.registerFamilyAlias('material', 'material-icons');\n     * ```\n     */\n\n\n    registerFamilyAlias(alias, className = alias) {\n      this._familyAliases.set(alias, className);\n\n      return this;\n    }\n    /**\n     *  Returns the custom class, if any, associated to a given font-family.\n     * ```typescript\n     *   const familyClass = this.iconService.familyClassName('material');\n     * ```\n     */\n\n\n    familyClassName(alias) {\n      return this._familyAliases.get(alias) || alias;\n    }\n    /**\n     *  Adds an SVG image to the cache. SVG source is an url.\n     * ```typescript\n     *   this.iconService.addSvgIcon('aruba', '/assets/svg/country_flags/aruba.svg', 'svg-flags');\n     * ```\n     */\n\n\n    addSvgIcon(name, url, family = this._family, stripMeta = false) {\n      if (name && url) {\n        const safeUrl = this._sanitizer.bypassSecurityTrustResourceUrl(url);\n\n        if (!safeUrl) {\n          throw new Error(`The provided URL could not be processed as trusted resource URL by Angular's DomSanitizer: \"${url}\".`);\n        }\n\n        const sanitizedUrl = this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, safeUrl);\n\n        if (!sanitizedUrl) {\n          throw new Error(`The URL provided was not trusted as a resource URL: \"${url}\".`);\n        }\n\n        if (!this.isSvgIconCached(name, family)) {\n          this.fetchSvg(url).subscribe(res => {\n            this.cacheSvgIcon(name, res, family, stripMeta);\n\n            this._iconLoaded.next({\n              name,\n              value: res,\n              family\n            });\n          });\n        }\n      } else {\n        throw new Error('You should provide at least `name` and `url` to register an svg icon.');\n      }\n    }\n    /**\n     *  Adds an SVG image to the cache. SVG source is its text.\n     * ```typescript\n     *   this.iconService.addSvgIconFromText('simple', '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 200 200\">\n     *   <path d=\"M74 74h54v54H74\" /></svg>', 'svg-flags');\n     * ```\n     */\n\n\n    addSvgIconFromText(name, iconText, family = '', stripMeta = false) {\n      if (name && iconText) {\n        if (this.isSvgIconCached(name, family)) {\n          return;\n        }\n\n        this.cacheSvgIcon(name, iconText, family, stripMeta);\n      } else {\n        throw new Error('You should provide at least `name` and `iconText` to register an svg icon.');\n      }\n    }\n    /**\n     *  Returns whether a given SVG image is present in the cache.\n     * ```typescript\n     *   const isSvgCached = this.iconService.isSvgIconCached('aruba', 'svg-flags');\n     * ```\n     */\n\n\n    isSvgIconCached(name, family = '') {\n      const familyClassName = this.familyClassName(family);\n\n      if (this._cachedSvgIcons.has(familyClassName)) {\n        const familyRegistry = this._cachedSvgIcons.get(familyClassName);\n\n        return familyRegistry.has(name);\n      }\n\n      return false;\n    }\n    /**\n     *  Returns the cached SVG image as string.\n     * ```typescript\n     *   const svgIcon = this.iconService.getSvgIcon('aruba', 'svg-flags');\n     * ```\n     */\n\n\n    getSvgIcon(name, family = '') {\n      var _a;\n\n      const familyClassName = this.familyClassName(family);\n      return (_a = this._cachedSvgIcons.get(familyClassName)) === null || _a === void 0 ? void 0 : _a.get(name);\n    }\n    /**\n     * @hidden\n     */\n\n\n    fetchSvg(url) {\n      const req = this._httpClient.get(url, {\n        responseType: 'text'\n      });\n\n      return req;\n    }\n    /**\n     * @hidden\n     */\n\n\n    cacheSvgIcon(name, value, family = this._family, stripMeta) {\n      var _a;\n\n      family = !!family ? family : this._family;\n\n      if (((_a = this._platformUtil) === null || _a === void 0 ? void 0 : _a.isBrowser) && name && value) {\n        const doc = this._domParser.parseFromString(value, 'image/svg+xml');\n\n        const svg = doc.querySelector('svg');\n\n        if (!this._cachedSvgIcons.has(family)) {\n          this._cachedSvgIcons.set(family, new Map());\n        }\n\n        if (svg) {\n          svg.setAttribute('fit', '');\n          svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n\n          if (stripMeta) {\n            const title = svg.querySelector('title');\n            const desc = svg.querySelector('desc');\n\n            if (title) {\n              svg.removeChild(title);\n            }\n\n            if (desc) {\n              svg.removeChild(desc);\n            }\n          }\n\n          const safeSvg = this._sanitizer.bypassSecurityTrustHtml(svg.outerHTML);\n\n          this._cachedSvgIcons.get(family).set(name, safeSvg);\n        }\n      }\n    }\n\n  }\n\n  IgxIconService.ɵfac = function IgxIconService_Factory(t) {\n    return new (t || IgxIconService)(i0.ɵɵinject(i1$1.DomSanitizer, 8), i0.ɵɵinject(i2.HttpClient, 8), i0.ɵɵinject(PlatformUtil, 8), i0.ɵɵinject(DOCUMENT, 8));\n  };\n\n  IgxIconService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxIconService,\n    factory: IgxIconService.ɵfac,\n    providedIn: 'root'\n  });\n  return IgxIconService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Icon provides a way to include material icons to markup\n *\n * @igxModule IgxIconModule\n *\n * @igxTheme igx-icon-theme\n *\n * @igxKeywords icon, picture\n *\n * @igxGroup Display\n *\n * @remarks\n *\n * The Ignite UI Icon makes it easy for developers to include material design icons directly in their markup. The icons\n * support different icon families and can be marked as active or disabled using the `active` property. This will change the appearance\n * of the icon.\n *\n * @example\n * ```html\n * <igx-icon family=\"filter-icons\" active=\"true\">home</igx-icon>\n * ```\n */\n\n\nlet IgxIconComponent = /*#__PURE__*/(() => {\n  class IgxIconComponent {\n    constructor(el, iconService, ref) {\n      this.el = el;\n      this.iconService = iconService;\n      this.ref = ref;\n      /**\n       *  This allows you to change the value of `class.igx-icon`. By default it's `igx-icon`.\n       *\n       * @hidden\n       * @internal\n       */\n\n      this.cssClass = 'igx-icon';\n      /**\n       *  This allows you to disable the `aria-hidden` attribute. By default it's applied.\n       *\n       * @example\n       * ```typescript\n       * @ViewChild(\"MyIcon\") public icon: IgxIconComponent;\n       * constructor(private cdRef:ChangeDetectorRef) {}\n       * ngAfterViewInit() {\n       *     this.icon.ariaHidden = false;\n       *     this.cdRef.detectChanges();\n       * }\n       * ```\n       */\n\n      this.ariaHidden = true;\n      /**\n       * An @Input property that allows you to disable the `active` property. By default it's applied.\n       *\n       * @example\n       * ```html\n       * <igx-icon [active]=\"false\">settings</igx-icon>\n       * ```\n       */\n\n      this.active = true;\n      this.destroy$ = new Subject();\n      this.family = this.iconService.defaultFamily;\n      this.iconService.registerFamilyAlias('material', 'material-icons');\n      this.iconService.iconLoaded.pipe(first$1(e => e.name === this.name && e.family === this.family), takeUntil(this.destroy$)).subscribe(() => this.ref.detectChanges());\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    ngOnInit() {\n      this.updateIconClass();\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n    /**\n     *  An accessor that returns the value of the family property.\n     *\n     * @example\n     * ```typescript\n     *  @ViewChild(\"MyIcon\")\n     * public icon: IgxIconComponent;\n     * ngAfterViewInit() {\n     *    let iconFamily = this.icon.getFamily;\n     * }\n     * ```\n     */\n\n\n    get getFamily() {\n      return this.family;\n    }\n    /**\n     *  An accessor that returns the value of the active property.\n     *\n     * @example\n     * ```typescript\n     * @ViewChild(\"MyIcon\")\n     * public icon: IgxIconComponent;\n     * ngAfterViewInit() {\n     *    let iconActive = this.icon.getActive;\n     * }\n     * ```\n     */\n\n\n    get getActive() {\n      return this.active;\n    }\n    /**\n     *  An accessor that returns inactive property.\n     *\n     * @example\n     * ```typescript\n     * @ViewChild(\"MyIcon\")\n     * public icon: IgxIconComponent;\n     * ngAfterViewInit() {\n     *    let iconActive = this.icon.getInactive;\n     * }\n     * ```\n     */\n\n\n    get getInactive() {\n      return !this.active;\n    }\n    /**\n     * An accessor that returns the value of the iconName property.\n     *\n     * @example\n     * ```typescript\n     * @ViewChild(\"MyIcon\")\n     * public icon: IgxIconComponent;\n     * ngAfterViewInit() {\n     *    let name = this.icon.getName;\n     * }\n     * ```\n     */\n\n\n    get getName() {\n      return this.name;\n    }\n    /**\n     *  An accessor that returns the underlying SVG image as SafeHtml.\n     *\n     * @example\n     * ```typescript\n     * @ViewChild(\"MyIcon\")\n     * public icon: IgxIconComponent;\n     * ngAfterViewInit() {\n     *    let svg: SafeHtml = this.icon.getSvg;\n     * }\n     * ```\n     */\n\n\n    get getSvg() {\n      if (this.iconService.isSvgIconCached(this.name, this.family)) {\n        return this.iconService.getSvgIcon(this.name, this.family);\n      }\n\n      return null;\n    }\n    /**\n     *   An accessor that returns a TemplateRef to explicit, svg or no ligature.\n     *\n     * @example\n     * ```typescript\n     * @ViewChild(\"MyIcon\")\n     * public icon: IgxIconComponent;\n     * ngAfterViewInit() {\n     *    let iconTemplate = this.icon.template;\n     * }\n     * ```\n     */\n\n\n    get template() {\n      if (this.name) {\n        if (this.iconService.isSvgIconCached(this.name, this.family)) {\n          return this.svgImage;\n        }\n\n        return this.noLigature;\n      }\n\n      return this.explicitLigature;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    updateIconClass() {\n      const className = this.iconService.familyClassName(this.family);\n      this.el.nativeElement.classList.add(className);\n\n      if (this.name && !this.iconService.isSvgIconCached(this.name, this.family)) {\n        this.el.nativeElement.classList.add(this.name);\n      }\n    }\n\n  }\n\n  IgxIconComponent.ɵfac = function IgxIconComponent_Factory(t) {\n    return new (t || IgxIconComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(IgxIconService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  IgxIconComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxIconComponent,\n    selectors: [[\"igx-icon\"]],\n    viewQuery: function IgxIconComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c9, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c10, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c11, 7, TemplateRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.noLigature = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.explicitLigature = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.svgImage = _t.first);\n      }\n    },\n    hostVars: 5,\n    hostBindings: function IgxIconComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-hidden\", ctx.ariaHidden);\n        i0.ɵɵclassProp(\"igx-icon\", ctx.cssClass)(\"igx-icon--inactive\", ctx.getInactive);\n      }\n    },\n    inputs: {\n      family: \"family\",\n      active: \"active\",\n      name: \"name\"\n    },\n    ngContentSelectors: _c8,\n    decls: 7,\n    vars: 1,\n    consts: [[\"noLigature\", \"\"], [\"explicitLigature\", \"\"], [\"svgImage\", \"\"], [4, \"ngTemplateOutlet\"], [3, \"innerHTML\"]],\n    template: function IgxIconComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, IgxIconComponent_ng_template_0_Template, 0, 0, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, IgxIconComponent_ng_template_2_Template, 1, 0, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(4, IgxIconComponent_ng_template_4_Template, 1, 1, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(6, IgxIconComponent_ng_container_6_Template, 1, 0, \"ng-container\", 3);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(6);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template);\n      }\n    },\n    directives: [i4.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return IgxIconComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxIconModule = /*#__PURE__*/(() => {\n  class IgxIconModule {}\n\n  IgxIconModule.ɵfac = function IgxIconModule_Factory(t) {\n    return new (t || IgxIconModule)();\n  };\n\n  IgxIconModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxIconModule\n  });\n  IgxIconModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return IgxIconModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst IgxInputGroupEnum = mkenum({\n  Line: 'line',\n  Box: 'box',\n  Border: 'border',\n  Search: 'search'\n});\n/**\n * Defines the InputGroupType DI token.\n */\n// Should this go trough Interface https://angular.io/api/core/InjectionToken\n\nconst IGX_INPUT_GROUP_TYPE = new InjectionToken('InputGroupType');\nconst IgxInputGroupTheme = mkenum({\n  Material: 'material',\n  Fluent: 'fluent',\n  Bootstrap: 'bootstrap',\n  IndigoDesign: 'indigo-design'\n});\nlet IgxInputGroupComponent = /*#__PURE__*/(() => {\n  class IgxInputGroupComponent extends DisplayDensityBase {\n    constructor(element, _displayDensityOptions, _inputGroupType, document, platform, cdr) {\n      super(_displayDensityOptions);\n      this.element = element;\n      this._inputGroupType = _inputGroupType;\n      this.document = document;\n      this.platform = platform;\n      this.cdr = cdr;\n      /**\n       * Property that enables/disables the auto-generated class of the `IgxInputGroupComponent`.\n       * By default applied the class is applied.\n       * ```typescript\n       *  @ViewChild(\"MyInputGroup\")\n       *  public inputGroup: IgxInputGroupComponent;\n       *  ngAfterViewInit(){\n       *  this.inputGroup.defaultClass = false;\n       * ```\n       * }\n       */\n\n      this.defaultClass = true;\n      /** @hidden */\n\n      this.hasPlaceholder = false;\n      /** @hidden */\n\n      this.isRequired = false;\n      /** @hidden */\n\n      this.isFocused = false;\n      /**\n       * @hidden @internal\n       * When truthy, disables the `IgxInputGroupComponent`.\n       * Controlled by the underlying `IgxInputDirective`.\n       * ```html\n       * <igx-input-group [disabled]=\"true\"></igx-input-group>\n       * ```\n       */\n\n      this.disabled = false;\n      /**\n       * Prevents automatically focusing the input when clicking on other elements in the input group (e.g. prefix or suffix).\n       *\n       * @remarks Automatic focus causes software keyboard to show on mobile devices.\n       *\n       * @example\n       * ```html\n       * <igx-input-group [suppressInputAutofocus]=\"true\"></igx-input-group>\n       * ```\n       */\n\n      this.suppressInputAutofocus = false;\n      /** @hidden */\n\n      this.hasWarning = false;\n      this._type = null;\n      this._filled = false;\n      this._theme$ = new Subject();\n      this._resourceStrings = CurrentResourceStrings.InputResStrings;\n      this._subscription = this._theme$.asObservable().subscribe(value => {\n        this._theme = value;\n        this.cdr.detectChanges();\n      });\n    }\n    /**\n     * Sets the resource strings.\n     * By default it uses EN resources.\n     */\n\n\n    set resourceStrings(value) {\n      this._resourceStrings = Object.assign({}, this._resourceStrings, value);\n    }\n    /**\n     * Returns the resource strings.\n     */\n\n\n    get resourceStrings() {\n      return this._resourceStrings;\n    }\n    /** @hidden */\n\n\n    get validClass() {\n      return this.input.valid === IgxInputState.VALID;\n    }\n    /** @hidden */\n\n\n    get invalidClass() {\n      return this.input.valid === IgxInputState.INVALID;\n    }\n    /** @hidden */\n\n\n    get isFilled() {\n      return this._filled || this.input && this.input.value;\n    }\n    /** @hidden */\n\n\n    get isDisplayDensityCosy() {\n      return this.displayDensity === DisplayDensity.cosy;\n    }\n    /** @hidden */\n\n\n    get isDisplayDensityComfortable() {\n      return this.displayDensity === DisplayDensity.comfortable;\n    }\n    /** @hidden */\n\n\n    get isDisplayDensityCompact() {\n      return this.displayDensity === DisplayDensity.compact;\n    }\n    /**\n     * An @Input property that sets how the input will be styled.\n     * Allowed values of type IgxInputGroupType.\n     * ```html\n     * <igx-input-group [type]=\"'search'\">\n     * ```\n     */\n\n\n    set type(value) {\n      this._type = value;\n    }\n    /**\n     * Returns the type of the `IgxInputGroupComponent`. How the input is styled.\n     * The default is `line`.\n     * ```typescript\n     * @ViewChild(\"MyInputGroup\")\n     * public inputGroup: IgxInputGroupComponent;\n     * ngAfterViewInit(){\n     *    let inputType = this.inputGroup.type;\n     * }\n     * ```\n     */\n\n\n    get type() {\n      return this._type || this._inputGroupType || 'line';\n    }\n    /**\n     * Sets the theme of the input.\n     * Allowed values of type IgxInputGroupTheme.\n     * ```typescript\n     * @ViewChild(\"MyInputGroup\")\n     * public inputGroup: IgxInputGroupComponent;\n     * ngAfterViewInit() {\n     *  let inputTheme = 'fluent';\n     * }\n     */\n\n\n    set theme(value) {\n      this._theme = value;\n    }\n    /**\n     * Returns the theme of the input.\n     * The returned value is of type IgxInputGroupType.\n     * ```typescript\n     * @ViewChild(\"MyInputGroup\")\n     * public inputGroup: IgxInputGroupComponent;\n     * ngAfterViewInit() {\n     *  let inputTheme = this.inputGroup.theme;\n     * }\n     */\n\n\n    get theme() {\n      return this._theme;\n    }\n    /** @hidden */\n\n\n    onClick(event) {\n      if (!this.isFocused && event.target !== this.input.nativeElement && !this.suppressInputAutofocus) {\n        this.input.focus();\n      }\n    }\n    /** @hidden */\n\n\n    onPointerDown(event) {\n      if (this.isFocused && event.target !== this.input.nativeElement) {\n        event.preventDefault();\n      }\n    }\n    /** @hidden @internal */\n\n\n    hintClickHandler(event) {\n      event.stopPropagation();\n    }\n    /**\n     * Returns whether the `IgxInputGroupComponent` has hints.\n     * ```typescript\n     * @ViewChild(\"MyInputGroup\")\n     * public inputGroup: IgxInputGroupComponent;\n     * ngAfterViewInit(){\n     *    let inputHints = this.inputGroup.hasHints;\n     * }\n     * ```\n     */\n\n\n    get hasHints() {\n      return this.hints.length > 0;\n    }\n    /**\n     * Returns whether the `IgxInputGroupComponent` has border.\n     * ```typescript\n     * @ViewChild(\"MyInputGroup\")\n     * public inputGroup: IgxInputGroupComponent;\n     * ngAfterViewInit(){\n     *    let inputBorder = this.inputGroup.hasBorder;\n     * }\n     * ```\n     */\n\n\n    get hasBorder() {\n      return (this.type === 'line' || this.type === 'box') && this._theme === 'material';\n    }\n    /**\n     * Returns whether the `IgxInputGroupComponent` type is line.\n     * ```typescript\n     * @ViewChild(\"MyInputGroup1\")\n     * public inputGroup: IgxInputGroupComponent;\n     * ngAfterViewInit(){\n     *    let isTypeLine = this.inputGroup.isTypeLine;\n     * }\n     * ```\n     */\n\n\n    get isTypeLine() {\n      return this.type === 'line' && this._theme === 'material';\n    }\n    /**\n     * Returns whether the `IgxInputGroupComponent` type is box.\n     * ```typescript\n     * @ViewChild(\"MyInputGroup1\")\n     * public inputGroup: IgxInputGroupComponent;\n     * ngAfterViewInit(){\n     *    let isTypeBox = this.inputGroup.isTypeBox;\n     * }\n     * ```\n     */\n\n\n    get isTypeBox() {\n      return this.type === 'box' && this._theme === 'material';\n    }\n    /** @hidden @internal */\n\n\n    uploadButtonHandler() {\n      this.input.nativeElement.click();\n    }\n    /** @hidden @internal */\n\n\n    clearValueHandler() {\n      this.input.clear();\n    }\n    /** @hidden @internal */\n\n\n    get isFileType() {\n      return this.input.type === 'file';\n    }\n    /** @hidden @internal */\n\n\n    get fileNames() {\n      return this.input.fileNames || this._resourceStrings.igx_input_file_placeholder;\n    }\n    /**\n     * Returns whether the `IgxInputGroupComponent` type is border.\n     * ```typescript\n     * @ViewChild(\"MyInputGroup1\")\n     * public inputGroup: IgxInputGroupComponent;\n     * ngAfterViewInit(){\n     *    let isTypeBorder = this.inputGroup.isTypeBorder;\n     * }\n     * ```\n     */\n\n\n    get isTypeBorder() {\n      return this.type === 'border' && this._theme === 'material';\n    }\n    /**\n     * Returns true if the `IgxInputGroupComponent` theme is Fluent.\n     * ```typescript\n     * @ViewChild(\"MyInputGroup1\")\n     * public inputGroup: IgxInputGroupComponent;\n     * ngAfterViewInit(){\n     *    let isTypeFluent = this.inputGroup.isTypeFluent;\n     * }\n     * ```\n     */\n\n\n    get isTypeFluent() {\n      return this._theme === 'fluent';\n    }\n    /**\n     * Returns true if the `IgxInputGroupComponent` theme is Bootstrap.\n     * ```typescript\n     * @ViewChild(\"MyInputGroup1\")\n     * public inputGroup: IgxInputGroupComponent;\n     * ngAfterViewInit(){\n     *    let isTypeBootstrap = this.inputGroup.isTypeBootstrap;\n     * }\n     * ```\n     */\n\n\n    get isTypeBootstrap() {\n      return this._theme === 'bootstrap';\n    }\n    /**\n     * Returns true if the `IgxInputGroupComponent` theme is Indigo.\n     * ```typescript\n     * @ViewChild(\"MyInputGroup1\")\n     * public inputGroup: IgxInputGroupComponent;\n     * ngAfterViewInit(){\n     *    let isTypeIndigo = this.inputGroup.isTypeIndigo;\n     * }\n     * ```\n     */\n\n\n    get isTypeIndigo() {\n      return this._theme === 'indigo-design';\n    }\n    /**\n     * Returns whether the `IgxInputGroupComponent` type is search.\n     * ```typescript\n     * @ViewChild(\"MyInputGroup1\")\n     * public inputGroup: IgxInputGroupComponent;\n     * ngAfterViewInit(){\n     *    let isTypeSearch = this.inputGroup.isTypeSearch;\n     * }\n     * ```\n     */\n\n\n    get isTypeSearch() {\n      return this.type === 'search';\n    }\n    /** @hidden */\n\n\n    get filled() {\n      return this._filled;\n    }\n    /** @hidden */\n\n\n    set filled(val) {\n      this._filled = val;\n    }\n    /** @hidden @internal */\n\n\n    ngAfterViewChecked() {\n      if (!this._theme) {\n        const cssProp = this.document.defaultView.getComputedStyle(this.element.nativeElement).getPropertyValue('--theme').trim();\n\n        if (cssProp !== '') {\n          Promise.resolve().then(() => {\n            this._theme$.next(cssProp);\n\n            this.cdr.markForCheck();\n          });\n        }\n      }\n    }\n    /** @hidden @internal */\n\n\n    ngOnDestroy() {\n      this._subscription.unsubscribe();\n    }\n\n  }\n\n  IgxInputGroupComponent.ɵfac = function IgxInputGroupComponent_Factory(t) {\n    return new (t || IgxInputGroupComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DisplayDensityToken, 8), i0.ɵɵdirectiveInject(IGX_INPUT_GROUP_TYPE, 8), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(PlatformUtil), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  IgxInputGroupComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxInputGroupComponent,\n    selectors: [[\"igx-input-group\"]],\n    contentQueries: function IgxInputGroupComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxInputDirective, 7, IgxInputDirective);\n        i0.ɵɵcontentQuery(dirIndex, IgxHintDirective, 4, IgxHintDirective);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.input = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.hints = _t);\n      }\n    },\n    hostVars: 38,\n    hostBindings: function IgxInputGroupComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function IgxInputGroupComponent_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        })(\"pointerdown\", function IgxInputGroupComponent_pointerdown_HostBindingHandler($event) {\n          return ctx.onPointerDown($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-input-group\", ctx.defaultClass)(\"igx-input-group--placeholder\", ctx.hasPlaceholder)(\"igx-input-group--required\", ctx.isRequired)(\"igx-input-group--focused\", ctx.isFocused)(\"igx-input-group--disabled\", ctx.disabled)(\"igx-input-group--warning\", ctx.hasWarning)(\"igx-input-group--valid\", ctx.validClass)(\"igx-input-group--invalid\", ctx.invalidClass)(\"igx-input-group--filled\", ctx.isFilled)(\"igx-input-group--cosy\", ctx.isDisplayDensityCosy)(\"igx-input-group--comfortable\", ctx.isDisplayDensityComfortable)(\"igx-input-group--compact\", ctx.isDisplayDensityCompact)(\"igx-input-group--box\", ctx.isTypeBox)(\"igx-input-group--file\", ctx.isFileType)(\"igx-input-group--border\", ctx.isTypeBorder)(\"igx-input-group--fluent\", ctx.isTypeFluent)(\"igx-input-group--bootstrap\", ctx.isTypeBootstrap)(\"igx-input-group--indigo\", ctx.isTypeIndigo)(\"igx-input-group--search\", ctx.isTypeSearch);\n      }\n    },\n    inputs: {\n      resourceStrings: \"resourceStrings\",\n      suppressInputAutofocus: \"suppressInputAutofocus\",\n      type: \"type\",\n      theme: \"theme\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxInputGroupBase,\n      useExisting: IgxInputGroupComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c14,\n    decls: 26,\n    vars: 3,\n    consts: [[\"class\", \"igx-input-group__wrapper\", 4, \"ngIf\", \"ngIfElse\"], [\"class\", \"igx-input-group__border\", 4, \"ngIf\"], [1, \"igx-input-group__hint\", 3, \"click\"], [\"label\", \"\"], [\"input\", \"\"], [\"prefix\", \"\"], [\"uploadButton\", \"\"], [\"files\", \"\"], [\"clear\", \"\"], [\"suffix\", \"\"], [\"materialBundle\", \"\"], [\"fluentBundle\", \"\"], [\"bootstrapBundle\", \"\"], [\"bundle\", \"\"], [1, \"igx-input-group__wrapper\"], [4, \"ngTemplateOutlet\"], [1, \"igx-input-group__border\"], [\"class\", \"igx-prefix--upload\", 4, \"ngIf\"], [1, \"igx-prefix--upload\"], [\"igxButton\", \"raised\", 3, \"displayDensity\", \"disabled\", \"ngClass\", \"click\"], [\"class\", \"igx-input-group__file-input\", 3, \"title\", 4, \"ngIf\"], [1, \"igx-input-group__file-input\", 3, \"title\"], [\"class\", \"igx-input-group__clear-icon\", \"title\", \"clear files\", \"tabindex\", \"0\", 3, \"click\", \"keydown.Enter\", 4, \"ngIf\"], [\"title\", \"clear files\", \"tabindex\", \"0\", 1, \"igx-input-group__clear-icon\", 3, \"click\", \"keydown.Enter\"], [1, \"igx-input-group__bundle\"], [1, \"igx-input-group__bundle-main\"], [3, \"ngSwitch\"], [4, \"ngSwitchCase\"], [4, \"ngSwitchDefault\"]],\n    template: function IgxInputGroupComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c13);\n        i0.ɵɵtemplate(0, IgxInputGroupComponent_div_0_Template, 2, 1, \"div\", 0);\n        i0.ɵɵtemplate(1, IgxInputGroupComponent_div_1_Template, 1, 0, \"div\", 1);\n        i0.ɵɵelementStart(2, \"div\", 2);\n        i0.ɵɵlistener(\"click\", function IgxInputGroupComponent_Template_div_click_2_listener($event) {\n          return ctx.hintClickHandler($event);\n        });\n        i0.ɵɵprojection(3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(4, IgxInputGroupComponent_ng_template_4_Template, 1, 0, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(6, IgxInputGroupComponent_ng_template_6_Template, 1, 0, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(8, IgxInputGroupComponent_ng_template_8_Template, 1, 0, \"ng-template\", null, 5, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(10, IgxInputGroupComponent_ng_template_10_Template, 1, 1, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(12, IgxInputGroupComponent_ng_template_12_Template, 1, 1, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(14, IgxInputGroupComponent_ng_template_14_Template, 1, 1, \"ng-template\", null, 8, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(16, IgxInputGroupComponent_ng_template_16_Template, 1, 0, \"ng-template\", null, 9, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(18, IgxInputGroupComponent_ng_template_18_Template, 9, 7, \"ng-template\", null, 10, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(20, IgxInputGroupComponent_ng_template_20_Template, 9, 7, \"ng-template\", null, 11, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(22, IgxInputGroupComponent_ng_template_22_Template, 8, 7, \"ng-template\", null, 12, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(24, IgxInputGroupComponent_ng_template_24_Template, 5, 4, \"ng-template\", null, 13, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        const _r22 = i0.ɵɵreference(25);\n\n        i0.ɵɵproperty(\"ngIf\", ctx.isTypeBox)(\"ngIfElse\", _r22);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasBorder);\n      }\n    },\n    directives: [IgxIconComponent, i4.NgIf, i4.NgTemplateOutlet, IgxPrefixDirective, IgxButtonDirective, i4.NgClass, IgxSuffixDirective, i4.NgSwitch, i4.NgSwitchCase, i4.NgSwitchDefault],\n    encapsulation: 2\n  });\n  return IgxInputGroupComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxInputGroupModule = /*#__PURE__*/(() => {\n  class IgxInputGroupModule {}\n\n  IgxInputGroupModule.ɵfac = function IgxInputGroupModule_Factory(t) {\n    return new (t || IgxInputGroupModule)();\n  };\n\n  IgxInputGroupModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxInputGroupModule\n  });\n  IgxInputGroupModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, IgxPrefixModule, IgxSuffixModule, IgxButtonModule, IgxIconModule], IgxPrefixModule, IgxSuffixModule, IgxButtonModule, IgxIconModule]\n  });\n  return IgxInputGroupModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * **Ignite UI for Angular Autocomplete** -\n * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/autocomplete.html)\n *\n * The igxAutocomplete directive provides a way to enhance a text input\n * by showing a drop down of suggested options, provided by the developer.\n *\n * Example:\n * ```html\n * <input type=\"text\" [igxAutocomplete]=\"townsPanel\" #autocompleteRef=\"igxAutocomplete\"/>\n * <igx-drop-down #townsPanel>\n *     <igx-drop-down-item *ngFor=\"let town of towns | startsWith:townSelected\" [value]=\"town\">\n *         {{town}}\n *     </igx-drop-down-item>\n * </igx-drop-down>\n * ```\n */\n\n\nlet IgxAutocompleteDirective = /*#__PURE__*/(() => {\n  class IgxAutocompleteDirective extends IgxDropDownItemNavigationDirective {\n    constructor(ngModel, formControl, group, elementRef, cdr) {\n      super(null);\n      this.ngModel = ngModel;\n      this.formControl = formControl;\n      this.group = group;\n      this.elementRef = elementRef;\n      this.cdr = cdr;\n      /** @hidden @internal */\n\n      this.autofill = 'off';\n      /** @hidden  @internal */\n\n      this.role = 'combobox';\n      /**\n       * Enables/disables autocomplete component\n       *\n       * ```typescript\n       * // get\n       * let disabled = this.autocomplete.disabled;\n       * ```\n       * ```html\n       * <!--set-->\n       * <input type=\"text\" [igxAutocomplete]=\"townsPanel\" [igxAutocompleteDisabled]=\"disabled\"/>\n       * ```\n       * ```typescript\n       * // set\n       * public disabled = true;\n       * ```\n       */\n\n      this.disabled = false;\n      /**\n       * Emitted after item from the drop down is selected\n       *\n       * ```html\n       * <input igxInput [igxAutocomplete]=\"townsPanel\" (selectionChanging)='selectionChanging($event)' />\n       * ```\n       */\n\n      this.selectionChanging = new EventEmitter();\n      this._shouldBeOpen = false;\n      this.destroy$ = new Subject();\n    }\n    /**\n     * Sets the target of the autocomplete directive\n     *\n     * ```html\n     * <!-- Set -->\n     * <input [igxAutocomplete]=\"dropdown\" />\n     * ...\n     * <igx-drop-down #dropdown>\n     * ...\n     * </igx-drop-down>\n     * ```\n     */\n\n\n    get target() {\n      return this._target;\n    }\n\n    set target(v) {\n      this._target = v;\n    }\n    /** @hidden @internal */\n\n\n    get nativeElement() {\n      return this.elementRef.nativeElement;\n    }\n    /** @hidden @internal */\n\n\n    get parentElement() {\n      return this.group ? this.group.element.nativeElement : this.nativeElement;\n    }\n\n    get settings() {\n      const settings = Object.assign({}, this.defaultSettings, this.autocompleteSettings);\n      const target = settings.target || settings.positionStrategy.settings.target;\n\n      if (!target) {\n        const positionStrategyClone = settings.positionStrategy.clone();\n        settings.target = this.parentElement;\n        settings.positionStrategy = positionStrategyClone;\n      }\n\n      return settings;\n    }\n    /** @hidden  @internal */\n\n\n    get ariaExpanded() {\n      return !this.collapsed;\n    }\n    /** @hidden  @internal */\n\n\n    get hasPopUp() {\n      return 'listbox';\n    }\n    /** @hidden  @internal */\n\n\n    get ariaOwns() {\n      return this.target.listId;\n    }\n    /** @hidden  @internal */\n\n\n    get ariaActiveDescendant() {\n      return !this.target.collapsed && this.target.focusedItem ? this.target.focusedItem.id : null;\n    }\n    /** @hidden  @internal */\n\n\n    get ariaAutocomplete() {\n      return 'list';\n    }\n\n    get model() {\n      return this.ngModel || this.formControl;\n    }\n    /** @hidden  @internal */\n\n\n    onInput() {\n      this.open();\n    }\n    /** @hidden  @internal */\n\n\n    onArrowDown(event) {\n      event.preventDefault();\n      this.open();\n    }\n    /** @hidden  @internal */\n\n\n    onTab() {\n      this.close();\n    }\n    /** @hidden  @internal */\n\n\n    handleKeyDown(event) {\n      if (!this.collapsed) {\n        switch (event.key.toLowerCase()) {\n          case 'space':\n          case 'spacebar':\n          case ' ':\n          case 'home':\n          case 'end':\n            return;\n\n          default:\n            super.handleKeyDown(event);\n        }\n      }\n    }\n    /** @hidden  @internal */\n\n\n    onArrowDownKeyDown() {\n      super.onArrowDownKeyDown();\n    }\n    /** @hidden  @internal */\n\n\n    onArrowUpKeyDown() {\n      super.onArrowUpKeyDown();\n    }\n    /** @hidden  @internal */\n\n\n    onEndKeyDown() {\n      super.onEndKeyDown();\n    }\n    /** @hidden  @internal */\n\n\n    onHomeKeyDown() {\n      super.onHomeKeyDown();\n    }\n    /**\n     * Closes autocomplete drop down\n     */\n\n\n    close() {\n      this._shouldBeOpen = false;\n\n      if (this.collapsed) {\n        return;\n      }\n\n      this.target.close();\n    }\n    /**\n     * Opens autocomplete drop down\n     */\n\n\n    open() {\n      this._shouldBeOpen = true;\n\n      if (this.disabled || !this.collapsed || this.target.children.length === 0) {\n        return;\n      } // if no drop-down width is set, the drop-down will be as wide as the autocomplete input;\n\n\n      this.target.width = this.target.width || this.parentElement.clientWidth + 'px';\n      this.target.open(this.settings);\n      this.highlightFirstItem();\n    }\n    /** @hidden @internal */\n\n\n    ngOnInit() {\n      const targetElement = this.parentElement;\n      this.defaultSettings = {\n        target: targetElement,\n        modal: false,\n        scrollStrategy: new AbsoluteScrollStrategy(),\n        positionStrategy: new AutoPositionStrategy(),\n        excludeFromOutsideClick: [targetElement]\n      };\n    }\n    /** @hidden */\n\n\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n\n    ngAfterViewInit() {\n      this.target.children.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        if (this.target.children.length) {\n          if (!this.collapsed) {\n            this.highlightFirstItem();\n          } else if (this._shouldBeOpen) {\n            this.open();\n          }\n        } else {\n          // _shouldBeOpen flag should remain unchanged since this state change doesn't come from outside of the component\n          // (like in the case of public API or user interaction).\n          this.target.close();\n        }\n      });\n      this.target.selectionChanging.pipe(takeUntil(this.destroy$)).subscribe(this.select.bind(this));\n    }\n\n    get collapsed() {\n      return this.target ? this.target.collapsed : true;\n    }\n\n    select(value) {\n      if (!value.newSelection) {\n        return;\n      }\n\n      value.cancel = true; // Disable selection in the drop down, because in autocomplete we do not save selection.\n\n      const newValue = value.newSelection.value;\n      const args = {\n        value: newValue,\n        cancel: false\n      };\n      this.selectionChanging.emit(args);\n\n      if (args.cancel) {\n        return;\n      }\n\n      this.close(); // Update model after the input is re-focused, in order to have proper valid styling.\n      // Otherwise when item is selected using mouse (and input is blurred), then valid style will be removed.\n\n      if (this.model) {\n        this.model.control.setValue(newValue);\n      } else {\n        this.nativeElement.value = newValue;\n      }\n    }\n\n    highlightFirstItem() {\n      if (this.target.focusedItem) {\n        this.target.focusedItem.focused = false;\n        this.target.focusedItem = null;\n      }\n\n      this.target.navigateFirst();\n      this.cdr.detectChanges();\n    }\n\n  }\n\n  IgxAutocompleteDirective.ɵfac = function IgxAutocompleteDirective_Factory(t) {\n    return new (t || IgxAutocompleteDirective)(i0.ɵɵdirectiveInject(NgModel, 10), i0.ɵɵdirectiveInject(FormControlName, 10), i0.ɵɵdirectiveInject(IgxInputGroupComponent, 8), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  IgxAutocompleteDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxAutocompleteDirective,\n    selectors: [[\"\", \"igxAutocomplete\", \"\"]],\n    hostVars: 7,\n    hostBindings: function IgxAutocompleteDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"input\", function IgxAutocompleteDirective_input_HostBindingHandler() {\n          return ctx.onInput();\n        })(\"keydown.ArrowDown\", function IgxAutocompleteDirective_keydown_ArrowDown_HostBindingHandler($event) {\n          return ctx.onArrowDown($event);\n        })(\"keydown.Alt.ArrowDown\", function IgxAutocompleteDirective_keydown_Alt_ArrowDown_HostBindingHandler($event) {\n          return ctx.onArrowDown($event);\n        })(\"keydown.ArrowUp\", function IgxAutocompleteDirective_keydown_ArrowUp_HostBindingHandler($event) {\n          return ctx.onArrowDown($event);\n        })(\"keydown.Alt.ArrowUp\", function IgxAutocompleteDirective_keydown_Alt_ArrowUp_HostBindingHandler($event) {\n          return ctx.onArrowDown($event);\n        })(\"keydown.Tab\", function IgxAutocompleteDirective_keydown_Tab_HostBindingHandler() {\n          return ctx.onTab();\n        })(\"keydown.Shift.Tab\", function IgxAutocompleteDirective_keydown_Shift_Tab_HostBindingHandler() {\n          return ctx.onTab();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"autocomplete\", ctx.autofill)(\"role\", ctx.role)(\"aria-expanded\", ctx.ariaExpanded)(\"aria-haspopup\", ctx.hasPopUp)(\"aria-owns\", ctx.ariaOwns)(\"aria-activedescendant\", ctx.ariaActiveDescendant)(\"aria-autocomplete\", ctx.ariaAutocomplete);\n      }\n    },\n    inputs: {\n      target: [\"igxAutocomplete\", \"target\"],\n      autocompleteSettings: [\"igxAutocompleteSettings\", \"autocompleteSettings\"],\n      disabled: [\"igxAutocompleteDisabled\", \"disabled\"]\n    },\n    outputs: {\n      selectionChanging: \"selectionChanging\"\n    },\n    exportAs: [\"igxAutocomplete\"],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return IgxAutocompleteDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxAutocompleteModule = /*#__PURE__*/(() => {\n  class IgxAutocompleteModule {}\n\n  IgxAutocompleteModule.ɵfac = function IgxAutocompleteModule_Factory(t) {\n    return new (t || IgxAutocompleteModule)();\n  };\n\n  IgxAutocompleteModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxAutocompleteModule\n  });\n  IgxAutocompleteModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[IgxDropDownModule, CommonModule]]\n  });\n  return IgxAutocompleteModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst IgxDividerType = mkenum({\n  SOLID: 'solid',\n  DASHED: 'dashed'\n});\nlet NEXT_ID$r = 0;\nlet IgxDividerDirective = /*#__PURE__*/(() => {\n  class IgxDividerDirective {\n    constructor() {\n      /**\n       * Sets/gets the `id` of the divider.\n       * If not set, `id` will have value `\"igx-divider-0\"`;\n       * ```html\n       * <igx-divider id=\"my-divider\"></igx-divider>\n       * ```\n       * ```typescript\n       * let dividerId =  this.divider.id;\n       * ```\n       */\n      this.id = `igx-divider-${NEXT_ID$r++}`;\n      /**\n       * An @Input property that sets the value of `role` attribute.\n       * If not the default value of `separator` will be used.\n       */\n\n      this.role = 'separator';\n      /**\n       * Sets the type of the divider. The default value\n       * is `default`. The divider can also be `dashed`;\n       * ```html\n       * <igx-divider type=\"dashed\"></igx-divider>\n       * ```\n       */\n\n      this.type = IgxDividerType.SOLID;\n      /**\n       * An @Input that sets the `middle` attribute of the divider.\n       * If set to `true` and an `inset` value has been provided,\n       * the divider will start shrinking from both ends.\n       * ```html\n       * <igx-divider [middle]=\"true\"></igx-divider>\n       * ```\n       */\n\n      this.middle = false;\n      /**\n       * An @Input that sets the vertical attribute of the divider.\n       * ```html\n       * <igx-divider [vertical]=\"true\"></igx-divider>\n       * ```\n       */\n\n      this.vertical = false;\n      /**\n       * An @Input property that sets the value of the `inset` attribute.\n       * If not provided it will be set to `'0'`.\n       * ```html\n       * <igx-divider inset=\"16px\"></igx-divider>\n       * ```\n       */\n\n      this._inset = '0';\n    }\n\n    get isDashed() {\n      return this.type === IgxDividerType.DASHED;\n    }\n    /**\n     * Sets the inset of the divider from the side(s).\n     * If the divider attribute `middle` is set to `true`,\n     * it will inset the divider on both sides.\n     * ```typescript\n     * this.divider.inset = '32px';\n     * ```\n     */\n\n\n    set inset(value) {\n      this._inset = value;\n    }\n    /**\n     * Gets the current divider inset in terms of\n     * margin representation as applied to the divider.\n     * ```typescript\n     * const inset = this.divider.inset;\n     * ```\n     */\n\n\n    get inset() {\n      const baseMargin = '0';\n\n      if (this.middle) {\n        if (this.vertical) {\n          return `${this._inset} ${baseMargin}`;\n        }\n\n        return `${baseMargin} ${this._inset}`;\n      } else {\n        if (this.vertical) {\n          return `${this._inset} ${baseMargin} 0 ${baseMargin}`;\n        }\n\n        return `${baseMargin} 0 ${baseMargin} ${this._inset}`;\n      }\n    }\n    /**\n     * A getter that returns `true` if the type of the divider is `default`;\n     * ```typescript\n     * const isDefault = this.divider.isDefault;\n     * ```\n     */\n\n\n    get isSolid() {\n      return this.type === IgxDividerType.SOLID;\n    }\n\n  }\n\n  IgxDividerDirective.ɵfac = function IgxDividerDirective_Factory(t) {\n    return new (t || IgxDividerDirective)();\n  };\n\n  IgxDividerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxDividerDirective,\n    selectors: [[\"igx-divider\"]],\n    hostVars: 12,\n    hostBindings: function IgxDividerDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id)(\"role\", ctx.role);\n        i0.ɵɵstyleProp(\"margin\", ctx.inset);\n        i0.ɵɵclassProp(\"igx-divider\", ctx.type)(\"igx-divider--dashed\", ctx.isDashed)(\"igx-divider--inset\", ctx.middle)(\"igx-divider--vertical\", ctx.vertical);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      role: \"role\",\n      type: \"type\",\n      middle: \"middle\",\n      vertical: \"vertical\",\n      _inset: [\"inset\", \"_inset\"]\n    }\n  });\n  return IgxDividerDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxDividerModule = /*#__PURE__*/(() => {\n  class IgxDividerModule {}\n\n  IgxDividerModule.ɵfac = function IgxDividerModule_Factory(t) {\n    return new (t || IgxDividerModule)();\n  };\n\n  IgxDividerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxDividerModule\n  });\n  IgxDividerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return IgxDividerModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // @dynamic\n\n\nclass IgxDefaultDropStrategy {\n  dropAction(_drag, _drop, _atIndex) {}\n\n} // @dynamic\n\n\nclass IgxAppendDropStrategy {\n  constructor(_renderer) {\n    this._renderer = _renderer;\n  }\n\n  dropAction(drag, drop, _atIndex) {\n    const dragElement = drag.element.nativeElement;\n    const dropAreaElement = drop.element.nativeElement;\n\n    this._renderer.removeChild(dragElement.parentNode, dragElement);\n\n    this._renderer.appendChild(dropAreaElement, dragElement);\n  }\n\n} // @dynamic\n\n\nclass IgxPrependDropStrategy {\n  constructor(_renderer) {\n    this._renderer = _renderer;\n  }\n\n  dropAction(drag, drop, _atIndex) {\n    const dragElement = drag.element.nativeElement;\n    const dropAreaElement = drop.element.nativeElement;\n\n    this._renderer.removeChild(dragElement.parentNode, dragElement);\n\n    if (dropAreaElement.children.length) {\n      this._renderer.insertBefore(dropAreaElement, dragElement, dropAreaElement.children[0]);\n    } else {\n      this._renderer.appendChild(dropAreaElement, dragElement);\n    }\n  }\n\n} // @dynamic\n\n\nclass IgxInsertDropStrategy {\n  constructor(_renderer) {\n    this._renderer = _renderer;\n  }\n\n  dropAction(drag, drop, atIndex) {\n    if (drag.element.nativeElement.parentElement === drop.element.nativeElement && atIndex === -1) {\n      return;\n    }\n\n    const dragElement = drag.element.nativeElement;\n    const dropAreaElement = drop.element.nativeElement;\n\n    this._renderer.removeChild(dragElement.parentNode, dragElement);\n\n    if (atIndex !== -1 && dropAreaElement.children.length > atIndex) {\n      this._renderer.insertBefore(dropAreaElement, dragElement, dropAreaElement.children[atIndex]);\n    } else {\n      this._renderer.appendChild(dropAreaElement, dragElement);\n    }\n  }\n\n}\n\nvar DragDirection = /*#__PURE__*/(() => {\n  (function (DragDirection) {\n    DragDirection[DragDirection[\"VERTICAL\"] = 0] = \"VERTICAL\";\n    DragDirection[DragDirection[\"HORIZONTAL\"] = 1] = \"HORIZONTAL\";\n    DragDirection[DragDirection[\"BOTH\"] = 2] = \"BOTH\";\n  })(DragDirection || (DragDirection = {}));\n\n  return DragDirection;\n})();\n\nclass IgxDragLocation {\n  constructor(_pageX, _pageY) {\n    this._pageX = _pageX;\n    this._pageY = _pageY;\n    this.pageX = parseFloat(_pageX);\n    this.pageY = parseFloat(_pageY);\n  }\n\n}\n\nlet IgxDragHandleDirective = /*#__PURE__*/(() => {\n  class IgxDragHandleDirective {\n    constructor(element) {\n      this.element = element;\n      this.baseClass = true;\n    }\n\n  }\n\n  IgxDragHandleDirective.ɵfac = function IgxDragHandleDirective_Factory(t) {\n    return new (t || IgxDragHandleDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxDragHandleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxDragHandleDirective,\n    selectors: [[\"\", \"igxDragHandle\", \"\"]],\n    hostVars: 2,\n    hostBindings: function IgxDragHandleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-drag__handle\", ctx.baseClass);\n      }\n    }\n  });\n  return IgxDragHandleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxDragIgnoreDirective = /*#__PURE__*/(() => {\n  class IgxDragIgnoreDirective {\n    constructor(element) {\n      this.element = element;\n      this.baseClass = true;\n    }\n\n  }\n\n  IgxDragIgnoreDirective.ɵfac = function IgxDragIgnoreDirective_Factory(t) {\n    return new (t || IgxDragIgnoreDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxDragIgnoreDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxDragIgnoreDirective,\n    selectors: [[\"\", \"igxDragIgnore\", \"\"]],\n    hostVars: 2,\n    hostBindings: function IgxDragIgnoreDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-drag__ignore\", ctx.baseClass);\n      }\n    }\n  });\n  return IgxDragIgnoreDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxDragDirective = /*#__PURE__*/(() => {\n  class IgxDragDirective {\n    constructor(cdr, element, viewContainer, zone, renderer, platformUtil) {\n      this.cdr = cdr;\n      this.element = element;\n      this.viewContainer = viewContainer;\n      this.zone = zone;\n      this.renderer = renderer;\n      this.platformUtil = platformUtil;\n      /**\n       * An @Input property that indicates when the drag should start.\n       * By default the drag starts after the draggable element is moved by 5px.\n       * ```html\n       * <div igxDrag [dragTolerance]=\"100\">\n       *         <span>Drag Me!</span>\n       * </div>\n       * ```\n       *\n       * @memberof IgxDragDirective\n       */\n\n      this.dragTolerance = 5;\n      /**\n       * An @Input property that indicates the directions that the element can be dragged.\n       * By default it is set to both horizontal and vertical directions.\n       * ```html\n       * <div igxDrag [dragDirection]=\"dragDir\">\n       *         <span>Drag Me!</span>\n       * </div>\n       * ```\n       * ```typescript\n       * public dragDir = DragDirection.HORIZONTAL;\n       * ```\n       *\n       * @memberof IgxDragDirective\n       */\n\n      this.dragDirection = DragDirection.BOTH;\n      /**\n       * An @Input property that specifies if the base element should not be moved and a ghost element should be rendered that represents it.\n       * By default it is set to `true`.\n       * If it is set to `false` when dragging the base element is moved instead and no ghost elements are rendered.\n       * ```html\n       * <div igxDrag [ghost]=\"false\">\n       *      <span>Drag Me!</span>\n       * </div>\n       * ```\n       *\n       * @memberof IgxDragDirective\n       */\n\n      this.ghost = true;\n      /**\n       * Sets a custom class that will be added to the `ghostElement` element.\n       * ```html\n       * <div igxDrag [ghostClass]=\"'ghostElement'\">\n       *         <span>Drag Me!</span>\n       * </div>\n       * ```\n       *\n       * @memberof IgxDragDirective\n       */\n\n      this.ghostClass = '';\n      /**\n       * Event triggered when the draggable element drag starts.\n       * ```html\n       * <div igxDrag (dragStart)=\"onDragStart()\">\n       *         <span>Drag Me!</span>\n       * </div>\n       * ```\n       * ```typescript\n       * public onDragStart(){\n       *      alert(\"The drag has stared!\");\n       * }\n       * ```\n       *\n       * @memberof IgxDragDirective\n       */\n\n      this.dragStart = new EventEmitter();\n      /**\n       * Event triggered when the draggable element has been moved.\n       * ```html\n       * <div igxDrag  (dragMove)=\"onDragMove()\">\n       *         <span>Drag Me!</span>\n       * </div>\n       * ```\n       * ```typescript\n       * public onDragMove(){\n       *      alert(\"The element has moved!\");\n       * }\n       * ```\n       *\n       * @memberof IgxDragDirective\n       */\n\n      this.dragMove = new EventEmitter();\n      /**\n       * Event triggered when the draggable element is released.\n       * ```html\n       * <div igxDrag (dragEnd)=\"onDragEnd()\">\n       *         <span>Drag Me!</span>\n       * </div>\n       * ```\n       * ```typescript\n       * public onDragEnd(){\n       *      alert(\"The drag has ended!\");\n       * }\n       * ```\n       *\n       * @memberof IgxDragDirective\n       */\n\n      this.dragEnd = new EventEmitter();\n      /**\n       * Event triggered when the draggable element is clicked.\n       * ```html\n       * <div igxDrag (dragClick)=\"onDragClick()\">\n       *         <span>Drag Me!</span>\n       * </div>\n       * ```\n       * ```typescript\n       * public onDragClick(){\n       *      alert(\"The element has been clicked!\");\n       * }\n       * ```\n       *\n       * @memberof IgxDragDirective\n       */\n\n      this.dragClick = new EventEmitter();\n      /**\n       * Event triggered when the drag ghost element is created.\n       * ```html\n       * <div igxDrag (ghostCreate)=\"ghostCreated()\">\n       *         <span>Drag Me!</span>\n       * </div>\n       * ```\n       * ```typescript\n       * public ghostCreated(){\n       *      alert(\"The ghost has been created!\");\n       * }\n       * ```\n       *\n       * @memberof IgxDragDirective\n       */\n\n      this.ghostCreate = new EventEmitter();\n      /**\n       * Event triggered when the drag ghost element is created.\n       * ```html\n       * <div igxDrag (ghostDestroy)=\"ghostDestroyed()\">\n       *         <span>Drag Me!</span>\n       * </div>\n       * ```\n       * ```typescript\n       * public ghostDestroyed(){\n       *      alert(\"The ghost has been destroyed!\");\n       * }\n       * ```\n       *\n       * @memberof IgxDragDirective\n       */\n\n      this.ghostDestroy = new EventEmitter();\n      /**\n       * Event triggered after the draggable element is released and after its animation has finished.\n       * ```html\n       * <div igxDrag (transitioned)=\"onMoveEnd()\">\n       *         <span>Drag Me!</span>\n       * </div>\n       * ```\n       * ```typescript\n       * public onMoveEnd(){\n       *      alert(\"The move has ended!\");\n       * }\n       * ```\n       *\n       * @memberof IgxDragDirective\n       */\n\n      this.transitioned = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.baseClass = true;\n      /**\n       * @hidden\n       */\n\n      this.selectDisabled = false;\n      /**\n       * @hidden\n       */\n\n      this.defaultReturnDuration = '0.5s';\n      /**\n       * @hidden\n       */\n\n      this.animInProgress = false;\n      this.ghostContext = null;\n      this._startX = 0;\n      this._startY = 0;\n      this._lastX = 0;\n      this._lastY = 0;\n      this._dragStarted = false;\n      this._ghostHostX = 0;\n      this._ghostHostY = 0;\n      this._pointerDownId = null;\n      this._clicked = false;\n      this._lastDropArea = null;\n      this._destroy = new Subject();\n      this._removeOnDestroy = true;\n    }\n    /**\n     * - Save data inside the `igxDrag` directive. This can be set when instancing `igxDrag` on an element.\n     * ```html\n     * <div [igxDrag]=\"{ source: myElement }\"></div>\n     * ```\n     *\n     * @memberof IgxDragDirective\n     */\n\n\n    set data(value) {\n      this._data = value;\n    }\n\n    get data() {\n      return this._data;\n    }\n    /**\n     * Gets the current location of the element relative to the page.\n     */\n\n\n    get location() {\n      return new IgxDragLocation(this.pageX, this.pageY);\n    }\n    /**\n     * Gets the original location of the element before dragging started.\n     */\n\n\n    get originLocation() {\n      return new IgxDragLocation(this.baseOriginLeft, this.baseOriginTop);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get pointerEventsEnabled() {\n      return typeof PointerEvent !== 'undefined';\n    }\n    /**\n     * @hidden\n     */\n\n\n    get touchEventsEnabled() {\n      return 'ontouchstart' in window;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get pageX() {\n      if (this.ghost && this.ghostElement) {\n        return this.ghostLeft;\n      }\n\n      return this.baseLeft;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get pageY() {\n      if (this.ghost && this.ghostElement) {\n        return this.ghostTop;\n      }\n\n      return this.baseTop;\n    }\n\n    get baseLeft() {\n      return this.element.nativeElement.getBoundingClientRect().left;\n    }\n\n    get baseTop() {\n      return this.element.nativeElement.getBoundingClientRect().top;\n    }\n\n    get baseOriginLeft() {\n      return this.baseLeft - this.getTransformX(this.element.nativeElement);\n    }\n\n    get baseOriginTop() {\n      return this.baseTop - this.getTransformY(this.element.nativeElement);\n    }\n\n    set ghostLeft(pageX) {\n      if (this.ghostElement) {\n        // We need to take into account marginLeft, since top style does not include margin, but pageX includes the margin.\n        const ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-left'], 10); // If ghost host is defined it needs to be taken into account.\n\n        this.ghostElement.style.left = pageX - ghostMarginLeft - this._ghostHostX + 'px';\n      }\n    }\n\n    get ghostLeft() {\n      return parseInt(this.ghostElement.style.left, 10) + this._ghostHostX;\n    }\n\n    set ghostTop(pageY) {\n      if (this.ghostElement) {\n        // We need to take into account marginTop, since top style does not include margin, but pageY includes the margin.\n        const ghostMarginTop = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-top'], 10); // If ghost host is defined it needs to be taken into account.\n\n        this.ghostElement.style.top = pageY - ghostMarginTop - this._ghostHostY + 'px';\n      }\n    }\n\n    get ghostTop() {\n      return parseInt(this.ghostElement.style.top, 10) + this._ghostHostY;\n    }\n    /**\n     * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.\n     * By default it's taking the relative position to the mouse when the drag started and keeps it the same.\n     * ```html\n     * <div #hostDiv></div>\n     * <div igxDrag [ghostOffsetX]=\"0\">\n     *         <span>Drag Me!</span>\n     * </div>\n     * ```\n     *\n     * @memberof IgxDragDirective\n     */\n\n\n    set ghostOffsetX(value) {\n      this._offsetX = parseInt(value, 10);\n    }\n\n    get ghostOffsetX() {\n      return this._offsetX !== undefined ? this._offsetX : this._defaultOffsetX;\n    }\n    /**\n     * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.\n     * By default it's taking the relative position to the mouse when the drag started and keeps it the same.\n     * ```html\n     * <div #hostDiv></div>\n     * <div igxDrag [ghostOffsetY]=\"0\">\n     *         <span>Drag Me!</span>\n     * </div>\n     * ```\n     *\n     * @memberof IgxDragDirective\n     */\n\n\n    set ghostOffsetY(value) {\n      this._offsetY = parseInt(value, 10);\n    }\n\n    get ghostOffsetY() {\n      return this._offsetY !== undefined ? this._offsetY : this._defaultOffsetY;\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterContentInit() {\n      if (!this.dragHandles || !this.dragHandles.length) {\n        // Set user select none to the whole draggable element if no drag handles are defined.\n        this.selectDisabled = true;\n      } // Bind events\n\n\n      this.zone.runOutsideAngular(() => {\n        if (!this.platformUtil.isBrowser) {\n          return;\n        }\n\n        const targetElements = this.dragHandles && this.dragHandles.length ? this.dragHandles.map(item => item.element.nativeElement) : [this.element.nativeElement];\n        targetElements.forEach(element => {\n          if (this.pointerEventsEnabled) {\n            fromEvent(element, 'pointerdown').pipe(takeUntil(this._destroy)).subscribe(res => this.onPointerDown(res));\n            fromEvent(element, 'pointermove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe(res => this.onPointerMove(res));\n            fromEvent(element, 'pointerup').pipe(takeUntil(this._destroy)).subscribe(res => this.onPointerUp(res));\n\n            if (!this.ghost) {\n              // Do not bind `lostpointercapture` to the target, because we will bind it on the ghost later.\n              fromEvent(element, 'lostpointercapture').pipe(takeUntil(this._destroy)).subscribe(res => this.onPointerLost(res));\n            }\n          } else if (this.touchEventsEnabled) {\n            fromEvent(element, 'touchstart').pipe(takeUntil(this._destroy)).subscribe(res => this.onPointerDown(res));\n          } else {\n            // We don't have pointer events and touch events. Use then mouse events.\n            fromEvent(element, 'mousedown').pipe(takeUntil(this._destroy)).subscribe(res => this.onPointerDown(res));\n          }\n        }); // We should bind to document events only once when there are no pointer events.\n\n        if (!this.pointerEventsEnabled && this.touchEventsEnabled) {\n          fromEvent(document.defaultView, 'touchmove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe(res => this.onPointerMove(res));\n          fromEvent(document.defaultView, 'touchend').pipe(takeUntil(this._destroy)).subscribe(res => this.onPointerUp(res));\n        } else if (!this.pointerEventsEnabled) {\n          fromEvent(document.defaultView, 'mousemove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe(res => this.onPointerMove(res));\n          fromEvent(document.defaultView, 'mouseup').pipe(takeUntil(this._destroy)).subscribe(res => this.onPointerUp(res));\n        }\n\n        this.element.nativeElement.addEventListener('transitionend', args => {\n          this.onTransitionEnd(args);\n        });\n      }); // Set transition duration to 0s. This also helps with setting `visibility: hidden` to the base to not lag.\n\n      this.element.nativeElement.style.transitionDuration = '0.0s';\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      this._destroy.next(true);\n\n      this._destroy.complete();\n\n      if (this.ghost && this.ghostElement && this._removeOnDestroy) {\n        this.ghostElement.parentNode.removeChild(this.ghostElement);\n        this.ghostElement = null;\n\n        if (this._dynamicGhostRef) {\n          this._dynamicGhostRef.destroy();\n\n          this._dynamicGhostRef = null;\n        }\n      }\n    }\n    /**\n     * Sets desired location of the base element or ghost element if rended relative to the document.\n     *\n     * @param newLocation New location that should be applied. It is advised to get new location using getBoundingClientRects() + scroll.\n     */\n\n\n    setLocation(newLocation) {\n      // We do not subtract marginLeft and marginTop here because here we calculate deltas.\n      if (this.ghost && this.ghostElement) {\n        const offsetHostX = this.ghostHost ? this.ghostHostOffsetLeft(this.ghostHost) : 0;\n        const offsetHostY = this.ghostHost ? this.ghostHostOffsetTop(this.ghostHost) : 0;\n        this.ghostLeft = newLocation.pageX - offsetHostX + this.getWindowScrollLeft();\n        this.ghostTop = newLocation.pageY - offsetHostY + this.getWindowScrollTop();\n      } else if (!this.ghost) {\n        const deltaX = newLocation.pageX - this.pageX;\n        const deltaY = newLocation.pageY - this.pageY;\n        const transformX = this.getTransformX(this.element.nativeElement);\n        const transformY = this.getTransformY(this.element.nativeElement);\n        this.setTransformXY(transformX + deltaX, transformY + deltaY);\n      }\n\n      this._startX = this.baseLeft;\n      this._startY = this.baseTop;\n    }\n    /**\n     * Animates the base or ghost element depending on the `ghost` input to its initial location.\n     * If `ghost` is true but there is not ghost rendered, it will be created and animated.\n     * If the base element has changed its DOM position its initial location will be changed accordingly.\n     *\n     * @param customAnimArgs Custom transition properties that will be applied when performing the transition.\n     * @param startLocation Start location from where the transition should start.\n     */\n\n\n    transitionToOrigin(customAnimArgs, startLocation) {\n      if (!!startLocation && startLocation.pageX === this.baseOriginLeft && startLocation.pageY === this.baseOriginLeft || !startLocation && this.ghost && !this.ghostElement) {\n        return;\n      }\n\n      if (!!startLocation && startLocation.pageX !== this.pageX && startLocation.pageY !== this.pageY) {\n        if (this.ghost && !this.ghostElement) {\n          this._startX = startLocation.pageX;\n          this._startY = startLocation.pageY;\n          this._ghostStartX = this._startX;\n          this._ghostStartY = this._startY;\n          this.createGhost(this._startX, this._startY);\n        }\n\n        this.setLocation(startLocation);\n      }\n\n      this.animInProgress = true; // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.\n\n      setTimeout(() => {\n        if (this.ghost) {\n          this.ghostElement.style.transitionProperty = 'top, left';\n          this.ghostElement.style.transitionDuration = customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;\n          this.ghostElement.style.transitionTimingFunction = customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';\n          this.ghostElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';\n          this.setLocation(new IgxDragLocation(this.baseLeft, this.baseTop));\n        } else if (!this.ghost) {\n          this.element.nativeElement.style.transitionProperty = 'transform';\n          this.element.nativeElement.style.transitionDuration = customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;\n          this.element.nativeElement.style.transitionTimingFunction = customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';\n          this.element.nativeElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';\n          this._startX = this.baseLeft;\n          this._startY = this.baseTop;\n          this.setTransformXY(0, 0);\n        }\n      }, 0);\n    }\n    /**\n     * Animates the base or ghost element to a specific target location or other element using transition.\n     * If `ghost` is true but there is not ghost rendered, it will be created and animated.\n     * It is recommended to use 'getBoundingClientRects() + pageScroll' when determining desired location.\n     *\n     * @param target Target that the base or ghost will transition to. It can be either location in the page or another HTML element.\n     * @param customAnimArgs Custom transition properties that will be applied when performing the transition.\n     * @param startLocation Start location from where the transition should start.\n     */\n\n\n    transitionTo(target, customAnimArgs, startLocation) {\n      if (!!startLocation && this.ghost && !this.ghostElement) {\n        this._startX = startLocation.pageX;\n        this._startY = startLocation.pageY;\n        this._ghostStartX = this._startX;\n        this._ghostStartY = this._startY;\n      } else if (!!startLocation && (!this.ghost || this.ghostElement)) {\n        this.setLocation(startLocation);\n      } else if (this.ghost && !this.ghostElement) {\n        this._startX = this.baseLeft;\n        this._startY = this.baseTop;\n        this._ghostStartX = this._startX + this.getWindowScrollLeft();\n        this._ghostStartY = this._startY + this.getWindowScrollTop();\n      }\n\n      if (this.ghost && !this.ghostElement) {\n        this.createGhost(this._startX, this._startY);\n      }\n\n      this.animInProgress = true; // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.\n\n      setTimeout(() => {\n        const movedElem = this.ghost ? this.ghostElement : this.element.nativeElement;\n        movedElem.style.transitionProperty = this.ghost && this.ghostElement ? 'left, top' : 'transform';\n        movedElem.style.transitionDuration = customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;\n        movedElem.style.transitionTimingFunction = customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';\n        movedElem.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';\n\n        if (target instanceof IgxDragLocation) {\n          this.setLocation(new IgxDragLocation(target.pageX, target.pageY));\n        } else {\n          const targetRects = target.nativeElement.getBoundingClientRect();\n          this.setLocation(new IgxDragLocation(targetRects.left - this.getWindowScrollLeft(), targetRects.top - this.getWindowScrollTop()));\n        }\n      }, 0);\n    }\n    /**\n     * @hidden\n     * Method bound to the PointerDown event of the base element igxDrag is initialized.\n     * @param event PointerDown event captured\n     */\n\n\n    onPointerDown(event) {\n      const ignoredElement = this.dragIgnoredElems.find(elem => elem.element.nativeElement === event.target);\n\n      if (ignoredElement) {\n        return;\n      }\n\n      this._clicked = true;\n      this._pointerDownId = event.pointerId; // Set pointer capture so we detect pointermove even if mouse is out of bounds until ghostElement is created.\n\n      const handleFound = this.dragHandles.find(handle => handle.element.nativeElement === event.currentTarget);\n      const targetElement = handleFound ? handleFound.element.nativeElement : this.element.nativeElement;\n\n      if (this.pointerEventsEnabled) {\n        targetElement.setPointerCapture(this._pointerDownId);\n      } else {\n        targetElement.focus();\n        event.preventDefault();\n      }\n\n      if (this.pointerEventsEnabled || !this.touchEventsEnabled) {\n        // Check first for pointer events or non touch, because we can have pointer events and touch events at once.\n        this._startX = event.pageX;\n        this._startY = event.pageY;\n      } else if (this.touchEventsEnabled) {\n        this._startX = event.touches[0].pageX;\n        this._startY = event.touches[0].pageY;\n      }\n\n      this._defaultOffsetX = this.baseLeft - this._startX + this.getWindowScrollLeft();\n      this._defaultOffsetY = this.baseTop - this._startY + this.getWindowScrollTop();\n      this._ghostStartX = this._startX + this.ghostOffsetX;\n      this._ghostStartY = this._startY + this.ghostOffsetY;\n      this._lastX = this._startX;\n      this._lastY = this._startY;\n    }\n    /**\n     * @hidden\n     * Perform drag move logic when dragging and dispatching events if there is igxDrop under the pointer.\n     * This method is bound at first at the base element.\n     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned it. Then this method is bound to it.\n     * @param event PointerMove event captured\n     */\n\n\n    onPointerMove(event) {\n      if (this._clicked) {\n        let pageX;\n        let pageY;\n\n        if (this.pointerEventsEnabled || !this.touchEventsEnabled) {\n          // Check first for pointer events or non touch, because we can have pointer events and touch events at once.\n          pageX = event.pageX;\n          pageY = event.pageY;\n        } else if (this.touchEventsEnabled) {\n          pageX = event.touches[0].pageX;\n          pageY = event.touches[0].pageY; // Prevent scrolling on touch while dragging\n\n          event.preventDefault();\n        }\n\n        const totalMovedX = pageX - this._startX;\n        const totalMovedY = pageY - this._startY;\n\n        if (!this._dragStarted && (Math.abs(totalMovedX) > this.dragTolerance || Math.abs(totalMovedY) > this.dragTolerance)) {\n          const dragStartArgs = {\n            originalEvent: event,\n            owner: this,\n            startX: pageX - totalMovedX,\n            startY: pageY - totalMovedY,\n            pageX,\n            pageY,\n            cancel: false\n          };\n          this.zone.run(() => {\n            this.dragStart.emit(dragStartArgs);\n          });\n\n          if (!dragStartArgs.cancel) {\n            this._dragStarted = true;\n\n            if (this.ghost) {\n              // We moved enough so ghostElement can be rendered and actual dragging to start.\n              // When creating it will take into account any offset set by the user by default.\n              this.createGhost(pageX, pageY);\n            } else if (this._offsetX !== undefined || this._offsetY !== undefined) {\n              // There is no need for ghost, but we will need to position initially the base element to reflect any offset.\n              const transformX = (this._offsetX !== undefined ? this._offsetX - this._defaultOffsetX : 0) + this.getTransformX(this.element.nativeElement);\n              const transformY = (this._offsetY !== undefined ? this._offsetY - this._defaultOffsetY : 0) + this.getTransformY(this.element.nativeElement);\n              this.setTransformXY(transformX, transformY);\n            }\n          } else {\n            return;\n          }\n        } else if (!this._dragStarted) {\n          return;\n        }\n\n        const moveArgs = {\n          originalEvent: event,\n          owner: this,\n          startX: this._startX,\n          startY: this._startY,\n          pageX: this._lastX,\n          pageY: this._lastY,\n          nextPageX: pageX,\n          nextPageY: pageY,\n          cancel: false\n        };\n        this.dragMove.emit(moveArgs);\n        const setPageX = moveArgs.nextPageX;\n        const setPageY = moveArgs.nextPageY;\n\n        if (!moveArgs.cancel) {\n          if (this.ghost) {\n            const updatedTotalMovedX = this.dragDirection === DragDirection.VERTICAL ? 0 : setPageX - this._startX;\n            const updatedTotalMovedY = this.dragDirection === DragDirection.HORIZONTAL ? 0 : setPageY - this._startY;\n            this.ghostLeft = this._ghostStartX + updatedTotalMovedX;\n            this.ghostTop = this._ghostStartY + updatedTotalMovedY;\n          } else {\n            const lastMovedX = this.dragDirection === DragDirection.VERTICAL ? 0 : setPageX - this._lastX;\n            const lastMovedY = this.dragDirection === DragDirection.HORIZONTAL ? 0 : setPageY - this._lastY;\n            const translateX = this.getTransformX(this.element.nativeElement) + lastMovedX;\n            const translateY = this.getTransformY(this.element.nativeElement) + lastMovedY;\n            this.setTransformXY(translateX, translateY);\n          }\n\n          this.dispatchDragEvents(pageX, pageY, event);\n        }\n\n        this._lastX = setPageX;\n        this._lastY = setPageY;\n      }\n    }\n    /**\n     * @hidden\n     * Perform drag end logic when releasing the ghostElement and dispatching drop event if igxDrop is under the pointer.\n     * This method is bound at first at the base element.\n     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned to it. Then this method is bound to it.\n     * @param event PointerUp event captured\n     */\n\n\n    onPointerUp(event) {\n      if (!this._clicked) {\n        return;\n      }\n\n      let pageX;\n      let pageY;\n\n      if (this.pointerEventsEnabled || !this.touchEventsEnabled) {\n        // Check first for pointer events or non touch, because we can have pointer events and touch events at once.\n        pageX = event.pageX;\n        pageY = event.pageY;\n      } else if (this.touchEventsEnabled) {\n        pageX = event.touches[0].pageX;\n        pageY = event.touches[0].pageY; // Prevent scrolling on touch while dragging\n\n        event.preventDefault();\n      }\n\n      const eventArgs = {\n        originalEvent: event,\n        owner: this,\n        startX: this._startX,\n        startY: this._startY,\n        pageX,\n        pageY\n      };\n      this._pointerDownId = null;\n      this._clicked = false;\n\n      if (this._dragStarted) {\n        if (this._lastDropArea && this._lastDropArea !== this.element.nativeElement) {\n          this.dispatchDropEvent(event.pageX, event.pageY, event);\n        }\n\n        this.zone.run(() => {\n          this.dragEnd.emit(eventArgs);\n        });\n\n        if (!this.animInProgress) {\n          this.onTransitionEnd(null);\n        }\n      } else {\n        // Trigger our own click event because when there is no ghost, native click cannot be prevented when dragging.\n        this.zone.run(() => {\n          this.dragClick.emit(eventArgs);\n        });\n      }\n    }\n    /**\n     * @hidden\n     * Execute this method whe the pointer capture has been lost.\n     * This means that during dragging the user has performed other action like right clicking and then clicking somewhere else.\n     * This method will ensure that the drag state is being reset in this case as if the user released the dragged element.\n     * @param event Event captured\n     */\n\n\n    onPointerLost(event) {\n      if (!this._clicked) {\n        return;\n      }\n\n      const eventArgs = {\n        originalEvent: event,\n        owner: this,\n        startX: this._startX,\n        startY: this._startY,\n        pageX: event.pageX,\n        pageY: event.pageY\n      };\n      this._pointerDownId = null;\n      this._clicked = false;\n\n      if (this._dragStarted) {\n        this.zone.run(() => {\n          this.dragEnd.emit(eventArgs);\n        });\n\n        if (!this.animInProgress) {\n          this.onTransitionEnd(null);\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onTransitionEnd(event) {\n      if (!this._dragStarted && !this.animInProgress || this._clicked) {\n        // Return if no dragging started and there is no animation in progress.\n        return;\n      }\n\n      if (this.ghost && this.ghostElement) {\n        this._ghostStartX = this.baseLeft + this.getWindowScrollLeft();\n        this._ghostStartY = this.baseTop + this.getWindowScrollTop();\n        const ghostDestroyArgs = {\n          owner: this,\n          ghostElement: this.ghostElement,\n          cancel: false\n        };\n        this.ghostDestroy.emit(ghostDestroyArgs);\n\n        if (ghostDestroyArgs.cancel) {\n          return;\n        }\n\n        this.ghostElement.parentNode.removeChild(this.ghostElement);\n        this.ghostElement = null;\n\n        if (this._dynamicGhostRef) {\n          this._dynamicGhostRef.destroy();\n\n          this._dynamicGhostRef = null;\n        }\n      } else if (!this.ghost) {\n        this.element.nativeElement.style.transitionProperty = '';\n        this.element.nativeElement.style.transitionDuration = '0.0s';\n        this.element.nativeElement.style.transitionTimingFunction = '';\n        this.element.nativeElement.style.transitionDelay = '';\n      }\n\n      this.animInProgress = false;\n      this._dragStarted = false; // Execute transitioned after everything is reset so if the user sets new location on the base now it would work as expected.\n\n      this.zone.run(() => {\n        this.transitioned.emit({\n          originalEvent: event,\n          owner: this,\n          startX: this._startX,\n          startY: this._startY,\n          pageX: this._startX,\n          pageY: this._startY\n        });\n      });\n    }\n    /**\n     * @hidden\n     * Create ghost element - if a Node object is provided it creates a clone of that node,\n     * otherwise it clones the host element.\n     * Bind all needed events.\n     * @param pageX Latest pointer position on the X axis relative to the page.\n     * @param pageY Latest pointer position on the Y axis relative to the page.\n     * @param node The Node object to be cloned.\n     */\n\n\n    createGhost(pageX, pageY, node = null) {\n      if (!this.ghost) {\n        return;\n      }\n\n      if (this.ghostTemplate) {\n        this._dynamicGhostRef = this.viewContainer.createEmbeddedView(this.ghostTemplate, this.ghostContext);\n        this.ghostElement = this._dynamicGhostRef.rootNodes[0];\n      } else {\n        this.ghostElement = node ? node.cloneNode(true) : this.element.nativeElement.cloneNode(true);\n      }\n\n      const totalMovedX = pageX - this._startX;\n      const totalMovedY = pageY - this._startY;\n      this._ghostHostX = this.ghostHost ? this.ghostHostOffsetLeft(this.ghostHost) : 0;\n      this._ghostHostY = this.ghostHost ? this.ghostHostOffsetTop(this.ghostHost) : 0;\n      this.ghostElement.style.transitionDuration = '0.0s';\n      this.ghostElement.style.position = 'absolute';\n\n      if (this.ghostClass) {\n        this.renderer.addClass(this.ghostElement, this.ghostClass);\n      }\n\n      const createEventArgs = {\n        owner: this,\n        ghostElement: this.ghostElement,\n        cancel: false\n      };\n      this.ghostCreate.emit(createEventArgs);\n\n      if (createEventArgs.cancel) {\n        this.ghostElement = null;\n\n        if (this.ghostTemplate && this._dynamicGhostRef) {\n          this._dynamicGhostRef.destroy();\n        }\n\n        return;\n      }\n\n      if (this.ghostHost) {\n        this.ghostHost.appendChild(this.ghostElement);\n      } else {\n        document.body.appendChild(this.ghostElement);\n      }\n\n      const ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-left'], 10);\n      const ghostMarginTop = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-top'], 10);\n      this.ghostElement.style.left = this._ghostStartX - ghostMarginLeft + totalMovedX - this._ghostHostX + 'px';\n      this.ghostElement.style.top = this._ghostStartY - ghostMarginTop + totalMovedY - this._ghostHostX + 'px';\n\n      if (this.pointerEventsEnabled) {\n        // The ghostElement takes control for moving and dragging after it has been rendered.\n        if (this._pointerDownId !== null) {\n          this.ghostElement.setPointerCapture(this._pointerDownId);\n        }\n\n        this.ghostElement.addEventListener('pointermove', args => {\n          this.onPointerMove(args);\n        });\n        this.ghostElement.addEventListener('pointerup', args => {\n          this.onPointerUp(args);\n        });\n        this.ghostElement.addEventListener('lostpointercapture', args => {\n          this.onPointerLost(args);\n        });\n      } // Transition animation when the ghostElement is released and it returns to it's original position.\n\n\n      this.ghostElement.addEventListener('transitionend', args => {\n        this.onTransitionEnd(args);\n      });\n      this.cdr.detectChanges();\n    }\n    /**\n     * @hidden\n     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.\n     */\n\n\n    dispatchDragEvents(pageX, pageY, originalEvent) {\n      let topDropArea;\n      const customEventArgs = {\n        startX: this._startX,\n        startY: this._startY,\n        pageX,\n        pageY,\n        owner: this,\n        originalEvent\n      };\n      let elementsFromPoint = this.getElementsAtPoint(pageX, pageY); // Check for shadowRoot instance and use it if present\n\n      for (const elFromPoint of elementsFromPoint) {\n        if (!!(elFromPoint === null || elFromPoint === void 0 ? void 0 : elFromPoint.shadowRoot)) {\n          elementsFromPoint = elFromPoint.shadowRoot.elementsFromPoint(pageX, pageY);\n        }\n      }\n\n      for (const element of elementsFromPoint) {\n        if (element.getAttribute('droppable') === 'true' && element !== this.ghostElement && element !== this.element.nativeElement) {\n          topDropArea = element;\n          break;\n        }\n      }\n\n      if (topDropArea && (!this._lastDropArea || this._lastDropArea && this._lastDropArea !== topDropArea)) {\n        if (this._lastDropArea) {\n          this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);\n        }\n\n        this._lastDropArea = topDropArea;\n        this.dispatchEvent(this._lastDropArea, 'igxDragEnter', customEventArgs);\n      } else if (!topDropArea && this._lastDropArea) {\n        this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);\n        this._lastDropArea = null;\n        return;\n      }\n\n      if (topDropArea) {\n        this.dispatchEvent(topDropArea, 'igxDragOver', customEventArgs);\n      }\n    }\n    /**\n     * @hidden\n     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.\n     * Last recorder drop area is updated in @dispatchDragEvents method.\n     */\n\n\n    dispatchDropEvent(pageX, pageY, originalEvent) {\n      const eventArgs = {\n        startX: this._startX,\n        startY: this._startY,\n        pageX,\n        pageY,\n        owner: this,\n        originalEvent\n      };\n      this.dispatchEvent(this._lastDropArea, 'igxDrop', eventArgs);\n      this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);\n      this._lastDropArea = null;\n    }\n    /**\n     * @hidden\n     */\n\n\n    getElementsAtPoint(pageX, pageY) {\n      // correct the coordinates with the current scroll position, because\n      // document.elementsFromPoint consider position within the current viewport\n      // window.pageXOffset == window.scrollX; // always true\n      // using window.pageXOffset for IE9 compatibility\n      const viewPortX = pageX - window.pageXOffset;\n      const viewPortY = pageY - window.pageYOffset;\n\n      if (document['msElementsFromPoint']) {\n        // Edge and IE special snowflakes\n        const elements = document['msElementsFromPoint'](viewPortX, viewPortY);\n        return elements === null ? [] : elements;\n      } else {\n        // Other browsers like Chrome, Firefox, Opera\n        return document.elementsFromPoint(viewPortX, viewPortY);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    dispatchEvent(target, eventName, eventArgs) {\n      // This way is IE11 compatible.\n      const dragLeaveEvent = document.createEvent('CustomEvent');\n      dragLeaveEvent.initCustomEvent(eventName, false, false, eventArgs);\n      target.dispatchEvent(dragLeaveEvent); // Otherwise can be used `target.dispatchEvent(new CustomEvent(eventName, eventArgs));`\n    }\n\n    getTransformX(elem) {\n      let posX = 0;\n\n      if (elem.style.transform) {\n        const matrix = elem.style.transform;\n        const values = matrix ? matrix.match(/-?[\\d\\.]+/g) : undefined;\n        posX = values ? Number(values[1]) : 0;\n      }\n\n      return posX;\n    }\n\n    getTransformY(elem) {\n      let posY = 0;\n\n      if (elem.style.transform) {\n        const matrix = elem.style.transform;\n        const values = matrix ? matrix.match(/-?[\\d\\.]+/g) : undefined;\n        posY = values ? Number(values[2]) : 0;\n      }\n\n      return posY;\n    }\n    /** Method setting transformation to the base draggable element. */\n\n\n    setTransformXY(x, y) {\n      this.element.nativeElement.style.transform = 'translate3d(' + x + 'px, ' + y + 'px, 0px)';\n    }\n\n    getWindowScrollTop() {\n      return window.scrollY ? window.scrollY : window.pageYOffset ? window.pageYOffset : 0;\n    }\n\n    getWindowScrollLeft() {\n      return window.scrollX ? window.scrollX : window.pageXOffset ? window.pageXOffset : 0;\n    }\n\n    ghostHostOffsetLeft(ghostHost) {\n      const ghostPosition = document.defaultView.getComputedStyle(ghostHost).getPropertyValue('position');\n\n      if (ghostPosition === 'static' && ghostHost.offsetParent && ghostHost.offsetParent === document.body) {\n        return 0;\n      } else if (ghostPosition === 'static' && ghostHost.offsetParent) {\n        return ghostHost.offsetParent.getBoundingClientRect().left - this.getWindowScrollLeft();\n      }\n\n      return ghostHost.getBoundingClientRect().left - this.getWindowScrollLeft();\n    }\n\n    ghostHostOffsetTop(ghostHost) {\n      const ghostPosition = document.defaultView.getComputedStyle(ghostHost).getPropertyValue('position');\n\n      if (ghostPosition === 'static' && ghostHost.offsetParent && ghostHost.offsetParent === document.body) {\n        return 0;\n      } else if (ghostPosition === 'static' && ghostHost.offsetParent) {\n        return ghostHost.offsetParent.getBoundingClientRect().top - this.getWindowScrollTop();\n      }\n\n      return ghostHost.getBoundingClientRect().top - this.getWindowScrollTop();\n    }\n\n  }\n\n  IgxDragDirective.ɵfac = function IgxDragDirective_Factory(t) {\n    return new (t || IgxDragDirective)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxDragDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxDragDirective,\n    selectors: [[\"\", \"igxDrag\", \"\"]],\n    contentQueries: function IgxDragDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxDragHandleDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, IgxDragIgnoreDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dragHandles = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dragIgnoredElems = _t);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function IgxDragDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-drag\", ctx.baseClass)(\"igx-drag--select-disabled\", ctx.selectDisabled);\n      }\n    },\n    inputs: {\n      data: [\"igxDrag\", \"data\"],\n      dragTolerance: \"dragTolerance\",\n      dragDirection: \"dragDirection\",\n      dragChannel: \"dragChannel\",\n      ghost: \"ghost\",\n      ghostClass: \"ghostClass\",\n      ghostTemplate: \"ghostTemplate\",\n      ghostHost: \"ghostHost\",\n      ghostOffsetX: \"ghostOffsetX\",\n      ghostOffsetY: \"ghostOffsetY\"\n    },\n    outputs: {\n      dragStart: \"dragStart\",\n      dragMove: \"dragMove\",\n      dragEnd: \"dragEnd\",\n      dragClick: \"dragClick\",\n      ghostCreate: \"ghostCreate\",\n      ghostDestroy: \"ghostDestroy\",\n      transitioned: \"transitioned\"\n    },\n    exportAs: [\"drag\"]\n  });\n  return IgxDragDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxDropDirective = /*#__PURE__*/(() => {\n  class IgxDropDirective {\n    constructor(element, _renderer, _zone) {\n      this.element = element;\n      this._renderer = _renderer;\n      this._zone = _zone;\n      /**\n       * Event triggered when dragged element enters the area of the element.\n       * ```html\n       * <div class=\"cageArea\" igxDrop (enter)=\"dragEnter()\" (igxDragEnter)=\"onDragCageEnter()\" (igxDragLeave)=\"onDragCageLeave()\">\n       * </div>\n       * ```\n       * ```typescript\n       * public dragEnter(){\n       *     alert(\"A draggable element has entered the chip area!\");\n       * }\n       * ```\n       *\n       * @memberof IgxDropDirective\n       */\n\n      this.enter = new EventEmitter();\n      /**\n       * Event triggered when dragged element enters the area of the element.\n       * ```html\n       * <div class=\"cageArea\" igxDrop (enter)=\"dragEnter()\" (igxDragEnter)=\"onDragCageEnter()\" (igxDragLeave)=\"onDragCageLeave()\">\n       * </div>\n       * ```\n       * ```typescript\n       * public dragEnter(){\n       *     alert(\"A draggable element has entered the chip area!\");\n       * }\n       * ```\n       *\n       * @memberof IgxDropDirective\n       */\n\n      this.over = new EventEmitter();\n      /**\n       * Event triggered when dragged element leaves the area of the element.\n       * ```html\n       * <div class=\"cageArea\" igxDrop (leave)=\"dragLeave()\" (igxDragEnter)=\"onDragCageEnter()\" (igxDragLeave)=\"onDragCageLeave()\">\n       * </div>\n       * ```\n       * ```typescript\n       * public dragLeave(){\n       *     alert(\"A draggable element has left the chip area!\");\n       * }\n       * ```\n       *\n       * @memberof IgxDropDirective\n       */\n\n      this.leave = new EventEmitter();\n      /**\n       * Event triggered when dragged element is dropped in the area of the element.\n       * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.\n       * To cancel the default logic the `cancel` property of the event needs to be set to true.\n       * ```html\n       * <div class=\"cageArea\" igxDrop (dropped)=\"dragDrop()\" (igxDragEnter)=\"onDragCageEnter()\" (igxDragLeave)=\"onDragCageLeave()\">\n       * </div>\n       * ```\n       * ```typescript\n       * public dragDrop(){\n       *     alert(\"A draggable element has been dropped in the chip area!\");\n       * }\n       * ```\n       *\n       * @memberof IgxDropDirective\n       */\n\n      this.dropped = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.droppable = true;\n      /**\n       * @hidden\n       */\n\n      this.dragover = false;\n      /**\n       * @hidden\n       */\n\n      this._destroy = new Subject();\n      this._dropStrategy = new IgxDefaultDropStrategy();\n    }\n    /**\n     * - Save data inside the `igxDrop` directive. This can be set when instancing `igxDrop` on an element.\n     * ```html\n     * <div [igxDrop]=\"{ source: myElement }\"></div>\n     * ```\n     *\n     * @memberof IgxDropDirective\n     */\n\n\n    set data(v) {\n      this._data = v;\n    }\n\n    get data() {\n      return this._data;\n    }\n    /**\n     * An @Input property that specifies a drop strategy type that will be executed when an `IgxDrag` element is released inside\n     *  the current drop area. The provided strategies are:\n     *  - IgxDefaultDropStrategy - This is the default base strategy and it doesn't perform any actions.\n     *  - IgxAppendDropStrategy - Appends the dropped element to last position as a direct child to the `igxDrop`.\n     *  - IgxPrependDropStrategy - Prepends the dropped element to first position as a direct child to the `igxDrop`.\n     *  - IgxInsertDropStrategy - If the dropped element is released above a child element of the `igxDrop`, it will be inserted\n     *      at that position. Otherwise the dropped element will be appended if released outside any child of the `igxDrop`.\n     * ```html\n     * <div igxDrag>\n     *      <span>DragMe</span>\n     * </div>\n     * <div igxDrop [dropStrategy]=\"myDropStrategy\">\n     *         <span>Numbers drop area!</span>\n     * </div>\n     * ```\n     * ```typescript\n     * import { IgxAppendDropStrategy } from 'igniteui-angular';\n     *\n     * export class App {\n     *      public myDropStrategy = IgxAppendDropStrategy;\n     * }\n     * ```\n     *\n     * @memberof IgxDropDirective\n     */\n\n\n    set dropStrategy(classRef) {\n      this._dropStrategy = new classRef(this._renderer);\n    }\n\n    get dropStrategy() {\n      return this._dropStrategy;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onDragDrop(event) {\n      if (!this.isDragLinked(event.detail.owner)) {\n        return;\n      }\n\n      const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();\n      const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();\n      const offsetX = event.detail.pageX - elementPosX;\n      const offsetY = event.detail.pageY - elementPosY;\n      const args = {\n        owner: this,\n        originalEvent: event.detail.originalEvent,\n        drag: event.detail.owner,\n        dragData: event.detail.owner.data,\n        startX: event.detail.startX,\n        startY: event.detail.startY,\n        pageX: event.detail.pageX,\n        pageY: event.detail.pageY,\n        offsetX,\n        offsetY,\n        cancel: false\n      };\n\n      this._zone.run(() => {\n        this.dropped.emit(args);\n      });\n\n      if (this._dropStrategy && !args.cancel) {\n        const elementsAtPoint = event.detail.owner.getElementsAtPoint(event.detail.pageX, event.detail.pageY);\n        const insertIndex = this.getInsertIndexAt(event.detail.owner, elementsAtPoint);\n\n        this._dropStrategy.dropAction(event.detail.owner, this, insertIndex);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      this._zone.runOutsideAngular(() => {\n        fromEvent(this.element.nativeElement, 'igxDragEnter').pipe(takeUntil(this._destroy)).subscribe(res => this.onDragEnter(res));\n        fromEvent(this.element.nativeElement, 'igxDragLeave').pipe(takeUntil(this._destroy)).subscribe(res => this.onDragLeave(res));\n        fromEvent(this.element.nativeElement, 'igxDragOver').pipe(takeUntil(this._destroy)).subscribe(res => this.onDragOver(res));\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      this._destroy.next(true);\n\n      this._destroy.complete();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onDragOver(event) {\n      const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();\n      const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();\n      const offsetX = event.detail.pageX - elementPosX;\n      const offsetY = event.detail.pageY - elementPosY;\n      const eventArgs = {\n        originalEvent: event.detail.originalEvent,\n        owner: this,\n        drag: event.detail.owner,\n        dragData: event.detail.owner.data,\n        startX: event.detail.startX,\n        startY: event.detail.startY,\n        pageX: event.detail.pageX,\n        pageY: event.detail.pageY,\n        offsetX,\n        offsetY\n      };\n      this.over.emit(eventArgs);\n    }\n    /**\n     * @hidden\n     */\n\n\n    onDragEnter(event) {\n      if (!this.isDragLinked(event.detail.owner)) {\n        return;\n      }\n\n      this.dragover = true;\n      const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();\n      const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();\n      const offsetX = event.detail.pageX - elementPosX;\n      const offsetY = event.detail.pageY - elementPosY;\n      const eventArgs = {\n        originalEvent: event.detail.originalEvent,\n        owner: this,\n        drag: event.detail.owner,\n        dragData: event.detail.owner.data,\n        startX: event.detail.startX,\n        startY: event.detail.startY,\n        pageX: event.detail.pageX,\n        pageY: event.detail.pageY,\n        offsetX,\n        offsetY\n      };\n\n      this._zone.run(() => {\n        this.enter.emit(eventArgs);\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    onDragLeave(event) {\n      if (!this.isDragLinked(event.detail.owner)) {\n        return;\n      }\n\n      this.dragover = false;\n      const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();\n      const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();\n      const offsetX = event.detail.pageX - elementPosX;\n      const offsetY = event.detail.pageY - elementPosY;\n      const eventArgs = {\n        originalEvent: event.detail.originalEvent,\n        owner: this,\n        drag: event.detail.owner,\n        dragData: event.detail.owner.data,\n        startX: event.detail.startX,\n        startY: event.detail.startY,\n        pageX: event.detail.pageX,\n        pageY: event.detail.pageY,\n        offsetX,\n        offsetY\n      };\n\n      this._zone.run(() => {\n        this.leave.emit(eventArgs);\n      });\n    }\n\n    getWindowScrollTop() {\n      return window.scrollY ? window.scrollY : window.pageYOffset ? window.pageYOffset : 0;\n    }\n\n    getWindowScrollLeft() {\n      return window.scrollX ? window.scrollX : window.pageXOffset ? window.pageXOffset : 0;\n    }\n\n    isDragLinked(drag) {\n      const dragLinkArray = drag.dragChannel instanceof Array;\n      const dropLinkArray = this.dropChannel instanceof Array;\n\n      if (!dragLinkArray && !dropLinkArray) {\n        return this.dropChannel === drag.dragChannel;\n      } else if (!dragLinkArray && dropLinkArray) {\n        const dropLinks = this.dropChannel;\n\n        for (const link of dropLinks) {\n          if (link === drag.dragChannel) {\n            return true;\n          }\n        }\n      } else if (dragLinkArray && !dropLinkArray) {\n        const dragLinks = drag.dragChannel;\n\n        for (const link of dragLinks) {\n          if (link === this.dropChannel) {\n            return true;\n          }\n        }\n      } else {\n        const dragLinks = drag.dragChannel;\n        const dropLinks = this.dropChannel;\n\n        for (const draglink of dragLinks) {\n          for (const droplink of dropLinks) {\n            if (draglink === droplink) {\n              return true;\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n\n    getInsertIndexAt(draggedDir, elementsAtPoint) {\n      let insertIndex = -1;\n      const dropChildren = Array.prototype.slice.call(this.element.nativeElement.children);\n\n      if (!dropChildren.length) {\n        return insertIndex;\n      }\n\n      let i = 0;\n      let childUnder = null;\n\n      while (!childUnder && i < elementsAtPoint.length) {\n        if (elementsAtPoint[i].parentElement === this.element.nativeElement) {\n          childUnder = elementsAtPoint[i];\n        }\n\n        i++;\n      }\n\n      const draggedElemIndex = dropChildren.indexOf(draggedDir.element.nativeElement);\n      insertIndex = dropChildren.indexOf(childUnder);\n\n      if (draggedElemIndex !== -1 && draggedElemIndex < insertIndex) {\n        insertIndex++;\n      }\n\n      return insertIndex;\n    }\n\n  }\n\n  IgxDropDirective.ɵfac = function IgxDropDirective_Factory(t) {\n    return new (t || IgxDropDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  IgxDropDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxDropDirective,\n    selectors: [[\"\", \"igxDrop\", \"\"]],\n    hostVars: 3,\n    hostBindings: function IgxDropDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"igxDrop\", function IgxDropDirective_igxDrop_HostBindingHandler($event) {\n          return ctx.onDragDrop($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"droppable\", ctx.droppable);\n        i0.ɵɵclassProp(\"dragOver\", ctx.dragover);\n      }\n    },\n    inputs: {\n      data: [\"igxDrop\", \"data\"],\n      dropChannel: \"dropChannel\",\n      dropStrategy: \"dropStrategy\"\n    },\n    outputs: {\n      enter: \"enter\",\n      over: \"over\",\n      leave: \"leave\",\n      dropped: \"dropped\"\n    },\n    exportAs: [\"drop\"]\n  });\n  return IgxDropDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxDragDropModule = /*#__PURE__*/(() => {\n  class IgxDragDropModule {}\n\n  IgxDragDropModule.ɵfac = function IgxDragDropModule_Factory(t) {\n    return new (t || IgxDragDropModule)();\n  };\n\n  IgxDragDropModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxDragDropModule\n  });\n  IgxDragDropModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return IgxDragDropModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass IgxFilterOptions {\n  constructor() {\n    // Input text value that will be used as a filtering pattern (matching condition is based on it)\n    this.inputValue = '';\n  } // Function - get value to be tested from the item\n  // item - single item of the list to be filtered\n  // key - property name of item, which value should be tested\n  // Default behavior - returns \"key\"- named property value of item if key si provided,\n  // otherwise textContent of the item's html element\n\n\n  get_value(item, key) {\n    let result = '';\n\n    if (key && item[key]) {\n      result = item[key].toString();\n    } else if (item.element) {\n      if (item.element.nativeElement) {\n        result = item.element.nativeElement.textContent.trim(); // Check if element doesn't return the DOM element directly\n      } else if (item.element.textContent) {\n        result = item.element.textContent.trim();\n      }\n    }\n\n    return result;\n  } // Function - formats the original text before matching process\n  // Default behavior - returns text to lower case\n\n\n  formatter(valueToTest) {\n    return valueToTest.toLowerCase();\n  } // Function - determines whether the item met the condition\n  // valueToTest - text value that should be tested\n  // inputValue - text value from input that condition is based on\n  // Default behavior - \"contains\"\n\n\n  matchFn(valueToTest, inputValue) {\n    return valueToTest.indexOf(inputValue && inputValue.toLowerCase() || '') > -1;\n  } // Function - executed after matching test for every matched item\n  // Default behavior - shows the item\n\n\n  metConditionFn(item) {\n    if (item.hasOwnProperty('hidden')) {\n      item.hidden = false;\n    }\n  } // Function - executed for every NOT matched item after matching test\n  // Default behavior - hides the item\n\n\n  overdueConditionFn(item) {\n    if (item.hasOwnProperty('hidden')) {\n      item.hidden = true;\n    }\n  }\n\n}\n\nlet IgxFilterDirective = /*#__PURE__*/(() => {\n  class IgxFilterDirective {\n    constructor(element, renderer) {\n      this.element = element;\n      this.filtering = new EventEmitter(false); // synchronous event emitter\n\n      this.filtered = new EventEmitter();\n    }\n\n    ngOnChanges(changes) {\n      // Detect only changes of input value\n      if (changes.filterOptions && changes.filterOptions.currentValue && changes.filterOptions.currentValue.inputValue !== undefined && changes.filterOptions.previousValue && changes.filterOptions.currentValue.inputValue !== changes.filterOptions.previousValue.inputValue) {\n        this.filter();\n      }\n    }\n\n    filter() {\n      if (!this.filterOptions.items) {\n        return;\n      }\n\n      const args = {\n        cancel: false,\n        items: this.filterOptions.items\n      };\n      this.filtering.emit(args);\n\n      if (args.cancel) {\n        return;\n      }\n\n      const pipe = new IgxFilterPipe();\n      const filtered = pipe.transform(this.filterOptions.items, this.filterOptions);\n      this.filtered.emit({\n        filteredItems: filtered\n      });\n    }\n\n  }\n\n  IgxFilterDirective.ɵfac = function IgxFilterDirective_Factory(t) {\n    return new (t || IgxFilterDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  IgxFilterDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxFilterDirective,\n    selectors: [[\"\", \"igxFilter\", \"\"]],\n    inputs: {\n      filterOptions: [\"igxFilter\", \"filterOptions\"]\n    },\n    outputs: {\n      filtering: \"filtering\",\n      filtered: \"filtered\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return IgxFilterDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxFilterPipe = /*#__PURE__*/(() => {\n  class IgxFilterPipe {\n    transform(items, // options - initial settings of filter functionality\n    options) {\n      let result = [];\n\n      if (!items || !items.length || !options) {\n        return;\n      }\n\n      if (options.items) {\n        items = options.items;\n      }\n\n      result = items.filter(item => {\n        const match = options.matchFn(options.formatter(options.get_value(item, options.key)), options.inputValue);\n\n        if (match) {\n          if (options.metConditionFn) {\n            options.metConditionFn(item);\n          }\n        } else {\n          if (options.overdueConditionFn) {\n            options.overdueConditionFn(item);\n          }\n        }\n\n        return match;\n      });\n      return result;\n    }\n\n  }\n\n  IgxFilterPipe.ɵfac = function IgxFilterPipe_Factory(t) {\n    return new (t || IgxFilterPipe)();\n  };\n\n  IgxFilterPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"igxFilter\",\n    type: IgxFilterPipe,\n    pure: false\n  });\n  return IgxFilterPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxFilterModule = /*#__PURE__*/(() => {\n  class IgxFilterModule {}\n\n  IgxFilterModule.ɵfac = function IgxFilterModule_Factory(t) {\n    return new (t || IgxFilterModule)();\n  };\n\n  IgxFilterModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxFilterModule\n  });\n  IgxFilterModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return IgxFilterModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxFocusDirective = /*#__PURE__*/(() => {\n  class IgxFocusDirective {\n    constructor(element, comp) {\n      this.element = element;\n      this.comp = comp;\n      this.focusState = true;\n    }\n    /**\n     * Returns the state of the igxFocus.\n     * ```typescript\n     * @ViewChild('focusContainer', {read: IgxFocusDirective})\n     * public igxFocus: IgxFocusDirective;\n     * let isFocusOn = this.igxFocus.focused;\n     * ```\n     *\n     * @memberof IgxFocusDirective\n     */\n\n\n    get focused() {\n      return this.focusState;\n    }\n    /**\n     * Sets the state of the igxFocus.\n     * ```html\n     * <igx-input-group >\n     *  <input #focusContainer igxInput [igxFocus]=\"true\"/>\n     * </igx-input-group>\n     * ```\n     *\n     * @memberof IgxFocusDirective\n     */\n\n\n    set focused(val) {\n      this.focusState = val;\n      this.trigger();\n    }\n    /**\n     * Gets the native element of the igxFocus.\n     * ```typescript\n     * @ViewChild('focusContainer', {read: IgxFocusDirective})\n     * public igxFocus: IgxFocusDirective;\n     * let igxFocusNativeElement = this.igxFocus.nativeElement;\n     * ```\n     *\n     * @memberof IgxFocusDirective\n     */\n\n\n    get nativeElement() {\n      if (this.comp && this.comp[0] && this.comp[0].getEditElement) {\n        return this.comp[0].getEditElement();\n      }\n\n      return this.element.nativeElement;\n    }\n    /**\n     * Triggers the igxFocus state.\n     * ```typescript\n     * @ViewChild('focusContainer', {read: IgxFocusDirective})\n     * public igxFocus: IgxFocusDirective;\n     * this.igxFocus.trigger();\n     * ```\n     *\n     * @memberof IgxFocusDirective\n     */\n\n\n    trigger() {\n      if (this.focusState) {\n        requestAnimationFrame(() => this.nativeElement.focus({\n          preventScroll: true\n        }));\n      }\n    }\n\n  }\n\n  IgxFocusDirective.ɵfac = function IgxFocusDirective_Factory(t) {\n    return new (t || IgxFocusDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 10));\n  };\n\n  IgxFocusDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxFocusDirective,\n    selectors: [[\"\", \"igxFocus\", \"\"]],\n    inputs: {\n      focused: [\"igxFocus\", \"focused\"]\n    },\n    exportAs: [\"igxFocus\"]\n  });\n  return IgxFocusDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxFocusModule = /*#__PURE__*/(() => {\n  class IgxFocusModule {}\n\n  IgxFocusModule.ɵfac = function IgxFocusModule_Factory(t) {\n    return new (t || IgxFocusModule)();\n  };\n\n  IgxFocusModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxFocusModule\n  });\n  IgxFocusModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return IgxFocusModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxFocusTrapDirective = /*#__PURE__*/(() => {\n  class IgxFocusTrapDirective {\n    /** @hidden */\n    constructor(elementRef, platformUtil) {\n      this.elementRef = elementRef;\n      this.platformUtil = platformUtil;\n      this.destroy$ = new Subject();\n      this._focusTrap = true;\n    }\n    /** @hidden */\n\n\n    get element() {\n      return this.elementRef.nativeElement;\n    }\n    /**\n     * Sets whether the Tab key focus is trapped within the element.\n     *\n     * @example\n     * ```html\n     * <div igxFocusTrap=\"true\"></div>\n     * ```\n     */\n\n\n    set focusTrap(focusTrap) {\n      this._focusTrap = focusTrap;\n    }\n    /** @hidden */\n\n\n    get focusTrap() {\n      return this._focusTrap;\n    }\n    /** @hidden */\n\n\n    ngAfterViewInit() {\n      fromEvent(this.element, 'keydown').pipe(takeUntil(this.destroy$)).subscribe(event => {\n        if (this._focusTrap && event.key === this.platformUtil.KEYMAP.TAB) {\n          this.handleTab(event);\n        }\n      });\n    }\n    /** @hidden */\n\n\n    ngOnDestroy() {\n      this.destroy$.complete();\n    }\n\n    handleTab(event) {\n      const elements = this.getFocusableElements(this.element);\n\n      if (elements.length > 0) {\n        const focusedElement = this.getFocusedElement();\n        const focusedElementIndex = elements.findIndex(element => element === focusedElement);\n        const direction = event.shiftKey ? -1 : 1;\n        let nextFocusableElementIndex = focusedElementIndex + direction;\n\n        if (nextFocusableElementIndex < 0) {\n          nextFocusableElementIndex = elements.length - 1;\n        }\n\n        if (nextFocusableElementIndex >= elements.length) {\n          nextFocusableElementIndex = 0;\n        }\n\n        elements[nextFocusableElementIndex].focus();\n      } else {\n        this.element.focus();\n      }\n\n      event.preventDefault();\n    }\n\n    getFocusableElements(element) {\n      return Array.from(element.querySelectorAll('a[href], button, input, textarea, select, details,[tabindex]:not([tabindex=\"-1\"])')).filter(el => !el.hasAttribute('disabled') && !el.getAttribute('aria-hidden'));\n    }\n\n    getFocusedElement() {\n      let activeElement = typeof document !== 'undefined' && document ? document.activeElement : null;\n\n      while (activeElement && activeElement.shadowRoot) {\n        const newActiveElement = activeElement.shadowRoot.activeElement;\n\n        if (newActiveElement === activeElement) {\n          break;\n        } else {\n          activeElement = newActiveElement;\n        }\n      }\n\n      return activeElement;\n    }\n\n  }\n\n  IgxFocusTrapDirective.ɵfac = function IgxFocusTrapDirective_Factory(t) {\n    return new (t || IgxFocusTrapDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxFocusTrapDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxFocusTrapDirective,\n    selectors: [[\"\", \"igxFocusTrap\", \"\"]],\n    inputs: {\n      focusTrap: [\"igxFocusTrap\", \"focusTrap\"]\n    }\n  });\n  return IgxFocusTrapDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxFocusTrapModule = /*#__PURE__*/(() => {\n  class IgxFocusTrapModule {}\n\n  IgxFocusTrapModule.ɵfac = function IgxFocusTrapModule_Factory(t) {\n    return new (t || IgxFocusTrapModule)();\n  };\n\n  IgxFocusTrapModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxFocusTrapModule\n  });\n  IgxFocusTrapModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return IgxFocusTrapModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxLayoutDirective = /*#__PURE__*/(() => {\n  class IgxLayoutDirective {\n    constructor() {\n      /**\n       * Sets the default flow direction of the container's children.\n       *\n       * Defaults to `rows`.\n       *\n       * ```html\n       *  <div\n       *   igxLayout\n       *   igxLayoutDir=\"row\">\n       *    <div igxFlex>1</div>\n       *    <div igxFlex>2</div>\n       *    <div igxFlex>3</div>\n       *  </div>\n       * ```\n       */\n      this.dir = 'row';\n      /**\n       * Defines the direction flex children are placed in the flex container.\n       *\n       * When set to `true`, the `rows` direction goes right to left and `columns` goes bottom to top.\n       *\n       * ```html\n       * <div\n       *   igxLayout\n       *   igxLayoutReverse=\"true\">\n       *    <div igxFlex>1</div>\n       *    <div igxFlex>2</div>\n       *    <div igxFlex>3</div>\n       * </div>\n       * ```\n       */\n\n      this.reverse = false;\n      /**\n       * By default the immediate children will all try to fit onto one line.\n       *\n       * The default value `nowrap` sets this behavior.\n       *\n       * Other accepted values are `wrap` and `wrap-reverse`.\n       *\n       * ```html\n       * <div\n       *   igxLayout\n       *   igxLayoutDir=\"row\"\n       *   igxLayoutWrap=\"wrap\">\n       *    <div igxFlex igxFlexGrow=\"0\">1</div>\n       *    <div igxFlex igxFlexGrow=\"0\">2</div>\n       *    <div igxFlex igxFlexGrow=\"0\">3</div>\n       * </div>\n       * ```\n       */\n\n      this.wrap = 'nowrap';\n      /**\n       * Defines the alignment along the main axis.\n       *\n       * Defaults to `flex-start` which packs the children toward the start line.\n       *\n       * Other possible values are `flex-end`, `center`, `space-between`, `space-around`.\n       *\n       * ```html\n       * <div\n       *   igxLayout\n       *   igxLayoutDir=\"column\"\n       *   igxLayoutJustify=\"space-between\">\n       *    <div>1</div>\n       *    <div>2</div>\n       *    <div>3</div>\n       * </div>\n       * ```\n       */\n\n      this.justify = 'flex-start';\n      /**\n       * Defines the default behavior for how children are laid out along the corss axis of the current line.\n       *\n       * Defaults to `flex-start`.\n       *\n       * Other possible values are `flex-end`, `center`, `baseline`, and `stretch`.\n       *\n       * ```html\n       * <div\n       *   igxLayout\n       *   igxLayoutDir=\"column\"\n       *   igxLayoutItemAlign=\"start\">\n       *    <div igxFlex igxFlexGrow=\"0\">1</div>\n       *    <div igxFlex igxFlexGrow=\"0\">2</div>\n       *    <div igxFlex igxFlexGrow=\"0\">3</div>\n       * </div>\n       * ```\n       */\n\n      this.itemAlign = 'stretch';\n      /**\n       * @hidden\n       */\n\n      this.display = 'flex';\n    }\n    /**\n     * @hidden\n     */\n\n\n    get flexwrap() {\n      return this.wrap;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get justifycontent() {\n      return this.justify;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get align() {\n      return this.itemAlign;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get direction() {\n      if (this.reverse) {\n        return this.dir === 'row' ? 'row-reverse' : 'column-reverse';\n      }\n\n      return this.dir === 'row' ? 'row' : 'column';\n    }\n\n  }\n\n  IgxLayoutDirective.ɵfac = function IgxLayoutDirective_Factory(t) {\n    return new (t || IgxLayoutDirective)();\n  };\n\n  IgxLayoutDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxLayoutDirective,\n    selectors: [[\"\", \"igxLayout\", \"\"]],\n    hostVars: 10,\n    hostBindings: function IgxLayoutDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"display\", ctx.display)(\"flex-wrap\", ctx.flexwrap)(\"justify-content\", ctx.justifycontent)(\"align-items\", ctx.align)(\"flex-direction\", ctx.direction);\n      }\n    },\n    inputs: {\n      dir: [\"igxLayoutDir\", \"dir\"],\n      reverse: [\"igxLayoutReverse\", \"reverse\"],\n      wrap: [\"igxLayoutWrap\", \"wrap\"],\n      justify: [\"igxLayoutJustify\", \"justify\"],\n      itemAlign: [\"igxLayoutItemAlign\", \"itemAlign\"]\n    }\n  });\n  return IgxLayoutDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxFlexDirective = /*#__PURE__*/(() => {\n  class IgxFlexDirective {\n    constructor() {\n      /**\n       * Applies the `grow` attribute to an element that uses the directive.\n       *\n       * Default value is `1`.\n       *\n       * ```html\n       * <div>\n       *    <div igxFlex igxFlexGrow=\"0\">Content1</div>\n       *    <div igxFlex igxFlexGrow=\"1\">Content2</div>\n       *    <div igxFlex igxFlexGrow=\"0\">Content3</div>\n       * </div>\n       * ```\n       */\n      this.grow = 1;\n      /**\n       * Applies the `shrink` attribute to an element that uses the directive.\n       *\n       * Default value is `1`.\n       *\n       * ```html\n       * <div>\n       *    <div igxFlex igxFlexShrink=\"1\">Content1</div>\n       *    <div igxFlex igxFlexShrink=\"0\">Content2</div>\n       *    <div igxFlex igxFlexShrink=\"1\">Content3</div>\n       * </div>\n       * ```\n       */\n\n      this.shrink = 1;\n      /**\n       * Applies the directive to an element.\n       *\n       * Possible values include `igxFlexGrow`, `igxFlexShrink`, `igxFlexOrder`, `igxFlexBasis`.\n       *\n       * ```html\n       * <div igxFlex>Content</div>\n       * ```\n       */\n\n      this.flex = '';\n      /**\n       * Applies the `order` attribute to an element that uses the directive.\n       *\n       * Default value is `0`.\n       *\n       * ```html\n       * <div>\n       *    <div igxFlex igxFlexOrder=\"1\">Content1</div>\n       *    <div igxFlex igxFlexOrder=\"0\">Content2</div>\n       *    <div igxFlex igxFlexOrder=\"2\">Content3</div>\n       * </div>\n       * ```\n       */\n\n      this.order = 0;\n      /**\n       * Applies the `flex-basis` attribute to an element that uses the directive.\n       *\n       * Default value is `auto`.\n       *\n       * Other possible values include `content`, `max-content`, `min-content`, `fit-content`.\n       *\n       * ```html\n       * <div igxFlex igxFlexBasis=\"fit-content\">Content</div>\n       * ```\n       */\n\n      this.basis = 'auto';\n    }\n    /**\n     * @hidden\n     */\n\n\n    get style() {\n      if (this.flex) {\n        return `${this.flex}`;\n      }\n\n      return `${this.grow} ${this.shrink} ${this.basis}`;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get itemorder() {\n      return this.order || 0;\n    }\n\n  }\n\n  IgxFlexDirective.ɵfac = function IgxFlexDirective_Factory(t) {\n    return new (t || IgxFlexDirective)();\n  };\n\n  IgxFlexDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxFlexDirective,\n    selectors: [[\"\", \"igxFlex\", \"\"]],\n    hostVars: 4,\n    hostBindings: function IgxFlexDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"flex\", ctx.style)(\"order\", ctx.itemorder);\n      }\n    },\n    inputs: {\n      grow: [\"igxFlexGrow\", \"grow\"],\n      shrink: [\"igxFlexShrink\", \"shrink\"],\n      flex: [\"igxFlex\", \"flex\"],\n      order: [\"igxFlexOrder\", \"order\"],\n      basis: [\"igxFlexBasis\", \"basis\"]\n    }\n  });\n  return IgxFlexDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxLayoutModule = /*#__PURE__*/(() => {\n  class IgxLayoutModule {}\n\n  IgxLayoutModule.ɵfac = function IgxLayoutModule_Factory(t) {\n    return new (t || IgxLayoutModule)();\n  };\n\n  IgxLayoutModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxLayoutModule\n  });\n  IgxLayoutModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return IgxLayoutModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nconst MASK_FLAGS = ['C', '&', 'a', 'A', '?', 'L', '9', '0', '#'];\n/** @hidden */\n\nlet MaskParsingService = /*#__PURE__*/(() => {\n  class MaskParsingService {\n    applyMask(inputVal, maskOptions) {\n      let outputVal = '';\n      let value = '';\n      const mask = maskOptions.format;\n      const literals = this.getMaskLiterals(mask);\n      const literalKeys = Array.from(literals.keys());\n      const nonLiteralIndices = this.getNonLiteralIndices(mask, literalKeys);\n      const literalValues = Array.from(literals.values());\n\n      if (inputVal != null) {\n        value = inputVal.toString();\n      }\n\n      for (const _maskSym of mask) {\n        outputVal += maskOptions.promptChar;\n      }\n\n      literals.forEach((val, key) => {\n        outputVal = this.replaceCharAt(outputVal, key, val);\n      });\n\n      if (!value) {\n        return outputVal;\n      }\n\n      const nonLiteralValues = this.getNonLiteralValues(value, literalValues);\n\n      for (let i = 0; i < nonLiteralValues.length; i++) {\n        const char = nonLiteralValues[i];\n        const isCharValid = this.validateCharOnPosition(char, nonLiteralIndices[i], mask);\n\n        if (!isCharValid && char !== maskOptions.promptChar) {\n          nonLiteralValues[i] = maskOptions.promptChar;\n        }\n      }\n\n      if (nonLiteralValues.length > nonLiteralIndices.length) {\n        nonLiteralValues.splice(nonLiteralIndices.length);\n      }\n\n      let pos = 0;\n\n      for (const nonLiteralValue of nonLiteralValues) {\n        const char = nonLiteralValue;\n        outputVal = this.replaceCharAt(outputVal, nonLiteralIndices[pos++], char);\n      }\n\n      return outputVal;\n    }\n\n    parseValueFromMask(maskedValue, maskOptions) {\n      let outputVal = '';\n      const mask = maskOptions.format;\n      const literals = this.getMaskLiterals(mask);\n      const literalValues = Array.from(literals.values());\n\n      for (const val of maskedValue) {\n        if (literalValues.indexOf(val) === -1) {\n          if (val !== maskOptions.promptChar) {\n            outputVal += val;\n          }\n        }\n      }\n\n      return outputVal;\n    }\n\n    replaceInMask(maskedValue, value, maskOptions, start, end) {\n      const literalsPositions = Array.from(this.getMaskLiterals(maskOptions.format).keys());\n      value = this.replaceIMENumbers(value);\n      const chars = Array.from(value);\n      let cursor = start;\n      end = Math.min(end, maskedValue.length);\n\n      for (let i = start; i < end || chars.length && i < maskedValue.length; i++) {\n        if (literalsPositions.indexOf(i) !== -1) {\n          if (chars[0] === maskedValue[i]) {\n            cursor = i + 1;\n            chars.shift();\n          }\n\n          continue;\n        }\n\n        if (chars[0] && !this.validateCharOnPosition(chars[0], i, maskOptions.format) && chars[0] !== maskOptions.promptChar) {\n          break;\n        }\n\n        let char = maskOptions.promptChar;\n\n        if (chars.length) {\n          cursor = i + 1;\n          char = chars.shift();\n        }\n\n        maskedValue = this.replaceCharAt(maskedValue, i, char);\n      }\n\n      return {\n        value: maskedValue,\n        end: cursor\n      };\n    }\n\n    replaceCharAt(strValue, index, char) {\n      if (strValue !== undefined) {\n        return strValue.substring(0, index) + char + strValue.substring(index + 1);\n      }\n    }\n\n    getMaskLiterals(mask) {\n      const literals = new Map();\n\n      for (let i = 0; i < mask.length; i++) {\n        const char = mask.charAt(i);\n\n        if (MASK_FLAGS.indexOf(char) === -1) {\n          literals.set(i, char);\n        }\n      }\n\n      return literals;\n    }\n    /** Validates only non literal positions. */\n\n\n    validateCharOnPosition(inputChar, position, mask) {\n      let regex;\n      let isValid;\n      const letterOrDigitRegEx = '[\\\\d\\\\u00C0-\\\\u1FFF\\\\u2C00-\\\\uD7FFa-zA-Z]';\n      const letterDigitOrSpaceRegEx = '[\\\\d\\\\u00C0-\\\\u1FFF\\\\u2C00-\\\\uD7FFa-zA-Z\\\\u0020]';\n      const letterRegEx = '[\\\\u00C0-\\\\u1FFF\\\\u2C00-\\\\uD7FFa-zA-Z]';\n      const letterSpaceRegEx = '[\\\\u00C0-\\\\u1FFF\\\\u2C00-\\\\uD7FFa-zA-Z\\\\u0020]';\n      const digitRegEx = '[\\\\d]';\n      const digitSpaceRegEx = '[\\\\d\\\\u0020]';\n      const digitSpecialRegEx = '[\\\\d-\\\\+]';\n\n      switch (mask.charAt(position)) {\n        case 'C':\n          isValid = inputChar !== '';\n          break;\n\n        case '&':\n          regex = new RegExp('[\\\\u0020]');\n          isValid = !regex.test(inputChar);\n          break;\n\n        case 'a':\n          regex = new RegExp(letterDigitOrSpaceRegEx);\n          isValid = regex.test(inputChar);\n          break;\n\n        case 'A':\n          regex = new RegExp(letterOrDigitRegEx);\n          isValid = regex.test(inputChar);\n          break;\n\n        case '?':\n          regex = new RegExp(letterSpaceRegEx);\n          isValid = regex.test(inputChar);\n          break;\n\n        case 'L':\n          regex = new RegExp(letterRegEx);\n          isValid = regex.test(inputChar);\n          break;\n\n        case '0':\n          regex = new RegExp(digitRegEx);\n          isValid = regex.test(inputChar);\n          break;\n\n        case '9':\n          regex = new RegExp(digitSpaceRegEx);\n          isValid = regex.test(inputChar);\n          break;\n\n        case '#':\n          regex = new RegExp(digitSpecialRegEx);\n          isValid = regex.test(inputChar);\n          break;\n\n        default:\n          {\n            isValid = null;\n          }\n      }\n\n      return isValid;\n    }\n\n    getNonLiteralIndices(mask, literalKeys) {\n      const nonLiteralsIndices = new Array();\n\n      for (let i = 0; i < mask.length; i++) {\n        if (literalKeys.indexOf(i) === -1) {\n          nonLiteralsIndices.push(i);\n        }\n      }\n\n      return nonLiteralsIndices;\n    }\n\n    getNonLiteralValues(value, literalValues) {\n      const nonLiteralValues = new Array();\n\n      for (const val of value) {\n        if (literalValues.indexOf(val) === -1) {\n          nonLiteralValues.push(val);\n        }\n      }\n\n      return nonLiteralValues;\n    }\n\n    replaceIMENumbers(value) {\n      return value.replace(/[０１２３４５６７８９]/g, num => ({\n        '１': '1',\n        '２': '2',\n        '３': '3',\n        '４': '4',\n        '５': '5',\n        '６': '6',\n        '７': '7',\n        '８': '8',\n        '９': '9',\n        '０': '0'\n      })[num]);\n    }\n\n  }\n\n  MaskParsingService.ɵfac = function MaskParsingService_Factory(t) {\n    return new (t || MaskParsingService)();\n  };\n\n  MaskParsingService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MaskParsingService,\n    factory: MaskParsingService.ɵfac,\n    providedIn: 'root'\n  });\n  return MaskParsingService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxMaskDirective = /*#__PURE__*/(() => {\n  class IgxMaskDirective {\n    constructor(elementRef, maskParser, renderer, platform) {\n      this.elementRef = elementRef;\n      this.maskParser = maskParser;\n      this.renderer = renderer;\n      this.platform = platform;\n      /**\n       * Sets the character representing a fillable spot in the input mask.\n       * Default value is \"'_'\".\n       * ```html\n       * <input [promptChar] = \"'/'\">\n       * ```\n       */\n\n      this.promptChar = '_';\n      /**\n       * Emits an event each time the value changes.\n       * Provides `rawValue: string` and `formattedValue: string` as event arguments.\n       * ```html\n       * <input (valueChanged) = \"valueChanged(rawValue: string, formattedValue: string)\">\n       * ```\n       */\n\n      this.valueChanged = new EventEmitter();\n      this._end = 0;\n      this._start = 0;\n      this._oldText = '';\n      this._dataValue = '';\n      this._focused = false;\n      this.defaultMask = 'CCCCCCCCCC';\n      this._onTouchedCallback = noop;\n      this._onChangeCallback = noop;\n    }\n    /**\n     * Sets the input mask.\n     * ```html\n     * <input [igxMask] = \"'00/00/0000'\">\n     * ```\n     */\n\n\n    get mask() {\n      return this._mask || this.defaultMask;\n    }\n\n    set mask(val) {\n      // B.P. 9th June 2021 #7490\n      if (val !== this._mask) {\n        const cleanInputValue = this.maskParser.parseValueFromMask(this.inputValue, this.maskOptions);\n        this.setPlaceholder(val);\n        this._mask = val;\n        this.updateInputValue(cleanInputValue);\n      }\n    }\n    /** @hidden */\n\n\n    get nativeElement() {\n      return this.elementRef.nativeElement;\n    }\n    /** @hidden @internal; */\n\n\n    get inputValue() {\n      return this.nativeElement.value;\n    }\n    /** @hidden @internal */\n\n\n    set inputValue(val) {\n      this.nativeElement.value = val;\n    }\n    /** @hidden */\n\n\n    get maskOptions() {\n      const format = this.mask || this.defaultMask;\n      const promptChar = this.promptChar && this.promptChar.substring(0, 1);\n      return {\n        format,\n        promptChar\n      };\n    }\n    /** @hidden */\n\n\n    get selectionStart() {\n      // Edge(classic) and FF don't select text on drop\n      return this.nativeElement.selectionStart === this.nativeElement.selectionEnd && this._hasDropAction ? this.nativeElement.selectionEnd - this._droppedData.length : this.nativeElement.selectionStart;\n    }\n    /** @hidden */\n\n\n    get selectionEnd() {\n      return this.nativeElement.selectionEnd;\n    }\n    /** @hidden */\n\n\n    get start() {\n      return this._start;\n    }\n    /** @hidden */\n\n\n    get end() {\n      return this._end;\n    }\n    /** @hidden */\n\n\n    onKeyDown(event) {\n      const key = event.key;\n\n      if (!key) {\n        return;\n      }\n\n      if (event.ctrlKey && (key === this.platform.KEYMAP.Z || key === this.platform.KEYMAP.Y)) {\n        event.preventDefault();\n      }\n\n      this._key = key;\n      this._start = this.selectionStart;\n      this._end = this.selectionEnd;\n    }\n    /** @hidden @internal */\n\n\n    onCompositionStart() {\n      if (!this._composing) {\n        this._compositionStartIndex = this._start;\n        this._composing = true;\n      }\n    }\n    /** @hidden @internal */\n\n\n    onCompositionEnd() {\n      this._start = this._compositionStartIndex;\n      const end = this.selectionEnd;\n      const valueToParse = this.inputValue.substring(this._start, end);\n      this.updateInput(valueToParse);\n      this._end = this.selectionEnd;\n      this._compositionValue = this.inputValue;\n    }\n    /** @hidden @internal */\n\n\n    onInputChanged(event) {\n      /**\n       * '!this._focused' is a fix for #8165\n       * On page load IE triggers input events before focus events and\n       * it does so for every single input on the page.\n       * The mask needs to be prevented from doing anything while this is happening because\n       * the end user will be unable to blur the input.\n       * https://stackoverflow.com/questions/21406138/input-event-triggered-on-internet-explorer-when-placeholder-changed\n       */\n      if (this._composing) {\n        if (this.inputValue.length < this._oldText.length) {\n          // software keyboard input delete\n          this._key = this.platform.KEYMAP.BACKSPACE;\n        }\n\n        return;\n      } // After the compositionend event Chromium triggers input events of type 'deleteContentBackward' and\n      // we need to adjust the start and end indexes to include mask literals\n\n\n      if (event.inputType === 'deleteContentBackward' && this._key !== this.platform.KEYMAP.BACKSPACE) {\n        const isInputComplete = this._compositionStartIndex === 0 && this._end === this.mask.length;\n        let numberOfMaskLiterals = 0;\n        const literalPos = this.maskParser.getMaskLiterals(this.maskOptions.format).keys();\n\n        for (const index of literalPos) {\n          if (index >= this._compositionStartIndex && index <= this._end) {\n            numberOfMaskLiterals++;\n          }\n        }\n\n        this.inputValue = isInputComplete ? this.inputValue.substring(0, this.selectionEnd - numberOfMaskLiterals) + this.inputValue.substring(this.selectionEnd) : this._compositionValue.substring(0, this._compositionStartIndex);\n        this._start = this.selectionStart;\n        this._end = this.selectionEnd;\n        this.nativeElement.selectionStart = isInputComplete ? this._start - numberOfMaskLiterals : this._compositionStartIndex;\n        this.nativeElement.selectionEnd = this._end - numberOfMaskLiterals;\n        this.nativeElement.selectionEnd = this._end;\n        this._start = this.selectionStart;\n        this._end = this.selectionEnd;\n      }\n\n      if (this._hasDropAction) {\n        this._start = this.selectionStart;\n      }\n\n      let valueToParse = '';\n\n      switch (this._key) {\n        case this.platform.KEYMAP.DELETE:\n          this._end = this._start === this._end ? ++this._end : this._end;\n          break;\n\n        case this.platform.KEYMAP.BACKSPACE:\n          this._start = this.selectionStart;\n          break;\n\n        default:\n          valueToParse = this.inputValue.substring(this._start, this.selectionEnd);\n          break;\n      }\n\n      this.updateInput(valueToParse);\n    }\n    /** @hidden */\n\n\n    onPaste() {\n      this._oldText = this.inputValue;\n      this._start = this.selectionStart;\n    }\n    /** @hidden */\n\n\n    onFocus() {\n      if (this.nativeElement.readOnly) {\n        return;\n      }\n\n      this._focused = true;\n      this.showMask(this.inputValue);\n    }\n    /** @hidden */\n\n\n    onBlur(value) {\n      this._focused = false;\n      this.showDisplayValue(value);\n\n      this._onTouchedCallback();\n    }\n    /** @hidden */\n\n\n    onDragEnter() {\n      if (!this._focused) {\n        this.showMask(this._dataValue);\n      }\n    }\n    /** @hidden */\n\n\n    onDragLeave() {\n      if (!this._focused) {\n        this.showDisplayValue(this.inputValue);\n      }\n    }\n    /** @hidden */\n\n\n    onDrop(event) {\n      this._hasDropAction = true;\n      this._droppedData = event.dataTransfer.getData('text');\n    }\n    /** @hidden */\n\n\n    ngOnInit() {\n      this.setPlaceholder(this.maskOptions.format);\n    }\n    /**\n     * TODO: Remove after date/time picker integration refactor\n     *\n     * @hidden\n     */\n\n\n    ngAfterViewChecked() {\n      if (this._composing) {\n        return;\n      }\n\n      this._oldText = this.inputValue;\n    }\n    /** @hidden */\n\n\n    writeValue(value) {\n      if (this.promptChar && this.promptChar.length > 1) {\n        this.maskOptions.promptChar = this.promptChar.substring(0, 1);\n      }\n\n      this.inputValue = value ? this.maskParser.applyMask(value, this.maskOptions) : '';\n\n      if (this.displayValuePipe) {\n        this.inputValue = this.displayValuePipe.transform(this.inputValue);\n      }\n\n      this._dataValue = this.includeLiterals ? this.inputValue : value;\n      this.valueChanged.emit({\n        rawValue: value,\n        formattedValue: this.inputValue\n      });\n    }\n    /** @hidden */\n\n\n    registerOnChange(fn) {\n      this._onChangeCallback = fn;\n    }\n    /** @hidden */\n\n\n    registerOnTouched(fn) {\n      this._onTouchedCallback = fn;\n    }\n    /** @hidden */\n\n\n    showMask(value) {\n      if (this.focusedValuePipe) {\n        // TODO(D.P.): focusedValuePipe should be deprecated or force-checked to match mask format\n        this.inputValue = this.focusedValuePipe.transform(value);\n      } else {\n        this.inputValue = this.maskParser.applyMask(value, this.maskOptions);\n      }\n\n      this._oldText = this.inputValue;\n    }\n    /** @hidden */\n\n\n    setSelectionRange(start, end = start) {\n      this.nativeElement.setSelectionRange(start, end);\n    }\n    /** @hidden */\n\n\n    afterInput() {\n      this._oldText = this.inputValue;\n      this._hasDropAction = false;\n      this._start = 0;\n      this._end = 0;\n      this._key = null;\n      this._composing = false;\n    }\n    /** @hidden */\n\n\n    setPlaceholder(value) {\n      const placeholder = this.nativeElement.placeholder;\n\n      if (!placeholder || placeholder === this.mask) {\n        this.renderer.setAttribute(this.nativeElement, 'placeholder', value || this.defaultMask);\n      }\n    }\n\n    updateInputValue(value) {\n      if (this._focused) {\n        this.showMask(value);\n      } else if (!this.displayValuePipe) {\n        this.inputValue = this.inputValue ? this.maskParser.applyMask(value, this.maskOptions) : '';\n      }\n    }\n\n    updateInput(valueToParse) {\n      const replacedData = this.maskParser.replaceInMask(this._oldText, valueToParse, this.maskOptions, this._start, this._end);\n      this.inputValue = replacedData.value;\n\n      if (this._key === this.platform.KEYMAP.BACKSPACE) {\n        replacedData.end = this._start;\n      }\n\n      ;\n      this.setSelectionRange(replacedData.end);\n      const rawVal = this.maskParser.parseValueFromMask(this.inputValue, this.maskOptions);\n      this._dataValue = this.includeLiterals ? this.inputValue : rawVal;\n\n      this._onChangeCallback(this._dataValue);\n\n      this.valueChanged.emit({\n        rawValue: rawVal,\n        formattedValue: this.inputValue\n      });\n      this.afterInput();\n    }\n\n    showDisplayValue(value) {\n      if (this.displayValuePipe) {\n        this.inputValue = this.displayValuePipe.transform(value);\n      } else if (value === this.maskParser.applyMask(null, this.maskOptions)) {\n        this.inputValue = '';\n      }\n    }\n\n  }\n\n  IgxMaskDirective.ɵfac = function IgxMaskDirective_Factory(t) {\n    return new (t || IgxMaskDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(MaskParsingService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxMaskDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxMaskDirective,\n    selectors: [[\"\", \"igxMask\", \"\"]],\n    hostBindings: function IgxMaskDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function IgxMaskDirective_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        })(\"compositionstart\", function IgxMaskDirective_compositionstart_HostBindingHandler() {\n          return ctx.onCompositionStart();\n        })(\"compositionend\", function IgxMaskDirective_compositionend_HostBindingHandler() {\n          return ctx.onCompositionEnd();\n        })(\"input\", function IgxMaskDirective_input_HostBindingHandler($event) {\n          return ctx.onInputChanged($event);\n        })(\"paste\", function IgxMaskDirective_paste_HostBindingHandler() {\n          return ctx.onPaste();\n        })(\"focus\", function IgxMaskDirective_focus_HostBindingHandler() {\n          return ctx.onFocus();\n        })(\"blur\", function IgxMaskDirective_blur_HostBindingHandler($event) {\n          return ctx.onBlur($event.target.value);\n        })(\"dragenter\", function IgxMaskDirective_dragenter_HostBindingHandler() {\n          return ctx.onDragEnter();\n        })(\"dragleave\", function IgxMaskDirective_dragleave_HostBindingHandler() {\n          return ctx.onDragLeave();\n        })(\"drop\", function IgxMaskDirective_drop_HostBindingHandler($event) {\n          return ctx.onDrop($event);\n        });\n      }\n    },\n    inputs: {\n      mask: [\"igxMask\", \"mask\"],\n      promptChar: \"promptChar\",\n      includeLiterals: \"includeLiterals\",\n      displayValuePipe: \"displayValuePipe\",\n      focusedValuePipe: \"focusedValuePipe\"\n    },\n    outputs: {\n      valueChanged: \"valueChanged\"\n    },\n    exportAs: [\"igxMask\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: IgxMaskDirective,\n      multi: true\n    }])]\n  });\n  return IgxMaskDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxMaskModule = /*#__PURE__*/(() => {\n  class IgxMaskModule {}\n\n  IgxMaskModule.ɵfac = function IgxMaskModule_Factory(t) {\n    return new (t || IgxMaskModule)();\n  };\n\n  IgxMaskModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxMaskModule\n  });\n  IgxMaskModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return IgxMaskModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxRippleDirective = /*#__PURE__*/(() => {\n  class IgxRippleDirective {\n    constructor(builder, elementRef, renderer, zone) {\n      this.builder = builder;\n      this.elementRef = elementRef;\n      this.renderer = renderer;\n      this.zone = zone;\n      /**\n       * Sets/gets the ripple target.\n       * ```html\n       * <div  #rippleContainer class=\"div-1\" igxRipple [igxRippleTarget] = \"'.div-1'\"></div>\n       * ```\n       * ```typescript\n       * @ViewChild('rippleContainer', {read: IgxRippleDirective})\n       * public ripple: IgxRippleDirective;\n       * let rippleTarget = this.ripple.rippleTarget;\n       * ```\n       * Can set the ripple to activate on a child element inside the parent where igxRipple is defined.\n       * ```html\n       * <div #rippleContainer [igxRippleTarget] = \"'#child\"'>\n       *  <button id=\"child\">Click</button>\n       * </div>\n       * ```\n       *\n       * @memberof IgxRippleDirective\n       */\n\n      this.rippleTarget = '';\n      /**\n       * Sets/gets the ripple duration(in milliseconds).\n       * Default value is `600`.\n       * ```html\n       * <button #rippleContainer igxRipple [igxRippleDuration] = \"800\"></button>\n       * ```\n       * ```typescript\n       * @ViewChild('rippleContainer', {read: IgxRippleDirective})\n       * public ripple: IgxRippleDirective;\n       * let rippleDuration = this.ripple.rippleDuration;\n       * ```\n       *\n       * @memberof IgxRippleDirective\n       */\n\n      this.rippleDuration = 600;\n      /**\n       * Sets/gets whether the ripple is disabled.\n       * Default value is `false`.\n       * ```html\n       * <button #rippleContainer igxRipple [igxRippleDisabled] = \"true\"></button>\n       * ```\n       * ```typescript\n       * @ViewChild('rippleContainer', {read: IgxRippleDirective})\n       * public ripple: IgxRippleDirective;\n       * let isRippleDisabled = this.ripple.rippleDisabled;\n       * ```\n       *\n       * @memberof IgxRippleDirective\n       */\n\n      this.rippleDisabled = false;\n      this.rippleElementClass = 'igx-ripple__inner';\n      this.rippleHostClass = 'igx-ripple';\n      this._centered = false;\n      this.animationQueue = [];\n    }\n    /**\n     * Enables/disables the ripple to be centered.\n     * ```html\n     * <button #rippleContainer igxRipple [igxRippleCentered] = \"true\"></button>\n     * ```\n     *\n     * @memberof IgxRippleDirective\n     */\n\n\n    set centered(value) {\n      this._centered = value || this.centered;\n    }\n\n    get nativeElement() {\n      return this.elementRef.nativeElement;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onMouseDown(event) {\n      this.zone.runOutsideAngular(() => this._ripple(event));\n    }\n\n    setStyles(rippleElement, styleParams) {\n      this.renderer.addClass(rippleElement, this.rippleElementClass);\n      this.renderer.setStyle(rippleElement, 'width', `${styleParams.radius}px`);\n      this.renderer.setStyle(rippleElement, 'height', `${styleParams.radius}px`);\n      this.renderer.setStyle(rippleElement, 'top', `${styleParams.top}px`);\n      this.renderer.setStyle(rippleElement, 'left', `${styleParams.left}px`);\n\n      if (this.rippleColor) {\n        this.renderer.setStyle(rippleElement, 'background', this.rippleColor);\n      }\n    }\n\n    _ripple(event) {\n      if (this.rippleDisabled) {\n        return;\n      }\n\n      const target = this.rippleTarget ? this.nativeElement.querySelector(this.rippleTarget) || this.nativeElement : this.nativeElement;\n      const rectBounds = target.getBoundingClientRect();\n      const radius = Math.max(rectBounds.width, rectBounds.height);\n      let left = Math.round(event.clientX - rectBounds.left - radius / 2);\n      let top = Math.round(event.clientY - rectBounds.top - radius / 2);\n\n      if (this._centered) {\n        left = top = 0;\n      }\n\n      const dimensions = {\n        radius,\n        top,\n        left\n      };\n      const rippleElement = this.renderer.createElement('span');\n      this.setStyles(rippleElement, dimensions);\n      this.renderer.addClass(target, this.rippleHostClass);\n      this.renderer.appendChild(target, rippleElement);\n      const animation = this.builder.build([style({\n        opacity: 0.5,\n        transform: 'scale(.3)'\n      }), animate(this.rippleDuration, style({\n        opacity: 0,\n        transform: 'scale(2)'\n      }))]).create(rippleElement);\n      this.animationQueue.push(animation);\n      animation.onDone(() => {\n        this.animationQueue.splice(this.animationQueue.indexOf(animation), 1);\n        target.removeChild(rippleElement);\n\n        if (this.animationQueue.length < 1) {\n          this.renderer.removeClass(target, this.rippleHostClass);\n        }\n      });\n      animation.play();\n    }\n\n  }\n\n  IgxRippleDirective.ɵfac = function IgxRippleDirective_Factory(t) {\n    return new (t || IgxRippleDirective)(i0.ɵɵdirectiveInject(i1.AnimationBuilder), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  IgxRippleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxRippleDirective,\n    selectors: [[\"\", \"igxRipple\", \"\"]],\n    hostBindings: function IgxRippleDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"mousedown\", function IgxRippleDirective_mousedown_HostBindingHandler($event) {\n          return ctx.onMouseDown($event);\n        });\n      }\n    },\n    inputs: {\n      rippleTarget: [\"igxRippleTarget\", \"rippleTarget\"],\n      rippleColor: [\"igxRipple\", \"rippleColor\"],\n      rippleDuration: [\"igxRippleDuration\", \"rippleDuration\"],\n      centered: [\"igxRippleCentered\", \"centered\"],\n      rippleDisabled: [\"igxRippleDisabled\", \"rippleDisabled\"]\n    }\n  });\n  return IgxRippleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxRippleModule = /*#__PURE__*/(() => {\n  class IgxRippleModule {}\n\n  IgxRippleModule.ɵfac = function IgxRippleModule_Factory(t) {\n    return new (t || IgxRippleModule)();\n  };\n\n  IgxRippleModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxRippleModule\n  });\n  IgxRippleModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return IgxRippleModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst RadioLabelPosition = mkenum({\n  BEFORE: 'before',\n  AFTER: 'after'\n});\nlet nextId$3 = 0;\n/**\n * **Ignite UI for Angular Radio Button** -\n * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/radio_button.html)\n *\n * The Ignite UI Radio Button allows the user to select a single option from an available set of options that are listed side by side.\n *\n * Example:\n * ```html\n * <igx-radio>\n *   Simple radio button\n * </igx-radio>\n * ```\n */\n\nlet IgxRadioComponent = /*#__PURE__*/(() => {\n  class IgxRadioComponent {\n    constructor(cdr) {\n      this.cdr = cdr;\n      /**\n       * Sets/gets the `id` of the radio component.\n       * If not set, the `id` of the first radio component will be `\"igx-radio-0\"`.\n       * ```html\n       * <igx-radio id = \"my-first-radio\"></igx-radio>\n       * ```\n       * ```typescript\n       * let radioId =  this.radio.id;\n       * ```\n       *\n       * @memberof IgxRadioComponent\n       */\n\n      this.id = `igx-radio-${nextId$3++}`;\n      /**\n       * Sets/gets the id of the `label` element in the radio component.\n       * If not set, the id of the `label` in the first radio component will be `\"igx-radio-0-label\"`.\n       * ```html\n       * <igx-radio labelId = \"Label1\"></igx-radio>\n       * ```\n       * ```typescript\n       * let labelId =  this.radio.labelId;\n       * ```\n       *\n       * @memberof IgxRadioComponent\n       */\n\n      this.labelId = `${this.id}-label`;\n      /**\n       * Sets the value of the `tabindex` attribute.\n       * ```html\n       * <igx-radio [tabindex] = \"1\"></igx-radio>\n       * ```\n       * ```typescript\n       * let tabIndex =  this.radio.tabindex;\n       * ```\n       *\n       * @memberof IgxRadioComponent\n       */\n\n      this.tabindex = null;\n      /**\n       * Enables/disables the ripple effect on the radio button..\n       * If not set, the `disableRipple` will have value `false`.\n       * ```html\n       * <igx-radio [disableRipple] = \"true\"></igx-radio>\n       * ```\n       * ```typescript\n       * let isDisabledRipple =  this.radio.disableRipple;\n       * ```\n       *\n       * @memberof IgxRadioComponent\n       */\n\n      this.disableRipple = false;\n      /**\n       * Sets/gets the `aria-labelledby` attribute of the radio component.\n       * If not set, the `aria-labelledby` will be equal to the value of `labelId` attribute.\n       * ```html\n       * <igx-radio aria-labelledby = \"Radio1\"></igx-radio>\n       * ```\n       * ```typescript\n       * let ariaLabelledBy = this.radio.ariaLabelledBy;\n       * ```\n       *\n       * @memberof IgxRadioComponent\n       */\n\n      this.ariaLabelledBy = this.labelId;\n      /**\n       * Sets/gets the `aria-label` attribute of the radio component.\n       * ```html\n       * <igx-radio aria-label = \"Radio1\"></igx-radio>\n       * ```\n       * ```typescript\n       * let ariaLabel =  this.radio.ariaLabel;\n       * ```\n       *\n       * @memberof IgxRadioComponent\n       */\n\n      this.ariaLabel = null;\n      /**\n       * An event that is emitted after the radio `value` is changed.\n       * Provides references to the `IgxRadioComponent` and the `value` property as event arguments.\n       *\n       * @memberof IgxRadioComponent\n       */\n      // eslint-disable-next-line @angular-eslint/no-output-native\n\n      this.change = new EventEmitter();\n      /**\n       * Returns the class of the radio component.\n       * ```typescript\n       * let radioClass = this.radio.cssClass;\n       * ```\n       *\n       * @memberof IgxRadioComponent\n       */\n\n      this.cssClass = 'igx-radio';\n      /**\n       * Sets/gets  the `checked` attribute.\n       * Default value is `false`.\n       * ```html\n       * <igx-radio [checked] = \"true\"></igx-radio>\n       * ```\n       * ```typescript\n       * let isChecked =  this.radio.checked;\n       * ```\n       *\n       * @memberof IgxRadioComponent\n       */\n\n      this.checked = false;\n      /**\n       * Sets/gets whether the radio component is on focus.\n       * Default value is `false`.\n       * ```typescript\n       * this.radio.focus = true;\n       * ```\n       * ```typescript\n       * let isFocused =  this.radio.focused;\n       * ```\n       *\n       * @memberof IgxRadioComponent\n       */\n\n      this.focused = false;\n      /**\n       * @hidden\n       */\n\n      this.inputId = `${this.id}-input`;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this._required = false;\n      /**\n       * @hidden\n       */\n\n      this._onTouchedCallback = noop;\n      /**\n       * @hidden\n       */\n\n      this._onChangeCallback = noop;\n    }\n    /**\n     * Sets/gets whether the radio button is required.\n     * If not set, `required` will have value `false`.\n     * ```html\n     * <igx-radio required></igx-radio>\n     * ```\n     * ```typescript\n     * let isRequired =  this.radio.required;\n     * ```\n     *\n     * @memberof IgxRadioComponent\n     */\n\n\n    get required() {\n      return this._required;\n    }\n\n    set required(value) {\n      this._required = value === '' || value;\n    }\n    /**\n     * Sets/gets  the `disabled` attribute.\n     * Default value is `false`.\n     * ```html\n     * <igx-radio disabled></igx-radio>\n     * ```\n     * ```typescript\n     * let isDisabled =  this.radio.disabled;\n     * ```\n     *\n     * @memberof IgxRadioComponent\n     */\n\n\n    get disabled() {\n      return this._disabled || false;\n    }\n\n    set disabled(value) {\n      this._disabled = value === '' || value;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    _changed() {\n      if (event instanceof Event) {\n        event.preventDefault();\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onKeyUp(event) {\n      event.stopPropagation();\n      this.focused = true;\n      this.select();\n    }\n    /**\n     * @hidden\n     */\n\n\n    _clicked() {\n      this.select();\n    }\n    /**\n     * Selects the current radio button.\n     * ```typescript\n     * this.radio.select();\n     * ```\n     *\n     * @memberof IgxRadioComponent\n     */\n\n\n    select() {\n      this.nativeRadio.nativeElement.focus();\n\n      if (!this.checked) {\n        this.checked = true;\n        this.change.emit({\n          value: this.value,\n          radio: this\n        });\n\n        this._onChangeCallback(this.value);\n      }\n    }\n    /**\n     * Deselects the current radio button.\n     * ```typescript\n     * this.radio.deselect();\n     * ```\n     *\n     * @memberof IgxRadioComponent\n     */\n\n\n    deselect() {\n      this.checked = false;\n      this.focused = false;\n      this.cdr.markForCheck();\n    }\n    /**\n     * Checks whether the provided value is consistent to the current radio button.\n     * If it is, the checked attribute will have value `true`;\n     * ```typescript\n     * this.radio.writeValue('radioButtonValue');\n     * ```\n     */\n\n\n    writeValue(value) {\n      this.value = this.value || value;\n\n      if (value === this.value) {\n        this.select();\n      } else {\n        this.deselect();\n      }\n    }\n    /** @hidden */\n\n\n    getEditElement() {\n      return this.nativeRadio.nativeElement;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get labelClass() {\n      switch (this.labelPosition) {\n        case RadioLabelPosition.BEFORE:\n          return `${this.cssClass}__label--before`;\n\n        case RadioLabelPosition.AFTER:\n        default:\n          return `${this.cssClass}__label`;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onBlur() {\n      this.focused = false;\n\n      this._onTouchedCallback();\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this._onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this._onTouchedCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n\n  }\n\n  IgxRadioComponent.ɵfac = function IgxRadioComponent_Factory(t) {\n    return new (t || IgxRadioComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  IgxRadioComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxRadioComponent,\n    selectors: [[\"igx-radio\"]],\n    viewQuery: function IgxRadioComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c15, 7);\n        i0.ɵɵviewQuery(_c16, 7);\n        i0.ɵɵviewQuery(_c17, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nativeRadio = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nativeLabel = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.placeholderLabel = _t.first);\n      }\n    },\n    hostVars: 9,\n    hostBindings: function IgxRadioComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"change\", function IgxRadioComponent_change_HostBindingHandler($event) {\n          return ctx._changed($event);\n        })(\"keyup\", function IgxRadioComponent_keyup_HostBindingHandler($event) {\n          return ctx.onKeyUp($event);\n        })(\"click\", function IgxRadioComponent_click_HostBindingHandler() {\n          return ctx._clicked();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id);\n        i0.ɵɵclassProp(\"igx-radio\", ctx.cssClass)(\"igx-radio--checked\", ctx.checked)(\"igx-radio--disabled\", ctx.disabled)(\"igx-radio--focused\", ctx.focused);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      labelId: \"labelId\",\n      labelPosition: \"labelPosition\",\n      value: \"value\",\n      name: \"name\",\n      tabindex: \"tabindex\",\n      disableRipple: \"disableRipple\",\n      required: \"required\",\n      ariaLabelledBy: [\"aria-labelledby\", \"ariaLabelledBy\"],\n      ariaLabel: [\"aria-label\", \"ariaLabel\"],\n      checked: \"checked\",\n      disabled: \"disabled\"\n    },\n    outputs: {\n      change: \"change\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: IgxRadioComponent,\n      multi: true\n    }])],\n    ngContentSelectors: _c8,\n    decls: 8,\n    vars: 16,\n    consts: [[\"type\", \"radio\", 1, \"igx-radio__input\", 3, \"id\", \"name\", \"value\", \"tabindex\", \"disabled\", \"checked\", \"required\", \"blur\"], [\"radio\", \"\"], [\"igxRipple\", \"\", \"igxRippleTarget\", \".igx-radio__ripple\", 1, \"igx-radio__composite\", 3, \"igxRippleDisabled\", \"igxRippleCentered\", \"igxRippleDuration\"], [\"nativeLabel\", \"\"], [1, \"igx-radio__ripple\"], [3, \"id\"], [\"placeholderLabel\", \"\"]],\n    template: function IgxRadioComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"input\", 0, 1);\n        i0.ɵɵlistener(\"blur\", function IgxRadioComponent_Template_input_blur_0_listener() {\n          return ctx.onBlur();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(2, \"span\", 2, 3);\n        i0.ɵɵelement(4, \"div\", 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(5, \"span\", 5, 6);\n        i0.ɵɵprojection(7);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"id\", ctx.inputId)(\"name\", ctx.name)(\"value\", ctx.value)(\"tabindex\", ctx.tabindex)(\"disabled\", ctx.disabled)(\"checked\", ctx.checked)(\"required\", ctx.required);\n        i0.ɵɵattribute(\"aria-checked\", ctx.checked)(\"aria-labelledby\", ctx.ariaLabel ? null : ctx.ariaLabelledBy)(\"aria-label\", ctx.ariaLabel);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"igxRippleDisabled\", ctx.disableRipple)(\"igxRippleCentered\", true)(\"igxRippleDuration\", 300);\n        i0.ɵɵadvance(3);\n        i0.ɵɵclassMap(ctx.labelClass);\n        i0.ɵɵproperty(\"id\", ctx.labelId);\n      }\n    },\n    directives: [IgxRippleDirective],\n    encapsulation: 2\n  });\n  return IgxRadioComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Determines the Radio Group alignment\n */\n\n\nconst RadioGroupAlignment = mkenum({\n  horizontal: 'horizontal',\n  vertical: 'vertical'\n});\nlet nextId$2 = 0;\n/**\n * Radio group directive renders set of radio buttons.\n *\n * @igxModule IgxRadioModule\n *\n * @igxTheme igx-radio-theme\n *\n * @igxKeywords radiogroup, radio, button, input\n *\n * @igxGroup Data Entry & Display\n *\n * @remarks\n * The Ignite UI Radio Group allows the user to select a single option from an available set of options that are listed side by side.\n *\n * @example:\n * ```html\n * <igx-radio-group name=\"radioGroup\">\n *   <igx-radio *ngFor=\"let item of ['Foo', 'Bar', 'Baz']\" value=\"{{item}}\">\n *      {{item}}\n *   </igx-radio>\n * </igx-radio-group>\n * ```\n */\n\nlet IgxRadioGroupDirective = /*#__PURE__*/(() => {\n  class IgxRadioGroupDirective {\n    constructor() {\n      /**\n       * An event that is emitted after the radio group `value` is changed.\n       *\n       * @remarks\n       * Provides references to the selected `IgxRadioComponent` and the `value` property as event arguments.\n       *\n       * @example\n       * ```html\n       * <igx-radio-group (change)=\"handler($event)\"></igx-radio-group>\n       * ```\n       */\n      // eslint-disable-next-line @angular-eslint/no-output-native\n      this.change = new EventEmitter();\n      /**\n       * The css class applied to the component.\n       *\n       * @hidden\n       * @internal\n       */\n\n      this.cssClass = 'igx-radio-group';\n      /**\n       * Sets vertical alignment to the radio group, if `alignment` is set to `vertical`.\n       * By default the alignment is horizontal.\n       *\n       * @example\n       * ```html\n       * <igx-radio-group alignment=\"vertical\"></igx-radio-group>\n       * ```\n       */\n\n      this.vertical = false;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this._onChangeCallback = noop;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this._name = `igx-radio-group-${nextId$2++}`;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this._value = null;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this._selected = null;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this._isInitialized = false;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this._labelPosition = 'after';\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this._disabled = false;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this._required = false;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this.destroy$ = new Subject();\n    }\n    /**\n     * Sets/gets the `value` attribute.\n     *\n     * @example\n     * ```html\n     * <igx-radio-group [value] = \"'radioButtonValue'\"></igx-radio-group>\n     * ```\n     */\n\n\n    get value() {\n      return this._value;\n    }\n\n    set value(newValue) {\n      if (this._value !== newValue) {\n        this._value = newValue;\n\n        this._selectRadioButton();\n      }\n    }\n    /**\n     * Sets/gets the `name` attribute of the radio group component. All child radio buttons inherits this name.\n     *\n     * @example\n     * ```html\n     * <igx-radio-group name = \"Radio1\"></igx-radio-group>\n     *  ```\n     */\n\n\n    get name() {\n      return this._name;\n    }\n\n    set name(newValue) {\n      if (this._name !== newValue) {\n        this._name = newValue;\n\n        this._setRadioButtonNames();\n      }\n    }\n    /**\n     * Sets/gets whether the radio group is required.\n     *\n     * @remarks\n     * If not set, `required` will have value `false`.\n     *\n     * @example\n     * ```html\n     * <igx-radio-group [required] = \"true\"></igx-radio-group>\n     * ```\n     */\n\n\n    get required() {\n      return this._required;\n    }\n\n    set required(value) {\n      this._required = value === '' || value;\n\n      this._setRadioButtonsRequired();\n    }\n    /**\n     * @deprecated in version 12.2.0\n     *\n     * An input property that allows you to disable the radio group. By default it's false.\n     *\n     * @example\n     *  ```html\n     * <igx-radio-group disabled></igx-radio-group>\n     * ```\n     */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n\n    set disabled(value) {\n      this._disabled = value === '' || value;\n      this.setDisabledState(value);\n    }\n    /**\n     * @deprecated in version 12.2.0\n     *\n     * Sets/gets the position of the `label` in the child radio buttons.\n     *\n     * @remarks\n     * If not set, `labelPosition` will have value `\"after\"`.\n     *\n     * @example\n     * ```html\n     * <igx-radio-group labelPosition = \"before\"></igx-radio-group>\n     * ```\n     */\n\n\n    get labelPosition() {\n      return this._labelPosition;\n    }\n\n    set labelPosition(newValue) {\n      if (this._labelPosition !== newValue) {\n        this._labelPosition = newValue === RadioLabelPosition.BEFORE ? RadioLabelPosition.BEFORE : RadioLabelPosition.AFTER;\n\n        this._setRadioButtonLabelPosition();\n      }\n    }\n    /**\n     * Sets/gets the selected child radio button.\n     *\n     * @example\n     * ```typescript\n     * let selectedButton = this.radioGroup.selected;\n     * this.radioGroup.selected = selectedButton;\n     * ```\n     */\n\n\n    get selected() {\n      return this._selected;\n    }\n\n    set selected(selected) {\n      if (this._selected !== selected) {\n        this._selected = selected;\n        this.value = selected ? selected.value : null;\n      }\n    }\n    /**\n     * Returns the alignment of the `igx-radio-group`.\n     * ```typescript\n     * @ViewChild(\"MyRadioGroup\")\n     * public radioGroup: IgxRadioGroupDirective;\n     * ngAfterViewInit(){\n     *    let radioAlignment = this.radioGroup.alignment;\n     * }\n     * ```\n     */\n\n\n    get alignment() {\n      return this.vertical ? RadioGroupAlignment.vertical : RadioGroupAlignment.horizontal;\n    }\n    /**\n     * Allows you to set the radio group alignment.\n     * Available options are `RadioGroupAlignment.horizontal` (default) and `RadioGroupAlignment.vertical`.\n     * ```typescript\n     * public alignment = RadioGroupAlignment.vertical;\n     * //..\n     * ```\n     * ```html\n     * <igx-radio-group [alignment]=\"alignment\"></igx-radio-group>\n     * ```\n     */\n\n\n    set alignment(value) {\n      this.vertical = value === RadioGroupAlignment.vertical;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    ngAfterContentInit() {\n      // The initial value can possibly be set by NgModel and it is possible that\n      // the OnInit of the NgModel occurs after the OnInit of this class.\n      this._isInitialized = true;\n      setTimeout(() => {\n        this._initRadioButtons();\n      });\n    }\n    /**\n     * Sets the \"checked\" property value on the radio input element.\n     *\n     * @remarks\n     * Checks whether the provided value is consistent to the current radio button.\n     * If it is, the checked attribute will have value `true` and selected property will contain the selected `IgxRadioComponent`.\n     *\n     * @example\n     * ```typescript\n     * this.radioGroup.writeValue('radioButtonValue');\n     * ```\n     */\n\n\n    writeValue(value) {\n      this.value = value;\n    }\n    /**\n     * Registers a function called when the control value changes.\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    registerOnChange(fn) {\n      this._onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    setDisabledState(isDisabled) {\n      if (this.radioButtons) {\n        this.radioButtons.forEach(button => {\n          button.setDisabledState(isDisabled);\n        });\n      }\n    }\n    /**\n     * Registers a function called when the control is touched.\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    registerOnTouched(fn) {\n      if (this.radioButtons) {\n        this.radioButtons.forEach(button => {\n          button.registerOnTouched(fn);\n        });\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    ngOnDestroy() {\n      this.destroy$.next(true);\n      this.destroy$.complete();\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    _initRadioButtons() {\n      if (this.radioButtons) {\n        const props = {\n          name: this._name,\n          required: this._required\n        };\n        this.radioButtons.forEach(button => {\n          Object.assign(button, props);\n\n          if (button.disabled === undefined) {\n            button.disabled = this._disabled;\n          }\n\n          if (button.labelPosition === undefined) {\n            button.labelPosition = this._labelPosition;\n          }\n\n          if (button.value === this._value) {\n            button.checked = true;\n            this._selected = button;\n          }\n\n          button.change.pipe(takeUntil(this.destroy$)).subscribe(ev => this._selectedRadioButtonChanged(ev));\n        });\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    _selectedRadioButtonChanged(args) {\n      this.radioButtons.forEach(button => {\n        button.checked = button.id === args.radio.id;\n      });\n      this._selected = args.radio;\n      this._value = args.value;\n\n      if (this._isInitialized) {\n        this.change.emit(args);\n\n        this._onChangeCallback(this.value);\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    _setRadioButtonNames() {\n      if (this.radioButtons) {\n        this.radioButtons.forEach(button => {\n          button.name = this._name;\n        });\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    _selectRadioButton() {\n      if (this.radioButtons) {\n        this.radioButtons.forEach(button => {\n          if (this._value === null) {\n            // no value - uncheck all radio buttons\n            if (button.checked) {\n              button.checked = false;\n            }\n          } else {\n            if (this._value === button.value) {\n              // selected button\n              if (this._selected !== button) {\n                this._selected = button;\n              }\n\n              if (!button.checked) {\n                button.select();\n              }\n            } else {\n              // non-selected button\n              if (button.checked) {\n                button.checked = false;\n              }\n            }\n          }\n        });\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    _setRadioButtonLabelPosition() {\n      if (this.radioButtons) {\n        this.radioButtons.forEach(button => {\n          button.labelPosition = this._labelPosition;\n        });\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    _setRadioButtonsRequired() {\n      if (this.radioButtons) {\n        this.radioButtons.forEach(button => {\n          button.required = this._required;\n        });\n      }\n    }\n\n  }\n\n  IgxRadioGroupDirective.ɵfac = function IgxRadioGroupDirective_Factory(t) {\n    return new (t || IgxRadioGroupDirective)();\n  };\n\n  IgxRadioGroupDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxRadioGroupDirective,\n    selectors: [[\"igx-radio-group\"], [\"\", \"igxRadioGroup\", \"\"]],\n    contentQueries: function IgxRadioGroupDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxRadioComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.radioButtons = _t);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function IgxRadioGroupDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-radio-group\", ctx.cssClass)(\"igx-radio-group--vertical\", ctx.vertical);\n      }\n    },\n    inputs: {\n      value: \"value\",\n      name: \"name\",\n      required: \"required\",\n      disabled: \"disabled\",\n      labelPosition: \"labelPosition\",\n      selected: \"selected\",\n      alignment: \"alignment\"\n    },\n    outputs: {\n      change: \"change\"\n    },\n    exportAs: [\"igxRadioGroup\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: IgxRadioGroupDirective,\n      multi: true\n    }])]\n  });\n  return IgxRadioGroupDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxRadioModule = /*#__PURE__*/(() => {\n  class IgxRadioModule {}\n\n  IgxRadioModule.ɵfac = function IgxRadioModule_Factory(t) {\n    return new (t || IgxRadioModule)();\n  };\n\n  IgxRadioModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxRadioModule\n  });\n  IgxRadioModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[IgxRippleModule]]\n  });\n  return IgxRadioModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass IgxTextHighlightDirective {\n  constructor(element, renderer) {\n    this.element = element;\n    this.renderer = renderer;\n    /**\n     * Identifies the highlight within a unique group.\n     * This allows it to have several different highlight groups,\n     * with each of them having their own active highlight.\n     *\n     * ```html\n     * <div\n     *   igxTextHighlight\n     *   [groupName]=\"myGroupName\">\n     * </div>\n     * ```\n     */\n\n    this.groupName = '';\n    this.destroy$ = new Subject();\n    this._value = '';\n    this._div = null;\n    this._observer = null;\n    this._nodeWasRemoved = false;\n    this._forceEvaluation = false;\n    this._activeElementIndex = -1;\n    this._defaultCssClass = 'igx-highlight';\n    this._defaultActiveCssClass = 'igx-highlight--active';\n    IgxTextHighlightDirective.onActiveElementChanged.pipe(takeUntil(this.destroy$)).subscribe(groupName => {\n      if (this.groupName === groupName) {\n        if (this._activeElementIndex !== -1) {\n          this.deactivate();\n        }\n\n        this.activateIfNecessary();\n      }\n    });\n  }\n  /**\n   * The underlying value of the element that will be highlighted.\n   *\n   * ```typescript\n   * // get\n   * const elementValue = this.textHighlight.value;\n   * ```\n   *\n   * ```html\n   * <!--set-->\n   * <div\n   *   igxTextHighlight\n   *   [value]=\"newValue\">\n   * </div>\n   * ```\n   */\n\n\n  get value() {\n    return this._value;\n  }\n\n  set value(value) {\n    if (value === undefined || value === null) {\n      this._value = '';\n    } else {\n      this._value = value;\n    }\n  }\n  /**\n   * @hidden\n   */\n\n\n  get lastSearchInfo() {\n    return this._lastSearchInfo;\n  }\n  /**\n   * Activates the highlight at a given index.\n   * (if such index exists)\n   */\n\n\n  static setActiveHighlight(groupName, highlight) {\n    IgxTextHighlightDirective.highlightGroupsMap.set(groupName, highlight);\n    IgxTextHighlightDirective.onActiveElementChanged.emit(groupName);\n  }\n  /**\n   * Clears any existing highlight.\n   */\n\n\n  static clearActiveHighlight(groupName) {\n    IgxTextHighlightDirective.highlightGroupsMap.set(groupName, {\n      index: -1\n    });\n    IgxTextHighlightDirective.onActiveElementChanged.emit(groupName);\n  }\n  /**\n   * @hidden\n   */\n\n\n  ngOnDestroy() {\n    this.clearHighlight();\n\n    if (this._observer !== null) {\n      this._observer.disconnect();\n    }\n\n    this.destroy$.next(true);\n    this.destroy$.complete();\n  }\n  /**\n   * @hidden\n   */\n\n\n  ngOnChanges(changes) {\n    if (changes.value && !changes.value.firstChange) {\n      this._valueChanged = true;\n    } else if (changes.row !== undefined && !changes.row.firstChange || changes.column !== undefined && !changes.column.firstChange || changes.page !== undefined && !changes.page.firstChange) {\n      if (this._activeElementIndex !== -1) {\n        this.deactivate();\n      }\n\n      this.activateIfNecessary();\n    }\n  }\n  /**\n   * @hidden\n   */\n\n\n  ngAfterViewInit() {\n    this.parentElement = this.renderer.parentNode(this.element.nativeElement);\n\n    if (IgxTextHighlightDirective.highlightGroupsMap.has(this.groupName) === false) {\n      IgxTextHighlightDirective.highlightGroupsMap.set(this.groupName, {\n        index: -1\n      });\n    }\n\n    this._lastSearchInfo = {\n      searchedText: '',\n      content: this.value,\n      matchCount: 0,\n      caseSensitive: false,\n      exactMatch: false\n    };\n    this._container = this.parentElement.firstElementChild;\n  }\n  /**\n   * @hidden\n   */\n\n\n  ngAfterViewChecked() {\n    if (this._valueChanged) {\n      this.highlight(this._lastSearchInfo.searchedText, this._lastSearchInfo.caseSensitive, this._lastSearchInfo.exactMatch);\n      this.activateIfNecessary();\n      this._valueChanged = false;\n    }\n  }\n  /**\n   * Clears the existing highlight and highlights the searched text.\n   * Returns how many times the element contains the searched text.\n   */\n\n\n  highlight(text, caseSensitive, exactMatch) {\n    const caseSensitiveResolved = caseSensitive ? true : false;\n    const exactMatchResolved = exactMatch ? true : false;\n\n    if (this.searchNeedsEvaluation(text, caseSensitiveResolved, exactMatchResolved)) {\n      this._lastSearchInfo.searchedText = text;\n      this._lastSearchInfo.caseSensitive = caseSensitiveResolved;\n      this._lastSearchInfo.exactMatch = exactMatchResolved;\n      this._lastSearchInfo.content = this.value;\n\n      if (text === '' || text === undefined || text === null) {\n        this.clearHighlight();\n      } else {\n        this.clearChildElements(true);\n        this._lastSearchInfo.matchCount = this.getHighlightedText(text, caseSensitive, exactMatch);\n      }\n    } else if (this._nodeWasRemoved) {\n      this._lastSearchInfo.searchedText = text;\n      this._lastSearchInfo.caseSensitive = caseSensitiveResolved;\n      this._lastSearchInfo.exactMatch = exactMatchResolved;\n    }\n\n    return this._lastSearchInfo.matchCount;\n  }\n  /**\n   * Clears any existing highlight.\n   */\n\n\n  clearHighlight() {\n    this.clearChildElements(false);\n    this._lastSearchInfo.searchedText = '';\n    this._lastSearchInfo.matchCount = 0;\n  }\n  /**\n   * Activates the highlight if it is on the currently active row and column.\n   */\n\n\n  activateIfNecessary() {\n    const group = IgxTextHighlightDirective.highlightGroupsMap.get(this.groupName);\n\n    if (group.index >= 0 && group.column === this.column && group.row === this.row && compareMaps(this.metadata, group.metadata)) {\n      this.activate(group.index);\n    }\n  }\n  /**\n   * Attaches a MutationObserver to the parentElement and watches for when the container element is removed/readded to the DOM.\n   * Should be used only when necessary as using many observers may lead to performance degradation.\n   */\n\n\n  observe() {\n    if (this._observer === null) {\n      const callback = mutationList => {\n        mutationList.forEach(mutation => {\n          const removedNodes = Array.from(mutation.removedNodes);\n          removedNodes.forEach(n => {\n            if (n === this._container) {\n              this._nodeWasRemoved = true;\n              this.clearChildElements(false);\n            }\n          });\n          const addedNodes = Array.from(mutation.addedNodes);\n          addedNodes.forEach(n => {\n            if (n === this.parentElement.firstElementChild && this._nodeWasRemoved) {\n              this._container = this.parentElement.firstElementChild;\n              this._nodeWasRemoved = false;\n              this._forceEvaluation = true;\n              this.highlight(this._lastSearchInfo.searchedText, this._lastSearchInfo.caseSensitive, this._lastSearchInfo.exactMatch);\n              this._forceEvaluation = false;\n              this.activateIfNecessary();\n\n              this._observer.disconnect();\n\n              this._observer = null;\n            }\n          });\n        });\n      };\n\n      this._observer = new MutationObserver(callback);\n\n      this._observer.observe(this.parentElement, {\n        childList: true\n      });\n    }\n  }\n\n  activate(index) {\n    this.deactivate();\n\n    if (this._div !== null) {\n      const spans = this._div.querySelectorAll('span');\n\n      this._activeElementIndex = index;\n\n      if (spans.length <= index) {\n        return;\n      }\n\n      const elementToActivate = spans[index];\n      this.renderer.addClass(elementToActivate, this._defaultActiveCssClass);\n      this.renderer.addClass(elementToActivate, this.activeCssClass);\n    }\n  }\n\n  deactivate() {\n    if (this._activeElementIndex === -1) {\n      return;\n    }\n\n    const spans = this._div.querySelectorAll('span');\n\n    if (spans.length <= this._activeElementIndex) {\n      this._activeElementIndex = -1;\n      return;\n    }\n\n    const elementToDeactivate = spans[this._activeElementIndex];\n    this.renderer.removeClass(elementToDeactivate, this._defaultActiveCssClass);\n    this.renderer.removeClass(elementToDeactivate, this.activeCssClass);\n    this._activeElementIndex = -1;\n  }\n\n  clearChildElements(originalContentHidden) {\n    this.renderer.setProperty(this.element.nativeElement, 'hidden', originalContentHidden);\n\n    if (this._div !== null) {\n      this.renderer.removeChild(this.parentElement, this._div);\n      this._div = null;\n      this._activeElementIndex = -1;\n    }\n  }\n\n  getHighlightedText(searchText, caseSensitive, exactMatch) {\n    this.appendDiv();\n    const stringValue = String(this.value);\n    const contentStringResolved = !caseSensitive ? stringValue.toLowerCase() : stringValue;\n    const searchTextResolved = !caseSensitive ? searchText.toLowerCase() : searchText;\n    let matchCount = 0;\n\n    if (exactMatch) {\n      if (contentStringResolved === searchTextResolved) {\n        this.appendSpan(`<span class=\"${this._defaultCssClass} ${this.cssClass ? this.cssClass : ''}\">${stringValue}</span>`);\n        matchCount++;\n      } else {\n        this.appendText(stringValue);\n      }\n    } else {\n      let foundIndex = contentStringResolved.indexOf(searchTextResolved, 0);\n      let previousMatchEnd = 0;\n\n      while (foundIndex !== -1) {\n        const start = foundIndex;\n        const end = foundIndex + searchTextResolved.length;\n        this.appendText(stringValue.substring(previousMatchEnd, start)); // eslint-disable-next-line max-len\n\n        this.appendSpan(`<span class=\"${this._defaultCssClass} ${this.cssClass ? this.cssClass : ''}\">${stringValue.substring(start, end)}</span>`);\n        previousMatchEnd = end;\n        matchCount++;\n        foundIndex = contentStringResolved.indexOf(searchTextResolved, end);\n      }\n\n      this.appendText(stringValue.substring(previousMatchEnd, stringValue.length));\n    }\n\n    return matchCount;\n  }\n\n  appendText(text) {\n    const textElement = this.renderer.createText(text);\n    this.renderer.appendChild(this._div, textElement);\n  }\n\n  appendSpan(outerHTML) {\n    const span = this.renderer.createElement('span');\n    this.renderer.appendChild(this._div, span);\n    this.renderer.setProperty(span, 'outerHTML', outerHTML);\n  }\n\n  appendDiv() {\n    this._div = this.renderer.createElement('div');\n\n    if (this.containerClass) {\n      this.renderer.addClass(this._div, this.containerClass);\n    }\n\n    this.renderer.appendChild(this.parentElement, this._div);\n  }\n\n  searchNeedsEvaluation(text, caseSensitive, exactMatch) {\n    const searchedText = this._lastSearchInfo.searchedText;\n    return !this._nodeWasRemoved && (searchedText === null || searchedText !== text || this._lastSearchInfo.content !== this.value || this._lastSearchInfo.caseSensitive !== caseSensitive || this._lastSearchInfo.exactMatch !== exactMatch || this._forceEvaluation);\n  }\n\n}\n\nIgxTextHighlightDirective.highlightGroupsMap = new Map();\nIgxTextHighlightDirective.onActiveElementChanged = new EventEmitter();\n\nIgxTextHighlightDirective.ɵfac = function IgxTextHighlightDirective_Factory(t) {\n  return new (t || IgxTextHighlightDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n};\n\nIgxTextHighlightDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: IgxTextHighlightDirective,\n  selectors: [[\"\", \"igxTextHighlight\", \"\"]],\n  inputs: {\n    cssClass: \"cssClass\",\n    activeCssClass: \"activeCssClass\",\n    containerClass: \"containerClass\",\n    groupName: \"groupName\",\n    value: \"value\",\n    row: \"row\",\n    column: \"column\",\n    metadata: \"metadata\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxTextHighlightModule = /*#__PURE__*/(() => {\n  class IgxTextHighlightModule {}\n\n  IgxTextHighlightModule.ɵfac = function IgxTextHighlightModule_Factory(t) {\n    return new (t || IgxTextHighlightModule)();\n  };\n\n  IgxTextHighlightModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxTextHighlightModule\n  });\n  IgxTextHighlightModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return IgxTextHighlightModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxTextSelectionDirective = /*#__PURE__*/(() => {\n  class IgxTextSelectionDirective {\n    constructor(element) {\n      this.element = element;\n      this.selectionState = true;\n    }\n    /**\n     * Returns whether the input element is selectable through the directive.\n     *\n     * ```typescript\n     * // get\n     * @ViewChild('firstName',\n     *  {read: IgxTextSelectionDirective})\n     * public firstName: IgxTextSelectionDirective;\n     *\n     * public getFirstNameSelectionStatus() {\n     *  return this.firstName.selected;\n     * }\n     * ```\n     */\n\n\n    get selected() {\n      return this.selectionState;\n    }\n    /**\n     *  Determines whether the input element could be selected through the directive.\n     *\n     * ```html\n     * <!--set-->\n     * <input\n     *   type=\"text\"\n     *   id=\"firstName\"\n     *   [igxTextSelection]=\"true\">\n     * </input>\n     *\n     * <input\n     *   type=\"text\"\n     *   id=\"lastName\"\n     *   igxTextSelection\n     *   [selected]=\"true\">\n     * </input>\n     * ```\n     */\n\n\n    set selected(val) {\n      this.selectionState = val;\n    }\n    /**\n     * Returns the nativeElement of the element where the directive was applied.\n     *\n     * ```html\n     * <input\n     *   type=\"text\"\n     *   id=\"firstName\"\n     *   igxTextSelection>\n     * </input>\n     * ```\n     *\n     * ```typescript\n     * @ViewChild('firstName',\n     *  {read: IgxTextSelectionDirective})\n     * public inputElement: IgxTextSelectionDirective;\n     *\n     * public getNativeElement() {\n     *  return this.inputElement.nativeElement;\n     * }\n     * ```\n     */\n\n\n    get nativeElement() {\n      return this.element.nativeElement;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onFocus() {\n      this.trigger();\n    }\n    /**\n     * Triggers the selection of the element if it is marked as selectable.\n     *\n     * ```html\n     * <input\n     *   type=\"text\"\n     *   id=\"firstName\"\n     *   igxTextSelection>\n     * </input>\n     * ```\n     *\n     * ```typescript\n     * @ViewChild('firstName',\n     *  {read: IgxTextSelectionDirective})\n     * public inputElement: IgxTextSelectionDirective;\n     *\n     * public triggerElementSelection() {\n     *  this.inputElement.trigger();\n     * }\n     * ```\n     */\n\n\n    trigger() {\n      if (this.selected && this.nativeElement.value.length) {\n        this.nativeElement.select();\n      }\n    }\n\n  }\n\n  IgxTextSelectionDirective.ɵfac = function IgxTextSelectionDirective_Factory(t) {\n    return new (t || IgxTextSelectionDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxTextSelectionDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxTextSelectionDirective,\n    selectors: [[\"\", \"igxTextSelection\", \"\"]],\n    hostBindings: function IgxTextSelectionDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focus\", function IgxTextSelectionDirective_focus_HostBindingHandler() {\n          return ctx.onFocus();\n        });\n      }\n    },\n    inputs: {\n      selected: [\"igxTextSelection\", \"selected\"]\n    },\n    exportAs: [\"igxTextSelection\"]\n  });\n  return IgxTextSelectionDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxTextSelectionModule = /*#__PURE__*/(() => {\n  class IgxTextSelectionModule {}\n\n  IgxTextSelectionModule.ɵfac = function IgxTextSelectionModule_Factory(t) {\n    return new (t || IgxTextSelectionModule)();\n  };\n\n  IgxTextSelectionModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxTextSelectionModule\n  });\n  IgxTextSelectionModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return IgxTextSelectionModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxTemplateOutletDirective = /*#__PURE__*/(() => {\n  class IgxTemplateOutletDirective {\n    constructor(_viewContainerRef, _zone, cdr) {\n      this._viewContainerRef = _viewContainerRef;\n      this._zone = _zone;\n      this.cdr = cdr;\n      this.viewCreated = new EventEmitter();\n      this.viewMoved = new EventEmitter();\n      this.cachedViewLoaded = new EventEmitter();\n      this.beforeViewDetach = new EventEmitter();\n      /**\n       * The embedded views cache. Collection is key-value paired.\n       * Key is the template type, value is another key-value paired collection\n       * where the key is the template id and value is the embedded view for the related template.\n       */\n\n      this._embeddedViewsMap = new Map();\n    }\n\n    ngOnChanges(changes) {\n      const actionType = this._getActionType(changes);\n\n      switch (actionType) {\n        case TemplateOutletAction.CreateView:\n          this._recreateView();\n\n          break;\n\n        case TemplateOutletAction.MoveView:\n          this._moveView();\n\n          break;\n\n        case TemplateOutletAction.UseCachedView:\n          this._useCachedView();\n\n          break;\n\n        case TemplateOutletAction.UpdateViewContext:\n          this._updateExistingContext(this.igxTemplateOutletContext);\n\n          break;\n      }\n    }\n\n    cleanCache() {\n      this._embeddedViewsMap.forEach(collection => {\n        collection.forEach(item => {\n          if (!item.destroyed) {\n            item.destroy();\n          }\n        });\n        collection.clear();\n      });\n\n      this._embeddedViewsMap.clear();\n    }\n\n    cleanView(tmplID) {\n      const embViewCollection = this._embeddedViewsMap.get(tmplID.type);\n\n      const embView = embViewCollection === null || embViewCollection === void 0 ? void 0 : embViewCollection.get(tmplID.id);\n\n      if (embView) {\n        embView.destroy();\n\n        this._embeddedViewsMap.get(tmplID.type).delete(tmplID.id);\n      }\n    }\n\n    _recreateView() {\n      const prevIndex = this._viewRef ? this._viewContainerRef.indexOf(this._viewRef) : -1; // detach old and create new\n\n      if (prevIndex !== -1) {\n        this.beforeViewDetach.emit({\n          owner: this,\n          view: this._viewRef,\n          context: this.igxTemplateOutletContext\n        });\n\n        this._viewContainerRef.detach(prevIndex);\n      }\n\n      if (this.igxTemplateOutlet) {\n        this._viewRef = this._viewContainerRef.createEmbeddedView(this.igxTemplateOutlet, this.igxTemplateOutletContext);\n        this.viewCreated.emit({\n          owner: this,\n          view: this._viewRef,\n          context: this.igxTemplateOutletContext\n        });\n        const tmplId = this.igxTemplateOutletContext['templateID'];\n\n        if (tmplId) {\n          // if context contains a template id, check if we have a view for that template already stored in the cache\n          // if not create a copy and add it to the cache in detached state.\n          // Note: Views in detached state do not appear in the DOM, however they remain stored in memory.\n          const resCollection = this._embeddedViewsMap.get(this.igxTemplateOutletContext['templateID'].type);\n\n          const res = resCollection === null || resCollection === void 0 ? void 0 : resCollection.get(this.igxTemplateOutletContext['templateID'].id);\n\n          if (!res) {\n            this._embeddedViewsMap.set(this.igxTemplateOutletContext['templateID'].type, new Map([[this.igxTemplateOutletContext['templateID'].id, this._viewRef]]));\n          }\n        }\n      }\n    }\n\n    _moveView() {\n      // using external view and inserting it in current view.\n      const view = this.igxTemplateOutletContext['moveView'];\n      const owner = this.igxTemplateOutletContext['owner'];\n\n      if (view !== this._viewRef) {\n        if (owner._viewContainerRef.indexOf(view) !== -1) {\n          // detach in case view it is attached somewhere else at the moment.\n          this.beforeViewDetach.emit({\n            owner: this,\n            view: this._viewRef,\n            context: this.igxTemplateOutletContext\n          });\n\n          owner._viewContainerRef.detach(owner._viewContainerRef.indexOf(view));\n        }\n\n        if (this._viewRef && this._viewContainerRef.indexOf(this._viewRef) !== -1) {\n          this.beforeViewDetach.emit({\n            owner: this,\n            view: this._viewRef,\n            context: this.igxTemplateOutletContext\n          });\n\n          this._viewContainerRef.detach(this._viewContainerRef.indexOf(this._viewRef));\n        }\n\n        this._viewRef = view;\n\n        this._viewContainerRef.insert(view, 0);\n\n        this._updateExistingContext(this.igxTemplateOutletContext);\n\n        this.viewMoved.emit({\n          owner: this,\n          view: this._viewRef,\n          context: this.igxTemplateOutletContext\n        });\n      } else {\n        this._updateExistingContext(this.igxTemplateOutletContext);\n      }\n    }\n\n    _useCachedView() {\n      var _a; // use view for specific template cached in the current template outlet\n\n\n      const tmplID = this.igxTemplateOutletContext['templateID'];\n      const cachedView = tmplID ? (_a = this._embeddedViewsMap.get(tmplID.type)) === null || _a === void 0 ? void 0 : _a.get(tmplID.id) : null; // if view exists, but template has been changed and there is a view in the cache with the related template\n      // then detach old view and insert the stored one with the matching template\n      // after that update its context.\n\n      if (this._viewContainerRef.length > 0) {\n        this.beforeViewDetach.emit({\n          owner: this,\n          view: this._viewRef,\n          context: this.igxTemplateOutletContext\n        });\n\n        this._viewContainerRef.detach(this._viewContainerRef.indexOf(this._viewRef));\n      }\n\n      this._viewRef = cachedView;\n\n      const oldContext = this._cloneContext(cachedView.context);\n\n      this._viewContainerRef.insert(this._viewRef, 0);\n\n      this._updateExistingContext(this.igxTemplateOutletContext);\n\n      this.cachedViewLoaded.emit({\n        owner: this,\n        view: this._viewRef,\n        context: this.igxTemplateOutletContext,\n        oldContext\n      });\n    }\n\n    _shouldRecreateView(changes) {\n      const ctxChange = changes['igxTemplateOutletContext'];\n      return !!changes['igxTemplateOutlet'] || ctxChange && this._hasContextShapeChanged(ctxChange);\n    }\n\n    _hasContextShapeChanged(ctxChange) {\n      const prevCtxKeys = Object.keys(ctxChange.previousValue || {});\n      const currCtxKeys = Object.keys(ctxChange.currentValue || {});\n\n      if (prevCtxKeys.length === currCtxKeys.length) {\n        for (const propName of currCtxKeys) {\n          if (prevCtxKeys.indexOf(propName) === -1) {\n            return true;\n          }\n        }\n\n        return false;\n      } else {\n        return true;\n      }\n    }\n\n    _updateExistingContext(ctx) {\n      for (const propName of Object.keys(ctx)) {\n        this._viewRef.context[propName] = this.igxTemplateOutletContext[propName];\n      }\n    }\n\n    _cloneContext(ctx) {\n      const clone = {};\n\n      for (const propName of Object.keys(ctx)) {\n        clone[propName] = ctx[propName];\n      }\n\n      return clone;\n    }\n\n    _getActionType(changes) {\n      var _a;\n\n      const movedView = this.igxTemplateOutletContext['moveView'];\n      const tmplID = this.igxTemplateOutletContext['templateID'];\n      const cachedView = tmplID ? (_a = this._embeddedViewsMap.get(tmplID.type)) === null || _a === void 0 ? void 0 : _a.get(tmplID.id) : null;\n\n      const shouldRecreate = this._shouldRecreateView(changes);\n\n      if (movedView) {\n        // view is moved from external source\n        return TemplateOutletAction.MoveView;\n      } else if (shouldRecreate && cachedView) {\n        // should recreate (template or context change) and there is a matching template in cache\n        return TemplateOutletAction.UseCachedView;\n      } else if (!this._viewRef || shouldRecreate) {\n        // no view or should recreate\n        return TemplateOutletAction.CreateView;\n      } else if (this.igxTemplateOutletContext) {\n        // has context, update context\n        return TemplateOutletAction.UpdateViewContext;\n      }\n    }\n\n  }\n\n  IgxTemplateOutletDirective.ɵfac = function IgxTemplateOutletDirective_Factory(t) {\n    return new (t || IgxTemplateOutletDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  IgxTemplateOutletDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxTemplateOutletDirective,\n    selectors: [[\"\", \"igxTemplateOutlet\", \"\"]],\n    inputs: {\n      igxTemplateOutletContext: \"igxTemplateOutletContext\",\n      igxTemplateOutlet: \"igxTemplateOutlet\"\n    },\n    outputs: {\n      viewCreated: \"viewCreated\",\n      viewMoved: \"viewMoved\",\n      cachedViewLoaded: \"cachedViewLoaded\",\n      beforeViewDetach: \"beforeViewDetach\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return IgxTemplateOutletDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar TemplateOutletAction = /*#__PURE__*/(() => {\n  (function (TemplateOutletAction) {\n    TemplateOutletAction[TemplateOutletAction[\"CreateView\"] = 0] = \"CreateView\";\n    TemplateOutletAction[TemplateOutletAction[\"MoveView\"] = 1] = \"MoveView\";\n    TemplateOutletAction[TemplateOutletAction[\"UseCachedView\"] = 2] = \"UseCachedView\";\n    TemplateOutletAction[TemplateOutletAction[\"UpdateViewContext\"] = 3] = \"UpdateViewContext\";\n  })(TemplateOutletAction || (TemplateOutletAction = {}));\n\n  return TemplateOutletAction;\n})();\n\n/**\n * @hidden\n */\nlet IgxTemplateOutletModule = /*#__PURE__*/(() => {\n  class IgxTemplateOutletModule {}\n\n  IgxTemplateOutletModule.ɵfac = function IgxTemplateOutletModule_Factory(t) {\n    return new (t || IgxTemplateOutletModule)();\n  };\n\n  IgxTemplateOutletModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxTemplateOutletModule\n  });\n  IgxTemplateOutletModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return IgxTemplateOutletModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$q = 0;\n/**\n * **Ignite UI for Angular Tooltip** -\n * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tooltip)\n *\n * The Ignite UI for Angular Tooltip directive is used to mark an HTML element in the markup as one that should behave as a tooltip.\n * The tooltip is used in combination with the Ignite UI for Angular Tooltip Target by assigning the exported tooltip reference to the\n * respective target's selector property.\n *\n * Example:\n * ```html\n * <button [igxTooltipTarget]=\"tooltipRef\">Hover me</button>\n * <span #tooltipRef=\"tooltip\" igxTooltip>Hello there, I am a tooltip!</span>\n * ```\n */\n\nlet IgxTooltipDirective = /*#__PURE__*/(() => {\n  class IgxTooltipDirective extends IgxToggleDirective {\n    /** @hidden */\n    constructor(elementRef, cdr, overlayService, navigationService) {\n      // D.P. constructor duplication due to es6 compilation, might be obsolete in the future\n      super(elementRef, cdr, overlayService, navigationService);\n      /**\n       * Identifier for the tooltip.\n       * If this is property is not explicitly set, it will be automatically generated.\n       *\n       * ```typescript\n       * let tooltipId = this.tooltip.id;\n       * ```\n       */\n\n      this.id = `igx-tooltip-${NEXT_ID$q++}`;\n      /**\n       * @hidden\n       * Returns whether close time out has started\n       */\n\n      this.toBeHidden = false;\n      /**\n       * @hidden\n       * Returns whether open time out has started\n       */\n\n      this.toBeShown = false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hiddenClass() {\n      return this.collapsed;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get defaultClass() {\n      return !this.collapsed;\n    }\n    /**\n     * Get the role attribute of the tooltip.\n     *\n     * ```typescript\n     * let tooltipRole = this.tooltip.role;\n     * ```\n     */\n\n\n    get role() {\n      return 'tooltip';\n    }\n    /**\n     * If there is open animation in progress this method will finish is.\n     * If there is no open animation in progress this method will open the toggle with no animation.\n     *\n     * @param overlaySettings setting to use for opening the toggle\n     */\n\n\n    forceOpen(overlaySettings) {\n      const info = this.overlayService.getOverlayById(this._overlayId);\n      const hasOpenAnimation = info ? info.openAnimationPlayer : false;\n\n      if (hasOpenAnimation) {\n        info.openAnimationPlayer.finish();\n        info.openAnimationPlayer.reset();\n        info.openAnimationPlayer = null;\n      } else if (this.collapsed) {\n        const animation = overlaySettings.positionStrategy.settings.openAnimation;\n        overlaySettings.positionStrategy.settings.openAnimation = null;\n        this.open(overlaySettings);\n        overlaySettings.positionStrategy.settings.openAnimation = animation;\n      }\n    }\n    /**\n     * If there is close animation in progress this method will finish is.\n     * If there is no close animation in progress this method will close the toggle with no animation.\n     *\n     * @param overlaySettings settings to use for closing the toggle\n     */\n\n\n    forceClose(overlaySettings) {\n      const info = this.overlayService.getOverlayById(this._overlayId);\n      const hasCloseAnimation = info ? info.closeAnimationPlayer : false;\n\n      if (hasCloseAnimation) {\n        info.closeAnimationPlayer.finish();\n        info.closeAnimationPlayer.reset();\n        info.closeAnimationPlayer = null;\n      } else if (!this.collapsed) {\n        const animation = overlaySettings.positionStrategy.settings.closeAnimation;\n        overlaySettings.positionStrategy.settings.closeAnimation = null;\n        this.close();\n        overlaySettings.positionStrategy.settings.closeAnimation = animation;\n      }\n    }\n\n  }\n\n  IgxTooltipDirective.ɵfac = function IgxTooltipDirective_Factory(t) {\n    return new (t || IgxTooltipDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(IgxOverlayService), i0.ɵɵdirectiveInject(IgxNavigationService, 8));\n  };\n\n  IgxTooltipDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxTooltipDirective,\n    selectors: [[\"\", \"igxTooltip\", \"\"]],\n    hostVars: 6,\n    hostBindings: function IgxTooltipDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id)(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"igx-tooltip--hidden\", ctx.hiddenClass)(\"igx-tooltip--desktop\", ctx.defaultClass);\n      }\n    },\n    inputs: {\n      context: \"context\",\n      id: \"id\"\n    },\n    exportAs: [\"tooltip\"],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return IgxTooltipDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxTooltipComponent = /*#__PURE__*/(() => {\n  class IgxTooltipComponent {}\n\n  IgxTooltipComponent.ɵfac = function IgxTooltipComponent_Factory(t) {\n    return new (t || IgxTooltipComponent)();\n  };\n\n  IgxTooltipComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxTooltipComponent,\n    selectors: [[\"igx-tooltip\"]],\n    viewQuery: function IgxTooltipComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxTooltipDirective, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tooltip = _t.first);\n      }\n    },\n    decls: 2,\n    vars: 1,\n    consts: [[\"igxTooltip\", \"\"]],\n    template: function IgxTooltipComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"span\", 0);\n        i0.ɵɵtext(1);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx.content);\n      }\n    },\n    directives: [IgxTooltipDirective],\n    encapsulation: 2\n  });\n  return IgxTooltipComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * **Ignite UI for Angular Tooltip Target** -\n * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tooltip)\n *\n * The Ignite UI for Angular Tooltip Target directive is used to mark an HTML element in the markup as one that has a tooltip.\n * The tooltip target is used in combination with the Ignite UI for Angular Tooltip by assigning the exported tooltip reference to the\n * target's selector property.\n *\n * Example:\n * ```html\n * <button [igxTooltipTarget]=\"tooltipRef\">Hover me</button>\n * <span #tooltipRef=\"tooltip\" igxTooltip>Hello there, I am a tooltip!</span>\n * ```\n */\n\n\nlet IgxTooltipTargetDirective = /*#__PURE__*/(() => {\n  class IgxTooltipTargetDirective extends IgxToggleActionDirective {\n    constructor(_element, _navigationService, _viewContainerRef) {\n      super(_element, _navigationService);\n      this._element = _element;\n      this._navigationService = _navigationService;\n      this._viewContainerRef = _viewContainerRef;\n      /**\n       * Gets/sets the amount of milliseconds that should pass before showing the tooltip.\n       *\n       * ```typescript\n       * // get\n       * let tooltipShowDelay = this.tooltipTarget.showDelay;\n       * ```\n       *\n       * ```html\n       * <!--set-->\n       * <button [igxTooltipTarget]=\"tooltipRef\" showDelay=\"1500\">Hover me</button>\n       * <span #tooltipRef=\"tooltip\" igxTooltip>Hello there, I am a tooltip!</span>\n       * ```\n       */\n\n      this.showDelay = 500;\n      /**\n       * Gets/sets the amount of milliseconds that should pass before hiding the tooltip.\n       *\n       * ```typescript\n       * // get\n       * let tooltipHideDelay = this.tooltipTarget.hideDelay;\n       * ```\n       *\n       * ```html\n       * <!--set-->\n       * <button [igxTooltipTarget]=\"tooltipRef\" hideDelay=\"1500\">Hover me</button>\n       * <span #tooltipRef=\"tooltip\" igxTooltip>Hello there, I am a tooltip!</span>\n       * ```\n       */\n\n      this.hideDelay = 500;\n      /**\n       * Specifies if the tooltip should not show when hovering its target with the mouse. (defaults to false)\n       * While setting this property to 'true' will disable the user interactions that shows/hides the tooltip,\n       * the developer will still be able to show/hide the tooltip through the API.\n       *\n       * ```typescript\n       * // get\n       * let tooltipDisabledValue = this.tooltipTarget.tooltipDisabled;\n       * ```\n       *\n       * ```html\n       * <!--set-->\n       * <button [igxTooltipTarget]=\"tooltipRef\" [tooltipDisabled]=\"true\">Hover me</button>\n       * <span #tooltipRef=\"tooltip\" igxTooltip>Hello there, I am a tooltip!</span>\n       * ```\n       */\n\n      this.tooltipDisabled = false;\n      /**\n       * Emits an event when the tooltip that is associated with this target starts showing.\n       * This event is fired before the start of the countdown to showing the tooltip.\n       *\n       * ```typescript\n       * tooltipShowing(args: ITooltipShowEventArgs) {\n       *    alert(\"Tooltip started showing!\");\n       * }\n       * ```\n       *\n       * ```html\n       * <button [igxTooltipTarget]=\"tooltipRef\"\n       *         (tooltipShow)='tooltipShowing($event)'>Hover me</button>\n       * <span #tooltipRef=\"tooltip\" igxTooltip>Hello there, I am a tooltip!</span>\n       * ```\n       */\n\n      this.tooltipShow = new EventEmitter();\n      /**\n       * Emits an event when the tooltip that is associated with this target starts hiding.\n       * This event is fired before the start of the countdown to hiding the tooltip.\n       *\n       * ```typescript\n       * tooltipHiding(args: ITooltipHideEventArgs) {\n       *    alert(\"Tooltip started hiding!\");\n       * }\n       * ```\n       *\n       * ```html\n       * <button [igxTooltipTarget]=\"tooltipRef\"\n       *         (tooltipHide)='tooltipHiding($event)'>Hover me</button>\n       * <span #tooltipRef=\"tooltip\" igxTooltip>Hello there, I am a tooltip!</span>\n       * ```\n       */\n\n      this.tooltipHide = new EventEmitter();\n      this.destroy$ = new Subject();\n    }\n    /**\n     * @hidden\n     */\n\n\n    set target(target) {\n      if (target !== null && target !== '') {\n        this._target = target;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get target() {\n      if (typeof this._target === 'string') {\n        return this._navigationService.get(this._target);\n      }\n\n      return this._target;\n    }\n    /**\n    * @hidden\n    */\n\n\n    set tooltip(content) {\n      if (!this.target && (typeof content === 'string' || content instanceof String)) {\n        const tooltipComponent = this._viewContainerRef.createComponent(IgxTooltipComponent);\n\n        tooltipComponent.instance.content = content;\n        this._target = tooltipComponent.instance.tooltip;\n      }\n    }\n    /**\n     * Gets the respective native element of the directive.\n     *\n     * ```typescript\n     * let tooltipTargetElement = this.tooltipTarget.nativeElement;\n     * ```\n     */\n\n\n    get nativeElement() {\n      return this._element.nativeElement;\n    }\n    /**\n     * Indicates if the tooltip that is is associated with this target is currently hidden.\n     *\n     * ```typescript\n     * let tooltipHiddenValue = this.tooltipTarget.tooltipHidden;\n     * ```\n     */\n\n\n    get tooltipHidden() {\n      return !this.target || this.target.collapsed;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onClick() {\n      if (!this.target.collapsed) {\n        this.target.forceClose(this.mergedOverlaySettings);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onMouseEnter() {\n      if (this.tooltipDisabled) {\n        return;\n      }\n\n      this.checkOutletAndOutsideClick();\n      const shouldReturn = this.preMouseEnterCheck();\n\n      if (shouldReturn) {\n        return;\n      }\n\n      const showingArgs = {\n        target: this,\n        tooltip: this.target,\n        cancel: false\n      };\n      this.tooltipShow.emit(showingArgs);\n\n      if (showingArgs.cancel) {\n        return;\n      }\n\n      this.target.toBeShown = true;\n      this.target.timeoutId = setTimeout(() => {\n        this.target.open(this.mergedOverlaySettings); // Call open() of IgxTooltipDirective\n\n        this.target.toBeShown = false;\n      }, this.showDelay);\n    }\n    /**\n     * @hidden\n     */\n\n\n    onMouseLeave() {\n      if (this.tooltipDisabled) {\n        return;\n      }\n\n      this.checkOutletAndOutsideClick();\n      const shouldReturn = this.preMouseLeaveCheck();\n\n      if (shouldReturn || this.target.collapsed) {\n        return;\n      }\n\n      this.target.toBeHidden = true;\n      this.target.timeoutId = setTimeout(() => {\n        this.target.close(); // Call close() of IgxTooltipDirective\n\n        this.target.toBeHidden = false;\n      }, this.hideDelay);\n    }\n    /**\n     * @hidden\n     */\n\n\n    onTouchStart() {\n      if (this.tooltipDisabled) {\n        return;\n      }\n\n      this.showTooltip();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onDocumentTouchStart(event) {\n      if (this.tooltipDisabled) {\n        return;\n      }\n\n      if (this.nativeElement !== event.target && !this.nativeElement.contains(event.target)) {\n        this.hideTooltip();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      super.ngOnInit();\n      const positionSettings = {\n        horizontalDirection: HorizontalAlignment.Center,\n        horizontalStartPoint: HorizontalAlignment.Center,\n        openAnimation: useAnimation(scaleInCenter, {\n          params: {\n            duration: '150ms'\n          }\n        }),\n        closeAnimation: useAnimation(fadeOut, {\n          params: {\n            duration: '75ms'\n          }\n        })\n      };\n      this._overlayDefaults.positionStrategy = new AutoPositionStrategy(positionSettings);\n      this._overlayDefaults.closeOnOutsideClick = false;\n      this._overlayDefaults.closeOnEscape = true;\n      this.target.closing.pipe(takeUntil(this.destroy$)).subscribe(event => {\n        const hidingArgs = {\n          target: this,\n          tooltip: this.target,\n          cancel: false\n        };\n        this.tooltipHide.emit(hidingArgs);\n\n        if (hidingArgs.cancel) {\n          event.cancel = true;\n        }\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n    /**\n     * Shows the tooltip by respecting the 'showDelay' property.\n     *\n     * ```typescript\n     * this.tooltipTarget.showTooltip();\n     * ```\n     */\n\n\n    showTooltip() {\n      clearTimeout(this.target.timeoutId);\n\n      if (!this.target.collapsed) {\n        //  if close animation has started finish it, or close the tooltip with no animation\n        this.target.forceClose(this.mergedOverlaySettings);\n        this.target.toBeHidden = false;\n      }\n\n      const showingArgs = {\n        target: this,\n        tooltip: this.target,\n        cancel: false\n      };\n      this.tooltipShow.emit(showingArgs);\n\n      if (showingArgs.cancel) {\n        return;\n      }\n\n      this.target.toBeShown = true;\n      this.target.timeoutId = setTimeout(() => {\n        this.target.open(this.mergedOverlaySettings); // Call open() of IgxTooltipDirective\n\n        this.target.toBeShown = false;\n      }, this.showDelay);\n    }\n    /**\n     * Hides the tooltip by respecting the 'hideDelay' property.\n     *\n     * ```typescript\n     * this.tooltipTarget.hideTooltip();\n     * ```\n     */\n\n\n    hideTooltip() {\n      if (this.target.collapsed && this.target.toBeShown) {\n        clearTimeout(this.target.timeoutId);\n      }\n\n      if (this.target.collapsed || this.target.toBeHidden) {\n        return;\n      }\n\n      this.target.toBeHidden = true;\n      this.target.timeoutId = setTimeout(() => {\n        this.target.close(); // Call close() of IgxTooltipDirective\n\n        this.target.toBeHidden = false;\n      }, this.hideDelay);\n    }\n\n    checkOutletAndOutsideClick() {\n      if (this.outlet) {\n        this._overlayDefaults.outlet = this.outlet;\n      }\n    }\n\n    get mergedOverlaySettings() {\n      return Object.assign({}, this._overlayDefaults, this.overlaySettings);\n    } // Return true if the execution in onMouseEnter should be terminated after this method\n\n\n    preMouseEnterCheck() {\n      // If tooltip is about to be opened\n      if (this.target.toBeShown) {\n        clearTimeout(this.target.timeoutId);\n        this.target.toBeShown = false;\n      } // If Tooltip is opened or about to be hidden\n\n\n      if (!this.target.collapsed || this.target.toBeHidden) {\n        clearTimeout(this.target.timeoutId); //  if close animation has started finish it, or close the tooltip with no animation\n\n        this.target.forceClose(this.mergedOverlaySettings);\n        this.target.toBeHidden = false;\n      }\n\n      return false;\n    } // Return true if the execution in onMouseLeave should be terminated after this method\n\n\n    preMouseLeaveCheck() {\n      clearTimeout(this.target.timeoutId); // If tooltip is about to be opened\n\n      if (this.target.toBeShown) {\n        this.target.toBeShown = false;\n        this.target.toBeHidden = false;\n        return true;\n      }\n\n      return false;\n    }\n\n  }\n\n  IgxTooltipTargetDirective.ɵfac = function IgxTooltipTargetDirective_Factory(t) {\n    return new (t || IgxTooltipTargetDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(IgxNavigationService, 8), i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  };\n\n  IgxTooltipTargetDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxTooltipTargetDirective,\n    selectors: [[\"\", \"igxTooltipTarget\", \"\"]],\n    hostBindings: function IgxTooltipTargetDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function IgxTooltipTargetDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        })(\"mouseenter\", function IgxTooltipTargetDirective_mouseenter_HostBindingHandler() {\n          return ctx.onMouseEnter();\n        })(\"mouseleave\", function IgxTooltipTargetDirective_mouseleave_HostBindingHandler() {\n          return ctx.onMouseLeave();\n        })(\"touchstart\", function IgxTooltipTargetDirective_touchstart_HostBindingHandler() {\n          return ctx.onTouchStart();\n        })(\"touchstart\", function IgxTooltipTargetDirective_touchstart_HostBindingHandler($event) {\n          return ctx.onDocumentTouchStart($event);\n        }, false, i0.ɵɵresolveDocument);\n      }\n    },\n    inputs: {\n      showDelay: \"showDelay\",\n      hideDelay: \"hideDelay\",\n      tooltipDisabled: \"tooltipDisabled\",\n      target: [\"igxTooltipTarget\", \"target\"],\n      tooltip: \"tooltip\"\n    },\n    outputs: {\n      tooltipShow: \"tooltipShow\",\n      tooltipHide: \"tooltipHide\"\n    },\n    exportAs: [\"tooltipTarget\"],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return IgxTooltipTargetDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxTooltipModule = /*#__PURE__*/(() => {\n  class IgxTooltipModule {}\n\n  IgxTooltipModule.ɵfac = function IgxTooltipModule_Factory(t) {\n    return new (t || IgxTooltipModule)();\n  };\n\n  IgxTooltipModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxTooltipModule\n  });\n  IgxTooltipModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IgxOverlayService],\n    imports: [[CommonModule]]\n  });\n  return IgxTooltipModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Specify a particular date, time or AmPm part.\n */\n\n\nvar DatePart = /*#__PURE__*/(() => {\n  (function (DatePart) {\n    DatePart[\"Date\"] = \"date\";\n    DatePart[\"Month\"] = \"month\";\n    DatePart[\"Year\"] = \"year\";\n    DatePart[\"Hours\"] = \"hours\";\n    DatePart[\"Minutes\"] = \"minutes\";\n    DatePart[\"Seconds\"] = \"seconds\";\n    DatePart[\"AmPm\"] = \"ampm\";\n    DatePart[\"Literal\"] = \"literal\";\n  })(DatePart || (DatePart = {}));\n\n  return DatePart;\n})();\nconst DATE_CHARS = ['h', 'H', 'm', 's', 'S', 't', 'T'];\nconst TIME_CHARS = ['d', 'D', 'M', 'y', 'Y'];\n/** @hidden */\n\nlet DateTimeUtil = /*#__PURE__*/(() => {\n  class DateTimeUtil {\n    /**\n     * Parse a Date value from masked string input based on determined date parts\n     *\n     * @param inputData masked value to parse\n     * @param dateTimeParts Date parts array for the mask\n     */\n    static parseValueFromMask(inputData, dateTimeParts, promptChar) {\n      const parts = {};\n      dateTimeParts.forEach(dp => {\n        let value = parseInt(DateTimeUtil.getCleanVal(inputData, dp, promptChar), 10);\n\n        if (!value) {\n          value = dp.type === DatePart.Date || dp.type === DatePart.Month ? 1 : 0;\n        }\n\n        parts[dp.type] = value;\n      });\n      parts[DatePart.Month] -= 1;\n\n      if (parts[DatePart.Month] < 0 || 11 < parts[DatePart.Month]) {\n        return null;\n      } // TODO: Century threshold\n\n\n      if (parts[DatePart.Year] < 50) {\n        parts[DatePart.Year] += 2000;\n      }\n\n      if (parts[DatePart.Date] > DateTimeUtil.daysInMonth(parts[DatePart.Year], parts[DatePart.Month])) {\n        return null;\n      }\n\n      if (parts[DatePart.Hours] > 23 || parts[DatePart.Minutes] > 59 || parts[DatePart.Seconds] > 59) {\n        return null;\n      }\n\n      const amPm = dateTimeParts.find(p => p.type === DatePart.AmPm);\n\n      if (amPm) {\n        parts[DatePart.Hours] %= 12;\n      }\n\n      if (amPm && DateTimeUtil.getCleanVal(inputData, amPm, promptChar).toLowerCase() === 'pm') {\n        parts[DatePart.Hours] += 12;\n      }\n\n      return new Date(parts[DatePart.Year] || 2000, parts[DatePart.Month] || 0, parts[DatePart.Date] || 1, parts[DatePart.Hours] || 0, parts[DatePart.Minutes] || 0, parts[DatePart.Seconds] || 0);\n    }\n    /** Parse the mask into date/time and literal parts */\n\n\n    static parseDateTimeFormat(mask, locale) {\n      const format = mask || DateTimeUtil.getDefaultInputFormat(locale);\n      const dateTimeParts = [];\n      const formatArray = Array.from(format);\n      let currentPart = null;\n      let position = 0;\n\n      for (let i = 0; i < formatArray.length; i++, position++) {\n        const type = DateTimeUtil.determineDatePart(formatArray[i]);\n\n        if (currentPart) {\n          if (currentPart.type === type) {\n            currentPart.format += formatArray[i];\n\n            if (i < formatArray.length - 1) {\n              continue;\n            }\n          }\n\n          DateTimeUtil.addCurrentPart(currentPart, dateTimeParts);\n          position = currentPart.end;\n        }\n\n        currentPart = {\n          start: position,\n          end: position + formatArray[i].length,\n          type,\n          format: formatArray[i]\n        };\n      } // make sure the last member of a format like H:m:s is not omitted\n\n\n      if (!dateTimeParts.filter(p => p.format.includes(currentPart.format)).length) {\n        DateTimeUtil.addCurrentPart(currentPart, dateTimeParts);\n      } // formats like \"y\" or \"yyy\" are treated like \"yyyy\" while editing\n\n\n      const yearPart = dateTimeParts.filter(p => p.type === DatePart.Year)[0];\n\n      if (yearPart && yearPart.format !== 'yy') {\n        yearPart.end += 4 - yearPart.format.length;\n        yearPart.format = 'yyyy';\n      }\n\n      return dateTimeParts;\n    }\n\n    static getPartValue(value, datePartInfo, partLength) {\n      let maskedValue;\n      const datePart = datePartInfo.type;\n\n      switch (datePart) {\n        case DatePart.Date:\n          maskedValue = value.getDate();\n          break;\n\n        case DatePart.Month:\n          // months are zero based\n          maskedValue = value.getMonth() + 1;\n          break;\n\n        case DatePart.Year:\n          if (partLength === 2) {\n            maskedValue = this.prependValue(parseInt(value.getFullYear().toString().slice(-2), 10), partLength, '0');\n          } else {\n            maskedValue = value.getFullYear();\n          }\n\n          break;\n\n        case DatePart.Hours:\n          if (datePartInfo.format.indexOf('h') !== -1) {\n            maskedValue = this.prependValue(this.toTwelveHourFormat(value.getHours().toString()), partLength, '0');\n          } else {\n            maskedValue = value.getHours();\n          }\n\n          break;\n\n        case DatePart.Minutes:\n          maskedValue = value.getMinutes();\n          break;\n\n        case DatePart.Seconds:\n          maskedValue = value.getSeconds();\n          break;\n\n        case DatePart.AmPm:\n          maskedValue = value.getHours() >= 12 ? 'PM' : 'AM';\n          break;\n      }\n\n      if (datePartInfo.type !== DatePart.AmPm) {\n        return this.prependValue(maskedValue, partLength, '0');\n      }\n\n      return maskedValue;\n    }\n    /** Builds a date-time editor's default input format based on provided locale settings. */\n\n\n    static getDefaultInputFormat(locale) {\n      locale = locale || DateTimeUtil.DEFAULT_LOCALE;\n\n      if (!Intl || !Intl.DateTimeFormat || !Intl.DateTimeFormat.prototype.formatToParts) {\n        // TODO: fallback with Intl.format for IE?\n        return DateTimeUtil.DEFAULT_INPUT_FORMAT;\n      }\n\n      const parts = DateTimeUtil.getDefaultLocaleMask(locale);\n      parts.forEach(p => {\n        if (p.type !== DatePart.Year && p.type !== DateTimeUtil.SEPARATOR) {\n          p.formatType = \"2-digit\"\n          /* TwoDigits */\n          ;\n        }\n      });\n      return DateTimeUtil.getMask(parts);\n    }\n    /** Tries to format a date using Angular's DatePipe. Fallbacks to `Intl` if no locale settings have been loaded. */\n\n\n    static formatDate(value, format, locale, timezone) {\n      let formattedDate;\n\n      try {\n        formattedDate = formatDate$1(value, format, locale, timezone);\n      } catch (_a) {\n        DateTimeUtil.logMissingLocaleSettings(locale);\n        const formatter = new Intl.DateTimeFormat(locale);\n        formattedDate = formatter.format(value);\n      }\n\n      return formattedDate;\n    }\n    /**\n     * Returns the date format based on a provided locale.\n     * Supports Angular's DatePipe format options such as `shortDate`, `longDate`.\n     */\n\n\n    static getLocaleDateFormat(locale, displayFormat) {\n      const formatKeys = Object.keys(FormatWidth);\n      const targetKey = formatKeys.find(k => k.toLowerCase() === (displayFormat === null || displayFormat === void 0 ? void 0 : displayFormat.toLowerCase().replace('date', '')));\n\n      if (!targetKey) {\n        // if displayFormat is not shortDate, longDate, etc.\n        // or if it is not set by the user\n        return displayFormat;\n      }\n\n      let format;\n\n      try {\n        format = getLocaleDateFormat(locale, FormatWidth[targetKey]);\n      } catch (_a) {\n        DateTimeUtil.logMissingLocaleSettings(locale);\n        format = DateTimeUtil.getDefaultInputFormat(locale);\n      }\n\n      return format;\n    }\n    /** Determines if a given character is `d/M/y` or `h/m/s`. */\n\n\n    static isDateOrTimeChar(char) {\n      return DATE_CHARS.indexOf(char) !== -1 || TIME_CHARS.indexOf(char) !== -1;\n    }\n    /** Spins the date portion in a date-time editor. */\n\n\n    static spinDate(delta, newDate, spinLoop) {\n      const maxDate = DateTimeUtil.daysInMonth(newDate.getFullYear(), newDate.getMonth());\n      let date = newDate.getDate() + delta;\n\n      if (date > maxDate) {\n        date = spinLoop ? date % maxDate : maxDate;\n      } else if (date < 1) {\n        date = spinLoop ? maxDate + date % maxDate : 1;\n      }\n\n      newDate.setDate(date);\n    }\n    /** Spins the month portion in a date-time editor. */\n\n\n    static spinMonth(delta, newDate, spinLoop) {\n      const maxDate = DateTimeUtil.daysInMonth(newDate.getFullYear(), newDate.getMonth() + delta);\n\n      if (newDate.getDate() > maxDate) {\n        newDate.setDate(maxDate);\n      }\n\n      const maxMonth = 11;\n      const minMonth = 0;\n      let month = newDate.getMonth() + delta;\n\n      if (month > maxMonth) {\n        month = spinLoop ? month % maxMonth - 1 : maxMonth;\n      } else if (month < minMonth) {\n        month = spinLoop ? maxMonth + month % maxMonth + 1 : minMonth;\n      }\n\n      newDate.setMonth(month);\n    }\n    /** Spins the year portion in a date-time editor. */\n\n\n    static spinYear(delta, newDate) {\n      const maxDate = DateTimeUtil.daysInMonth(newDate.getFullYear() + delta, newDate.getMonth());\n\n      if (newDate.getDate() > maxDate) {\n        // clip to max to avoid leap year change shifting the entire value\n        newDate.setDate(maxDate);\n      }\n\n      newDate.setFullYear(newDate.getFullYear() + delta);\n    }\n    /** Spins the hours portion in a date-time editor. */\n\n\n    static spinHours(delta, newDate, spinLoop) {\n      const maxHour = 23;\n      const minHour = 0;\n      let hours = newDate.getHours() + delta;\n\n      if (hours > maxHour) {\n        hours = spinLoop ? hours % maxHour - 1 : maxHour;\n      } else if (hours < minHour) {\n        hours = spinLoop ? maxHour + hours % maxHour + 1 : minHour;\n      }\n\n      newDate.setHours(hours);\n    }\n    /** Spins the minutes portion in a date-time editor. */\n\n\n    static spinMinutes(delta, newDate, spinLoop) {\n      const maxMinutes = 59;\n      const minMinutes = 0;\n      let minutes = newDate.getMinutes() + delta;\n\n      if (minutes > maxMinutes) {\n        minutes = spinLoop ? minutes % maxMinutes - 1 : maxMinutes;\n      } else if (minutes < minMinutes) {\n        minutes = spinLoop ? maxMinutes + minutes % maxMinutes + 1 : minMinutes;\n      }\n\n      newDate.setMinutes(minutes);\n    }\n    /** Spins the seconds portion in a date-time editor. */\n\n\n    static spinSeconds(delta, newDate, spinLoop) {\n      const maxSeconds = 59;\n      const minSeconds = 0;\n      let seconds = newDate.getSeconds() + delta;\n\n      if (seconds > maxSeconds) {\n        seconds = spinLoop ? seconds % maxSeconds - 1 : maxSeconds;\n      } else if (seconds < minSeconds) {\n        seconds = spinLoop ? maxSeconds + seconds % maxSeconds + 1 : minSeconds;\n      }\n\n      newDate.setSeconds(seconds);\n    }\n    /** Spins the AM/PM portion in a date-time editor. */\n\n\n    static spinAmPm(newDate, currentDate, amPmFromMask) {\n      switch (amPmFromMask) {\n        case 'AM':\n          newDate = new Date(newDate.setHours(newDate.getHours() + 12));\n          break;\n\n        case 'PM':\n          newDate = new Date(newDate.setHours(newDate.getHours() - 12));\n          break;\n      }\n\n      if (newDate.getDate() !== currentDate.getDate()) {\n        return currentDate;\n      }\n\n      return newDate;\n    }\n    /**\n     * Determines whether the provided value is greater than the provided max value.\n     *\n     * @param includeTime set to false if you want to exclude time portion of the two dates\n     * @param includeDate set to false if you want to exclude the date portion of the two dates\n     * @returns true if provided value is greater than provided maxValue\n     */\n\n\n    static greaterThanMaxValue(value, maxValue, includeTime = true, includeDate = true) {\n      if (includeTime && includeDate) {\n        return value.getTime() > maxValue.getTime();\n      }\n\n      const _value = new Date(value.getTime());\n\n      const _maxValue = new Date(maxValue.getTime());\n\n      if (!includeTime) {\n        _value.setHours(0, 0, 0, 0);\n\n        _maxValue.setHours(0, 0, 0, 0);\n      }\n\n      if (!includeDate) {\n        _value.setFullYear(0, 0, 0);\n\n        _maxValue.setFullYear(0, 0, 0);\n      }\n\n      return _value.getTime() > _maxValue.getTime();\n    }\n    /**\n     * Determines whether the provided value is less than the provided min value.\n     *\n     * @param includeTime set to false if you want to exclude time portion of the two dates\n     * @param includeDate set to false if you want to exclude the date portion of the two dates\n     * @returns true if provided value is less than provided minValue\n     */\n\n\n    static lessThanMinValue(value, minValue, includeTime = true, includeDate = true) {\n      if (includeTime && includeDate) {\n        return value.getTime() < minValue.getTime();\n      }\n\n      const _value = new Date(value.getTime());\n\n      const _minValue = new Date(minValue.getTime());\n\n      if (!includeTime) {\n        _value.setHours(0, 0, 0, 0);\n\n        _minValue.setHours(0, 0, 0, 0);\n      }\n\n      if (!includeDate) {\n        _value.setFullYear(0, 0, 0);\n\n        _minValue.setFullYear(0, 0, 0);\n      }\n\n      return _value.getTime() < _minValue.getTime();\n    }\n    /**\n     * Validates a value within a given min and max value range.\n     *\n     * @param value The value to validate\n     * @param minValue The lowest possible value that `value` can take\n     * @param maxValue The largest possible value that `value` can take\n     */\n\n\n    static validateMinMax(value, minValue, maxValue, includeTime = true, includeDate = true) {\n      if (!value) {\n        return null;\n      }\n\n      const errors = {};\n      const min = DateTimeUtil.isValidDate(minValue) ? minValue : DateTimeUtil.parseIsoDate(minValue);\n      const max = DateTimeUtil.isValidDate(maxValue) ? maxValue : DateTimeUtil.parseIsoDate(maxValue);\n\n      if (min && value && DateTimeUtil.lessThanMinValue(value, min, includeTime, includeDate)) {\n        Object.assign(errors, {\n          minValue: true\n        });\n      }\n\n      if (max && value && DateTimeUtil.greaterThanMaxValue(value, max, includeTime, includeDate)) {\n        Object.assign(errors, {\n          maxValue: true\n        });\n      }\n\n      return errors;\n    }\n    /** Parse an ISO string to a Date */\n\n\n    static parseIsoDate(value) {\n      let regex = /^\\d{4}/g;\n      const timeLiteral = 'T';\n\n      if (regex.test(value)) {\n        return new Date(value + `${value.indexOf(timeLiteral) === -1 ? 'T00:00:00' : ''}`);\n      }\n\n      regex = /^\\d{2}/g;\n\n      if (regex.test(value)) {\n        const dateNow = new Date().toISOString(); // eslint-disable-next-line prefer-const\n\n        let [datePart, _timePart] = dateNow.split(timeLiteral);\n        return new Date(`${datePart}T${value}`);\n      }\n\n      return null;\n    }\n    /**\n     * Returns whether the input is valid date\n     *\n     * @param value input to check\n     * @returns true if provided input is a valid date\n     */\n\n\n    static isValidDate(value) {\n      if (isDate(value)) {\n        return !isNaN(value.getTime());\n      }\n\n      return false;\n    }\n\n    static addCurrentPart(currentPart, dateTimeParts) {\n      DateTimeUtil.ensureLeadingZero(currentPart);\n      currentPart.end = currentPart.start + currentPart.format.length;\n      dateTimeParts.push(currentPart);\n    }\n\n    static daysInMonth(fullYear, month) {\n      return new Date(fullYear, month + 1, 0).getDate();\n    }\n\n    static trimEmptyPlaceholders(value, promptChar) {\n      const result = value.replace(new RegExp(promptChar || '_', 'g'), '');\n      return result;\n    }\n\n    static getMask(dateStruct) {\n      const mask = [];\n\n      for (const part of dateStruct) {\n        switch (part.formatType) {\n          case \"numeric\"\n          /* Numeric */\n          :\n            {\n              if (part.type === \"day\"\n              /* Day */\n              ) {\n                mask.push('d');\n              } else if (part.type === \"month\"\n              /* Month */\n              ) {\n                mask.push('M');\n              } else {\n                mask.push('yyyy');\n              }\n\n              break;\n            }\n\n          case \"2-digit\"\n          /* TwoDigits */\n          :\n            {\n              if (part.type === \"day\"\n              /* Day */\n              ) {\n                mask.push('dd');\n              } else if (part.type === \"month\"\n              /* Month */\n              ) {\n                mask.push('MM');\n              } else {\n                mask.push('yy');\n              }\n            }\n        }\n\n        if (part.type === DateTimeUtil.SEPARATOR) {\n          mask.push(part.value);\n        }\n      }\n\n      return mask.join('');\n    }\n\n    static logMissingLocaleSettings(locale) {\n      console.warn(`Missing locale data for the locale ${locale}. Please refer to https://angular.io/guide/i18n#i18n-pipes`);\n      console.warn('Using default browser locale settings.');\n    }\n\n    static prependValue(value, partLength, prependChar) {\n      return (prependChar + value.toString()).slice(-partLength);\n    }\n\n    static toTwelveHourFormat(value, promptChar = '_') {\n      let hour = parseInt(value.replace(new RegExp(promptChar, 'g'), '0'), 10);\n\n      if (hour > 12) {\n        hour -= 12;\n      } else if (hour === 0) {\n        hour = 12;\n      }\n\n      return hour;\n    }\n\n    static ensureLeadingZero(part) {\n      switch (part.type) {\n        case DatePart.Date:\n        case DatePart.Month:\n        case DatePart.Hours:\n        case DatePart.Minutes:\n        case DatePart.Seconds:\n          if (part.format.length === 1) {\n            part.format = part.format.repeat(2);\n          }\n\n          break;\n      }\n    }\n\n    static getCleanVal(inputData, datePart, promptChar) {\n      return DateTimeUtil.trimEmptyPlaceholders(inputData.substring(datePart.start, datePart.end), promptChar);\n    }\n\n    static determineDatePart(char) {\n      switch (char) {\n        case 'd':\n        case 'D':\n          return DatePart.Date;\n\n        case 'M':\n          return DatePart.Month;\n\n        case 'y':\n        case 'Y':\n          return DatePart.Year;\n\n        case 'h':\n        case 'H':\n          return DatePart.Hours;\n\n        case 'm':\n          return DatePart.Minutes;\n\n        case 's':\n        case 'S':\n          return DatePart.Seconds;\n\n        case 't':\n        case 'T':\n          return DatePart.AmPm;\n\n        default:\n          return DatePart.Literal;\n      }\n    }\n\n    static getDefaultLocaleMask(locale) {\n      const dateStruct = [];\n      const formatter = new Intl.DateTimeFormat(locale);\n      const formatToParts = formatter.formatToParts(new Date());\n\n      for (const part of formatToParts) {\n        if (part.type === DateTimeUtil.SEPARATOR) {\n          dateStruct.push({\n            type: DateTimeUtil.SEPARATOR,\n            value: part.value\n          });\n        } else {\n          dateStruct.push({\n            type: part.type\n          });\n        }\n      }\n\n      const formatterOptions = formatter.resolvedOptions();\n\n      for (const part of dateStruct) {\n        switch (part.type) {\n          case \"day\"\n          /* Day */\n          :\n            {\n              part.formatType = formatterOptions.day;\n              break;\n            }\n\n          case \"month\"\n          /* Month */\n          :\n            {\n              part.formatType = formatterOptions.month;\n              break;\n            }\n\n          case \"year\"\n          /* Year */\n          :\n            {\n              part.formatType = formatterOptions.year;\n              break;\n            }\n        }\n      }\n\n      DateTimeUtil.fillDatePartsPositions(dateStruct);\n      return dateStruct;\n    }\n\n    static fillDatePartsPositions(dateArray) {\n      let currentPos = 0;\n\n      for (const part of dateArray) {\n        // Day|Month part positions\n        if (part.type === \"day\"\n        /* Day */\n        || part.type === \"month\"\n        /* Month */\n        ) {\n          // Offset 2 positions for number\n          part.position = [currentPos, currentPos + 2];\n          currentPos += 2;\n        } else if (part.type === \"year\"\n        /* Year */\n        ) {\n          // Year part positions\n          switch (part.formatType) {\n            case \"numeric\"\n            /* Numeric */\n            :\n              {\n                // Offset 4 positions for full year\n                part.position = [currentPos, currentPos + 4];\n                currentPos += 4;\n                break;\n              }\n\n            case \"2-digit\"\n            /* TwoDigits */\n            :\n              {\n                // Offset 2 positions for short year\n                part.position = [currentPos, currentPos + 2];\n                currentPos += 2;\n                break;\n              }\n          }\n        } else if (part.type === DateTimeUtil.SEPARATOR) {\n          // Separator positions\n          part.position = [currentPos, currentPos + 1];\n          currentPos++;\n        }\n      }\n    }\n\n  }\n\n  DateTimeUtil.DEFAULT_INPUT_FORMAT = 'MM/dd/yyyy';\n  DateTimeUtil.DEFAULT_TIME_INPUT_FORMAT = 'hh:mm tt';\n  DateTimeUtil.SEPARATOR = 'literal';\n  DateTimeUtil.DEFAULT_LOCALE = 'en';\n  /* eslint-disable @angular-eslint/no-conflicting-lifecycle */\n\n  /**\n   * Date Time Editor provides a functionality to input, edit and format date and time.\n   *\n   * @igxModule IgxDateTimeEditorModule\n   *\n   * @igxParent IgxInputGroup\n   *\n   * @igxTheme igx-input-theme\n   *\n   * @igxKeywords date, time, editor\n   *\n   * @igxGroup Scheduling\n   *\n   * @remarks\n   *\n   * The Ignite UI Date Time Editor Directive makes it easy for developers to manipulate date/time user input.\n   * It requires input in a specified or default input format which is visible in the input element as a placeholder.\n   * It allows the input of only date (ex: 'dd/MM/yyyy'), only time (ex:'HH:mm tt') or both at once, if needed.\n   * Supports display format that may differ from the input format.\n   * Provides methods to increment and decrement any specific/targeted `DatePart`.\n   *\n   * @example\n   * ```html\n   * <igx-input-group>\n   *   <input type=\"text\" igxInput [igxDateTimeEditor]=\"'dd/MM/yyyy'\" [displayFormat]=\"'shortDate'\" [(ngModel)]=\"date\"/>\n   * </igx-input-group>\n   * ```\n   */\n\n  return DateTimeUtil;\n})();\nlet IgxDateTimeEditorDirective = /*#__PURE__*/(() => {\n  class IgxDateTimeEditorDirective extends IgxMaskDirective {\n    constructor(renderer, elementRef, maskParser, platform, _document, _locale) {\n      super(elementRef, maskParser, renderer, platform);\n      this.renderer = renderer;\n      this.elementRef = elementRef;\n      this.maskParser = maskParser;\n      this.platform = platform;\n      this._document = _document;\n      this._locale = _locale;\n      /**\n       * Specify if the currently spun date segment should loop over.\n       *\n       * @example\n       * ```html\n       * <input igxDateTimeEditor [spinLoop]=\"false\">\n       * ```\n       */\n\n      this.spinLoop = true;\n      /**\n       * Emitted when the editor's value has changed.\n       *\n       * @example\n       * ```html\n       * <input igxDateTimeEditor (valueChange)=\"valueChange($event)\"/>\n       * ```\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * Emitted when the editor is not within a specified range or when the editor's value is in an invalid state.\n       *\n       * @example\n       * ```html\n       * <input igxDateTimeEditor [minValue]=\"minDate\" [maxValue]=\"maxDate\" (validationFailed)=\"onValidationFailed($event)\"/>\n       * ```\n       */\n\n      this.validationFailed = new EventEmitter();\n      this._datePartDeltas = {\n        date: 1,\n        month: 1,\n        year: 1,\n        hours: 1,\n        minutes: 1,\n        seconds: 1\n      };\n      this.onTouchCallback = noop;\n      this.onChangeCallback = noop;\n      this.onValidatorChange = noop;\n      this.document = this._document;\n      this.locale = this.locale || this._locale;\n    }\n    /**\n     * Minimum value required for the editor to remain valid.\n     *\n     * @remarks\n     * If a `string` value is passed, it must be in the defined input format.\n     *\n     * @example\n     * ```html\n     * <input igxDateTimeEditor [minValue]=\"minDate\">\n     * ```\n     */\n\n\n    get minValue() {\n      return this._minValue;\n    }\n\n    set minValue(value) {\n      this._minValue = value;\n      this.onValidatorChange();\n    }\n    /**\n     * Maximum value required for the editor to remain valid.\n     *\n     * @remarks\n     * If a `string` value is passed in, it must be in the defined input format.\n     *\n     * @example\n     * ```html\n     * <input igxDateTimeEditor [maxValue]=\"maxDate\">\n     * ```\n     */\n\n\n    get maxValue() {\n      return this._maxValue;\n    }\n\n    set maxValue(value) {\n      this._maxValue = value;\n      this.onValidatorChange();\n    }\n    /**\n     * Expected user input format (and placeholder).\n     *\n     * @example\n     * ```html\n     * <input [igxDateTimeEditor]=\"'dd/MM/yyyy'\">\n     * ```\n     */\n\n\n    set inputFormat(value) {\n      if (value) {\n        this.setMask(value);\n        this._inputFormat = value;\n      }\n    }\n\n    get inputFormat() {\n      return this._inputFormat || this._defaultInputFormat;\n    }\n    /**\n     * Editor value.\n     *\n     * @example\n     * ```html\n     * <input igxDateTimeEditor [value]=\"date\">\n     * ```\n     */\n\n\n    set value(value) {\n      this._value = value;\n      this.setDateValue(value);\n      this.onChangeCallback(value);\n      this.updateMask();\n    }\n\n    get value() {\n      return this._value;\n    }\n\n    get datePartDeltas() {\n      return Object.assign({}, this._datePartDeltas, this.spinDelta);\n    }\n\n    get emptyMask() {\n      return this.maskParser.applyMask(null, this.maskOptions);\n    }\n\n    get targetDatePart() {\n      var _a, _b, _c; // V.K. May 16th, 2022 #11556 Get correct date part in shadow DOM\n\n\n      if (this.document.activeElement === this.nativeElement || ((_b = (_a = this.document.activeElement) === null || _a === void 0 ? void 0 : _a.shadowRoot) === null || _b === void 0 ? void 0 : _b.activeElement) === this.nativeElement) {\n        return (_c = this._inputDateParts.find(p => p.start <= this.selectionStart && this.selectionStart <= p.end && p.type !== DatePart.Literal)) === null || _c === void 0 ? void 0 : _c.type;\n      } else {\n        if (this._inputDateParts.some(p => p.type === DatePart.Date)) {\n          return DatePart.Date;\n        } else if (this._inputDateParts.some(p => p.type === DatePart.Hours)) {\n          return DatePart.Hours;\n        }\n      }\n    }\n\n    get hasDateParts() {\n      return this._inputDateParts.some(p => p.type === DatePart.Date || p.type === DatePart.Month || p.type === DatePart.Year);\n    }\n\n    get hasTimeParts() {\n      return this._inputDateParts.some(p => p.type === DatePart.Hours || p.type === DatePart.Minutes || p.type === DatePart.Seconds);\n    }\n\n    get dateValue() {\n      return this._dateValue;\n    }\n\n    onWheel(event) {\n      if (!this._isFocused) {\n        return;\n      }\n\n      event.preventDefault();\n      event.stopPropagation();\n\n      if (event.deltaY > 0) {\n        this.decrement();\n      } else {\n        this.increment();\n      }\n    }\n\n    ngOnInit() {\n      this.updateDefaultFormat();\n      this.setMask(this.inputFormat);\n      this.updateMask();\n    }\n    /** @hidden @internal */\n\n\n    ngOnChanges(changes) {\n      if (changes['locale'] && !changes['locale'].firstChange) {\n        this.updateDefaultFormat();\n\n        if (!this._inputFormat) {\n          this.setMask(this.inputFormat);\n          this.updateMask();\n        }\n      }\n\n      if (changes['inputFormat'] && !changes['inputFormat'].firstChange) {\n        this.updateMask();\n      }\n    }\n    /** Clear the input element value. */\n\n\n    clear() {\n      this._onClear = true;\n      this.updateValue(null);\n      this.setSelectionRange(0, this.inputValue.length);\n      this._onClear = false;\n    }\n    /**\n     * Increment specified DatePart.\n     *\n     * @param datePart The optional DatePart to increment. Defaults to Date or Hours (when Date is absent from the inputFormat - ex:'HH:mm').\n     * @param delta The optional delta to increment by. Overrides `spinDelta`.\n     */\n\n\n    increment(datePart, delta) {\n      const targetPart = datePart || this.targetDatePart;\n\n      if (!targetPart) {\n        return;\n      }\n\n      const newValue = this.trySpinValue(targetPart, delta);\n      this.updateValue(newValue);\n    }\n    /**\n     * Decrement specified DatePart.\n     *\n     * @param datePart The optional DatePart to decrement. Defaults to Date or Hours (when Date is absent from the inputFormat - ex:'HH:mm').\n     * @param delta The optional delta to decrement by. Overrides `spinDelta`.\n     */\n\n\n    decrement(datePart, delta) {\n      const targetPart = datePart || this.targetDatePart;\n\n      if (!targetPart) {\n        return;\n      }\n\n      const newValue = this.trySpinValue(targetPart, delta, true);\n      this.updateValue(newValue);\n    }\n    /** @hidden @internal */\n\n\n    writeValue(value) {\n      this._value = value;\n      this.setDateValue(value);\n      this.updateMask();\n    }\n    /** @hidden @internal */\n\n\n    validate(control) {\n      if (!control.value) {\n        return null;\n      } // InvalidDate handling\n\n\n      if (isDate(control.value) && !DateTimeUtil.isValidDate(control.value)) {\n        return {\n          value: true\n        };\n      }\n\n      let errors = {};\n      const value = DateTimeUtil.isValidDate(control.value) ? control.value : DateTimeUtil.parseIsoDate(control.value);\n      const minValueDate = DateTimeUtil.isValidDate(this.minValue) ? this.minValue : this.parseDate(this.minValue);\n      const maxValueDate = DateTimeUtil.isValidDate(this.maxValue) ? this.maxValue : this.parseDate(this.maxValue);\n\n      if (minValueDate || maxValueDate) {\n        errors = DateTimeUtil.validateMinMax(value, minValueDate, maxValueDate, this.hasTimeParts, this.hasDateParts);\n      }\n\n      return Object.keys(errors).length > 0 ? errors : null;\n    }\n    /** @hidden @internal */\n\n\n    registerOnValidatorChange(fn) {\n      this.onValidatorChange = fn;\n    }\n    /** @hidden @internal */\n\n\n    registerOnChange(fn) {\n      this.onChangeCallback = fn;\n    }\n    /** @hidden @internal */\n\n\n    registerOnTouched(fn) {\n      this.onTouchCallback = fn;\n    }\n    /** @hidden @internal */\n\n\n    setDisabledState(_isDisabled) {}\n    /** @hidden @internal */\n\n\n    onCompositionEnd() {\n      super.onCompositionEnd();\n      this.updateValue(this.parseDate(this.inputValue));\n      this.updateMask();\n    }\n    /** @hidden @internal */\n\n\n    onInputChanged(event) {\n      super.onInputChanged(event);\n\n      if (this._composing) {\n        return;\n      }\n\n      if (this.inputIsComplete()) {\n        const parsedDate = this.parseDate(this.inputValue);\n\n        if (DateTimeUtil.isValidDate(parsedDate)) {\n          this.updateValue(parsedDate);\n        } else {\n          const oldValue = this.value && new Date(this.dateValue.getTime());\n          const args = {\n            oldValue,\n            newValue: parsedDate,\n            userInput: this.inputValue\n          };\n          this.validationFailed.emit(args);\n\n          if (DateTimeUtil.isValidDate(args.newValue)) {\n            this.updateValue(args.newValue);\n          } else {\n            this.updateValue(null);\n          }\n        }\n      } else {\n        this.updateValue(null);\n      }\n    }\n    /** @hidden @internal */\n\n\n    onKeyDown(event) {\n      if (this.nativeElement.readOnly) {\n        return;\n      }\n\n      super.onKeyDown(event);\n      const key = event.key;\n\n      if (event.altKey) {\n        return;\n      }\n\n      if (key === this.platform.KEYMAP.ARROW_DOWN || key === this.platform.KEYMAP.ARROW_UP) {\n        this.spin(event);\n        return;\n      }\n\n      if (event.ctrlKey && key === this.platform.KEYMAP.SEMICOLON) {\n        this.updateValue(new Date());\n      }\n\n      this.moveCursor(event);\n    }\n    /** @hidden @internal */\n\n\n    onFocus() {\n      if (this.nativeElement.readOnly) {\n        return;\n      }\n\n      this._isFocused = true;\n      this.onTouchCallback();\n      this.updateMask();\n      super.onFocus();\n    }\n    /** @hidden @internal */\n\n\n    onBlur(value) {\n      this._isFocused = false;\n\n      if (!this.inputIsComplete() && this.inputValue !== this.emptyMask) {\n        this.updateValue(this.parseDate(this.inputValue));\n      } else {\n        this.updateMask();\n      } // TODO: think of a better way to set displayValuePipe in mask directive\n\n\n      if (this.displayValuePipe) {\n        return;\n      }\n\n      super.onBlur(value);\n    } // the date editor sets its own inputFormat as its placeholder if none is provided\n\n    /** @hidden */\n\n\n    setPlaceholder(_value) {}\n\n    updateDefaultFormat() {\n      this._defaultInputFormat = DateTimeUtil.getDefaultInputFormat(this.locale);\n    }\n\n    updateMask() {\n      if (this._isFocused) {\n        // store the cursor position as it will be moved during masking\n        const cursor = this.selectionEnd;\n        this.inputValue = this.getMaskedValue();\n        this.setSelectionRange(cursor);\n      } else {\n        if (!this.dateValue || !DateTimeUtil.isValidDate(this.dateValue)) {\n          this.inputValue = '';\n          return;\n        }\n\n        if (this.displayValuePipe) {\n          // TODO: remove when formatter func has been deleted\n          this.inputValue = this.displayValuePipe.transform(this.value);\n          return;\n        }\n\n        const format = this.displayFormat || this.inputFormat;\n\n        if (format) {\n          this.inputValue = DateTimeUtil.formatDate(this.dateValue, format.replace('tt', 'aa'), this.locale);\n        } else {\n          this.inputValue = this.dateValue.toLocaleString();\n        }\n      }\n    }\n\n    setMask(inputFormat) {\n      var _a;\n\n      const oldFormat = (_a = this._inputDateParts) === null || _a === void 0 ? void 0 : _a.map(p => p.format).join('');\n      this._inputDateParts = DateTimeUtil.parseDateTimeFormat(inputFormat);\n      inputFormat = this._inputDateParts.map(p => p.format).join('');\n      const mask = (inputFormat || DateTimeUtil.DEFAULT_INPUT_FORMAT).replace(new RegExp(/(?=[^t])[\\w]/, 'g'), '0');\n      this.mask = mask.indexOf('tt') !== -1 ? mask.replace(new RegExp('tt', 'g'), 'LL') : mask;\n      const placeholder = this.nativeElement.placeholder;\n\n      if (!placeholder || oldFormat === placeholder) {\n        this.renderer.setAttribute(this.nativeElement, 'placeholder', inputFormat);\n      }\n    }\n\n    parseDate(val) {\n      if (!val) {\n        return null;\n      }\n\n      return DateTimeUtil.parseValueFromMask(val, this._inputDateParts, this.promptChar);\n    }\n\n    getMaskedValue() {\n      let mask = this.emptyMask;\n\n      if (DateTimeUtil.isValidDate(this.value)) {\n        for (const part of this._inputDateParts) {\n          if (part.type === DatePart.Literal) {\n            continue;\n          }\n\n          const targetValue = this.getPartValue(part, part.format.length);\n          mask = this.maskParser.replaceInMask(mask, targetValue, this.maskOptions, part.start, part.end).value;\n        }\n\n        return mask;\n      }\n\n      if (!this.inputIsComplete() || !this._onClear) {\n        return this.inputValue;\n      }\n\n      return mask;\n    }\n\n    valueInRange(value) {\n      if (!value) {\n        return false;\n      }\n\n      let errors = {};\n      const minValueDate = DateTimeUtil.isValidDate(this.minValue) ? this.minValue : this.parseDate(this.minValue);\n      const maxValueDate = DateTimeUtil.isValidDate(this.maxValue) ? this.maxValue : this.parseDate(this.maxValue);\n\n      if (minValueDate || maxValueDate) {\n        errors = DateTimeUtil.validateMinMax(value, this.minValue, this.maxValue, this.hasTimeParts, this.hasDateParts);\n      }\n\n      return Object.keys(errors).length === 0;\n    }\n\n    spinValue(datePart, delta) {\n      if (!this.dateValue || !DateTimeUtil.isValidDate(this.dateValue)) {\n        return null;\n      }\n\n      const newDate = new Date(this.dateValue.getTime());\n\n      switch (datePart) {\n        case DatePart.Date:\n          DateTimeUtil.spinDate(delta, newDate, this.spinLoop);\n          break;\n\n        case DatePart.Month:\n          DateTimeUtil.spinMonth(delta, newDate, this.spinLoop);\n          break;\n\n        case DatePart.Year:\n          DateTimeUtil.spinYear(delta, newDate);\n          break;\n\n        case DatePart.Hours:\n          DateTimeUtil.spinHours(delta, newDate, this.spinLoop);\n          break;\n\n        case DatePart.Minutes:\n          DateTimeUtil.spinMinutes(delta, newDate, this.spinLoop);\n          break;\n\n        case DatePart.Seconds:\n          DateTimeUtil.spinSeconds(delta, newDate, this.spinLoop);\n          break;\n\n        case DatePart.AmPm:\n          const formatPart = this._inputDateParts.find(dp => dp.type === DatePart.AmPm);\n\n          const amPmFromMask = this.inputValue.substring(formatPart.start, formatPart.end);\n          return DateTimeUtil.spinAmPm(newDate, this.dateValue, amPmFromMask);\n      }\n\n      return newDate;\n    }\n\n    trySpinValue(datePart, delta, negative = false) {\n      if (!delta) {\n        // default to 1 if a delta is set to 0 or any other falsy value\n        delta = this.datePartDeltas[datePart] || 1;\n      }\n\n      const spinValue = negative ? -Math.abs(delta) : Math.abs(delta);\n      return this.spinValue(datePart, spinValue) || new Date();\n    }\n\n    setDateValue(value) {\n      this._dateValue = DateTimeUtil.isValidDate(value) ? value : DateTimeUtil.parseIsoDate(value);\n    }\n\n    updateValue(newDate) {\n      this._oldValue = this.dateValue;\n      this.value = newDate; // TODO: should we emit events here?\n\n      if (this.inputIsComplete() || this.inputValue === this.emptyMask) {\n        this.valueChange.emit(this.dateValue);\n      }\n\n      if (this.dateValue && !this.valueInRange(this.dateValue)) {\n        this.validationFailed.emit({\n          oldValue: this._oldValue,\n          newValue: this.dateValue,\n          userInput: this.inputValue\n        });\n      }\n    }\n\n    toTwelveHourFormat(value) {\n      let hour = parseInt(value.replace(new RegExp(this.promptChar, 'g'), '0'), 10);\n\n      if (hour > 12) {\n        hour -= 12;\n      } else if (hour === 0) {\n        hour = 12;\n      }\n\n      return hour;\n    }\n\n    getPartValue(datePartInfo, partLength) {\n      let maskedValue;\n      const datePart = datePartInfo.type;\n\n      switch (datePart) {\n        case DatePart.Date:\n          maskedValue = this.dateValue.getDate();\n          break;\n\n        case DatePart.Month:\n          // months are zero based\n          maskedValue = this.dateValue.getMonth() + 1;\n          break;\n\n        case DatePart.Year:\n          if (partLength === 2) {\n            maskedValue = this.prependValue(parseInt(this.dateValue.getFullYear().toString().slice(-2), 10), partLength, '0');\n          } else {\n            maskedValue = this.dateValue.getFullYear();\n          }\n\n          break;\n\n        case DatePart.Hours:\n          if (datePartInfo.format.indexOf('h') !== -1) {\n            maskedValue = this.prependValue(this.toTwelveHourFormat(this.dateValue.getHours().toString()), partLength, '0');\n          } else {\n            maskedValue = this.dateValue.getHours();\n          }\n\n          break;\n\n        case DatePart.Minutes:\n          maskedValue = this.dateValue.getMinutes();\n          break;\n\n        case DatePart.Seconds:\n          maskedValue = this.dateValue.getSeconds();\n          break;\n\n        case DatePart.AmPm:\n          maskedValue = this.dateValue.getHours() >= 12 ? 'PM' : 'AM';\n          break;\n      }\n\n      if (datePartInfo.type !== DatePart.AmPm) {\n        return this.prependValue(maskedValue, partLength, '0');\n      }\n\n      return maskedValue;\n    }\n\n    prependValue(value, partLength, prependChar) {\n      return (prependChar + value.toString()).slice(-partLength);\n    }\n\n    spin(event) {\n      event.preventDefault();\n\n      switch (event.key) {\n        case this.platform.KEYMAP.ARROW_UP:\n          this.increment();\n          break;\n\n        case this.platform.KEYMAP.ARROW_DOWN:\n          this.decrement();\n          break;\n      }\n    }\n\n    inputIsComplete() {\n      return this.inputValue.indexOf(this.promptChar) === -1;\n    }\n\n    moveCursor(event) {\n      const value = event.target.value;\n\n      switch (event.key) {\n        case this.platform.KEYMAP.ARROW_LEFT:\n          if (event.ctrlKey) {\n            event.preventDefault();\n            this.setSelectionRange(this.getNewPosition(value));\n          }\n\n          break;\n\n        case this.platform.KEYMAP.ARROW_RIGHT:\n          if (event.ctrlKey) {\n            event.preventDefault();\n            this.setSelectionRange(this.getNewPosition(value, 1));\n          }\n\n          break;\n      }\n    }\n    /**\n     * Move the cursor in a specific direction until it reaches a date/time separator.\n     * Then return its index.\n     *\n     * @param value The string it operates on.\n     * @param direction 0 is left, 1 is right. Default is 0.\n     */\n\n\n    getNewPosition(value, direction = 0) {\n      const literals = this._inputDateParts.filter(p => p.type === DatePart.Literal);\n\n      let cursorPos = this.selectionStart;\n\n      if (!direction) {\n        do {\n          cursorPos = cursorPos > 0 ? --cursorPos : cursorPos;\n        } while (!literals.some(l => l.end === cursorPos) && cursorPos > 0);\n\n        return cursorPos;\n      } else {\n        do {\n          cursorPos++;\n        } while (!literals.some(l => l.start === cursorPos) && cursorPos < value.length);\n\n        return cursorPos;\n      }\n    }\n\n  }\n\n  IgxDateTimeEditorDirective.ɵfac = function IgxDateTimeEditorDirective_Factory(t) {\n    return new (t || IgxDateTimeEditorDirective)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(MaskParsingService), i0.ɵɵdirectiveInject(PlatformUtil), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(LOCALE_ID));\n  };\n\n  IgxDateTimeEditorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxDateTimeEditorDirective,\n    selectors: [[\"\", \"igxDateTimeEditor\", \"\"]],\n    hostBindings: function IgxDateTimeEditorDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"wheel\", function IgxDateTimeEditorDirective_wheel_HostBindingHandler($event) {\n          return ctx.onWheel($event);\n        });\n      }\n    },\n    inputs: {\n      locale: \"locale\",\n      minValue: \"minValue\",\n      maxValue: \"maxValue\",\n      spinLoop: \"spinLoop\",\n      displayFormat: \"displayFormat\",\n      inputFormat: [\"igxDateTimeEditor\", \"inputFormat\"],\n      value: \"value\",\n      spinDelta: \"spinDelta\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      validationFailed: \"validationFailed\"\n    },\n    exportAs: [\"igxDateTimeEditor\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: IgxDateTimeEditorDirective,\n      multi: true\n    }, {\n      provide: NG_VALIDATORS,\n      useExisting: IgxDateTimeEditorDirective,\n      multi: true\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  });\n  return IgxDateTimeEditorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxDateTimeEditorModule = /*#__PURE__*/(() => {\n  class IgxDateTimeEditorModule {}\n\n  IgxDateTimeEditorModule.ɵfac = function IgxDateTimeEditorModule_Factory(t) {\n    return new (t || IgxDateTimeEditorModule)();\n  };\n\n  IgxDateTimeEditorModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxDateTimeEditorModule\n  });\n  IgxDateTimeEditorModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return IgxDateTimeEditorModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Provides base filtering operations\n * Implementations should be Singleton\n *\n * @export\n */\n\n\nlet IgxFilteringOperand = /*#__PURE__*/(() => {\n  class IgxFilteringOperand {\n    constructor() {\n      this.operations = [{\n        name: 'null',\n        isUnary: true,\n        iconName: 'is-null',\n        logic: target => target === null\n      }, {\n        name: 'notNull',\n        isUnary: true,\n        iconName: 'is-not-null',\n        logic: target => target !== null\n      }, {\n        name: 'in',\n        isUnary: false,\n        iconName: 'is-in',\n        hidden: true,\n        logic: (target, searchVal) => this.findValueInSet(target, searchVal)\n      }];\n    }\n\n    static instance() {\n      return this._instance || (this._instance = new this());\n    }\n    /**\n     * Returns an array of names of the conditions which are visible in the UI\n     */\n\n\n    conditionList() {\n      return this.operations.filter(f => !f.hidden).map(element => element.name);\n    }\n    /**\n     * Returns an instance of the condition with the specified name.\n     *\n     * @param name The name of the condition.\n     */\n\n\n    condition(name) {\n      return this.operations.find(element => element.name === name);\n    }\n    /**\n     * Adds a new condition to the filtering operations.\n     *\n     * @param operation The filtering operation.\n     */\n\n\n    append(operation) {\n      this.operations.push(operation);\n    }\n    /**\n     * @hidden\n     */\n\n\n    findValueInSet(target, searchVal) {\n      return searchVal.has(target);\n    }\n\n  }\n\n  IgxFilteringOperand._instance = null;\n  /**\n   * Provides filtering operations for booleans\n   *\n   * @export\n   */\n\n  return IgxFilteringOperand;\n})();\n\nclass IgxBooleanFilteringOperand extends IgxFilteringOperand {\n  constructor() {\n    super();\n    this.operations = [{\n      name: 'all',\n      isUnary: true,\n      iconName: 'select-all',\n      logic: target => true\n    }, {\n      name: 'true',\n      isUnary: true,\n      iconName: 'is-true',\n      logic: target => !!(target && target !== null && target !== undefined)\n    }, {\n      name: 'false',\n      isUnary: true,\n      iconName: 'is-false',\n      logic: target => !target && target !== null && target !== undefined\n    }, {\n      name: 'empty',\n      isUnary: true,\n      iconName: 'is-empty',\n      logic: target => target === null || target === undefined\n    }, {\n      name: 'notEmpty',\n      isUnary: true,\n      iconName: 'not-empty',\n      logic: target => target !== null && target !== undefined\n    }].concat(this.operations);\n  }\n\n}\n/**\n * @internal\n * @hidden\n */\n\n\nclass IgxBaseDateTimeFilteringOperand extends IgxFilteringOperand {\n  constructor() {\n    super();\n    this.operations = [{\n      name: 'empty',\n      isUnary: true,\n      iconName: 'is-empty',\n      logic: target => target === null || target === undefined\n    }, {\n      name: 'notEmpty',\n      isUnary: true,\n      iconName: 'not-empty',\n      logic: target => target !== null && target !== undefined\n    }].concat(this.operations);\n  }\n  /**\n   * Splits a Date object into parts\n   *\n   * @memberof IgxDateFilteringOperand\n   */\n\n\n  static getDateParts(date, dateFormat) {\n    const res = {\n      day: null,\n      hours: null,\n      milliseconds: null,\n      minutes: null,\n      month: null,\n      seconds: null,\n      year: null\n    };\n\n    if (!date || !dateFormat) {\n      return res;\n    }\n\n    if (dateFormat.indexOf('y') >= 0) {\n      res.year = date.getFullYear();\n    }\n\n    if (dateFormat.indexOf('M') >= 0) {\n      res.month = date.getMonth();\n    }\n\n    if (dateFormat.indexOf('d') >= 0) {\n      res.day = date.getDate();\n    }\n\n    if (dateFormat.indexOf('h') >= 0) {\n      res.hours = date.getHours();\n    }\n\n    if (dateFormat.indexOf('m') >= 0) {\n      res.minutes = date.getMinutes();\n    }\n\n    if (dateFormat.indexOf('s') >= 0) {\n      res.seconds = date.getSeconds();\n    }\n\n    if (dateFormat.indexOf('f') >= 0) {\n      res.milliseconds = date.getMilliseconds();\n    }\n\n    return res;\n  }\n\n  findValueInSet(target, searchVal) {\n    if (!target) {\n      return false;\n    }\n\n    return searchVal.has(target instanceof Date ? target.toISOString() : target);\n  }\n\n  validateInputData(target) {\n    if (!(target instanceof Date)) {\n      throw new Error('Could not perform filtering on \\'date\\' column because the datasource object type is not \\'Date\\'.');\n    }\n  }\n\n}\n/**\n * Provides filtering operations for Dates\n *\n * @export\n */\n\n\nclass IgxDateFilteringOperand extends IgxBaseDateTimeFilteringOperand {\n  constructor() {\n    super();\n    this.operations = [{\n      name: 'equals',\n      isUnary: false,\n      iconName: 'equals',\n      logic: (target, searchVal) => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const targetp = IgxDateFilteringOperand.getDateParts(target, 'yMd');\n        const searchp = IgxDateFilteringOperand.getDateParts(searchVal, 'yMd');\n        return targetp.year === searchp.year && targetp.month === searchp.month && targetp.day === searchp.day;\n      }\n    }, {\n      name: 'doesNotEqual',\n      isUnary: false,\n      iconName: 'not-equal',\n      logic: (target, searchVal) => {\n        if (!target) {\n          return true;\n        }\n\n        this.validateInputData(target);\n        const targetp = IgxDateFilteringOperand.getDateParts(target, 'yMd');\n        const searchp = IgxDateFilteringOperand.getDateParts(searchVal, 'yMd');\n        return targetp.year !== searchp.year || targetp.month !== searchp.month || targetp.day !== searchp.day;\n      }\n    }, {\n      name: 'before',\n      isUnary: false,\n      iconName: 'is-before',\n      logic: (target, searchVal) => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        return target < searchVal;\n      }\n    }, {\n      name: 'after',\n      isUnary: false,\n      iconName: 'is-after',\n      logic: (target, searchVal) => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        return target > searchVal;\n      }\n    }, {\n      name: 'today',\n      isUnary: true,\n      iconName: 'today',\n      logic: target => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const d = IgxDateFilteringOperand.getDateParts(target, 'yMd');\n        const now = IgxDateFilteringOperand.getDateParts(new Date(), 'yMd');\n        return d.year === now.year && d.month === now.month && d.day === now.day;\n      }\n    }, {\n      name: 'yesterday',\n      isUnary: true,\n      iconName: 'yesterday',\n      logic: target => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const td = IgxDateFilteringOperand.getDateParts(target, 'yMd');\n\n        const y = (d => new Date(d.setDate(d.getDate() - 1)))(new Date());\n\n        const yesterday = IgxDateFilteringOperand.getDateParts(y, 'yMd');\n        return td.year === yesterday.year && td.month === yesterday.month && td.day === yesterday.day;\n      }\n    }, {\n      name: 'thisMonth',\n      isUnary: true,\n      iconName: 'this-month',\n      logic: target => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const d = IgxDateFilteringOperand.getDateParts(target, 'yM');\n        const now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');\n        return d.year === now.year && d.month === now.month;\n      }\n    }, {\n      name: 'lastMonth',\n      isUnary: true,\n      iconName: 'last-month',\n      logic: target => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const d = IgxDateFilteringOperand.getDateParts(target, 'yM');\n        const now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');\n\n        if (!now.month) {\n          now.month = 11;\n          now.year -= 1;\n        } else {\n          now.month--;\n        }\n\n        return d.year === now.year && d.month === now.month;\n      }\n    }, {\n      name: 'nextMonth',\n      isUnary: true,\n      iconName: 'next-month',\n      logic: target => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const d = IgxDateFilteringOperand.getDateParts(target, 'yM');\n        const now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');\n\n        if (now.month === 11) {\n          now.month = 0;\n          now.year += 1;\n        } else {\n          now.month++;\n        }\n\n        return d.year === now.year && d.month === now.month;\n      }\n    }, {\n      name: 'thisYear',\n      isUnary: true,\n      iconName: 'this-year',\n      logic: target => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const d = IgxDateFilteringOperand.getDateParts(target, 'y');\n        const now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');\n        return d.year === now.year;\n      }\n    }, {\n      name: 'lastYear',\n      isUnary: true,\n      iconName: 'last-year',\n      logic: target => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const d = IgxDateFilteringOperand.getDateParts(target, 'y');\n        const now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');\n        return d.year === now.year - 1;\n      }\n    }, {\n      name: 'nextYear',\n      isUnary: true,\n      iconName: 'next-year',\n      logic: target => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const d = IgxDateFilteringOperand.getDateParts(target, 'y');\n        const now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');\n        return d.year === now.year + 1;\n      }\n    }].concat(this.operations);\n  }\n\n}\n\nclass IgxDateTimeFilteringOperand extends IgxBaseDateTimeFilteringOperand {\n  constructor() {\n    super();\n    this.operations = [{\n      name: 'equals',\n      isUnary: false,\n      iconName: 'equals',\n      logic: (target, searchVal) => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const targetp = IgxDateTimeFilteringOperand.getDateParts(target, 'yMdhms');\n        const searchp = IgxDateTimeFilteringOperand.getDateParts(searchVal, 'yMdhms');\n        return targetp.year === searchp.year && targetp.month === searchp.month && targetp.day === searchp.day && targetp.hours === searchp.hours && targetp.minutes === searchp.minutes && targetp.seconds === searchp.seconds;\n      }\n    }, {\n      name: 'doesNotEqual',\n      isUnary: false,\n      iconName: 'not-equal',\n      logic: (target, searchVal) => {\n        if (!target) {\n          return true;\n        }\n\n        this.validateInputData(target);\n        const targetp = IgxDateTimeFilteringOperand.getDateParts(target, 'yMdhms');\n        const searchp = IgxDateTimeFilteringOperand.getDateParts(searchVal, 'yMdhms');\n        return targetp.year !== searchp.year || targetp.month !== searchp.month || targetp.day !== searchp.day || targetp.hours !== searchp.hours || targetp.minutes !== searchp.minutes || targetp.seconds !== searchp.seconds;\n      }\n    }, {\n      name: 'before',\n      isUnary: false,\n      iconName: 'is-before',\n      logic: (target, searchVal) => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        return target < searchVal;\n      }\n    }, {\n      name: 'after',\n      isUnary: false,\n      iconName: 'is-after',\n      logic: (target, searchVal) => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        return target > searchVal;\n      }\n    }, {\n      name: 'today',\n      isUnary: true,\n      iconName: 'today',\n      logic: target => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const d = IgxDateTimeFilteringOperand.getDateParts(target, 'yMd');\n        const now = IgxDateTimeFilteringOperand.getDateParts(new Date(), 'yMd');\n        return d.year === now.year && d.month === now.month && d.day === now.day;\n      }\n    }, {\n      name: 'yesterday',\n      isUnary: true,\n      iconName: 'yesterday',\n      logic: target => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const td = IgxDateTimeFilteringOperand.getDateParts(target, 'yMd');\n\n        const y = (d => new Date(d.setDate(d.getDate() - 1)))(new Date());\n\n        const yesterday = IgxDateTimeFilteringOperand.getDateParts(y, 'yMd');\n        return td.year === yesterday.year && td.month === yesterday.month && td.day === yesterday.day;\n      }\n    }, {\n      name: 'thisMonth',\n      isUnary: true,\n      iconName: 'this-month',\n      logic: target => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const d = IgxDateTimeFilteringOperand.getDateParts(target, 'yM');\n        const now = IgxDateTimeFilteringOperand.getDateParts(new Date(), 'yM');\n        return d.year === now.year && d.month === now.month;\n      }\n    }, {\n      name: 'lastMonth',\n      isUnary: true,\n      iconName: 'last-month',\n      logic: target => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const d = IgxDateTimeFilteringOperand.getDateParts(target, 'yM');\n        const now = IgxDateTimeFilteringOperand.getDateParts(new Date(), 'yM');\n\n        if (!now.month) {\n          now.month = 11;\n          now.year -= 1;\n        } else {\n          now.month--;\n        }\n\n        return d.year === now.year && d.month === now.month;\n      }\n    }, {\n      name: 'nextMonth',\n      isUnary: true,\n      iconName: 'next-month',\n      logic: target => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const d = IgxDateTimeFilteringOperand.getDateParts(target, 'yM');\n        const now = IgxDateTimeFilteringOperand.getDateParts(new Date(), 'yM');\n\n        if (now.month === 11) {\n          now.month = 0;\n          now.year += 1;\n        } else {\n          now.month++;\n        }\n\n        return d.year === now.year && d.month === now.month;\n      }\n    }, {\n      name: 'thisYear',\n      isUnary: true,\n      iconName: 'this-year',\n      logic: target => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const d = IgxDateTimeFilteringOperand.getDateParts(target, 'y');\n        const now = IgxDateTimeFilteringOperand.getDateParts(new Date(), 'y');\n        return d.year === now.year;\n      }\n    }, {\n      name: 'lastYear',\n      isUnary: true,\n      iconName: 'last-year',\n      logic: target => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const d = IgxDateTimeFilteringOperand.getDateParts(target, 'y');\n        const now = IgxDateTimeFilteringOperand.getDateParts(new Date(), 'y');\n        return d.year === now.year - 1;\n      }\n    }, {\n      name: 'nextYear',\n      isUnary: true,\n      iconName: 'next-year',\n      logic: target => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const d = IgxDateTimeFilteringOperand.getDateParts(target, 'y');\n        const now = IgxDateTimeFilteringOperand.getDateParts(new Date(), 'y');\n        return d.year === now.year + 1;\n      }\n    }].concat(this.operations);\n  }\n\n}\n\nclass IgxTimeFilteringOperand extends IgxBaseDateTimeFilteringOperand {\n  constructor() {\n    super();\n    this.operations = [{\n      name: 'at',\n      isUnary: false,\n      iconName: 'equals',\n      logic: (target, searchVal) => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const targetp = IgxTimeFilteringOperand.getDateParts(target, 'hms');\n        const searchp = IgxTimeFilteringOperand.getDateParts(searchVal, 'hms');\n        return targetp.hours === searchp.hours && targetp.minutes === searchp.minutes && targetp.seconds === searchp.seconds;\n      }\n    }, {\n      name: 'not_at',\n      isUnary: false,\n      iconName: 'not-equal',\n      logic: (target, searchVal) => {\n        if (!target) {\n          return true;\n        }\n\n        this.validateInputData(target);\n        const targetp = IgxTimeFilteringOperand.getDateParts(target, 'hms');\n        const searchp = IgxTimeFilteringOperand.getDateParts(searchVal, 'hms');\n        return targetp.hours !== searchp.hours || targetp.minutes !== searchp.minutes || targetp.seconds !== searchp.seconds;\n      }\n    }, {\n      name: 'before',\n      isUnary: false,\n      iconName: 'is-before',\n      logic: (target, searchVal) => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const targetn = IgxTimeFilteringOperand.getDateParts(target, 'hms');\n        const search = IgxTimeFilteringOperand.getDateParts(searchVal, 'hms');\n        return targetn.hours < search.hours ? true : targetn.hours === search.hours && targetn.minutes < search.minutes ? true : targetn.hours === search.hours && targetn.minutes === search.minutes && targetn.seconds < search.seconds;\n      }\n    }, {\n      name: 'after',\n      isUnary: false,\n      iconName: 'is-after',\n      logic: (target, searchVal) => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const targetn = IgxTimeFilteringOperand.getDateParts(target, 'hms');\n        const search = IgxTimeFilteringOperand.getDateParts(searchVal, 'hms');\n        return targetn.hours > search.hours ? true : targetn.hours === search.hours && targetn.minutes > search.minutes ? true : targetn.hours === search.hours && targetn.minutes === search.minutes && targetn.seconds > search.seconds;\n      }\n    }, {\n      name: 'at_before',\n      isUnary: false,\n      iconName: 'is-before',\n      logic: (target, searchVal) => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const targetn = IgxTimeFilteringOperand.getDateParts(target, 'hms');\n        const search = IgxTimeFilteringOperand.getDateParts(searchVal, 'hms');\n        return targetn.hours === search.hours && targetn.minutes === search.minutes && targetn.seconds === search.seconds || targetn.hours < search.hours ? true : targetn.hours === search.hours && targetn.minutes < search.minutes ? true : targetn.hours === search.hours && targetn.minutes === search.minutes && targetn.seconds < search.seconds;\n      }\n    }, {\n      name: 'at_after',\n      isUnary: false,\n      iconName: 'is-after',\n      logic: (target, searchVal) => {\n        if (!target) {\n          return false;\n        }\n\n        this.validateInputData(target);\n        const targetn = IgxTimeFilteringOperand.getDateParts(target, 'hms');\n        const search = IgxTimeFilteringOperand.getDateParts(searchVal, 'hms');\n        return targetn.hours === search.hours && targetn.minutes === search.minutes && targetn.seconds === search.seconds || targetn.hours > search.hours ? true : targetn.hours === search.hours && targetn.minutes > search.minutes ? true : targetn.hours === search.hours && targetn.minutes === search.minutes && targetn.seconds > search.seconds;\n      }\n    }].concat(this.operations);\n  }\n\n  findValueInSet(target, searchVal) {\n    if (!target) {\n      return false;\n    }\n\n    return searchVal.has(target.toLocaleTimeString());\n  }\n\n}\n/**\n * Provides filtering operations for numbers\n *\n * @export\n */\n\n\nclass IgxNumberFilteringOperand extends IgxFilteringOperand {\n  constructor() {\n    super();\n    this.operations = [{\n      name: 'equals',\n      isUnary: false,\n      iconName: 'equals',\n      logic: (target, searchVal) => target === searchVal\n    }, {\n      name: 'doesNotEqual',\n      isUnary: false,\n      iconName: 'not-equal',\n      logic: (target, searchVal) => target !== searchVal\n    }, {\n      name: 'greaterThan',\n      isUnary: false,\n      iconName: 'greater-than',\n      logic: (target, searchVal) => target > searchVal\n    }, {\n      name: 'lessThan',\n      isUnary: false,\n      iconName: 'less-than',\n      logic: (target, searchVal) => target < searchVal\n    }, {\n      name: 'greaterThanOrEqualTo',\n      isUnary: false,\n      iconName: 'greater-than-or-equal',\n      logic: (target, searchVal) => target >= searchVal\n    }, {\n      name: 'lessThanOrEqualTo',\n      isUnary: false,\n      iconName: 'less-than-or-equal',\n      logic: (target, searchVal) => target <= searchVal\n    }, {\n      name: 'empty',\n      isUnary: true,\n      iconName: 'is-empty',\n      logic: target => target === null || target === undefined || isNaN(target)\n    }, {\n      name: 'notEmpty',\n      isUnary: true,\n      iconName: 'not-empty',\n      logic: target => target !== null && target !== undefined && !isNaN(target)\n    }].concat(this.operations);\n  }\n\n}\n/**\n * Provides filtering operations for strings\n *\n * @export\n */\n\n\nclass IgxStringFilteringOperand extends IgxFilteringOperand {\n  constructor() {\n    super();\n    this.operations = [{\n      name: 'contains',\n      isUnary: false,\n      iconName: 'contains',\n      logic: (target, searchVal, ignoreCase) => {\n        const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);\n        target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);\n        return target.indexOf(search) !== -1;\n      }\n    }, {\n      name: 'doesNotContain',\n      isUnary: false,\n      iconName: 'does-not-contain',\n      logic: (target, searchVal, ignoreCase) => {\n        const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);\n        target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);\n        return target.indexOf(search) === -1;\n      }\n    }, {\n      name: 'startsWith',\n      isUnary: false,\n      iconName: 'starts-with',\n      logic: (target, searchVal, ignoreCase) => {\n        const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);\n        target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);\n        return target.startsWith(search);\n      }\n    }, {\n      name: 'endsWith',\n      isUnary: false,\n      iconName: 'ends-with',\n      logic: (target, searchVal, ignoreCase) => {\n        const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);\n        target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);\n        return target.endsWith(search);\n      }\n    }, {\n      name: 'equals',\n      isUnary: false,\n      iconName: 'equals',\n      logic: (target, searchVal, ignoreCase) => {\n        const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);\n        target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);\n        return target === search;\n      }\n    }, {\n      name: 'doesNotEqual',\n      isUnary: false,\n      iconName: 'not-equal',\n      logic: (target, searchVal, ignoreCase) => {\n        const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);\n        target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);\n        return target !== search;\n      }\n    }, {\n      name: 'empty',\n      isUnary: true,\n      iconName: 'is-empty',\n      logic: target => target === null || target === undefined || target.length === 0\n    }, {\n      name: 'notEmpty',\n      isUnary: true,\n      iconName: 'not-empty',\n      logic: target => target !== null && target !== undefined && target.length > 0\n    }].concat(this.operations);\n  }\n  /**\n   * Applies case sensitivity on strings if provided\n   *\n   * @memberof IgxStringFilteringOperand\n   */\n\n\n  static applyIgnoreCase(a, ignoreCase) {\n    a = a !== null && a !== void 0 ? a : ''; // bulletproof\n\n    return ignoreCase ? ('' + a).toLowerCase() : a;\n  }\n\n}\n\nconst filteringStateDefaults = {\n  strategy: new FilteringStrategy()\n};\n\nconst clear = el => el === 0 || Boolean(el);\n\nconst first = arr => arr[0];\n\nconst last = arr => arr[arr.length - 1];\n\nclass IgxSummaryOperand {\n  /**\n   * Counts all the records in the data source.\n   * If filtering is applied, counts only the filtered records.\n   * ```typescript\n   * IgxSummaryOperand.count(dataSource);\n   * ```\n   *\n   * @memberof IgxSummaryOperand\n   */\n  static count(data) {\n    return data.length;\n  }\n  /**\n   * Executes the static `count` method and returns `IgxSummaryResult[]`.\n   * ```typescript\n   * interface IgxSummaryResult {\n   *   key: string;\n   *   label: string;\n   *   summaryResult: any;\n   * }\n   * ```\n   * Can be overridden in the inherited classes to provide customization for the `summary`.\n   * ```typescript\n   * class CustomSummary extends IgxSummaryOperand {\n   *   constructor() {\n   *     super();\n   *   }\n   *   public operate(data: any[], allData: any[], fieldName: string): IgxSummaryResult[] {\n   *     const result = [];\n   *     result.push({\n   *       key: \"test\",\n   *       label: \"Test\",\n   *       summaryResult: IgxSummaryOperand.count(data)\n   *     });\n   *     return result;\n   *   }\n   * }\n   * this.grid.getColumnByName('ColumnName').summaries = CustomSummary;\n   * ```\n   *\n   * @memberof IgxSummaryOperand\n   */\n\n\n  operate(data = [], allData = [], fieldName) {\n    return [{\n      key: 'count',\n      label: 'Count',\n      defaultFormatting: false,\n      summaryResult: IgxSummaryOperand.count(data)\n    }];\n  }\n\n} // @dynamic\n\n\nclass IgxNumberSummaryOperand extends IgxSummaryOperand {\n  /**\n   * Returns the minimum numeric value in the provided data records.\n   * If filtering is applied, returns the minimum value in the filtered data records.\n   * ```typescript\n   * IgxNumberSummaryOperand.min(data);\n   * ```\n   *\n   * @memberof IgxNumberSummaryOperand\n   */\n  static min(data) {\n    return data.length && data.filter(clear).length ? data.filter(clear).reduce((a, b) => Math.min(a, b)) : 0;\n  }\n  /**\n   * Returns the maximum numeric value in the provided data records.\n   * If filtering is applied, returns the maximum value in the filtered data records.\n   * ```typescript\n   * IgxNumberSummaryOperand.max(data);\n   * ```\n   *\n   * @memberof IgxNumberSummaryOperand\n   */\n\n\n  static max(data) {\n    return data.length && data.filter(clear).length ? data.filter(clear).reduce((a, b) => Math.max(a, b)) : 0;\n  }\n  /**\n   * Returns the sum of the numeric values in the provided data records.\n   * If filtering is applied, returns the sum of the numeric values in the data records.\n   * ```typescript\n   * IgxNumberSummaryOperand.sum(data);\n   * ```\n   *\n   * @memberof IgxNumberSummaryOperand\n   */\n\n\n  static sum(data) {\n    return data.length && data.filter(clear).length ? data.filter(clear).reduce((a, b) => +a + +b) : 0;\n  }\n  /**\n   * Returns the average numeric value in the data provided data records.\n   * If filtering is applied, returns the average numeric value in the filtered data records.\n   * ```typescript\n   * IgxSummaryOperand.average(data);\n   * ```\n   *\n   * @memberof IgxNumberSummaryOperand\n   */\n\n\n  static average(data) {\n    return data.length && data.filter(clear).length ? this.sum(data) / this.count(data) : 0;\n  }\n  /**\n   * Executes the static methods and returns `IgxSummaryResult[]`.\n   * ```typescript\n   * interface IgxSummaryResult {\n   *   key: string;\n   *   label: string;\n   *   summaryResult: any;\n   * }\n   * ```\n   * Can be overridden in the inherited classes to provide customization for the `summary`.\n   * ```typescript\n   * class CustomNumberSummary extends IgxNumberSummaryOperand {\n   *   constructor() {\n   *     super();\n   *   }\n   *   public operate(data: any[], allData: any[], fieldName: string): IgxSummaryResult[] {\n   *     const result = super.operate(data, allData, fieldName);\n   *     result.push({\n   *       key: \"avg\",\n   *       label: \"Avg\",\n   *       summaryResult: IgxNumberSummaryOperand.average(data)\n   *     });\n   *     result.push({\n   *       key: 'mdn',\n   *       label: 'Median',\n   *       summaryResult: this.findMedian(data)\n   *     });\n   *     return result;\n   *   }\n   * }\n   * this.grid.getColumnByName('ColumnName').summaries = CustomNumberSummary;\n   * ```\n   *\n   * @memberof IgxNumberSummaryOperand\n   */\n\n\n  operate(data = [], allData = [], fieldName) {\n    const result = super.operate(data, allData, fieldName);\n    result.push({\n      key: 'min',\n      label: 'Min',\n      defaultFormatting: true,\n      summaryResult: IgxNumberSummaryOperand.min(data)\n    });\n    result.push({\n      key: 'max',\n      label: 'Max',\n      defaultFormatting: true,\n      summaryResult: IgxNumberSummaryOperand.max(data)\n    });\n    result.push({\n      key: 'sum',\n      label: 'Sum',\n      defaultFormatting: true,\n      summaryResult: IgxNumberSummaryOperand.sum(data)\n    });\n    result.push({\n      key: 'average',\n      label: 'Avg',\n      defaultFormatting: true,\n      summaryResult: IgxNumberSummaryOperand.average(data)\n    });\n    return result;\n  }\n\n} // @dynamic\n\n\nclass IgxDateSummaryOperand extends IgxSummaryOperand {\n  /**\n   * Returns the latest date value in the data records.\n   * If filtering is applied, returns the latest date value in the filtered data records.\n   * ```typescript\n   * IgxDateSummaryOperand.latest(data);\n   * ```\n   *\n   * @memberof IgxDateSummaryOperand\n   */\n  static latest(data) {\n    return data.length && data.filter(clear).length ? first(data.filter(clear).sort((a, b) => new Date(b).valueOf() - new Date(a).valueOf())) : undefined;\n  }\n  /**\n   * Returns the earliest date value in the data records.\n   * If filtering is applied, returns the latest date value in the filtered data records.\n   * ```typescript\n   * IgxDateSummaryOperand.earliest(data);\n   * ```\n   *\n   * @memberof IgxDateSummaryOperand\n   */\n\n\n  static earliest(data) {\n    return data.length && data.filter(clear).length ? last(data.filter(clear).sort((a, b) => new Date(b).valueOf() - new Date(a).valueOf())) : undefined;\n  }\n  /**\n   * Executes the static methods and returns `IgxSummaryResult[]`.\n   * ```typescript\n   * interface IgxSummaryResult {\n   *   key: string;\n   *   label: string;\n   *   summaryResult: any;\n   * }\n   * ```\n   * Can be overridden in the inherited classes to provide customization for the `summary`.\n   * ```typescript\n   * class CustomDateSummary extends IgxDateSummaryOperand {\n   *   constructor() {\n   *     super();\n   *   }\n   *   public operate(data: any[], allData: any[], fieldName: string): IgxSummaryResult[] {\n   *     const result = super.operate(data, allData, fieldName);\n   *     result.push({\n   *       key: \"deadline\",\n   *       label: \"Deadline Date\",\n   *       summaryResult: this.calculateDeadline(data);\n   *     });\n   *     return result;\n   *   }\n   * }\n   * this.grid.getColumnByName('ColumnName').summaries = CustomDateSummary;\n   * ```\n   *\n   * @memberof IgxDateSummaryOperand\n   */\n\n\n  operate(data = [], allData = [], fieldName) {\n    const result = super.operate(data, allData, fieldName);\n    result.push({\n      key: 'earliest',\n      label: 'Earliest',\n      defaultFormatting: true,\n      summaryResult: IgxDateSummaryOperand.earliest(data)\n    });\n    result.push({\n      key: 'latest',\n      label: 'Latest',\n      defaultFormatting: true,\n      summaryResult: IgxDateSummaryOperand.latest(data)\n    });\n    return result;\n  }\n\n} // @dynamic\n\n\nclass IgxTimeSummaryOperand extends IgxSummaryOperand {\n  /**\n   * Returns the latest time value in the data records. Compare only the time part of the date.\n   * If filtering is applied, returns the latest time value in the filtered data records.\n   * ```typescript\n   * IgxTimeSummaryOperand.latestTime(data);\n   * ```\n   *\n   * @memberof IgxTimeSummaryOperand\n   */\n  static latestTime(data) {\n    return data.length && data.filter(clear).length ? first(data.filter(clear).map(v => new Date(v)).sort((a, b) => new Date().setHours(b.getHours(), b.getMinutes(), b.getSeconds()) - new Date().setHours(a.getHours(), a.getMinutes(), a.getSeconds()))) : undefined;\n  }\n  /**\n   * Returns the earliest time value in the data records. Compare only the time part of the date.\n   * If filtering is applied, returns the earliest time value in the filtered data records.\n   * ```typescript\n   * IgxTimeSummaryOperand.earliestTime(data);\n   * ```\n   *\n   * @memberof IgxTimeSummaryOperand\n   */\n\n\n  static earliestTime(data) {\n    return data.length && data.filter(clear).length ? last(data.filter(clear).map(v => new Date(v)).sort((a, b) => new Date().setHours(b.getHours(), b.getMinutes(), b.getSeconds()) - new Date().setHours(a.getHours(), a.getMinutes(), a.getSeconds()))) : undefined;\n  }\n  /**\n   * @memberof IgxTimeSummaryOperand\n   */\n\n\n  operate(data = [], allData = [], fieldName) {\n    const result = super.operate(data, allData, fieldName);\n    result.push({\n      key: 'earliest',\n      label: 'Earliest',\n      defaultFormatting: true,\n      summaryResult: IgxTimeSummaryOperand.earliestTime(data)\n    });\n    result.push({\n      key: 'latest',\n      label: 'Latest',\n      defaultFormatting: true,\n      summaryResult: IgxTimeSummaryOperand.latestTime(data)\n    });\n    return result;\n  }\n\n}\n\nclass IgxPivotAggregate {\n  /**\n   * Gets/Sets the resource strings.\n   *\n   * @remarks\n   * By default it uses EN resources.\n   */\n  static set resourceStrings(value) {\n    this._resourceStrings = Object.assign({}, this._resourceStrings, value);\n  }\n\n  static get resourceStrings() {\n    return this._resourceStrings;\n  }\n  /**\n   * Gets array with default aggregator function for base aggregation.\n   * ```typescript\n   * IgxPivotAggregate.aggregators();\n   * ```\n   *\n   * @memberof IgxPivotAggregate\n   */\n\n\n  static aggregators() {\n    return [{\n      key: 'COUNT',\n      label: this.resourceStrings.igx_grid_pivot_aggregate_count,\n      aggregator: IgxPivotAggregate.count\n    }];\n  }\n  /**\n   * Counts all the records in the data source.\n   * If filtering is applied, counts only the filtered records.\n   * ```typescript\n   * IgxSummaryOperand.count(dataSource);\n   * ```\n   *\n   * @memberof IgxPivotAggregate\n   */\n\n\n  static count(members) {\n    return members.length;\n  }\n\n}\n\nIgxPivotAggregate._resourceStrings = CurrentResourceStrings.GridResStrings;\n\nclass IgxPivotNumericAggregate extends IgxPivotAggregate {\n  /**\n   * Gets array with default aggregator function for numeric aggregation.\n   * ```typescript\n   * IgxPivotAggregate.aggregators();\n   * ```\n   *\n   * @memberof IgxPivotAggregate\n   */\n  static aggregators() {\n    let result = [];\n    result = result.concat(super.aggregators());\n    result.push({\n      key: 'MIN',\n      label: this.resourceStrings.igx_grid_pivot_aggregate_min,\n      aggregator: IgxPivotNumericAggregate.min\n    });\n    result.push({\n      key: 'MAX',\n      label: this.resourceStrings.igx_grid_pivot_aggregate_max,\n      aggregator: IgxPivotNumericAggregate.max\n    });\n    result.push({\n      key: 'SUM',\n      label: this.resourceStrings.igx_grid_pivot_aggregate_sum,\n      aggregator: IgxPivotNumericAggregate.sum\n    });\n    result.push({\n      key: 'AVG',\n      label: this.resourceStrings.igx_grid_pivot_aggregate_avg,\n      aggregator: IgxPivotNumericAggregate.average\n    });\n    return result;\n  }\n  /**\n   * Returns the minimum numeric value in the provided data records.\n   * If filtering is applied, returns the minimum value in the filtered data records.\n   * ```typescript\n   * IgxPivotNumericAggregate.min(members, data);\n   * ```\n   *\n   * @memberof IgxPivotNumericAggregate\n   */\n\n\n  static min(members) {\n    return IgxNumberSummaryOperand.min(members);\n  }\n  /**\n   * Returns the maximum numeric value in the provided data records.\n   * If filtering is applied, returns the maximum value in the filtered data records.\n   * ```typescript\n   * IgxPivotNumericAggregate.max(data);\n   * ```\n   *\n   * @memberof IgxPivotNumericAggregate\n   */\n\n\n  static max(members) {\n    return IgxNumberSummaryOperand.max(members);\n  }\n  /**\n   * Returns the sum of the numeric values in the provided data records.\n   * If filtering is applied, returns the sum of the numeric values in the data records.\n   * ```typescript\n   * IgxPivotNumericAggregate.sum(data);\n   * ```\n   *\n   * @memberof IgxPivotNumericAggregate\n   */\n\n\n  static sum(members) {\n    return IgxNumberSummaryOperand.sum(members);\n  }\n  /**\n   * Returns the average numeric value in the data provided data records.\n   * If filtering is applied, returns the average numeric value in the filtered data records.\n   * ```typescript\n   * IgxPivotNumericAggregate.average(data);\n   * ```\n   *\n   * @memberof IgxPivotNumericAggregate\n   */\n\n\n  static average(members) {\n    return IgxNumberSummaryOperand.average(members);\n  }\n\n}\n\nclass IgxPivotDateAggregate extends IgxPivotAggregate {\n  /**\n   * Gets array with default aggregator function for date aggregation.\n   * ```typescript\n   * IgxPivotDateAggregate.aggregators();\n   * ```\n   *\n   * @memberof IgxPivotAggregate\n   */\n  static aggregators() {\n    let result = [];\n    result = result.concat(super.aggregators());\n    result.push({\n      key: 'LATEST',\n      label: this.resourceStrings.igx_grid_pivot_aggregate_date_latest,\n      aggregator: IgxPivotDateAggregate.latest\n    });\n    result.push({\n      key: 'EARLIEST',\n      label: this.resourceStrings.igx_grid_pivot_aggregate_date_earliest,\n      aggregator: IgxPivotDateAggregate.earliest\n    });\n    return result;\n  }\n  /**\n   * Returns the latest date value in the data records.\n   * If filtering is applied, returns the latest date value in the filtered data records.\n   * ```typescript\n   * IgxPivotDateAggregate.latest(data);\n   * ```\n   *\n   * @memberof IgxPivotDateAggregate\n   */\n\n\n  static latest(members) {\n    return IgxDateSummaryOperand.latest(members);\n  }\n  /**\n   * Returns the earliest date value in the data records.\n   * If filtering is applied, returns the latest date value in the filtered data records.\n   * ```typescript\n   * IgxPivotDateAggregate.earliest(data);\n   * ```\n   *\n   * @memberof IgxPivotDateAggregate\n   */\n\n\n  static earliest(members) {\n    return IgxDateSummaryOperand.earliest(members);\n  }\n\n}\n\nclass IgxPivotTimeAggregate extends IgxPivotAggregate {\n  /**\n   * Gets array with default aggregator function for time aggregation.\n   * ```typescript\n   * IgxPivotTimeAggregate.aggregators();\n   * ```\n   *\n   * @memberof IgxPivotAggregate\n   */\n  static aggregators() {\n    let result = [];\n    result = result.concat(super.aggregators());\n    result.push({\n      key: 'LATEST',\n      label: this.resourceStrings.igx_grid_pivot_aggregate_time_latest,\n      aggregator: IgxPivotTimeAggregate.latestTime\n    });\n    result.push({\n      key: 'EARLIEST',\n      label: this.resourceStrings.igx_grid_pivot_aggregate_time_earliest,\n      aggregator: IgxPivotTimeAggregate.earliestTime\n    });\n    return result;\n  }\n  /**\n   * Returns the latest time value in the data records. Compare only the time part of the date.\n   * If filtering is applied, returns the latest time value in the filtered data records.\n   * ```typescript\n   * IgxPivotTimeAggregate.latestTime(data);\n   * ```\n   *\n   * @memberof IgxPivotTimeAggregate\n   */\n\n\n  static latestTime(members) {\n    return IgxTimeSummaryOperand.latestTime(members);\n  }\n  /**\n   * Returns the earliest time value in the data records. Compare only the time part of the date.\n   * If filtering is applied, returns the earliest time value in the filtered data records.\n   * ```typescript\n   * IgxPivotTimeAggregate.earliestTime(data);\n   * ```\n   *\n   * @memberof IgxPivotTimeAggregate\n   */\n\n\n  static earliestTime(members) {\n    return IgxTimeSummaryOperand.earliestTime(members);\n  }\n\n}\n/**\n* Default pivot keys used for data processing in the pivot pipes.\n*/\n\n\nconst DEFAULT_PIVOT_KEYS = {\n  aggregations: 'aggregations',\n  records: 'records',\n  children: 'children',\n  level: 'level',\n  rowDimensionSeparator: '_',\n  columnDimensionSeparator: '-'\n};\n/** The dimension types - Row, Column or Filter. */\n\nvar PivotDimensionType = /*#__PURE__*/(() => {\n  (function (PivotDimensionType) {\n    PivotDimensionType[PivotDimensionType[\"Row\"] = 0] = \"Row\";\n    PivotDimensionType[PivotDimensionType[\"Column\"] = 1] = \"Column\";\n    PivotDimensionType[PivotDimensionType[\"Filter\"] = 2] = \"Filter\";\n  })(PivotDimensionType || (PivotDimensionType = {}));\n\n  return PivotDimensionType;\n})();\n\nclass PivotUtil {\n  // go through all children and apply new dimension groups as child\n  static processGroups(recs, dimension, pivotKeys) {\n    for (const rec of recs) {\n      // process existing children\n      if (rec.children && rec.children.size > 0) {\n        // process hierarchy in dept\n        rec.children.forEach((values, key) => {\n          this.processGroups(values, dimension, pivotKeys);\n        });\n      } // add children for current dimension\n\n\n      const hierarchyFields = PivotUtil.getFieldsHierarchy(rec.records, [dimension], PivotDimensionType.Row, pivotKeys);\n      const values = Array.from(hierarchyFields.values()).find(x => x.dimension.memberName === dimension.memberName);\n      const siblingData = PivotUtil.processHierarchy(hierarchyFields, pivotKeys, 0);\n      rec.children.set(dimension.memberName, siblingData);\n    }\n  }\n\n  static flattenGroups(data, dimension, expansionStates, defaultExpand, parent, parentRec) {\n    for (let i = 0; i < data.length; i++) {\n      const rec = data[i];\n      const field = dimension.memberName;\n\n      if (!field) {\n        continue;\n      }\n\n      let recordsData = rec.children.get(field);\n\n      if (!recordsData && parent) {\n        // check parent\n        recordsData = rec.children.get(parent.memberName);\n\n        if (recordsData) {\n          dimension = parent;\n        }\n      }\n\n      if (parentRec) {\n        parentRec.dimensionValues.forEach((value, key) => {\n          if (parent.memberName !== key) {\n            rec.dimensionValues.set(key, value);\n            const dim = parentRec.dimensions.find(x => x.memberName === key);\n            rec.dimensions.unshift(dim);\n          }\n        });\n      }\n\n      const expansionRowKey = PivotUtil.getRecordKey(rec, dimension);\n      const isExpanded = expansionStates.get(expansionRowKey) === undefined ? defaultExpand : expansionStates.get(expansionRowKey);\n      const shouldExpand = isExpanded || !dimension.childLevel || !rec.dimensionValues.get(dimension.memberName);\n\n      if (shouldExpand && recordsData) {\n        if (dimension.childLevel) {\n          this.flattenGroups(recordsData, dimension.childLevel, expansionStates, defaultExpand, dimension, rec);\n        } else {\n          // copy parent values and dims in child\n          recordsData.forEach(x => {\n            rec.dimensionValues.forEach((value, key) => {\n              if (dimension.memberName !== key) {\n                x.dimensionValues.set(key, value);\n                const dim = rec.dimensions.find(y => y.memberName === key);\n                x.dimensions.unshift(dim);\n              }\n            });\n          });\n        }\n\n        data.splice(i + 1, 0, ...recordsData);\n        i += recordsData.length;\n      }\n    }\n  }\n\n  static assignLevels(dims) {\n    for (const dim of dims) {\n      let currDim = dim;\n      let lvl = 0;\n\n      while (currDim.childLevel) {\n        currDim.level = lvl;\n        currDim = currDim.childLevel;\n        lvl++;\n      }\n\n      currDim.level = lvl;\n    }\n  }\n\n  static getFieldsHierarchy(data, dimensions, dimensionType, pivotKeys) {\n    const hierarchy = new Map();\n\n    for (const rec of data) {\n      const vals = dimensionType === PivotDimensionType.Column ? this.extractValuesForColumn(dimensions, rec, pivotKeys) : this.extractValuesForRow(dimensions, rec, pivotKeys);\n\n      for (const [key, val] of vals) {\n        // this should go in depth also vals.children\n        if (hierarchy.get(val.value) != null) {\n          this.applyHierarchyChildren(hierarchy, val, rec, pivotKeys);\n        } else {\n          hierarchy.set(val.value, cloneValue(val));\n          this.applyHierarchyChildren(hierarchy, val, rec, pivotKeys);\n        }\n      }\n    }\n\n    return hierarchy;\n  }\n\n  static sort(data, expressions, sorting = new IgxSorting()) {\n    data.forEach(rec => {\n      const children = rec.children;\n\n      if (children) {\n        children.forEach(x => {\n          this.sort(x, expressions, sorting);\n        });\n      }\n    });\n    return DataUtil.sort(data, expressions, sorting);\n  }\n\n  static extractValueFromDimension(dim, recData) {\n    return dim.memberFunction ? dim.memberFunction.call(null, recData) : recData[dim.memberName];\n  }\n\n  static getDimensionDepth(dim) {\n    let lvl = 0;\n\n    while (dim.childLevel) {\n      lvl++;\n      dim = dim.childLevel;\n    }\n\n    return lvl;\n  }\n\n  static extractValuesForRow(dims, recData, pivotKeys) {\n    const values = new Map();\n\n    for (const col of dims) {\n      if (recData[pivotKeys.level] && recData[pivotKeys.level] > 0) {\n        const childData = recData[pivotKeys.records];\n        return this.getFieldsHierarchy(childData, [col], PivotDimensionType.Row, pivotKeys);\n      }\n\n      const value = this.extractValueFromDimension(col, recData);\n      const objValue = {};\n      objValue['value'] = value;\n      objValue['dimension'] = col;\n\n      if (col.childLevel) {\n        const childValues = this.extractValuesForRow([col.childLevel], recData, pivotKeys);\n        objValue[pivotKeys.children] = childValues;\n      }\n\n      values.set(value, objValue);\n    }\n\n    return values;\n  }\n\n  static extractValuesForColumn(dims, recData, pivotKeys, path = []) {\n    const vals = new Map();\n    let lvlCollection = vals;\n    const flattenedDims = this.flatten(dims);\n\n    for (const col of flattenedDims) {\n      const value = this.extractValueFromDimension(col, recData);\n      path.push(value);\n      const newValue = path.join(pivotKeys.columnDimensionSeparator);\n      const newObj = {\n        value: newValue,\n        expandable: col.expandable,\n        children: null,\n        dimension: col\n      };\n\n      if (!newObj.children) {\n        newObj.children = new Map();\n      }\n\n      lvlCollection.set(newValue, newObj);\n      lvlCollection = newObj.children;\n    }\n\n    return vals;\n  }\n\n  static flatten(arr, lvl = 0) {\n    const newArr = arr.reduce((acc, item) => {\n      item.level = lvl;\n      acc.push(item);\n\n      if (item.childLevel) {\n        item.expandable = true;\n        acc = acc.concat(this.flatten([item.childLevel], lvl + 1));\n      }\n\n      return acc;\n    }, []);\n    return newArr;\n  }\n\n  static applyAggregations(rec, hierarchies, values, pivotKeys) {\n    if (hierarchies.size === 0) {\n      // no column groups\n      const aggregationResult = this.aggregate(rec.records, values);\n      this.applyAggregationRecordData(aggregationResult, undefined, rec, pivotKeys);\n      return;\n    }\n\n    hierarchies.forEach(hierarchy => {\n      const children = hierarchy[pivotKeys.children];\n\n      if (children && children.size > 0) {\n        this.applyAggregations(rec, children, values, pivotKeys);\n        const childRecords = this.collectRecords(children, pivotKeys);\n        hierarchy[pivotKeys.aggregations] = this.aggregate(childRecords, values);\n        this.applyAggregationRecordData(hierarchy[pivotKeys.aggregations], hierarchy.value, rec, pivotKeys);\n      } else if (hierarchy[pivotKeys.records]) {\n        hierarchy[pivotKeys.aggregations] = this.aggregate(hierarchy[pivotKeys.records], values);\n        this.applyAggregationRecordData(hierarchy[pivotKeys.aggregations], hierarchy.value, rec, pivotKeys);\n      }\n    });\n  }\n\n  static applyAggregationRecordData(aggregationData, groupName, rec, pivotKeys) {\n    const aggregationKeys = Object.keys(aggregationData);\n\n    if (aggregationKeys.length > 1) {\n      aggregationKeys.forEach(key => {\n        const aggregationKey = groupName ? groupName + pivotKeys.columnDimensionSeparator + key : key;\n        rec.aggregationValues.set(aggregationKey, aggregationData[key]);\n      });\n    } else if (aggregationKeys.length === 1) {\n      const aggregationKey = aggregationKeys[0];\n      rec.aggregationValues.set(groupName || aggregationKey, aggregationData[aggregationKey]);\n    }\n  }\n\n  static aggregate(records, values) {\n    const result = {};\n\n    for (const pivotValue of values) {\n      result[pivotValue.member] = pivotValue.aggregate.aggregator(records.map(r => r[pivotValue.member]), records);\n    }\n\n    return result;\n  }\n\n  static processHierarchy(hierarchies, pivotKeys, level = 0, rootData = false) {\n    const flatData = [];\n    hierarchies.forEach((h, key) => {\n      const field = h.dimension.memberName;\n      const rec = {\n        dimensionValues: new Map(),\n        aggregationValues: new Map(),\n        children: new Map(),\n        dimensions: [h.dimension]\n      };\n      rec.dimensionValues.set(field, key);\n\n      if (h[pivotKeys.records]) {\n        rec.records = this.getDirectLeafs(h[pivotKeys.records]);\n      }\n\n      rec.level = level;\n      flatData.push(rec);\n\n      if (h[pivotKeys.children] && h[pivotKeys.children].size > 0) {\n        const nestedData = this.processHierarchy(h[pivotKeys.children], pivotKeys, level + 1, rootData);\n        rec.records = this.getDirectLeafs(nestedData);\n        rec.children.set(field, nestedData);\n      }\n    });\n    return flatData;\n  }\n\n  static getDirectLeafs(records) {\n    let leafs = [];\n\n    for (const rec of records) {\n      if (rec.records) {\n        const data = rec.records.filter(x => !x.records && leafs.indexOf(x) === -1);\n        leafs = leafs.concat(data);\n      } else {\n        leafs.push(rec);\n      }\n    }\n\n    return leafs;\n  }\n\n  static getRecordKey(rec, currentDim) {\n    const parentFields = [];\n    const currentDimIndex = rec.dimensions.findIndex(x => x.memberName === currentDim.memberName) + 1;\n    const prevDims = rec.dimensions.slice(0, currentDimIndex);\n\n    for (const prev of prevDims) {\n      const prevValue = rec.dimensionValues.get(prev.memberName);\n      parentFields.push(prevValue);\n    }\n\n    return parentFields.join('-');\n  }\n\n  static buildExpressionTree(config) {\n    const allDimensions = (config.rows || []).concat(config.columns || []).concat(config.filters || []).filter(x => x !== null && x !== undefined);\n    const enabledDimensions = allDimensions.filter(x => x && x.enabled);\n    const expressionsTree = new FilteringExpressionsTree(FilteringLogic.And); // add expression trees from all filters\n\n    PivotUtil.flatten(enabledDimensions).forEach(x => {\n      if (x.filter && x.filter.filteringOperands) {\n        expressionsTree.filteringOperands.push(...x.filter.filteringOperands);\n      }\n    });\n    return expressionsTree;\n  }\n\n  static collectRecords(children, pivotKeys) {\n    let result = [];\n    children.forEach(value => result = result.concat(value[pivotKeys.records]));\n    return result;\n  }\n\n  static applyHierarchyChildren(hierarchy, val, rec, pivotKeys) {\n    const recordsKey = pivotKeys.records;\n    const childKey = pivotKeys.children;\n    const childCollection = val[childKey];\n    const hierarchyValue = hierarchy.get(val.value);\n\n    if (Array.isArray(hierarchyValue[childKey])) {\n      hierarchyValue[childKey] = new Map();\n    }\n\n    if (!childCollection || childCollection.size === 0) {\n      const dim = hierarchyValue.dimension;\n      const isValid = this.extractValueFromDimension(dim, rec) === val.value;\n\n      if (isValid) {\n        if (hierarchyValue[recordsKey]) {\n          hierarchyValue[recordsKey].push(rec);\n        } else {\n          hierarchyValue[recordsKey] = [rec];\n        }\n      }\n    } else {\n      const hierarchyChild = hierarchyValue[childKey];\n\n      for (const [key, child] of childCollection) {\n        let hierarchyChildValue = hierarchyChild.get(child.value);\n\n        if (!hierarchyChildValue) {\n          hierarchyChild.set(child.value, child);\n          hierarchyChildValue = child;\n        }\n\n        if (hierarchyChildValue[recordsKey]) {\n          const copy = Object.assign({}, rec);\n\n          if (rec[recordsKey]) {\n            // not all nested children are valid\n            const nestedValue = hierarchyChildValue.value;\n            const dimension = hierarchyChildValue.dimension;\n            const validRecs = rec[recordsKey].filter(x => this.extractValueFromDimension(dimension, x) === nestedValue);\n            copy[recordsKey] = validRecs;\n          }\n\n          hierarchyChildValue[recordsKey].push(copy);\n        } else {\n          hierarchyChildValue[recordsKey] = [rec];\n        }\n\n        if (child[childKey] && child[childKey].size > 0) {\n          this.applyHierarchyChildren(hierarchyChild, child, rec, pivotKeys);\n        }\n      }\n    }\n  }\n\n  static getAggregateList(val, grid) {\n    if (!val.aggregateList) {\n      let defaultAggr = this.getAggregatorsForValue(val, grid);\n      const isDefault = defaultAggr.find(x => x.key === val.aggregate.key); // resolve custom aggregations\n\n      if (!isDefault && grid.data[0][val.member] !== undefined) {\n        // if field exists, then we can apply default aggregations and add the custom one.\n        defaultAggr.unshift(val.aggregate);\n      } else if (!isDefault) {\n        // otherwise this is a custom aggregation that is not compatible\n        // with the defaults, since it operates on field that is not in the data\n        // leave only the custom one.\n        defaultAggr = [val.aggregate];\n      }\n\n      val.aggregateList = defaultAggr;\n    }\n\n    return val.aggregateList;\n  }\n\n  static getAggregatorsForValue(value, grid) {\n    const dataType = value.dataType || grid.resolveDataTypes(grid.data[0][value.member]);\n\n    switch (dataType) {\n      case GridColumnDataType.Number:\n      case GridColumnDataType.Currency:\n        return IgxPivotNumericAggregate.aggregators();\n\n      case GridColumnDataType.Date:\n      case GridColumnDataType.DateTime:\n        return IgxPivotDateAggregate.aggregators();\n\n      case GridColumnDataType.Time:\n        return IgxPivotTimeAggregate.aggregators();\n\n      default:\n        return IgxPivotAggregate.aggregators();\n    }\n  }\n\n}\n\nlet DefaultPivotGridRecordSortingStrategy = /*#__PURE__*/(() => {\n  class DefaultPivotGridRecordSortingStrategy extends DefaultSortingStrategy {\n    static instance() {\n      return this._instance || (this._instance = new this());\n    }\n\n    sort(data, fieldName, dir, ignoreCase, valueResolver, isDate, isTime, grid) {\n      const reverse = dir === SortingDirection.Desc ? -1 : 1;\n\n      const cmpFunc = (obj1, obj2) => this.compareObjects(obj1, obj2, fieldName, reverse, ignoreCase, this.getFieldValue, isDate, isTime);\n\n      return this.arraySort(data, cmpFunc);\n    }\n\n    getFieldValue(obj, key, isDate = false, isTime = false) {\n      return obj.aggregationValues.get(key);\n    }\n\n  }\n\n  DefaultPivotGridRecordSortingStrategy._instance = null;\n  return DefaultPivotGridRecordSortingStrategy;\n})();\nlet DefaultPivotSortingStrategy = /*#__PURE__*/(() => {\n  class DefaultPivotSortingStrategy extends DefaultSortingStrategy {\n    static instance() {\n      return this._instance || (this._instance = new this());\n    }\n\n    sort(data, fieldName, dir, ignoreCase, valueResolver, isDate, isTime, grid) {\n      const key = fieldName;\n      const allDimensions = grid.allDimensions;\n      const enabledDimensions = allDimensions.filter(x => x && x.enabled);\n      this.dimension = PivotUtil.flatten(enabledDimensions).find(x => x.memberName === key);\n      const reverse = dir === SortingDirection.Desc ? -1 : 1;\n\n      const cmpFunc = (obj1, obj2) => this.compareObjects(obj1, obj2, key, reverse, ignoreCase, this.getFieldValue, isDate, isTime);\n\n      return this.arraySort(data, cmpFunc);\n    }\n\n    getFieldValue(obj, key, isDate = false, isTime = false) {\n      let resolvedValue = PivotUtil.extractValueFromDimension(this.dimension, obj) || obj[0];\n      const formatAsDate = this.dimension.dataType === GridColumnDataType.Date || this.dimension.dataType === GridColumnDataType.DateTime;\n\n      if (formatAsDate) {\n        const date = parseDate(resolvedValue);\n        resolvedValue = isTime && date ? new Date().setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()) : date;\n      }\n\n      return resolvedValue;\n    }\n\n  }\n\n  DefaultPivotSortingStrategy._instance = null;\n  return DefaultPivotSortingStrategy;\n})();\nlet NoopPivotDimensionsStrategy = /*#__PURE__*/(() => {\n  class NoopPivotDimensionsStrategy {\n    static instance() {\n      return this._instance || (this._instance = new NoopPivotDimensionsStrategy());\n    }\n\n    process(collection, _, __) {\n      return collection;\n    }\n\n  }\n\n  NoopPivotDimensionsStrategy._instance = null;\n  return NoopPivotDimensionsStrategy;\n})();\nlet PivotRowDimensionsStrategy = /*#__PURE__*/(() => {\n  class PivotRowDimensionsStrategy {\n    static instance() {\n      return this._instance || (this._instance = new PivotRowDimensionsStrategy());\n    }\n\n    process(collection, rows, values, pivotKeys = DEFAULT_PIVOT_KEYS) {\n      let hierarchies;\n      let data;\n      const prevRowDims = [];\n      let prevDim;\n      let prevDimTopRecords = [];\n      const currRows = cloneArray(rows, true);\n      PivotUtil.assignLevels(currRows);\n\n      if (currRows.length === 0) {\n        hierarchies = PivotUtil.getFieldsHierarchy(collection, [{\n          memberName: '',\n          enabled: true\n        }], PivotDimensionType.Row, pivotKeys); // generate flat data from the hierarchies\n\n        data = PivotUtil.processHierarchy(hierarchies, pivotKeys, 0, true);\n        return data;\n      }\n\n      for (const row of currRows) {\n        if (!data) {\n          // build hierarchies - groups and subgroups\n          hierarchies = PivotUtil.getFieldsHierarchy(collection, [row], PivotDimensionType.Row, pivotKeys); // generate flat data from the hierarchies\n\n          data = PivotUtil.processHierarchy(hierarchies, pivotKeys, 0, true);\n          prevRowDims.push(row);\n          prevDim = row;\n          prevDimTopRecords = data;\n        } else {\n          PivotUtil.processGroups(data, row, pivotKeys);\n        }\n      }\n\n      return data;\n    }\n\n  }\n\n  PivotRowDimensionsStrategy._instance = null;\n  return PivotRowDimensionsStrategy;\n})();\nlet PivotColumnDimensionsStrategy = /*#__PURE__*/(() => {\n  class PivotColumnDimensionsStrategy {\n    static instance() {\n      return this._instance || (this._instance = new PivotColumnDimensionsStrategy());\n    }\n\n    process(collection, columns, values, pivotKeys = DEFAULT_PIVOT_KEYS) {\n      const res = this.processHierarchy(collection, columns, values, pivotKeys);\n      return res;\n    }\n\n    processHierarchy(collection, columns, values, pivotKeys) {\n      const result = [];\n      collection.forEach(rec => {\n        // apply aggregations based on the created groups and generate column fields based on the hierarchies\n        this.groupColumns(rec, columns, values, pivotKeys);\n        result.push(rec);\n      });\n      return result;\n    }\n\n    groupColumns(rec, columns, values, pivotKeys) {\n      const children = rec.children;\n\n      if (children && children.size > 0) {\n        children.forEach((childRecs, key) => {\n          if (childRecs) {\n            childRecs.forEach(child => {\n              this.groupColumns(child, columns, values, pivotKeys);\n            });\n          }\n        });\n      }\n\n      this.applyAggregates(rec, columns, values, pivotKeys);\n    }\n\n    applyAggregates(rec, columns, values, pivotKeys) {\n      const leafRecords = this.getLeafs(rec.records, pivotKeys);\n      const hierarchy = PivotUtil.getFieldsHierarchy(leafRecords, columns, PivotDimensionType.Column, pivotKeys);\n      PivotUtil.applyAggregations(rec, hierarchy, values, pivotKeys);\n    }\n\n    getLeafs(records, pivotKeys) {\n      let leafs = [];\n\n      for (const rec of records) {\n        if (rec[pivotKeys.records]) {\n          leafs = leafs.concat(this.getLeafs(rec[pivotKeys.records], pivotKeys));\n        } else {\n          leafs.push(rec);\n        }\n      }\n\n      return leafs;\n    }\n\n  }\n\n  PivotColumnDimensionsStrategy._instance = null;\n  return PivotColumnDimensionsStrategy;\n})();\n\nclass DimensionValuesFilteringStrategy extends FilteringStrategy {\n  /**\n   * Creates a new instance of FormattedValuesFilteringStrategy.\n   *\n   * @param fields An array of column field names that should be formatted.\n   * If omitted the values of all columns which has formatter will be formatted.\n   */\n  constructor(fields) {\n    super();\n    this.fields = fields;\n  }\n\n  getFieldValue(rec, fieldName, isDate = false, isTime = false, grid) {\n    const allDimensions = grid.allDimensions;\n    const enabledDimensions = allDimensions.filter(x => x && x.enabled);\n    const dim = PivotUtil.flatten(enabledDimensions).find(x => x.memberName === fieldName);\n    const value = dim.childLevel ? this._getDimensionValueHierarchy(dim, rec).map(x => `[` + x + `]`).join('.') : PivotUtil.extractValueFromDimension(dim, rec);\n    return value;\n  }\n\n  getFilterItems(column, tree) {\n    const grid = column.grid;\n    const enabledDimensions = grid.allDimensions.filter(x => x && x.enabled);\n    let data = column.grid.gridAPI.filterDataByExpressions(tree);\n    const dim = enabledDimensions.find(x => x.memberName === column.field);\n    const allValuesHierarchy = PivotUtil.getFieldsHierarchy(data, [dim], PivotDimensionType.Column, grid.pivotKeys);\n    const isNoop = grid.pivotConfiguration.columnStrategy instanceof NoopPivotDimensionsStrategy || grid.pivotConfiguration.rowStrategy instanceof NoopPivotDimensionsStrategy;\n    const items = !isNoop ? this._getFilterItems(allValuesHierarchy, grid.pivotKeys) : [{\n      value: ''\n    }];\n    return Promise.resolve(items);\n  }\n\n  _getFilterItems(hierarchy, pivotKeys) {\n    const items = [];\n    hierarchy.forEach(value => {\n      const val = value.value;\n      const path = val.split(pivotKeys.columnDimensionSeparator);\n      const hierarchicalValue = path.length > 1 ? path.map(x => `[` + x + `]`).join('.') : val;\n      const text = path[path.length - 1];\n      items.push({\n        value: hierarchicalValue,\n        label: text,\n        children: this._getFilterItems(value.children, pivotKeys)\n      });\n    });\n    return items;\n  }\n\n  _getDimensionValueHierarchy(dim, rec) {\n    let path = [];\n    let value = PivotUtil.extractValueFromDimension(dim, rec);\n    path.push(value);\n\n    if (dim.childLevel) {\n      const childVals = this._getDimensionValueHierarchy(dim.childLevel, rec);\n\n      path = path.concat(childVals);\n    }\n\n    return path;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass GroupedRecords extends Array {}\n\nlet IgxGridActionButtonComponent = /*#__PURE__*/(() => {\n  class IgxGridActionButtonComponent {\n    constructor() {\n      /**\n       * Event emitted when action button is clicked.\n       *\n       * @example\n       * ```html\n       *  <igx-grid-action-button (actionClick)=\"startEdit($event)\"></igx-grid-action-button>\n       * ```\n       */\n      this.actionClick = new EventEmitter();\n      /**\n       * Whether button action is rendered in menu and should container text label.\n       */\n\n      this.asMenuItem = false;\n    }\n    /** @hidden @internal */\n\n\n    get containerClass() {\n      return 'igx-action-strip__menu-button ' + (this.classNames || '');\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    handleClick(event) {\n      this.actionClick.emit(event);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    preventEvent(event) {\n      if (event) {\n        event.stopPropagation();\n        event.preventDefault();\n      }\n    }\n\n  }\n\n  IgxGridActionButtonComponent.ɵfac = function IgxGridActionButtonComponent_Factory(t) {\n    return new (t || IgxGridActionButtonComponent)();\n  };\n\n  IgxGridActionButtonComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxGridActionButtonComponent,\n    selectors: [[\"igx-grid-action-button\"]],\n    viewQuery: function IgxGridActionButtonComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c6, 5);\n        i0.ɵɵviewQuery(_c18, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.templateRef = _t.first);\n      }\n    },\n    inputs: {\n      asMenuItem: \"asMenuItem\",\n      iconName: \"iconName\",\n      classNames: \"classNames\",\n      iconSet: \"iconSet\",\n      labelText: \"labelText\"\n    },\n    outputs: {\n      actionClick: \"actionClick\"\n    },\n    decls: 3,\n    vars: 1,\n    consts: [[4, \"ngIf\"], [\"menuItemTemplate\", \"\"], [\"igxButton\", \"icon\", \"igxRipple\", \"\", 3, \"title\", \"click\", \"mousedown\"], [3, \"family\", \"name\", 4, \"ngIf\"], [3, \"family\", \"name\"], [3, \"className\"], [\"container\", \"\"], [\"igxLabel\", \"\"]],\n    template: function IgxGridActionButtonComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxGridActionButtonComponent_ng_container_0_Template, 4, 3, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, IgxGridActionButtonComponent_ng_template_1_Template, 1, 1, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.asMenuItem);\n      }\n    },\n    directives: [IgxIconComponent, i4.NgIf, IgxButtonDirective, IgxRippleDirective],\n    encapsulation: 2\n  });\n  return IgxGridActionButtonComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst LabelPosition = mkenum({\n  BEFORE: 'before',\n  AFTER: 'after'\n});\nlet nextId$1 = 0;\n/**\n * Allows users to make a binary choice for a certain condition.\n *\n * @igxModule IgxCheckboxModule\n *\n * @igxTheme igx-checkbox-theme\n *\n * @igxKeywords checkbox, label\n *\n * @igxGroup Data entry and display\n *\n * @remarks\n * The Ignite UI Checkbox is a selection control that allows users to make a binary choice for a certain condition.It behaves similarly\n * to the native browser checkbox.\n *\n * @example\n * ```html\n * <igx-checkbox [checked]=\"true\">\n *   simple checkbox\n * </igx-checkbox>\n * ```\n */\n\nlet IgxCheckboxComponent = /*#__PURE__*/(() => {\n  class IgxCheckboxComponent {\n    constructor() {\n      /**\n       * An event that is emitted after the checkbox state is changed.\n       * Provides references to the `IgxCheckboxComponent` and the `checked` property as event arguments.\n       */\n      // eslint-disable-next-line @angular-eslint/no-output-native\n      this.change = new EventEmitter();\n      /**\n       * Sets/gets the `id` of the checkbox component.\n       * If not set, the `id` of the first checkbox component will be `\"igx-checkbox-0\"`.\n       *\n       * @example\n       * ```html\n       * <igx-checkbox id=\"my-first-checkbox\"></igx-checkbox>\n       * ```\n       * ```typescript\n       * let checkboxId =  this.checkbox.id;\n       * ```\n       */\n\n      this.id = `igx-checkbox-${nextId$1++}`;\n      /**\n       * Sets/gets the id of the `label` element.\n       * If not set, the id of the `label` in the first checkbox component will be `\"igx-checkbox-0-label\"`.\n       *\n       * @example\n       * ```html\n       * <igx-checkbox labelId = \"Label1\"></igx-checkbox>\n       * ```\n       * ```typescript\n       * let labelId =  this.checkbox.labelId;\n       * ```\n       */\n\n      this.labelId = `${this.id}-label`;\n      /**\n       * Sets/gets the value of the `tabindex` attribute.\n       *\n       * @example\n       * ```html\n       * <igx-checkbox [tabindex] = \"1\"></igx-checkbox>\n       * ```\n       * ```typescript\n       * let tabIndex =  this.checkbox.tabindex;\n       * ```\n       */\n\n      this.tabindex = null;\n      /**\n       *  Sets/gets the position of the `label`.\n       *  If not set, the `labelPosition` will have value `\"after\"`.\n       *\n       * @example\n       * ```html\n       * <igx-checkbox labelPosition = \"before\"></igx-checkbox>\n       * ```\n       * ```typescript\n       * let labelPosition =  this.checkbox.labelPosition;\n       * ```\n       */\n\n      this.labelPosition = LabelPosition.AFTER;\n      /**\n       * Enables/Disables the ripple effect.\n       * If not set, `disableRipple` will have value `false`.\n       *\n       * @example\n       * ```html\n       * <igx-checkbox [disableRipple] = \"true\"></igx-checkbox>\n       * ```\n       * ```typescript\n       * let isRippleDisabled = this.checkbox.desableRipple;\n       * ```\n       */\n\n      this.disableRipple = false;\n      /**\n       * Sets/gets the `aria-labelledby` attribute.\n       * If not set, the `aria-labelledby` will be equal to the value of `labelId` attribute.\n       *\n       * @example\n       * ```html\n       * <igx-checkbox aria-labelledby = \"Checkbox1\"></igx-checkbox>\n       * ```\n       * ```typescript\n       * let ariaLabelledBy =  this.checkbox.ariaLabelledBy;\n       * ```\n       */\n\n      this.ariaLabelledBy = this.labelId;\n      /**\n       * Sets/gets the value of the `aria-label` attribute.\n       *\n       * @example\n       * ```html\n       * <igx-checkbox aria-label = \"Checkbox1\"></igx-checkbox>\n       * ```\n       * ```typescript\n       * let ariaLabel = this.checkbox.ariaLabel;\n       * ```\n       */\n\n      this.ariaLabel = null;\n      /**\n       * Returns the class of the checkbox component.\n       *\n       * @example\n       * ```typescript\n       * let class =  this.checkbox.cssClass;\n       * ```\n       */\n\n      this.cssClass = 'igx-checkbox';\n      /**\n       * Sets/gets whether the checkbox component is on focus.\n       * Default value is `false`.\n       *\n       * @example\n       * ```typescript\n       * this.checkbox.focused =  true;\n       * ```\n       * ```typescript\n       * let isFocused =  this.checkbox.focused;\n       * ```\n       */\n\n      this.focused = false;\n      /**\n       * Sets/gets the checkbox indeterminate visual state.\n       * Default value is `false`;\n       *\n       * @example\n       * ```html\n       * <igx-checkbox [indeterminate] = \"true\"></igx-checkbox>\n       * ```\n       * ```typescript\n       * let isIndeterminate = this.checkbox.indeterminate;\n       * ```\n       */\n\n      this.indeterminate = false;\n      /**\n       * Sets/gets whether the checkbox is readonly.\n       * Default value is `false`.\n       *\n       * @example\n       * ```html\n       * <igx-checkbox [readonly]=\"true\"></igx-checkbox>\n       * ```\n       * ```typescript\n       * let readonly = this.checkbox.readonly;\n       * ```\n       */\n\n      this.readonly = false;\n      /**\n       * Sets/gets whether the checkbox should disable all css transitions.\n       * Default value is `false`.\n       *\n       * @example\n       * ```html\n       * <igx-checkbox [disableTransitions]=\"true\"></igx-checkbox>\n       * ```\n       * ```typescript\n       * let disableTransitions = this.checkbox.disableTransitions;\n       * ```\n       */\n\n      this.disableTransitions = false;\n      /** @hidden @internal */\n\n      this.inputId = `${this.id}-input`;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this._checked = false;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this._required = false;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this._disabled = false;\n      /**\n       * @hidden\n       */\n\n      this._onTouchedCallback = noop;\n      /**\n       * @hidden\n       */\n\n      this._onChangeCallback = noop;\n    }\n    /**\n     * Sets/gets whether the checkbox is required.\n     * If not set, `required` will have value `false`.\n     *\n     * @example\n     * ```html\n     * <igx-checkbox required></igx-checkbox>\n     * ```\n     * ```typescript\n     * let isRequired =  this.checkbox.required;\n     * ```\n     */\n\n\n    get required() {\n      return this._required;\n    }\n\n    set required(value) {\n      this._required = value === '' || value;\n    }\n    /**\n     * Sets/gets whether the checkbox is checked.\n     * Default value is `false`.\n     *\n     * @example\n     * ```html\n     * <igx-checkbox [checked] = \"true\"></igx-checkbox>\n     * ```\n     * ```typescript\n     * let isChecked =  this.checkbox.checked;\n     * ```\n     */\n\n\n    get checked() {\n      return this._checked;\n    }\n\n    set checked(value) {\n      if (this._checked !== value) {\n        this._checked = value;\n\n        this._onChangeCallback(this._checked);\n      }\n    }\n    /**\n     * Sets/gets whether the checkbox is disabled.\n     * Default value is `false`.\n     *\n     * @example\n     * ```html\n     * <igx-checkbox disabled></igx-checkbox>\n     * ```\n     * ```typescript\n     * let isDisabled = this.checkbox.disabled;\n     * ```\n     */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n\n    set disabled(value) {\n      this._disabled = value === '' || value;\n    }\n    /** @hidden @internal */\n\n\n    onKeyUp(event) {\n      event.stopPropagation();\n      this.focused = true;\n    }\n    /** @hidden @internal */\n\n\n    _onCheckboxClick(event) {\n      // Since the original checkbox is hidden and the label\n      // is used for styling and to change the checked state of the checkbox,\n      // we need to prevent the checkbox click event from bubbling up\n      // as it gets triggered on label click\n      // NOTE: The above is no longer valid, as the native checkbox is not labeled\n      // by the SVG anymore.\n      if (this.disabled || this.readonly) {\n        // readonly prevents the component from changing state (see toggle() method).\n        // However, the native checkbox can still be activated through user interaction (focus + space, label click)\n        // Prevent the native change so the input remains in sync\n        event.preventDefault();\n        return;\n      }\n\n      this.nativeCheckbox.nativeElement.focus();\n      this.indeterminate = false;\n      this.checked = !this.checked; // K.D. March 23, 2021 Emitting on click and not on the setter because otherwise every component\n      // bound on change would have to perform self checks for weather the value has changed because\n      // of the initial set on initialization\n\n      this.change.emit({\n        checked: this._checked,\n        checkbox: this\n      });\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get ariaChecked() {\n      if (this.indeterminate) {\n        return 'mixed';\n      } else {\n        return this.checked;\n      }\n    }\n    /** @hidden @internal */\n\n\n    _onCheckboxChange(event) {\n      // We have to stop the original checkbox change event\n      // from bubbling up since we emit our own change event\n      event.stopPropagation();\n    }\n    /** @hidden @internal */\n\n\n    onBlur() {\n      this.focused = false;\n\n      this._onTouchedCallback();\n    }\n    /** @hidden @internal */\n\n\n    writeValue(value) {\n      this._checked = value;\n    }\n    /** @hidden @internal */\n\n\n    get labelClass() {\n      switch (this.labelPosition) {\n        case LabelPosition.BEFORE:\n          return `${this.cssClass}__label--before`;\n\n        case LabelPosition.AFTER:\n        default:\n          return `${this.cssClass}__label`;\n      }\n    }\n    /** @hidden @internal */\n\n\n    registerOnChange(fn) {\n      this._onChangeCallback = fn;\n    }\n    /** @hidden @internal */\n\n\n    registerOnTouched(fn) {\n      this._onTouchedCallback = fn;\n    }\n    /** @hidden @internal */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n    /** @hidden @internal */\n\n\n    getEditElement() {\n      return this.nativeCheckbox.nativeElement;\n    }\n\n  }\n\n  IgxCheckboxComponent.ɵfac = function IgxCheckboxComponent_Factory(t) {\n    return new (t || IgxCheckboxComponent)();\n  };\n\n  IgxCheckboxComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxCheckboxComponent,\n    selectors: [[\"igx-checkbox\"]],\n    viewQuery: function IgxCheckboxComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c19, 7);\n        i0.ɵɵviewQuery(_c20, 7);\n        i0.ɵɵviewQuery(_c17, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nativeCheckbox = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nativeLabel = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.placeholderLabel = _t.first);\n      }\n    },\n    hostVars: 13,\n    hostBindings: function IgxCheckboxComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keyup\", function IgxCheckboxComponent_keyup_HostBindingHandler($event) {\n          return ctx.onKeyUp($event);\n        })(\"click\", function IgxCheckboxComponent_click_HostBindingHandler($event) {\n          return ctx._onCheckboxClick($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id);\n        i0.ɵɵclassProp(\"igx-checkbox\", ctx.cssClass)(\"igx-checkbox--focused\", ctx.focused)(\"igx-checkbox--indeterminate\", ctx.indeterminate)(\"igx-checkbox--checked\", ctx.checked)(\"igx-checkbox--disabled\", ctx.disabled)(\"igx-checkbox--plain\", ctx.disableTransitions);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      labelId: \"labelId\",\n      value: \"value\",\n      name: \"name\",\n      tabindex: \"tabindex\",\n      labelPosition: \"labelPosition\",\n      disableRipple: \"disableRipple\",\n      required: \"required\",\n      ariaLabelledBy: [\"aria-labelledby\", \"ariaLabelledBy\"],\n      ariaLabel: [\"aria-label\", \"ariaLabel\"],\n      indeterminate: \"indeterminate\",\n      checked: \"checked\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      disableTransitions: \"disableTransitions\"\n    },\n    outputs: {\n      change: \"change\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: IgxCheckboxComponent,\n      multi: true\n    }])],\n    ngContentSelectors: _c8,\n    decls: 11,\n    vars: 17,\n    consts: [[\"type\", \"checkbox\", 1, \"igx-checkbox__input\", 3, \"id\", \"name\", \"value\", \"tabindex\", \"disabled\", \"indeterminate\", \"checked\", \"required\", \"change\", \"blur\"], [\"checkbox\", \"\"], [\"igxRipple\", \"\", \"igxRippleTarget\", \".igx-checkbox__ripple\", 1, \"igx-checkbox__composite-wrapper\", 3, \"igxRippleDisabled\", \"igxRippleCentered\", \"igxRippleDuration\"], [1, \"igx-checkbox__composite\"], [\"label\", \"\"], [\"xmlns\", \"http://www.w3.org/2000/svg\", \"viewBox\", \"0 0 24 24\", 1, \"igx-checkbox__composite-mark\"], [\"d\", \"M4.1,12.7 9,17.6 20.3,6.3\"], [1, \"igx-checkbox__ripple\"], [3, \"id\"], [\"placeholderLabel\", \"\"]],\n    template: function IgxCheckboxComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"input\", 0, 1);\n        i0.ɵɵlistener(\"change\", function IgxCheckboxComponent_Template_input_change_0_listener($event) {\n          return ctx._onCheckboxChange($event);\n        })(\"blur\", function IgxCheckboxComponent_Template_input_blur_0_listener() {\n          return ctx.onBlur();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(2, \"div\", 2)(3, \"span\", 3, 4);\n        i0.ɵɵnamespaceSVG();\n        i0.ɵɵelementStart(5, \"svg\", 5);\n        i0.ɵɵelement(6, \"path\", 6);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵnamespaceHTML();\n        i0.ɵɵelement(7, \"div\", 7);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(8, \"span\", 8, 9);\n        i0.ɵɵprojection(10);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"id\", ctx.inputId)(\"name\", ctx.name)(\"value\", ctx.value)(\"tabindex\", ctx.tabindex)(\"disabled\", ctx.disabled)(\"indeterminate\", ctx.indeterminate)(\"checked\", ctx.checked)(\"required\", ctx.required);\n        i0.ɵɵattribute(\"aria-checked\", ctx.ariaChecked)(\"aria-labelledby\", ctx.ariaLabel ? null : ctx.ariaLabelledBy)(\"aria-label\", ctx.ariaLabel);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"igxRippleDisabled\", ctx.disableRipple)(\"igxRippleCentered\", true)(\"igxRippleDuration\", 300);\n        i0.ɵɵadvance(6);\n        i0.ɵɵclassMap(ctx.labelClass);\n        i0.ɵɵproperty(\"id\", ctx.labelId);\n      }\n    },\n    directives: [IgxRippleDirective],\n    encapsulation: 2\n  });\n  return IgxCheckboxComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst IGX_CHECKBOX_REQUIRED_VALIDATOR = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => IgxCheckboxRequiredDirective),\n  multi: true\n};\n/* eslint-disable  @angular-eslint/directive-selector */\n\nlet IgxCheckboxRequiredDirective = /*#__PURE__*/(() => {\n  class IgxCheckboxRequiredDirective extends CheckboxRequiredValidator {}\n\n  IgxCheckboxRequiredDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxCheckboxRequiredDirective_BaseFactory;\n    return function IgxCheckboxRequiredDirective_Factory(t) {\n      return (ɵIgxCheckboxRequiredDirective_BaseFactory || (ɵIgxCheckboxRequiredDirective_BaseFactory = i0.ɵɵgetInheritedFactory(IgxCheckboxRequiredDirective)))(t || IgxCheckboxRequiredDirective);\n    };\n  }();\n\n  IgxCheckboxRequiredDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxCheckboxRequiredDirective,\n    selectors: [[\"igx-checkbox\", \"required\", \"\", \"formControlName\", \"\"], [\"igx-checkbox\", \"required\", \"\", \"formControl\", \"\"], [\"igx-checkbox\", \"required\", \"\", \"ngModel\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([IGX_CHECKBOX_REQUIRED_VALIDATOR]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return IgxCheckboxRequiredDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxCheckboxModule = /*#__PURE__*/(() => {\n  class IgxCheckboxModule {}\n\n  IgxCheckboxModule.ɵfac = function IgxCheckboxModule_Factory(t) {\n    return new (t || IgxCheckboxModule)();\n  };\n\n  IgxCheckboxModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxCheckboxModule\n  });\n  IgxCheckboxModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[IgxRippleModule]]\n  });\n  return IgxCheckboxModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass IgxEditRow {\n  constructor(id, index, data, grid) {\n    this.id = id;\n    this.index = index;\n    this.data = data;\n    this.grid = grid;\n  }\n\n  createEditEventArgs(includeNewValue = true, event) {\n    var _a;\n\n    const args = {\n      rowID: this.id,\n      rowData: this.data,\n      oldValue: this.data,\n      cancel: false,\n      owner: this.grid,\n      isAddRow: false,\n      event\n    };\n\n    if (includeNewValue) {\n      args.newValue = (_a = this.newData) !== null && _a !== void 0 ? _a : this.data;\n    }\n\n    return args;\n  }\n\n  createDoneEditEventArgs(cachedRowData, event) {\n    const updatedData = this.grid.transactions.enabled ? this.grid.transactions.getAggregatedValue(this.id, true) : this.grid.gridAPI.getRowData(this.id);\n    const rowData = updatedData !== null && updatedData !== void 0 ? updatedData : this.grid.gridAPI.getRowData(this.id);\n    const args = {\n      rowID: this.id,\n      rowData,\n      oldValue: cachedRowData,\n      newValue: updatedData,\n      owner: this.grid,\n      isAddRow: false,\n      event\n    };\n    return args;\n  }\n\n  getClassName() {\n    return this.constructor.name;\n  }\n\n}\n\nclass IgxAddRow extends IgxEditRow {\n  constructor(id, index, data, recordRef, grid) {\n    super(id, index, data, grid);\n    this.id = id;\n    this.index = index;\n    this.data = data;\n    this.recordRef = recordRef;\n    this.grid = grid;\n    this.isAddRow = true;\n  }\n\n  createEditEventArgs(includeNewValue = true, event) {\n    const args = super.createEditEventArgs(includeNewValue, event);\n    args.oldValue = null;\n    args.isAddRow = true;\n    return args;\n  }\n\n  createDoneEditEventArgs(cachedRowData, event) {\n    const args = super.createDoneEditEventArgs(null, event);\n    args.isAddRow = true;\n    return args;\n  }\n\n}\n\nclass IgxCell {\n  constructor(id, rowIndex, column, value, editValue, rowData, grid) {\n    this.id = id;\n    this.rowIndex = rowIndex;\n    this.column = column;\n    this.value = value;\n    this.editValue = editValue;\n    this.rowData = rowData;\n    this.grid = grid;\n  }\n\n  castToNumber(value) {\n    if (this.column.dataType === 'number' && !this.column.inlineEditorTemplate) {\n      const v = parseFloat(value);\n      return !isNaN(v) && isFinite(v) ? v : 0;\n    }\n\n    return value;\n  }\n\n  createEditEventArgs(includeNewValue = true, event) {\n    const args = {\n      rowID: this.id.rowID,\n      cellID: this.id,\n      rowData: this.rowData,\n      oldValue: this.value,\n      cancel: false,\n      column: this.column,\n      owner: this.grid,\n      event\n    };\n\n    if (includeNewValue) {\n      args.newValue = this.castToNumber(this.editValue);\n    }\n\n    return args;\n  }\n\n  createDoneEditEventArgs(value, event) {\n    const updatedData = this.grid.transactions.enabled ? this.grid.transactions.getAggregatedValue(this.id.rowID, true) : this.rowData;\n    const rowData = updatedData === null ? this.grid.gridAPI.getRowData(this.id.rowID) : updatedData;\n    const args = {\n      rowID: this.id.rowID,\n      cellID: this.id,\n      // rowData - should be the updated/committed rowData - this effectively should be the newValue\n      // the only case we use this.rowData directly, is when there is no rowEditing or transactions enabled\n      rowData,\n      oldValue: this.value,\n      newValue: value,\n      column: this.column,\n      owner: this.grid,\n      event\n    };\n    return args;\n  }\n\n}\n\nclass IgxCellCrudState {\n  constructor() {\n    this.cell = null;\n    this.row = null;\n    this.isInCompositionMode = false;\n  }\n\n  createCell(cell) {\n    return this.cell = new IgxCell(cell.cellID || cell.id, cell.row.index, cell.column, cell.value, cell.value, cell.row.data, cell.grid);\n  }\n\n  createRow(cell) {\n    return this.row = new IgxEditRow(cell.id.rowID, cell.rowIndex, cell.rowData, cell.grid);\n  }\n\n  sameRow(rowID) {\n    return this.row && this.row.id === rowID;\n  }\n\n  sameCell(cell) {\n    return this.cell.id.rowID === cell.id.rowID && this.cell.id.columnID === cell.id.columnID;\n  }\n\n  get cellInEditMode() {\n    return !!this.cell;\n  }\n\n  beginCellEdit(event) {\n    const args = this.cell.createEditEventArgs(false, event);\n    this.grid.cellEditEnter.emit(args);\n\n    if (args.cancel) {\n      this.endCellEdit();\n    }\n  }\n\n  cellEdit(event) {\n    const args = this.cell.createEditEventArgs(true, event);\n    this.grid.cellEdit.emit(args);\n    return args;\n  }\n\n  updateCell(exit, event) {\n    if (!this.cell) {\n      return;\n    }\n\n    let doneArgs;\n\n    if (isEqual(this.cell.value, this.cell.editValue)) {\n      doneArgs = this.exitCellEdit(event);\n      return doneArgs;\n    }\n\n    const args = this.cellEdit(event);\n\n    if (args.cancel) {\n      return args;\n    }\n\n    this.grid.gridAPI.update_cell(this.cell);\n    doneArgs = this.cellEditDone(event, false);\n\n    if (exit) {\n      doneArgs = this.exitCellEdit(event);\n    }\n\n    return Object.assign(Object.assign({}, args), doneArgs);\n  }\n\n  cellEditDone(event, addRow) {\n    const newValue = this.cell.castToNumber(this.cell.editValue);\n    const doneArgs = this.cell.createDoneEditEventArgs(newValue, event);\n    this.grid.cellEditDone.emit(doneArgs);\n\n    if (addRow) {\n      doneArgs.rowData = this.row.data;\n    }\n\n    return doneArgs;\n  }\n  /** Exit cell edit mode */\n\n\n  exitCellEdit(event) {\n    var _a;\n\n    if (!this.cell) {\n      return;\n    }\n\n    const newValue = this.cell.castToNumber(this.cell.editValue);\n    const args = (_a = this.cell) === null || _a === void 0 ? void 0 : _a.createDoneEditEventArgs(newValue, event);\n    this.cell.value = newValue;\n    this.grid.cellEditExit.emit(args);\n    this.endCellEdit();\n    return args;\n  }\n  /** Clears cell editing state */\n\n\n  endCellEdit() {\n    this.cell = null;\n  }\n  /** Returns whether the targeted cell is in edit mode */\n\n\n  targetInEdit(rowIndex, columnIndex) {\n    if (!this.cell) {\n      return false;\n    }\n\n    const res = this.cell.column.index === columnIndex && this.cell.rowIndex === rowIndex;\n    return res;\n  }\n\n}\n\nclass IgxRowCrudState extends IgxCellCrudState {\n  constructor() {\n    super(...arguments);\n    this.row = null;\n    this.closeRowEditingOverlay = new Subject();\n    this._rowEditingBlocked = false;\n  }\n\n  get primaryKey() {\n    return this.grid.primaryKey;\n  }\n\n  get rowInEditMode() {\n    const editRowState = this.row;\n    return editRowState !== null ? this.grid.rowList.find(e => e.key === editRowState.id) : null;\n  }\n\n  get rowEditing() {\n    return this.grid.rowEditable;\n  }\n\n  get rowEditingBlocked() {\n    return this._rowEditingBlocked;\n  }\n\n  set rowEditingBlocked(val) {\n    this._rowEditingBlocked = val;\n  }\n  /** Enters row edit mode */\n\n\n  beginRowEdit(event) {\n    if (this.grid.rowEditable && (this.grid.primaryKey === undefined || this.grid.primaryKey === null)) {\n      console.warn('The grid must have a `primaryKey` specified when using `rowEditable`!');\n    }\n\n    if (!this.row || !(this.row.getClassName() === IgxEditRow.name)) {\n      if (!this.row) {\n        this.createRow(this.cell);\n      }\n\n      const rowArgs = this.row.createEditEventArgs(false, event);\n      this.grid.rowEditEnter.emit(rowArgs);\n\n      if (rowArgs.cancel) {\n        this.endEditMode();\n        return true;\n      }\n\n      this.row.transactionState = this.grid.transactions.getAggregatedValue(this.row.id, true);\n      this.grid.transactions.startPending();\n      this.grid.openRowOverlay(this.row.id);\n    }\n  }\n\n  rowEdit(event) {\n    const args = this.row.createEditEventArgs(true, event);\n    this.grid.rowEdit.emit(args);\n    return args;\n  }\n\n  updateRow(commit, event) {\n    if (!this.grid.rowEditable || this.grid.rowEditingOverlay && this.grid.rowEditingOverlay.collapsed || !this.row) {\n      return {};\n    }\n\n    let args;\n\n    if (commit) {\n      this.row.newData = this.grid.transactions.getAggregatedValue(this.row.id, true);\n      this.updateRowEditData(this.row, this.row.newData);\n      args = this.rowEdit(event);\n\n      if (args.cancel) {\n        delete this.row.newData;\n        this.grid.transactions.clear(this.row.id);\n        return args;\n      }\n    }\n\n    args = this.endRowTransaction(commit, event);\n    return args;\n  }\n  /**\n   * @hidden @internal\n   */\n\n\n  endRowTransaction(commit, event) {\n    var _a;\n\n    this.row.newData = this.grid.transactions.getAggregatedValue(this.row.id, true);\n    let rowEditArgs = this.row.createEditEventArgs(true, event);\n    let nonCancelableArgs;\n\n    if (!commit) {\n      this.grid.transactions.endPending(false);\n    } else if (this.row.getClassName() === IgxEditRow.name) {\n      rowEditArgs = this.grid.gridAPI.update_row(this.row, this.row.newData, event);\n      nonCancelableArgs = this.rowEditDone(rowEditArgs.oldValue, event);\n    } else {\n      const rowAddArgs = this.row.createEditEventArgs(true, event);\n      this.grid.rowAdd.emit(rowAddArgs);\n\n      if (rowAddArgs.cancel) {\n        return rowAddArgs;\n      }\n\n      this.grid.transactions.endPending(false);\n      const parentId = this.getParentRowId();\n      this.grid.gridAPI.addRowToData((_a = this.row.newData) !== null && _a !== void 0 ? _a : this.row.data, parentId);\n      this.grid.triggerPipes();\n      nonCancelableArgs = this.rowEditDone(null, event);\n    }\n\n    nonCancelableArgs = this.exitRowEdit(rowEditArgs.oldValue, event);\n    return Object.assign(Object.assign({}, nonCancelableArgs), rowEditArgs);\n  }\n\n  rowEditDone(cachedRowData, event) {\n    const doneArgs = this.row.createDoneEditEventArgs(cachedRowData, event);\n    this.grid.rowEditDone.emit(doneArgs);\n    return doneArgs;\n  }\n  /** Exit row edit mode */\n\n\n  exitRowEdit(cachedRowData, event) {\n    const nonCancelableArgs = this.row.createDoneEditEventArgs(cachedRowData, event);\n    this.grid.rowEditExit.emit(nonCancelableArgs);\n    this.grid.closeRowEditingOverlay();\n    this.endRowEdit();\n    return nonCancelableArgs;\n  }\n  /** Clears row editing state */\n\n\n  endRowEdit() {\n    this.row = null;\n    this.rowEditingBlocked = false;\n  }\n  /** Clears cell and row editing state and closes row editing template if it is open */\n\n\n  endEditMode() {\n    this.endCellEdit();\n\n    if (this.grid.rowEditable) {\n      this.endRowEdit();\n      this.grid.closeRowEditingOverlay();\n    }\n  }\n\n  updateRowEditData(row, value) {\n    const grid = this.grid;\n    const rowInEditMode = grid.gridAPI.crudService.row;\n    row.newData = value !== null && value !== void 0 ? value : rowInEditMode.transactionState;\n\n    if (rowInEditMode && row.id === rowInEditMode.id) {\n      // do not use spread operator here as it will copy everything over an empty object with no descriptors\n      row.data = Object.assign(copyDescriptors(row.data), row.data, rowInEditMode.transactionState); // TODO: Workaround for updating a row in edit mode through the API\n    } else if (this.grid.transactions.enabled) {\n      const state = grid.transactions.getState(row.id);\n      row.data = state ? Object.assign({}, row.data, state.value) : row.data;\n    }\n  }\n\n  getParentRowId() {\n    return null;\n  }\n\n}\n\nclass IgxRowAddCrudState extends IgxRowCrudState {\n  constructor() {\n    super(...arguments);\n    this.addRowParent = null;\n  }\n  /**\n   * @hidden @internal\n   */\n\n\n  createAddRow(parentRow, asChild) {\n    this.createAddRowParent(parentRow, asChild);\n    const newRec = this.grid.getEmptyRecordObjectFor(parentRow);\n    const addRowIndex = this.addRowParent.index + 1;\n    return this.row = new IgxAddRow(newRec.rowID, addRowIndex, newRec.data, newRec.recordRef, this.grid);\n  }\n  /**\n   * @hidden @internal\n   */\n\n\n  createAddRowParent(row, newRowAsChild) {\n    const rowIndex = row ? row.index : -1;\n    const rowId = row ? row.key : rowIndex >= 0 ? this.grid.rowList.last.key : null;\n    const isInPinnedArea = this.grid.isRecordPinnedByViewIndex(rowIndex);\n    const pinIndex = this.grid.pinnedRecords.findIndex(x => x[this.primaryKey] === rowId);\n    const unpinIndex = this.grid.getUnpinnedIndexById(rowId);\n    this.addRowParent = {\n      rowID: rowId,\n      index: isInPinnedArea ? pinIndex : unpinIndex,\n      asChild: newRowAsChild,\n      isPinned: isInPinnedArea\n    };\n  }\n  /**\n   * @hidden @internal\n   */\n\n\n  endRowTransaction(commit, event) {\n    const isAddRow = this.row && this.row.getClassName() === IgxAddRow.name;\n\n    if (isAddRow) {\n      this.grid.rowAdded.pipe(first$1()).subscribe(addRowArgs => {\n        const rowData = addRowArgs.data;\n        const pinnedIndex = this.grid.pinnedRecords.findIndex(x => x[this.primaryKey] === rowData[this.primaryKey]); // A check whether the row is in the current view\n\n        const viewIndex = pinnedIndex !== -1 ? pinnedIndex : this._findRecordIndexInView(rowData);\n        const dataIndex = this.grid.filteredSortedData.findIndex(data => data[this.primaryKey] === rowData[this.primaryKey]);\n        const isInView = viewIndex !== -1 && !this.grid.navigation.shouldPerformVerticalScroll(viewIndex, 0);\n        const showIndex = isInView ? -1 : dataIndex;\n        this.grid.showSnackbarFor(showIndex);\n      });\n    }\n\n    const args = super.endRowTransaction(commit, event);\n\n    if (args.cancel) {\n      return args;\n    }\n\n    if (isAddRow) {\n      this.endAddRow();\n\n      if (commit) {\n        this.grid.rowAddedNotifier.next({\n          data: args.newValue\n        });\n        this.grid.rowAdded.emit({\n          data: args.newValue\n        });\n      }\n    }\n\n    return args;\n  }\n  /**\n   * @hidden @internal\n   */\n\n\n  endAddRow() {\n    this.addRowParent = null;\n    this.grid.triggerPipes();\n  }\n  /**\n   * @hidden\n   * @internal\n   * TODO: consider changing modifier\n   */\n\n\n  _findRecordIndexInView(rec) {\n    return this.grid.dataView.findIndex(data => data[this.primaryKey] === rec[this.primaryKey]);\n  }\n\n  getParentRowId() {\n    var _a;\n\n    if (this.addRowParent.asChild) {\n      return this.addRowParent.asChild ? this.addRowParent.rowID : undefined;\n    } else if (this.addRowParent.rowID !== null && this.addRowParent.rowID !== undefined) {\n      const spawnedForRecord = this.grid.gridAPI.get_rec_by_id(this.addRowParent.rowID);\n      return (_a = spawnedForRecord === null || spawnedForRecord === void 0 ? void 0 : spawnedForRecord.parent) === null || _a === void 0 ? void 0 : _a.rowID;\n    }\n  }\n\n}\n\nlet IgxGridCRUDService = /*#__PURE__*/(() => {\n  class IgxGridCRUDService extends IgxRowAddCrudState {\n    enterEditMode(cell, event) {\n      var _a;\n\n      if (this.isInCompositionMode) {\n        return;\n      }\n\n      if (this.cellInEditMode) {\n        // TODO: case solely for f2/enter nav that uses enterEditMode as toggle. Refactor.\n        const canceled = this.endEdit(true, event);\n\n        if (!canceled || !this.cell) {\n          this.grid.tbody.nativeElement.focus();\n        }\n      } else {\n        if (this.rowEditing) {\n          // TODO rowData\n          if (this.row && !this.sameRow((_a = cell === null || cell === void 0 ? void 0 : cell.cellID) === null || _a === void 0 ? void 0 : _a.rowID)) {\n            this.rowEditingBlocked = this.endEdit(true, event);\n\n            if (this.rowEditingBlocked) {\n              return true;\n            }\n\n            this.rowEditingBlocked = false;\n            this.endRowEdit();\n          }\n\n          this.createCell(cell);\n          const canceled = this.beginRowEdit(event);\n\n          if (!canceled) {\n            this.beginCellEdit(event);\n          }\n        } else {\n          this.createCell(cell);\n          this.beginCellEdit(event);\n        }\n      }\n    }\n    /**\n     * Enters add row mode by creating temporary dummy so the user can fill in new row cells.\n     *\n     * @param parentRow Parent row after which the Add Row UI will be rendered.\n     *                  If `null` will show it at the bottom after all rows (or top if there are not rows).\n     * @param asChild Specifies if the new row should be added as a child to a tree row.\n     * @param event Base event that triggered the add row mode.\n     */\n\n\n    enterAddRowMode(parentRow, asChild, event) {\n      if (!this.rowEditing && (this.grid.primaryKey === undefined || this.grid.primaryKey === null)) {\n        console.warn('The grid must use row edit mode to perform row adding! Please set rowEditable to true.');\n        return;\n      }\n\n      this.endEdit(true, event);\n\n      if (parentRow != null && this.grid.expansionStates.get(parentRow.key)) {\n        this.grid.collapseRow(parentRow.key);\n      }\n\n      this.createAddRow(parentRow, asChild);\n      this.grid.transactions.startPending();\n\n      if (this.addRowParent.isPinned) {\n        // If parent is pinned, add the new row to pinned records\n        this.grid._pinnedRecordIDs.splice(this.row.index, 0, this.row.id);\n      }\n\n      this.grid.triggerPipes();\n      this.grid.notifyChanges(true);\n      this.grid.navigateTo(this.row.index, -1); // when selecting the dummy row we need to adjust for top pinned rows\n\n      const indexAdjust = this.grid.isRowPinningToTop && !this.addRowParent.isPinned ? this.grid.pinnedRows.length : 0; // TODO: Type this without shoving a bunch of internal properties in the row type\n\n      const dummyRow = this.grid.gridAPI.get_row_by_index(this.row.index + indexAdjust);\n      dummyRow.triggerAddAnimation();\n      dummyRow.cdr.detectChanges();\n      dummyRow.addAnimationEnd.pipe(first$1()).subscribe(() => {\n        const cell = dummyRow.cells.find(c => c.editable);\n\n        if (cell) {\n          this.grid.gridAPI.update_cell(this.cell);\n          this.enterEditMode(cell, event);\n          cell.activate();\n        }\n      });\n    }\n    /**\n     * Finishes the row transactions on the current row.\n     *\n     * @remarks\n     * If `commit === true`, passes them from the pending state to the data (or transaction service)\n     * @example\n     * ```html\n     * <button igxButton (click)=\"grid.endEdit(true)\">Commit Row</button>\n     * ```\n     * @param commit\n     */\n    // TODO: Implement the same representation of the method without evt emission.\n\n\n    endEdit(commit = true, event) {\n      if (!this.row && !this.cell) {\n        return;\n      }\n\n      let args;\n\n      if (commit) {\n        args = this.updateCell(true, event);\n\n        if (args && args.cancel) {\n          return args.cancel;\n        }\n      } else {\n        this.exitCellEdit(event);\n      }\n\n      args = this.updateRow(commit, event);\n      this.rowEditingBlocked = args.cancel;\n\n      if (args.cancel) {\n        return true;\n      }\n\n      const activeCell = this.grid.selectionService.activeElement;\n\n      if (event && activeCell) {\n        const rowIndex = activeCell.row;\n        const visibleColIndex = activeCell.layout ? activeCell.layout.columnVisibleIndex : activeCell.column;\n        this.grid.navigateTo(rowIndex, visibleColIndex);\n      }\n\n      return false;\n    }\n\n  }\n\n  IgxGridCRUDService.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxGridCRUDService_BaseFactory;\n    return function IgxGridCRUDService_Factory(t) {\n      return (ɵIgxGridCRUDService_BaseFactory || (ɵIgxGridCRUDService_BaseFactory = i0.ɵɵgetInheritedFactory(IgxGridCRUDService)))(t || IgxGridCRUDService);\n    };\n  }();\n\n  IgxGridCRUDService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxGridCRUDService,\n    factory: IgxGridCRUDService.ɵfac\n  });\n  return IgxGridCRUDService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst IGX_GRID_BASE = new InjectionToken('IgxGridBaseToken');\nconst IGX_GRID_SERVICE_BASE = new InjectionToken('IgxGridServiceBaseToken');\nlet IgxGridSelectionService = /*#__PURE__*/(() => {\n  class IgxGridSelectionService {\n    constructor(zone, platform) {\n      this.zone = zone;\n      this.platform = platform;\n      this.dragMode = false;\n      this.keyboardState = {};\n      this.pointerState = {};\n      this.columnsState = {};\n      this.selection = new Map();\n      this.temp = new Map();\n      this.rowSelection = new Set();\n      this.indeterminateRows = new Set();\n      this.columnSelection = new Set();\n      /**\n       * @hidden @internal\n       */\n\n      this.selectedRowsChange = new Subject();\n      /**\n       * Toggled when a pointerdown event is triggered inside the grid body (cells).\n       * When `false` the drag select behavior is disabled.\n       */\n\n      this.pointerEventInGridBody = false;\n      this._ranges = new Set();\n\n      this.pointerOriginHandler = () => {\n        this.pointerEventInGridBody = false;\n        document.body.removeEventListener('pointerup', this.pointerOriginHandler);\n      };\n\n      this.initPointerState();\n      this.initKeyboardState();\n      this.initColumnsState();\n    }\n    /**\n     * Returns the current selected ranges in the grid from both\n     * keyboard and pointer interactions\n     */\n\n\n    get ranges() {\n      // The last action was keyboard + shift selection -> add it\n      this.addKeyboardRange();\n      const ranges = Array.from(this._ranges).map(range => JSON.parse(range)); // No ranges but we have a focused cell -> add it\n\n      if (!ranges.length && this.activeElement && this.grid.isCellSelectable) {\n        ranges.push(this.generateRange(this.activeElement));\n      }\n\n      return ranges;\n    }\n\n    get primaryButton() {\n      return this.pointerState.primaryButton;\n    }\n\n    set primaryButton(value) {\n      this.pointerState.primaryButton = value;\n    }\n    /**\n     * Resets the keyboard state\n     */\n\n\n    initKeyboardState() {\n      this.keyboardState.node = null;\n      this.keyboardState.shift = false;\n      this.keyboardState.range = null;\n      this.keyboardState.active = false;\n    }\n    /**\n     * Resets the pointer state\n     */\n\n\n    initPointerState() {\n      this.pointerState.node = null;\n      this.pointerState.ctrl = false;\n      this.pointerState.shift = false;\n      this.pointerState.range = null;\n      this.pointerState.primaryButton = true;\n    }\n    /**\n     * Resets the columns state\n     */\n\n\n    initColumnsState() {\n      this.columnsState.field = null;\n      this.columnsState.range = [];\n    }\n    /**\n     * Adds a single node.\n     * Single clicks | Ctrl + single clicks on cells is the usual case.\n     */\n\n\n    add(node, addToRange = true) {\n      if (this.selection.has(node.row)) {\n        this.selection.get(node.row).add(node.column);\n      } else {\n        this.selection.set(node.row, new Set()).get(node.row).add(node.column);\n      }\n\n      if (addToRange) {\n        this._ranges.add(JSON.stringify(this.generateRange(node)));\n      }\n    }\n    /**\n     * Adds the active keyboard range selection (if any) to the `ranges` meta.\n     */\n\n\n    addKeyboardRange() {\n      if (this.keyboardState.range) {\n        this._ranges.add(JSON.stringify(this.keyboardState.range));\n      }\n    }\n\n    remove(node) {\n      if (this.selection.has(node.row)) {\n        this.selection.get(node.row).delete(node.column);\n      }\n\n      if (this.isActiveNode(node)) {\n        this.activeElement = null;\n      }\n\n      this._ranges.delete(JSON.stringify(this.generateRange(node)));\n    }\n\n    isInMap(node) {\n      return this.selection.has(node.row) && this.selection.get(node.row).has(node.column) || this.temp.has(node.row) && this.temp.get(node.row).has(node.column);\n    }\n\n    selected(node) {\n      return this.isActiveNode(node) && this.grid.isCellSelectable || this.isInMap(node);\n    }\n\n    isActiveNode(node) {\n      if (this.activeElement) {\n        const isActive = this.activeElement.column === node.column && this.activeElement.row === node.row;\n\n        if (this.grid.hasColumnLayouts) {\n          const layout = this.activeElement.layout;\n          return isActive && this.isActiveLayout(layout, node.layout);\n        }\n\n        return isActive;\n      }\n\n      return false;\n    }\n\n    isActiveLayout(current, target) {\n      return current.columnVisibleIndex === target.columnVisibleIndex;\n    }\n\n    addRangeMeta(node, state) {\n      this._ranges.add(JSON.stringify(this.generateRange(node, state)));\n    }\n\n    removeRangeMeta(node, state) {\n      this._ranges.delete(JSON.stringify(this.generateRange(node, state)));\n    }\n    /**\n     * Generates a new selection range from the given `node`.\n     * If `state` is passed instead it will generate the range based on the passed `node`\n     * and the start node of the `state`.\n     */\n\n\n    generateRange(node, state) {\n      if (!state) {\n        return {\n          rowStart: node.row,\n          rowEnd: node.row,\n          columnStart: node.column,\n          columnEnd: node.column\n        };\n      }\n\n      const {\n        row,\n        column\n      } = state.node;\n      const rowStart = Math.min(node.row, row);\n      const rowEnd = Math.max(node.row, row);\n      const columnStart = Math.min(node.column, column);\n      const columnEnd = Math.max(node.column, column);\n      return {\n        rowStart,\n        rowEnd,\n        columnStart,\n        columnEnd\n      };\n    }\n    /**\n     *\n     */\n\n\n    keyboardStateOnKeydown(node, shift, shiftTab) {\n      this.keyboardState.active = true;\n      this.initPointerState();\n      this.keyboardState.shift = shift && !shiftTab;\n\n      if (!this.grid.navigation.isDataRow(node.row)) {\n        return;\n      } // Kb navigation with shift and no previous node.\n      // Clear the current selection init the start node.\n\n\n      if (this.keyboardState.shift && !this.keyboardState.node) {\n        this.clear();\n        this.keyboardState.node = Object.assign({}, node);\n      }\n    }\n\n    keyboardStateOnFocus(node, emitter, dom) {\n      const kbState = this.keyboardState; // Focus triggered by keyboard navigation\n\n      if (kbState.active) {\n        if (this.platform.isChromium) {\n          this._moveSelectionChrome(dom);\n        } // Start generating a range if shift is hold\n\n\n        if (kbState.shift) {\n          this.dragSelect(node, kbState);\n          kbState.range = this.generateRange(node, kbState);\n          emitter.emit(this.generateRange(node, kbState));\n          return;\n        }\n\n        this.initKeyboardState();\n        this.clear();\n        this.add(node);\n      }\n    }\n\n    pointerDown(node, shift, ctrl) {\n      this.addKeyboardRange();\n      this.initKeyboardState();\n      this.pointerState.ctrl = ctrl;\n      this.pointerState.shift = shift;\n      this.pointerEventInGridBody = true;\n      document.body.addEventListener('pointerup', this.pointerOriginHandler); // No ctrl key pressed - no multiple selection\n\n      if (!ctrl) {\n        this.clear();\n      }\n\n      if (shift) {\n        // No previously 'clicked' node. Use the last active node.\n        if (!this.pointerState.node) {\n          this.pointerState.node = this.activeElement || node;\n        }\n\n        this.pointerDownShiftKey(node);\n        this.clearTextSelection();\n        return;\n      }\n\n      this.removeRangeMeta(node);\n      this.pointerState.node = node;\n    }\n\n    pointerDownShiftKey(node) {\n      this.clear();\n      this.selectRange(node, this.pointerState);\n    }\n\n    mergeMap(target, source) {\n      const iterator = source.entries();\n      let pair = iterator.next();\n      let key;\n      let value;\n\n      while (!pair.done) {\n        [key, value] = pair.value;\n\n        if (target.has(key)) {\n          const newValue = target.get(key);\n          value.forEach(record => newValue.add(record));\n          target.set(key, newValue);\n        } else {\n          target.set(key, value);\n        }\n\n        pair = iterator.next();\n      }\n    }\n\n    pointerEnter(node, event) {\n      // https://www.w3.org/TR/pointerevents/#the-button-property\n      this.dragMode = event.buttons === 1 && (event.button === -1 || event.button === 0) && this.pointerEventInGridBody;\n\n      if (!this.dragMode) {\n        return false;\n      }\n\n      this.clearTextSelection(); // If the users triggers a drag-like event by first clicking outside the grid cells\n      // and then enters in the grid body we may not have a initial pointer starting node.\n      // Assume the first pointerenter node is where we start.\n\n      if (!this.pointerState.node) {\n        this.pointerState.node = node;\n      }\n\n      if (this.pointerState.ctrl) {\n        this.selectRange(node, this.pointerState, this.temp);\n      } else {\n        this.dragSelect(node, this.pointerState);\n      }\n\n      return true;\n    }\n\n    pointerUp(node, emitter) {\n      if (this.dragMode) {\n        this.restoreTextSelection();\n        this.addRangeMeta(node, this.pointerState);\n        this.mergeMap(this.selection, this.temp);\n        this.zone.runTask(() => emitter.emit(this.generateRange(node, this.pointerState)));\n        this.temp.clear();\n        this.dragMode = false;\n        return true;\n      }\n\n      if (this.pointerState.shift) {\n        this.clearTextSelection();\n        this.restoreTextSelection();\n        this.addRangeMeta(node, this.pointerState);\n        emitter.emit(this.generateRange(node, this.pointerState));\n        return true;\n      }\n\n      if (this.pointerEventInGridBody) {\n        this.add(node);\n      }\n\n      return false;\n    }\n\n    selectRange(node, state, collection = this.selection) {\n      if (collection === this.temp) {\n        collection.clear();\n      }\n\n      const {\n        rowStart,\n        rowEnd,\n        columnStart,\n        columnEnd\n      } = this.generateRange(node, state);\n\n      for (let i = rowStart; i <= rowEnd; i++) {\n        for (let j = columnStart; j <= columnEnd; j++) {\n          if (collection.has(i)) {\n            collection.get(i).add(j);\n          } else {\n            collection.set(i, new Set()).get(i).add(j);\n          }\n        }\n      }\n    }\n\n    dragSelect(node, state) {\n      if (!this.pointerState.ctrl) {\n        this.selection.clear();\n      }\n\n      this.selectRange(node, state);\n    }\n\n    clear(clearAcriveEl = false) {\n      if (clearAcriveEl) {\n        this.activeElement = null;\n      }\n\n      this.selection.clear();\n      this.temp.clear();\n\n      this._ranges.clear();\n    }\n\n    clearTextSelection() {\n      const selection = window.getSelection();\n\n      if (selection.rangeCount) {\n        this._selectionRange = selection.getRangeAt(0);\n\n        this._selectionRange.collapse(true);\n\n        selection.removeAllRanges();\n      }\n    }\n\n    restoreTextSelection() {\n      const selection = window.getSelection();\n\n      if (!selection.rangeCount) {\n        selection.addRange(this._selectionRange || document.createRange());\n      }\n    }\n    /** Returns array of the selected row id's. */\n\n\n    getSelectedRows() {\n      return this.rowSelection.size ? Array.from(this.rowSelection.keys()) : [];\n    }\n    /** Returns array of the rows in indeterminate state. */\n\n\n    getIndeterminateRows() {\n      return this.indeterminateRows.size ? Array.from(this.indeterminateRows.keys()) : [];\n    }\n    /** Clears row selection, if filtering is applied clears only selected rows from filtered data. */\n\n\n    clearRowSelection(event) {\n      const removedRec = this.isFilteringApplied() ? this.getRowIDs(this.allData).filter(rID => this.isRowSelected(rID)) : this.getSelectedRows();\n      const newSelection = this.isFilteringApplied() ? this.getSelectedRows().filter(x => !removedRec.includes(x)) : [];\n      this.emitRowSelectionEvent(newSelection, [], removedRec, event);\n    }\n    /** Select all rows, if filtering is applied select only from filtered data. */\n\n\n    selectAllRows(event) {\n      const allRowIDs = this.getRowIDs(this.allData);\n      const addedRows = allRowIDs.filter(rID => !this.isRowSelected(rID));\n      const newSelection = this.rowSelection.size ? this.getSelectedRows().concat(addedRows) : addedRows;\n      this.indeterminateRows.clear();\n      this.emitRowSelectionEvent(newSelection, addedRows, [], event);\n    }\n    /** Select the specified row and emit event. */\n\n\n    selectRowById(rowID, clearPrevSelection, event) {\n      if (!(this.grid.isRowSelectable || this.grid.isPivot) || this.isRowDeleted(rowID)) {\n        return;\n      }\n\n      clearPrevSelection = !this.grid.isMultiRowSelectionEnabled || clearPrevSelection;\n      const selectedRows = this.getSelectedRows();\n      const newSelection = clearPrevSelection ? [rowID] : this.rowSelection.has(rowID) ? selectedRows : [...selectedRows, rowID];\n      const removed = clearPrevSelection ? selectedRows : [];\n      this.emitRowSelectionEvent(newSelection, [rowID], removed, event);\n    }\n    /** Deselect the specified row and emit event. */\n\n\n    deselectRow(rowID, event) {\n      if (!this.isRowSelected(rowID)) {\n        return;\n      }\n\n      const newSelection = this.getSelectedRows().filter(r => r !== rowID);\n\n      if (this.rowSelection.size && this.rowSelection.has(rowID)) {\n        this.emitRowSelectionEvent(newSelection, [], [rowID], event);\n      }\n    }\n    /** Select the specified rows and emit event. */\n\n\n    selectRows(keys, clearPrevSelection, event) {\n      if (!this.grid.isMultiRowSelectionEnabled) {\n        return;\n      }\n\n      const rowsToSelect = keys.filter(x => !this.isRowDeleted(x) && !this.rowSelection.has(x));\n\n      if (!rowsToSelect.length && !clearPrevSelection) {\n        // no valid/additional rows to select and no clear\n        return;\n      }\n\n      const selectedRows = this.getSelectedRows();\n      const newSelection = clearPrevSelection ? rowsToSelect : [...selectedRows, ...rowsToSelect];\n      const keysAsSet = new Set(rowsToSelect);\n      const removed = clearPrevSelection ? selectedRows.filter(x => !keysAsSet.has(x)) : [];\n      this.emitRowSelectionEvent(newSelection, rowsToSelect, removed, event);\n    }\n\n    deselectRows(keys, event) {\n      if (!this.rowSelection.size) {\n        return;\n      }\n\n      const rowsToDeselect = keys.filter(x => this.rowSelection.has(x));\n\n      if (!rowsToDeselect.length) {\n        return;\n      }\n\n      const keysAsSet = new Set(rowsToDeselect);\n      const newSelection = this.getSelectedRows().filter(r => !keysAsSet.has(r));\n      this.emitRowSelectionEvent(newSelection, [], rowsToDeselect, event);\n    }\n    /** Select specified rows. No event is emitted. */\n\n\n    selectRowsWithNoEvent(rowIDs, clearPrevSelection) {\n      if (clearPrevSelection) {\n        this.rowSelection.clear();\n      }\n\n      rowIDs.forEach(rowID => this.rowSelection.add(rowID));\n      this.allRowsSelected = undefined;\n      this.selectedRowsChange.next();\n    }\n    /** Deselect specified rows. No event is emitted. */\n\n\n    deselectRowsWithNoEvent(rowIDs) {\n      rowIDs.forEach(rowID => this.rowSelection.delete(rowID));\n      this.allRowsSelected = undefined;\n      this.selectedRowsChange.next();\n    }\n\n    isRowSelected(rowID) {\n      return this.rowSelection.size > 0 && this.rowSelection.has(rowID);\n    }\n\n    isPivotRowSelected(rowID) {\n      let contains = false;\n      this.rowSelection.forEach(x => {\n        const correctRowId = rowID.replace(x, '');\n\n        if (rowID.includes(x) && (correctRowId === '' || correctRowId.startsWith('_'))) {\n          contains = true;\n          return;\n        }\n      });\n      return this.rowSelection.size > 0 && contains;\n    }\n\n    isRowInIndeterminateState(rowID) {\n      return this.indeterminateRows.size > 0 && this.indeterminateRows.has(rowID);\n    }\n    /** Select range from last selected row to the current specified row. */\n\n\n    selectMultipleRows(rowID, rowData, event) {\n      this.allRowsSelected = undefined;\n\n      if (!this.rowSelection.size || this.isRowDeleted(rowID)) {\n        this.selectRowById(rowID);\n        return;\n      }\n\n      const gridData = this.allData;\n      const lastRowID = this.getSelectedRows()[this.rowSelection.size - 1];\n      const currIndex = gridData.indexOf(this.getRowDataById(lastRowID));\n      const newIndex = gridData.indexOf(rowData);\n      const rows = gridData.slice(Math.min(currIndex, newIndex), Math.max(currIndex, newIndex) + 1);\n      const added = this.getRowIDs(rows).filter(rID => !this.isRowSelected(rID));\n      const newSelection = this.getSelectedRows().concat(added);\n      this.emitRowSelectionEvent(newSelection, added, [], event);\n    }\n\n    areAllRowSelected() {\n      if (!this.grid.data) {\n        return false;\n      }\n\n      if (this.allRowsSelected !== undefined) {\n        return this.allRowsSelected;\n      }\n\n      const dataItemsID = this.getRowIDs(this.allData);\n      return this.allRowsSelected = Math.min(this.rowSelection.size, dataItemsID.length) > 0 && new Set(Array.from(this.rowSelection.values()).concat(dataItemsID)).size === this.rowSelection.size;\n    }\n\n    hasSomeRowSelected() {\n      const filteredData = this.isFilteringApplied() ? this.getRowIDs(this.grid.filteredData).some(rID => this.isRowSelected(rID)) : true;\n      return this.rowSelection.size > 0 && filteredData && !this.areAllRowSelected();\n    }\n\n    get filteredSelectedRowIds() {\n      return this.isFilteringApplied() ? this.getRowIDs(this.allData).filter(rowID => this.isRowSelected(rowID)) : this.getSelectedRows().filter(rowID => !this.isRowDeleted(rowID));\n    }\n\n    emitRowSelectionEvent(newSelection, added, removed, event) {\n      const currSelection = this.getSelectedRows();\n\n      if (this.areEqualCollections(currSelection, newSelection)) {\n        return;\n      }\n\n      const args = {\n        oldSelection: currSelection,\n        newSelection,\n        added,\n        removed,\n        event,\n        cancel: false\n      };\n      this.grid.rowSelectionChanging.emit(args);\n\n      if (args.cancel) {\n        return;\n      }\n\n      this.selectRowsWithNoEvent(args.newSelection, true);\n    }\n\n    getRowDataById(rowID) {\n      if (!this.grid.primaryKey) {\n        return rowID;\n      }\n\n      const rowIndex = this.getRowIDs(this.grid.gridAPI.get_all_data(true)).indexOf(rowID);\n      return rowIndex < 0 ? {} : this.grid.gridAPI.get_all_data(true)[rowIndex];\n    }\n\n    getRowIDs(data) {\n      return this.grid.primaryKey && data.length ? data.map(rec => rec[this.grid.primaryKey]) : data;\n    }\n\n    clearHeaderCBState() {\n      this.allRowsSelected = undefined;\n    }\n    /** Clear rowSelection and update checkbox state */\n\n\n    clearAllSelectedRows() {\n      this.rowSelection.clear();\n      this.indeterminateRows.clear();\n      this.clearHeaderCBState();\n      this.selectedRowsChange.next();\n    }\n    /** Returns all data in the grid, with applied filtering and sorting and without deleted rows. */\n\n\n    get allData() {\n      let allData;\n\n      if (this.isFilteringApplied() || this.grid.sortingExpressions.length) {\n        allData = this.grid.pinnedRecordsCount ? this.grid._filteredSortedUnpinnedData : this.grid.filteredSortedData;\n      } else {\n        allData = this.grid.gridAPI.get_all_data(true);\n      }\n\n      return allData.filter(rData => !this.isRowDeleted(this.grid.gridAPI.get_row_id(rData)));\n    }\n    /** Returns array of the selected columns fields. */\n\n\n    getSelectedColumns() {\n      return this.columnSelection.size ? Array.from(this.columnSelection.keys()) : [];\n    }\n\n    isColumnSelected(field) {\n      return this.columnSelection.size > 0 && this.columnSelection.has(field);\n    }\n    /** Select the specified column and emit event. */\n\n\n    selectColumn(field, clearPrevSelection, selectColumnsRange, event) {\n      const stateColumn = this.columnsState.field ? this.grid.getColumnByName(this.columnsState.field) : null;\n\n      if (!event || !stateColumn || stateColumn.visibleIndex < 0 || !selectColumnsRange) {\n        this.columnsState.field = field;\n        this.columnsState.range = [];\n        const newSelection = clearPrevSelection ? [field] : this.getSelectedColumns().indexOf(field) !== -1 ? this.getSelectedColumns() : [...this.getSelectedColumns(), field];\n        const removed = clearPrevSelection ? this.getSelectedColumns().filter(colField => colField !== field) : [];\n        const added = this.isColumnSelected(field) ? [] : [field];\n        this.emitColumnSelectionEvent(newSelection, added, removed, event);\n      } else if (selectColumnsRange) {\n        this.selectColumnsRange(field, event);\n      }\n    }\n    /** Select specified columns. And emit event. */\n\n\n    selectColumns(fields, clearPrevSelection, selectColumnsRange, event) {\n      const columns = fields.map(f => this.grid.getColumnByName(f)).sort((a, b) => a.visibleIndex - b.visibleIndex);\n      const stateColumn = this.columnsState.field ? this.grid.getColumnByName(this.columnsState.field) : null;\n\n      if (!stateColumn || stateColumn.visibleIndex < 0 || !selectColumnsRange) {\n        this.columnsState.field = columns[0] ? columns[0].field : null;\n        this.columnsState.range = [];\n        const added = fields.filter(colField => !this.isColumnSelected(colField));\n        const removed = clearPrevSelection ? this.getSelectedColumns().filter(colField => fields.indexOf(colField) === -1) : [];\n        const newSelection = clearPrevSelection ? fields : this.getSelectedColumns().concat(added);\n        this.emitColumnSelectionEvent(newSelection, added, removed, event);\n      } else {\n        const filedStart = stateColumn.visibleIndex > columns[columns.length - 1].visibleIndex ? columns[0].field : columns[columns.length - 1].field;\n        this.selectColumnsRange(filedStart, event);\n      }\n    }\n    /** Select range from last clicked column to the current specified column. */\n\n\n    selectColumnsRange(field, event) {\n      const currIndex = this.grid.getColumnByName(this.columnsState.field).visibleIndex;\n      const newIndex = this.grid.columnToVisibleIndex(field);\n      const columnsFields = this.grid.visibleColumns.filter(c => !c.columnGroup).sort((a, b) => a.visibleIndex - b.visibleIndex).slice(Math.min(currIndex, newIndex), Math.max(currIndex, newIndex) + 1).filter(col => col.selectable).map(col => col.field);\n      const removed = [];\n      const oldAdded = [];\n      const added = columnsFields.filter(colField => !this.isColumnSelected(colField));\n      this.columnsState.range.forEach(f => {\n        if (columnsFields.indexOf(f) === -1) {\n          removed.push(f);\n        } else {\n          oldAdded.push(f);\n        }\n      });\n      this.columnsState.range = columnsFields.filter(colField => !this.isColumnSelected(colField) || oldAdded.indexOf(colField) > -1);\n      const newSelection = this.getSelectedColumns().concat(added).filter(c => removed.indexOf(c) === -1);\n      this.emitColumnSelectionEvent(newSelection, added, removed, event);\n    }\n    /** Select specified columns. No event is emitted. */\n\n\n    selectColumnsWithNoEvent(fields, clearPrevSelection) {\n      if (clearPrevSelection) {\n        this.columnSelection.clear();\n      }\n\n      fields.forEach(field => {\n        this.columnSelection.add(field);\n      });\n    }\n    /** Deselect the specified column and emit event. */\n\n\n    deselectColumn(field, event) {\n      this.initColumnsState();\n      const newSelection = this.getSelectedColumns().filter(c => c !== field);\n      this.emitColumnSelectionEvent(newSelection, [], [field], event);\n    }\n    /** Deselect specified columns. No event is emitted. */\n\n\n    deselectColumnsWithNoEvent(fields) {\n      fields.forEach(field => this.columnSelection.delete(field));\n    }\n    /** Deselect specified columns. And emit event. */\n\n\n    deselectColumns(fields, event) {\n      const removed = this.getSelectedColumns().filter(colField => fields.indexOf(colField) > -1);\n      const newSelection = this.getSelectedColumns().filter(colField => fields.indexOf(colField) === -1);\n      this.emitColumnSelectionEvent(newSelection, [], removed, event);\n    }\n\n    emitColumnSelectionEvent(newSelection, added, removed, event) {\n      const currSelection = this.getSelectedColumns();\n\n      if (this.areEqualCollections(currSelection, newSelection)) {\n        return;\n      }\n\n      const args = {\n        oldSelection: currSelection,\n        newSelection,\n        added,\n        removed,\n        event,\n        cancel: false\n      };\n      this.grid.columnSelectionChanging.emit(args);\n\n      if (args.cancel) {\n        return;\n      }\n\n      this.selectColumnsWithNoEvent(args.newSelection, true);\n    }\n    /** Clear columnSelection */\n\n\n    clearAllSelectedColumns() {\n      this.columnSelection.clear();\n    }\n\n    areEqualCollections(first, second) {\n      return first.length === second.length && new Set(first.concat(second)).size === first.length;\n    }\n    /**\n     * (╯°□°）╯︵ ┻━┻\n     * Chrome and Chromium don't care about the active\n     * range after keyboard navigation, thus this.\n     */\n\n\n    _moveSelectionChrome(node) {\n      const selection = window.getSelection();\n      selection.removeAllRanges();\n      const range = new Range();\n      range.selectNode(node);\n      range.collapse(true);\n      selection.addRange(range);\n    }\n\n    isFilteringApplied() {\n      return !FilteringExpressionsTree.empty(this.grid.filteringExpressionsTree) || !FilteringExpressionsTree.empty(this.grid.advancedFilteringExpressionsTree);\n    }\n\n    isRowDeleted(rowID) {\n      return this.grid.gridAPI.row_deleted_transaction(rowID);\n    }\n\n  }\n\n  IgxGridSelectionService.ɵfac = function IgxGridSelectionService_Factory(t) {\n    return new (t || IgxGridSelectionService)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(PlatformUtil));\n  };\n\n  IgxGridSelectionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxGridSelectionService,\n    factory: IgxGridSelectionService.ɵfac\n  });\n  return IgxGridSelectionService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxRowDirective = /*#__PURE__*/(() => {\n  class IgxRowDirective {\n    constructor(grid, selectionService, element, cdr) {\n      this.grid = grid;\n      this.selectionService = selectionService;\n      this.element = element;\n      this.cdr = cdr;\n      /**\n       * @hidden\n       */\n\n      this.addAnimationEnd = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.role = 'row';\n      /**\n       * Sets whether this specific row has disabled functionality for editing and row selection.\n       * Default value is `false`.\n       * ```typescript\n       * this.grid.selectedRows[0].pinned = true;\n       * ```\n       */\n\n      this.disabled = false;\n      /**\n       * @hidden\n       */\n\n      this.focused = false;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this.defaultCssClass = 'igx-grid__tr';\n      /**\n       * @hidden\n       */\n\n      this.triggerAddAnimationClass = false;\n      this.destroy$ = new Subject();\n    }\n    /**\n     *  The data passed to the row component.\n     *\n     * ```typescript\n     * // get the row data for the first selected row\n     * let selectedRowData = this.grid.selectedRows[0].data;\n     * ```\n     */\n\n\n    get data() {\n      if (this.inEditMode) {\n        return mergeWith(this.grid.dataCloneStrategy.clone(this._data), this.grid.transactions.getAggregatedValue(this.key, false), (objValue, srcValue) => {\n          if (Array.isArray(srcValue)) {\n            return objValue = srcValue;\n          }\n        });\n      }\n\n      return this._data;\n    }\n\n    set data(v) {\n      this._data = v;\n    }\n    /**\n     * Sets whether the row is pinned.\n     * Default value is `false`.\n     * ```typescript\n     * this.grid.selectedRows[0].pinned = true;\n     * ```\n     */\n\n\n    set pinned(value) {\n      if (value) {\n        this.grid.pinRow(this.key);\n      } else {\n        this.grid.unpinRow(this.key);\n      }\n    }\n    /**\n     * Gets whether the row is pinned.\n     * ```typescript\n     * let isPinned = row.pinned;\n     * ```\n     */\n\n\n    get pinned() {\n      return this.grid.isRecordPinned(this.data);\n    }\n    /**\n     * Gets the expanded state of the row.\n     * ```typescript\n     * let isExpanded = row.expanded;\n     * ```\n     */\n\n\n    get expanded() {\n      return this.grid.gridAPI.get_row_expansion_state(this.data);\n    }\n    /**\n     * Expands/collapses the current row.\n     *\n     * ```typescript\n     * this.grid.selectedRows[2].expanded = true;\n     * ```\n     */\n\n\n    set expanded(val) {\n      this.grid.gridAPI.set_row_expansion_state(this.key, val);\n    }\n\n    get addRowUI() {\n      return !!this.grid.crudService.row && this.grid.crudService.row.getClassName() === IgxAddRow.name && this.grid.crudService.row.id === this.key;\n    }\n\n    get rowHeight() {\n      let height = this.grid.rowHeight || 32;\n\n      if (this.grid.hasColumnLayouts) {\n        const maxRowSpan = this.grid.multiRowLayoutRowSize;\n        height = height * maxRowSpan;\n      }\n\n      return this.addRowUI ? height : null;\n    }\n\n    get cellHeight() {\n      return this.addRowUI && !this.inEditMode ? null : this.grid.rowHeight || 32;\n    }\n\n    get virtDirRow() {\n      return this._virtDirRow ? this._virtDirRow.first : null;\n    }\n    /**\n     * Gets the rendered cells in the row component.\n     *\n     * ```typescript\n     * // get the cells of the third selected row\n     * let selectedRowCells = this.grid.selectedRows[2].cells;\n     * ```\n     */\n\n\n    get cells() {\n      const res = new QueryList();\n\n      if (!this._cells) {\n        return res;\n      }\n\n      const cList = this._cells.filter(item => item.nativeElement.parentElement !== null).sort((item1, item2) => item1.column.visibleIndex - item2.column.visibleIndex);\n\n      res.reset(cList);\n      return res;\n    }\n\n    get dataRowIndex() {\n      return this.index;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get selected() {\n      return this.selectionService.isRowSelected(this.key);\n    }\n\n    set selected(value) {\n      if (value) {\n        this.selectionService.selectRowsWithNoEvent([this.key]);\n      } else {\n        this.selectionService.deselectRowsWithNoEvent([this.key]);\n      }\n\n      this.grid.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    get columns() {\n      return this.grid.visibleColumns;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get viewIndex() {\n      if (this.grid.groupingExpressions.length) {\n        return this.grid.filteredSortedData.indexOf(this.data);\n      }\n\n      return this.index + this.grid.page * this.grid.perPage;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get pinnedColumns() {\n      return this.grid.pinnedColumns;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isRoot() {\n      return true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hasChildren() {\n      return false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get unpinnedColumns() {\n      return this.grid.unpinnedColumns;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get showRowSelectors() {\n      return this.grid.showRowSelectors;\n    }\n    /** @hidden */\n\n\n    get dirty() {\n      const row = this.grid.transactions.getState(this.key);\n\n      if (row) {\n        return row.type === TransactionType.ADD || row.type === TransactionType.UPDATE;\n      }\n\n      return false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get rowDraggable() {\n      return this.grid.rowDraggable;\n    }\n    /** @hidden */\n\n\n    get added() {\n      const row = this.grid.transactions.getState(this.key);\n\n      if (row) {\n        return row.type === TransactionType.ADD;\n      }\n\n      return false;\n    }\n    /** @hidden */\n\n\n    get deleted() {\n      return this.grid.gridAPI.row_deleted_transaction(this.key);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get dragging() {\n      return this.grid.dragRowID === this.key;\n    } // TODO: Refactor\n\n\n    get inEditMode() {\n      if (this.grid.rowEditable) {\n        const editRowState = this.grid.crudService.row;\n        return editRowState && editRowState.id === this.key || false;\n      } else {\n        return false;\n      }\n    }\n    /**\n     * Gets the ID of the row.\n     * A row in the grid is identified either by:\n     * - primaryKey data value,\n     * - the whole data, if the primaryKey is omitted.\n     *\n     * ```typescript\n     * let rowID = this.grid.selectedRows[2].key;\n     * ```\n     */\n\n\n    get key() {\n      const primaryKey = this.grid.primaryKey;\n\n      if (this._data) {\n        return primaryKey ? this._data[primaryKey] : this._data;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * The native DOM element representing the row. Could be null in certain environments.\n     *\n     * ```typescript\n     * // get the nativeElement of the second selected row\n     * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;\n     * ```\n     */\n\n\n    get nativeElement() {\n      return this.element.nativeElement;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onClick(event) {\n      if (this.grid.rowSelection === 'none' || this.deleted || !this.grid.selectRowOnClick) {\n        return;\n      }\n\n      if (event.shiftKey && this.grid.isMultiRowSelectionEnabled) {\n        this.selectionService.selectMultipleRows(this.key, this.data, event);\n        return;\n      } // eslint-disable-next-line no-bitwise\n\n\n      const clearSelection = !(+event.ctrlKey ^ +event.metaKey);\n      this.selectionService.selectRowById(this.key, clearSelection, event);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    showActionStrip() {\n      if (this.grid.actionStrip) {\n        this.grid.actionStrip.show(this);\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    ngAfterViewInit() {\n      // If the template of the row changes, the forOf in it is recreated and is not detected by the grid and rows can't be scrolled.\n      this._virtDirRow.changes.pipe(takeUntil(this.destroy$)).subscribe(() => this.grid.resetHorizontalVirtualization());\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    ngOnDestroy() {\n      this.destroy$.next(true);\n      this.destroy$.complete();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onRowSelectorClick(event) {\n      event.stopPropagation();\n\n      if (event.shiftKey && this.grid.isMultiRowSelectionEnabled) {\n        this.selectionService.selectMultipleRows(this.key, this.data, event);\n        return;\n      }\n\n      if (this.selected) {\n        this.selectionService.deselectRow(this.key, event);\n      } else {\n        this.selectionService.selectRowById(this.key, false, event);\n      }\n    }\n    /**\n     * Updates the specified row object and the data source record with the passed value.\n     *\n     * ```typescript\n     * // update the second selected row's value\n     * let newValue = \"Apple\";\n     * this.grid.selectedRows[1].update(newValue);\n     * ```\n     */\n\n\n    update(value) {\n      const crudService = this.grid.crudService;\n\n      if (crudService.cellInEditMode && crudService.cell.id.key === this.key) {\n        this.grid.transactions.endPending(false);\n      }\n\n      const row = new IgxEditRow(this.key, this.index, this.data, this.grid);\n      this.grid.gridAPI.update_row(row, value);\n      this.cdr.markForCheck();\n    }\n    /**\n     * Removes the specified row from the grid's data source.\n     * This method emits `rowDeleted` event.\n     *\n     * ```typescript\n     * // delete the third selected row from the grid\n     * this.grid.selectedRows[2].delete();\n     * ```\n     */\n\n\n    delete() {\n      this.grid.deleteRowById(this.key);\n    }\n\n    isCellActive(visibleColumnIndex) {\n      const node = this.grid.navigation.activeNode;\n      return node ? node.row === this.index && node.column === visibleColumnIndex : false;\n    }\n    /**\n     * Pins the specified row.\n     * This method emits `rowPinning`\\`rowPinned` event.\n     *\n     * ```typescript\n     * // pin the selected row from the grid\n     * this.grid.selectedRows[0].pin();\n     * ```\n     */\n\n\n    pin() {\n      return this.grid.pinRow(this.key);\n    }\n    /**\n     * Unpins the specified row.\n     * This method emits `rowPinning`\\`rowPinned` event.\n     *\n     * ```typescript\n     * // unpin the selected row from the grid\n     * this.grid.selectedRows[0].unpin();\n     * ```\n     */\n\n\n    unpin() {\n      return this.grid.unpinRow(this.key);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get rowCheckboxAriaLabel() {\n      return this.grid.primaryKey ? this.selected ? 'Deselect row with key ' + this.key : 'Select row with key ' + this.key : this.selected ? 'Deselect row' : 'Select row';\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngDoCheck() {\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    shouldDisplayPinnedChip(visibleColumnIndex) {\n      return this.pinned && this.disabled && visibleColumnIndex === 0;\n    }\n    /**\n     * Spawns the add row UI for the specific row.\n     *\n     * @example\n     * ```typescript\n     * const row = this.grid1.getRowByIndex(1);\n     * row.beginAddRow();\n     * ```\n     */\n\n\n    beginAddRow() {\n      this.grid.crudService.enterAddRowMode(this);\n    }\n    /**\n     * @hidden\n     */\n\n\n    triggerAddAnimation() {\n      this.triggerAddAnimationClass = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    animationEndHandler() {\n      this.triggerAddAnimationClass = false;\n      this.addAnimationEnd.emit(this);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get resolveDragIndicatorClasses() {\n      const defaultDragIndicatorCssClass = 'igx-grid__drag-indicator';\n      const dragIndicatorOff = this.grid.rowDragging && !this.dragging ? 'igx-grid__drag-indicator--off' : '';\n      return `${defaultDragIndicatorCssClass} ${dragIndicatorOff}`;\n    }\n\n  }\n\n  IgxRowDirective.ɵfac = function IgxRowDirective_Factory(t) {\n    return new (t || IgxRowDirective)(i0.ɵɵdirectiveInject(IGX_GRID_BASE), i0.ɵɵdirectiveInject(IgxGridSelectionService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  IgxRowDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxRowDirective,\n    selectors: [[\"\", \"igxRowBaseComponent\", \"\"]],\n    viewQuery: function IgxRowDirective_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxCheckboxComponent, 5, IgxCheckboxComponent);\n        i0.ɵɵviewQuery(_c21, 5, IgxGridForOfDirective);\n        i0.ɵɵviewQuery(_c22, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.checkboxElement = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._virtDirRow = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._cells = _t);\n      }\n    },\n    hostVars: 8,\n    hostBindings: function IgxRowDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function IgxRowDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        })(\"mouseenter\", function IgxRowDirective_mouseenter_HostBindingHandler() {\n          return ctx.showActionStrip();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"aria-disabled\", ctx.disabled)(\"data-rowIndex\", ctx.dataRowIndex)(\"aria-selected\", ctx.selected);\n        i0.ɵɵstyleProp(\"min-height\", ctx.rowHeight, \"px\");\n        i0.ɵɵclassProp(\"igx-grid__tr--disabled\", ctx.disabled);\n      }\n    },\n    inputs: {\n      data: \"data\",\n      index: \"index\",\n      disabled: \"disabled\",\n      gridID: \"gridID\",\n      selected: \"selected\"\n    },\n    outputs: {\n      addAnimationEnd: \"addAnimationEnd\"\n    }\n  });\n  return IgxRowDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridActionsBaseDirective = /*#__PURE__*/(() => {\n  class IgxGridActionsBaseDirective {\n    constructor(iconService, differs) {\n      this.iconService = iconService;\n      this.differs = differs;\n      /**\n       * Gets/Sets if the action buttons will be rendered as menu items. When in menu, items will be rendered with text label.\n       *\n       * @example\n       * ```html\n       *  <igx-grid-pinning-actions [asMenuItems]='true'></igx-grid-pinning-actions>\n       *  <igx-grid-editing-actions [asMenuItems]='true'></igx-grid-editing-actions>\n       * ```\n       */\n\n      this.asMenuItems = false;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get grid() {\n      return this.strip.context.grid;\n    }\n    /**\n     * Getter to be used in template\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    get isRowContext() {\n      return this.isRow(this.strip.context) && !this.strip.context.inEditMode;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    ngAfterViewInit() {\n      if (this.asMenuItems) {\n        this.buttons.changes.subscribe(() => {\n          this.strip.cdr.detectChanges();\n        });\n      }\n    }\n    /**\n     * Check if the param is a row from a grid\n     *\n     * @hidden\n     * @internal\n     * @param context\n     */\n\n\n    isRow(context) {\n      return context && context instanceof IgxRowDirective;\n    }\n\n  }\n\n  IgxGridActionsBaseDirective.ɵfac = function IgxGridActionsBaseDirective_Factory(t) {\n    return new (t || IgxGridActionsBaseDirective)(i0.ɵɵdirectiveInject(IgxIconService), i0.ɵɵdirectiveInject(i0.IterableDiffers));\n  };\n\n  IgxGridActionsBaseDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxGridActionsBaseDirective,\n    selectors: [[\"\", \"igxGridActionsBase\", \"\"]],\n    viewQuery: function IgxGridActionsBaseDirective_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxGridActionButtonComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.buttons = _t);\n      }\n    },\n    inputs: {\n      asMenuItems: \"asMenuItems\"\n    }\n  });\n  return IgxGridActionsBaseDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridEditingActionsComponent = /*#__PURE__*/(() => {\n  class IgxGridEditingActionsComponent extends IgxGridActionsBaseDirective {\n    constructor() {\n      super(...arguments);\n      /**\n       * Host `class.igx-action-strip` binding.\n       *\n       * @hidden\n       * @internal\n       */\n\n      this.cssClass = 'igx-action-strip__editing-actions';\n      /**\n       * An input to enable/disable action strip child row adding button\n       */\n\n      this.addChild = false;\n      this.isMessageShown = false;\n      this._addRow = false;\n      this.iconsRendered = false;\n    }\n    /**\n     * An input to enable/disable action strip row adding button\n     */\n\n\n    set addRow(value) {\n      this._addRow = value;\n    }\n\n    get addRow() {\n      if (!this.iconsRendered) {\n        this.registerIcons();\n        this.iconsRendered = true;\n      }\n\n      return this._addRow;\n    }\n    /**\n     * Getter if the row is disabled\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    get disabled() {\n      if (!this.isRow(this.strip.context)) {\n        return;\n      }\n\n      return this.strip.context.disabled;\n    }\n    /**\n     * Getter if the row is root.\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    get isRootRow() {\n      if (!this.isRow(this.strip.context)) {\n        return false;\n      }\n\n      return this.strip.context.isRoot;\n    }\n\n    get hasChildren() {\n      if (!this.isRow(this.strip.context)) {\n        return false;\n      }\n\n      return this.strip.context.hasChildren;\n    }\n    /**\n     * Enter row or cell edit mode depending the grid rowEditable option\n     *\n     * @example\n     * ```typescript\n     * this.gridEditingActions.startEdit();\n     * ```\n     */\n\n\n    startEdit(event) {\n      if (event) {\n        event.stopPropagation();\n      }\n\n      if (!this.isRow(this.strip.context)) {\n        return;\n      }\n\n      const row = this.strip.context;\n      const firstEditable = row.cells.filter(cell => cell.editable)[0];\n      const grid = row.grid;\n\n      if (!grid.hasEditableColumns) {\n        this.isMessageShown = showMessage('The grid should be editable in order to use IgxGridEditingActionsComponent', this.isMessageShown);\n        return;\n      } // be sure row is in view\n\n\n      if (grid.rowList.filter(r => r === row).length !== 0) {\n        grid.gridAPI.crudService.enterEditMode(firstEditable, event);\n        firstEditable.activate(event);\n      }\n\n      this.strip.hide();\n    }\n    /**\n     * Delete a row according to the context\n     *\n     * @example\n     * ```typescript\n     * this.gridEditingActions.deleteRow();\n     * ```\n     */\n\n\n    deleteRow(event) {\n      if (event) {\n        event.stopPropagation();\n      }\n\n      if (!this.isRow(this.strip.context)) {\n        return;\n      }\n\n      const context = this.strip.context;\n      const grid = context.grid;\n      grid.deleteRow(context.key);\n      this.strip.hide();\n    }\n\n    addRowHandler(event, asChild) {\n      if (event) {\n        event.stopPropagation();\n      }\n\n      if (!this.isRow(this.strip.context)) {\n        return;\n      }\n\n      const context = this.strip.context;\n      const grid = context.grid;\n\n      if (!grid.rowEditable) {\n        console.warn('The grid must use row edit mode to perform row adding! Please set rowEditable to true.');\n        return;\n      }\n\n      grid.gridAPI.crudService.enterAddRowMode(context, asChild, event);\n      this.strip.hide();\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    registerIcons() {\n      this.iconService.addSvgIconFromText(addRow.name, addRow.value, 'imx-icons', true);\n      this.iconService.addSvgIconFromText(addChild.name, addChild.value, 'imx-icons', true);\n    }\n\n  }\n\n  IgxGridEditingActionsComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxGridEditingActionsComponent_BaseFactory;\n    return function IgxGridEditingActionsComponent_Factory(t) {\n      return (ɵIgxGridEditingActionsComponent_BaseFactory || (ɵIgxGridEditingActionsComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxGridEditingActionsComponent)))(t || IgxGridEditingActionsComponent);\n    };\n  }();\n\n  IgxGridEditingActionsComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxGridEditingActionsComponent,\n    selectors: [[\"igx-grid-editing-actions\"]],\n    hostVars: 2,\n    hostBindings: function IgxGridEditingActionsComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-action-strip__editing-actions\", ctx.cssClass);\n      }\n    },\n    inputs: {\n      addRow: \"addRow\",\n      addChild: \"addChild\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxGridActionsBaseDirective,\n      useExisting: IgxGridEditingActionsComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngIf\"], [\"iconName\", \"edit\", 3, \"asMenuItem\", \"labelText\", \"actionClick\", 4, \"ngIf\"], [\"iconName\", \"add-row\", \"iconSet\", \"imx-icons\", 3, \"asMenuItem\", \"labelText\", \"actionClick\", 4, \"ngIf\"], [\"iconName\", \"add-child\", \"iconSet\", \"imx-icons\", 3, \"asMenuItem\", \"labelText\", \"actionClick\", 4, \"ngIf\"], [\"class\", \"igx-action-strip__delete\", \"classNames\", \"igx-action-strip__menu-item--danger\", \"iconName\", \"delete\", 3, \"asMenuItem\", \"labelText\", \"actionClick\", 4, \"ngIf\"], [\"iconName\", \"edit\", 3, \"asMenuItem\", \"labelText\", \"actionClick\"], [\"iconName\", \"add-row\", \"iconSet\", \"imx-icons\", 3, \"asMenuItem\", \"labelText\", \"actionClick\"], [\"iconName\", \"add-child\", \"iconSet\", \"imx-icons\", 3, \"asMenuItem\", \"labelText\", \"actionClick\"], [\"classNames\", \"igx-action-strip__menu-item--danger\", \"iconName\", \"delete\", 1, \"igx-action-strip__delete\", 3, \"asMenuItem\", \"labelText\", \"actionClick\"]],\n    template: function IgxGridEditingActionsComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxGridEditingActionsComponent_ng_container_0_Template, 5, 4, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.isRowContext);\n      }\n    },\n    directives: [IgxGridActionButtonComponent, i4.NgIf],\n    encapsulation: 2\n  });\n  return IgxGridEditingActionsComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridPinningActionsComponent = /*#__PURE__*/(() => {\n  class IgxGridPinningActionsComponent extends IgxGridActionsBaseDirective {\n    constructor() {\n      super(...arguments);\n      /**\n       * Host `class.igx-action-strip` binding.\n       *\n       * @hidden\n       * @internal\n       */\n\n      this.cssClass = 'igx-action-strip__pinning-actions';\n      this.iconsRendered = false;\n    }\n    /**\n     * Getter to know if the row is pinned\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    get pinned() {\n      if (!this.isRow(this.strip.context)) {\n        return;\n      }\n\n      const context = this.strip.context;\n\n      if (context && !this.iconsRendered) {\n        this.registerSVGIcons();\n        this.iconsRendered = true;\n      }\n\n      return context && context.pinned;\n    }\n    /**\n     * Getter to know if the row is in pinned and ghost\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    get inPinnedArea() {\n      if (!this.isRow(this.strip.context)) {\n        return;\n      }\n\n      const context = this.strip.context;\n      return this.pinned && !context.disabled;\n    }\n    /**\n     * Getter to know if the row pinning is set to top or bottom\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    get pinnedTop() {\n      if (!this.isRow(this.strip.context)) {\n        return;\n      }\n\n      return this.strip.context.grid.isRowPinningToTop;\n    }\n    /**\n     * Pin the row according to the context.\n     *\n     * @example\n     * ```typescript\n     * this.gridPinningActions.pin();\n     * ```\n     */\n\n\n    pin(event) {\n      if (event) {\n        event.stopPropagation();\n      }\n\n      if (!this.isRow(this.strip.context)) {\n        return;\n      }\n\n      const row = this.strip.context;\n      const grid = row.grid;\n      grid.pinRow(row.key);\n      this.strip.hide();\n    }\n    /**\n     * Unpin the row according to the context.\n     *\n     * @example\n     * ```typescript\n     * this.gridPinningActions.unpin();\n     * ```\n     */\n\n\n    unpin(event) {\n      if (event) {\n        event.stopPropagation();\n      }\n\n      if (!this.isRow(this.strip.context)) {\n        return;\n      }\n\n      const row = this.strip.context;\n      const grid = row.grid;\n      grid.unpinRow(row.key);\n      this.strip.hide();\n    }\n\n    scrollToRow(event) {\n      if (event) {\n        event.stopPropagation();\n      }\n\n      const context = this.strip.context;\n      const grid = context.grid;\n      grid.scrollTo(context.data, 0);\n      this.strip.hide();\n    }\n\n    registerSVGIcons() {\n      if (!this.isRow(this.strip.context)) {\n        return;\n      }\n\n      const context = this.strip.context;\n      const grid = context.grid;\n\n      if (grid) {\n        this.iconService.addSvgIconFromText(pinLeft.name, pinLeft.value, 'imx-icons', true);\n        this.iconService.addSvgIconFromText(unpinLeft.name, unpinLeft.value, 'imx-icons', true);\n        this.iconService.addSvgIconFromText(jumpDown.name, jumpDown.value, 'imx-icons', true);\n        this.iconService.addSvgIconFromText(jumpUp.name, jumpDown.value, 'imx-icons', true);\n      }\n    }\n\n  }\n\n  IgxGridPinningActionsComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxGridPinningActionsComponent_BaseFactory;\n    return function IgxGridPinningActionsComponent_Factory(t) {\n      return (ɵIgxGridPinningActionsComponent_BaseFactory || (ɵIgxGridPinningActionsComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxGridPinningActionsComponent)))(t || IgxGridPinningActionsComponent);\n    };\n  }();\n\n  IgxGridPinningActionsComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxGridPinningActionsComponent,\n    selectors: [[\"igx-grid-pinning-actions\"]],\n    hostVars: 2,\n    hostBindings: function IgxGridPinningActionsComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-action-strip__pinning-actions\", ctx.cssClass);\n      }\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxGridActionsBaseDirective,\n      useExisting: IgxGridPinningActionsComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngIf\"], [\"iconSet\", \"imx-icons\", \"iconName\", \"jump-down\", 3, \"asMenuItem\", \"labelText\", \"actionClick\", 4, \"ngIf\"], [\"iconSet\", \"imx-icons\", \"iconName\", \"jump-up\", 3, \"asMenuItem\", \"labelText\", \"actionClick\", 4, \"ngIf\"], [\"iconSet\", \"imx-icons\", \"iconName\", \"pin-left\", 3, \"asMenuItem\", \"labelText\", \"actionClick\", 4, \"ngIf\"], [\"iconSet\", \"imx-icons\", \"iconName\", \"unpin-left\", 3, \"asMenuItem\", \"labelText\", \"actionClick\", 4, \"ngIf\"], [\"iconSet\", \"imx-icons\", \"iconName\", \"jump-down\", 3, \"asMenuItem\", \"labelText\", \"actionClick\"], [\"iconSet\", \"imx-icons\", \"iconName\", \"jump-up\", 3, \"asMenuItem\", \"labelText\", \"actionClick\"], [\"iconSet\", \"imx-icons\", \"iconName\", \"pin-left\", 3, \"asMenuItem\", \"labelText\", \"actionClick\"], [\"iconSet\", \"imx-icons\", \"iconName\", \"unpin-left\", 3, \"asMenuItem\", \"labelText\", \"actionClick\"]],\n    template: function IgxGridPinningActionsComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxGridPinningActionsComponent_ng_container_0_Template, 5, 4, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.isRowContext);\n      }\n    },\n    directives: [IgxGridActionButtonComponent, i4.NgIf],\n    encapsulation: 2\n  });\n  return IgxGridPinningActionsComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxActionStripMenuItemDirective = /*#__PURE__*/(() => {\n  class IgxActionStripMenuItemDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  IgxActionStripMenuItemDirective.ɵfac = function IgxActionStripMenuItemDirective_Factory(t) {\n    return new (t || IgxActionStripMenuItemDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxActionStripMenuItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxActionStripMenuItemDirective,\n    selectors: [[\"\", \"igxActionStripMenuItem\", \"\"]]\n  });\n  return IgxActionStripMenuItemDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Action Strip provides templatable area for one or more actions.\n *\n * @igxModule IgxActionStripModule\n *\n * @igxTheme igx-action-strip-theme\n *\n * @igxKeywords action, strip, actionStrip, pinning, editing\n *\n * @igxGroup Data Entry & Display\n *\n * @remarks\n * The Ignite UI Action Strip is a container, overlaying its parent container,\n * and displaying action buttons with action applicable to the parent component the strip is instantiated or shown for.\n *\n * @example\n * ```html\n * <igx-action-strip #actionStrip>\n *     <igx-icon (click)=\"doSomeAction()\"></igx-icon>\n * </igx-action-strip>\n */\n\n\nlet IgxActionStripComponent = /*#__PURE__*/(() => {\n  class IgxActionStripComponent extends DisplayDensityBase {\n    constructor(_viewContainer, renderer, _displayDensityOptions, cdr) {\n      super(_displayDensityOptions);\n      this._viewContainer = _viewContainer;\n      this.renderer = renderer;\n      this._displayDensityOptions = _displayDensityOptions;\n      this.cdr = cdr;\n      /**\n       * Getter for menu overlay settings\n       *\n       * @hidden\n       * @internal\n       */\n\n      this.menuOverlaySettings = {\n        scrollStrategy: new CloseScrollStrategy()\n      };\n      this._hidden = false;\n    }\n    /**\n     * An @Input property that set the visibility of the Action Strip.\n     * Could be used to set if the Action Strip will be initially hidden.\n     *\n     * @example\n     * ```html\n     *  <igx-action-strip [hidden]=\"false\">\n     * ```\n     */\n\n\n    set hidden(value) {\n      this._hidden = value;\n    }\n\n    get hidden() {\n      return this._hidden;\n    }\n    /**\n     * Gets/Sets the resource strings.\n     *\n     * @remarks\n     * By default it uses EN resources.\n     */\n\n\n    set resourceStrings(value) {\n      this._resourceStrings = Object.assign({}, this._resourceStrings, value);\n    }\n\n    get resourceStrings() {\n      if (!this._resourceStrings) {\n        this._resourceStrings = CurrentResourceStrings.ActionStripResourceStrings;\n      }\n\n      return this._resourceStrings;\n    }\n    /**\n     * Getter for the 'display' property of the current `IgxActionStrip`\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    get display() {\n      return this._hidden ? 'none' : 'flex';\n    }\n    /**\n     * Host `attr.class` binding.\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    get hostClasses() {\n      const classes = [this.getComponentDensityClass('igx-action-strip')]; // The custom classes should be at the end.\n\n      if (!classes.includes('igx-action-strip')) {\n        classes.push('igx-action-strip');\n      }\n\n      classes.push(this.hostClass);\n      return classes.join(' ');\n    }\n    /**\n     * Menu Items list.\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    get menuItems() {\n      const actions = [];\n      this.actionButtons.forEach(button => {\n        if (button.asMenuItems) {\n          const children = button.buttons;\n\n          if (children) {\n            children.toArray().forEach(x => actions.push(x));\n          }\n        }\n      });\n      return [...this._menuItems.toArray(), ...actions];\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    ngAfterContentInit() {\n      this.actionButtons.forEach(button => {\n        button.strip = this;\n      });\n      this.actionButtons.changes.subscribe(() => {\n        this.actionButtons.forEach(button => {\n          button.strip = this;\n        });\n      });\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    ngAfterViewInit() {\n      this.menu.selectionChanging.subscribe($event => {\n        const newSelection = $event.newSelection.elementRef.nativeElement;\n        let allButtons = [];\n        this.actionButtons.forEach(actionButtons => {\n          if (actionButtons.asMenuItems) {\n            allButtons = [...allButtons, ...actionButtons.buttons.toArray()];\n          }\n        });\n        const button = allButtons.find(x => newSelection.contains(x.container.nativeElement));\n\n        if (button) {\n          button.actionClick.emit();\n        }\n      });\n    }\n    /**\n     * Showing the Action Strip and appending it the specified context element.\n     *\n     * @param context\n     * @example\n     * ```typescript\n     * this.actionStrip.show(row);\n     * ```\n     */\n\n\n    show(context) {\n      this.hidden = false;\n\n      if (!context) {\n        return;\n      } // when shown for different context make sure the menu won't stay opened\n\n\n      if (this.context !== context) {\n        this.closeMenu();\n      }\n\n      this.context = context;\n\n      if (this.context && this.context.element) {\n        this.renderer.appendChild(context.element.nativeElement, this._viewContainer.element.nativeElement);\n      }\n\n      this.cdr.detectChanges();\n    }\n    /**\n     * Hiding the Action Strip and removing it from its current context element.\n     *\n     * @example\n     * ```typescript\n     * this.actionStrip.hide();\n     * ```\n     */\n\n\n    hide() {\n      this.hidden = true;\n      this.closeMenu();\n\n      if (this.context && this.context.element) {\n        this.renderer.removeChild(this.context.element.nativeElement, this._viewContainer.element.nativeElement);\n      }\n    }\n    /**\n     * Close the menu if opened\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    closeMenu() {\n      if (this.menu && !this.menu.collapsed) {\n        this.menu.close();\n      }\n    }\n\n  }\n\n  IgxActionStripComponent.ɵfac = function IgxActionStripComponent_Factory(t) {\n    return new (t || IgxActionStripComponent)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DisplayDensityToken, 8), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  IgxActionStripComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxActionStripComponent,\n    selectors: [[\"igx-action-strip\"]],\n    contentQueries: function IgxActionStripComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxActionStripMenuItemDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, IgxGridActionsBaseDirective, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._menuItems = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.actionButtons = _t);\n      }\n    },\n    viewQuery: function IgxActionStripComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c23, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.menu = _t.first);\n      }\n    },\n    hostVars: 3,\n    hostBindings: function IgxActionStripComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"class\", ctx.hostClasses);\n        i0.ɵɵstyleProp(\"display\", ctx.display);\n      }\n    },\n    inputs: {\n      context: \"context\",\n      hidden: \"hidden\",\n      hostClass: [\"class\", \"hostClass\"],\n      resourceStrings: \"resourceStrings\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c8,\n    decls: 6,\n    vars: 3,\n    consts: [[1, \"igx-action-strip__actions\"], [4, \"ngIf\"], [3, \"displayDensity\"], [\"dropdown\", \"\"], [\"class\", \"igx-action-strip__menu-item\", 4, \"ngFor\", \"ngForOf\"], [\"igxButton\", \"icon\", \"igxRipple\", \"\", 3, \"igxToggleAction\", \"overlaySettings\", \"title\", \"igxDropDownItemNavigation\", \"click\"], [1, \"igx-action-strip__menu-item\"], [1, \"igx-drop-down__item-template\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function IgxActionStripComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵprojection(1, 0, [\"#content\", \"\"]);\n        i0.ɵɵtemplate(2, IgxActionStripComponent_ng_container_2_Template, 4, 4, \"ng-container\", 1);\n        i0.ɵɵelementStart(3, \"igx-drop-down\", 2, 3);\n        i0.ɵɵtemplate(5, IgxActionStripComponent_igx_drop_down_item_5_Template, 3, 4, \"igx-drop-down-item\", 4);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.menuItems.length > 0);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"displayDensity\", ctx.displayDensity);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngForOf\", ctx.menuItems);\n      }\n    },\n    directives: [IgxIconComponent, IgxDropDownComponent, IgxDropDownItemComponent, i4.NgIf, IgxButtonDirective, IgxRippleDirective, IgxToggleActionDirective, IgxDropDownItemNavigationDirective, i4.NgForOf, i4.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return IgxActionStripComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxActionStripModule = /*#__PURE__*/(() => {\n  class IgxActionStripModule {}\n\n  IgxActionStripModule.ɵfac = function IgxActionStripModule_Factory(t) {\n    return new (t || IgxActionStripModule)();\n  };\n\n  IgxActionStripModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxActionStripModule\n  });\n  IgxActionStripModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, IgxDropDownModule, IgxToggleModule, IgxButtonModule, IgxIconModule, IgxRippleModule]]\n  });\n  return IgxActionStripModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$p = 0;\nconst IgxAvatarSize = mkenum({\n  SMALL: 'small',\n  MEDIUM: 'medium',\n  LARGE: 'large'\n});\nconst IgxAvatarType = mkenum({\n  INITIALS: 'initials',\n  IMAGE: 'image',\n  ICON: 'icon',\n  CUSTOM: 'custom'\n});\n/**\n * Avatar provides a way to display an image, icon or initials to the user.\n *\n * @igxModule IgxAvatarModule\n *\n * @igxTheme igx-avatar-theme, igx-icon-theme\n *\n * @igxKeywords avatar, profile, picture, initials\n *\n * @igxGroup Layouts\n *\n * @remarks\n *\n * The Ignite UI Avatar provides an easy way to add an avatar icon to your application.  This icon can be an\n * image, someone's initials or a material icon from the Google Material icon set.\n *\n * @example\n * ```html\n * <igx-avatar initials=\"MS\" [roundShape]=\"true\" size=\"large\">\n * </igx-avatar>\n * ```\n */\n\nlet IgxAvatarComponent = /*#__PURE__*/(() => {\n  class IgxAvatarComponent {\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n      /**\n       * Returns the `aria-label` attribute of the avatar.\n       *\n       * @example\n       * ```typescript\n       * let ariaLabel = this.avatar.ariaLabel;\n       * ```\n       *\n       */\n\n      this.ariaLabel = 'avatar';\n      /**\n       * Returns the `role` attribute of the avatar.\n       *\n       * @example\n       * ```typescript\n       * let avatarRole = this.avatar.role;\n       * ```\n       */\n\n      this.role = 'img';\n      /**\n       * Host `class.igx-avatar` binding.\n       *\n       * @hidden\n       * @internal\n       */\n\n      this.cssClass = 'igx-avatar';\n      /**\n       * Sets the `id` of the avatar. If not set, the first avatar component will have `id` = `\"igx-avatar-0\"`.\n       *\n       * @example\n       * ```html\n       * <igx-avatar id=\"my-first-avatar\"></igx-avatar>\n       * ```\n       */\n\n      this.id = `igx-avatar-${NEXT_ID$p++}`;\n      /**\n       * Sets a round shape to the avatar, if `[roundShape]` is set to `true`.\n       * By default the shape of the avatar is a square.\n       *\n       * @example\n       * ```html\n       * <igx-avatar [roundShape]=\"true\" ></igx-avatar>\n       * ```\n       */\n\n      this.roundShape = false;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this._size = IgxAvatarSize.SMALL;\n    }\n    /**\n     * Returns the size of the avatar.\n     *\n     * @example\n     * ```typescript\n     * let avatarSize = this.avatar.size;\n     * ```\n     */\n\n\n    get size() {\n      return this._size;\n    }\n    /**\n     * Sets the size  of the avatar.\n     * By default, the size is `\"small\"`. It can be set to `\"medium\"` or `\"large\"`.\n     *\n     * @example\n     * ```html\n     * <igx-avatar size=\"large\"></igx-avatar>\n     * ```\n     */\n\n\n    set size(value) {\n      switch (value) {\n        case 'small':\n        case 'medium':\n        case 'large':\n          this._size = value;\n          break;\n\n        default:\n          this._size = 'small';\n      }\n    }\n    /** @hidden @internal */\n\n\n    get _isSmallSize() {\n      return this.size === 'small';\n    }\n    /** @hidden @internal */\n\n\n    get _isMediumSize() {\n      return this.size === 'medium';\n    }\n    /** @hidden @internal */\n\n\n    get _isLargeSize() {\n      return this.size === 'large';\n    }\n    /**\n     * Returns the type of the avatar.\n     *\n     * @example\n     * ```typescript\n     * let avatarType = this.avatar.type;\n     * ```\n     */\n\n\n    get type() {\n      if (this.src) {\n        return IgxAvatarType.IMAGE;\n      }\n\n      if (this.icon) {\n        return IgxAvatarType.ICON;\n      }\n\n      if (this.initials) {\n        return IgxAvatarType.INITIALS;\n      }\n\n      return IgxAvatarType.CUSTOM;\n    }\n    /** @hidden @internal */\n\n\n    get _isImageType() {\n      return this.type === IgxAvatarType.IMAGE;\n    }\n    /** @hidden @internal */\n\n\n    get _isIconType() {\n      return this.type === IgxAvatarType.ICON;\n    }\n    /** @hidden @internal */\n\n\n    get _isInitialsType() {\n      return this.type === IgxAvatarType.INITIALS;\n    }\n    /**\n     * Returns the template of the avatar.\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    get template() {\n      switch (this.type) {\n        case IgxAvatarType.IMAGE:\n          return this.imageTemplate;\n\n        case IgxAvatarType.INITIALS:\n          return this.initialsTemplate;\n\n        case IgxAvatarType.ICON:\n          return this.iconTemplate;\n\n        default:\n          return this.defaultTemplate;\n      }\n    }\n    /**\n     * Returns the css url of the image.\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    getSrcUrl() {\n      return `url(${this.src})`;\n    }\n    /** @hidden @internal */\n\n\n    ngOnInit() {\n      this.roleDescription = this.getRole();\n    }\n    /** @hidden @internal */\n\n\n    getRole() {\n      switch (this.type) {\n        case IgxAvatarType.IMAGE:\n          return 'image avatar';\n\n        case IgxAvatarType.ICON:\n          return 'icon avatar';\n\n        case IgxAvatarType.INITIALS:\n          return 'initials avatar';\n\n        default:\n          return 'custom avatar';\n      }\n    }\n\n  }\n\n  IgxAvatarComponent.ɵfac = function IgxAvatarComponent_Factory(t) {\n    return new (t || IgxAvatarComponent)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxAvatarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxAvatarComponent,\n    selectors: [[\"igx-avatar\"]],\n    viewQuery: function IgxAvatarComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c25, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c26, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c27, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c28, 7, TemplateRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.imageTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.initialsTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.iconTemplate = _t.first);\n      }\n    },\n    hostVars: 24,\n    hostBindings: function IgxAvatarComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-label\", ctx.ariaLabel)(\"role\", ctx.role)(\"aria-roledescription\", ctx.roleDescription)(\"id\", ctx.id);\n        i0.ɵɵstyleProp(\"color\", ctx.color)(\"background\", ctx.bgColor);\n        i0.ɵɵclassProp(\"igx-avatar\", ctx.cssClass)(\"igx-avatar--rounded\", ctx.roundShape)(\"igx-avatar--small\", ctx._isSmallSize)(\"igx-avatar--medium\", ctx._isMediumSize)(\"igx-avatar--large\", ctx._isLargeSize)(\"igx-avatar--image\", ctx._isImageType)(\"igx-avatar--icon\", ctx._isIconType)(\"igx-avatar--initials\", ctx._isInitialsType);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      roundShape: \"roundShape\",\n      color: \"color\",\n      bgColor: \"bgColor\",\n      initials: \"initials\",\n      icon: \"icon\",\n      src: \"src\",\n      size: \"size\"\n    },\n    ngContentSelectors: _c8,\n    decls: 9,\n    vars: 1,\n    consts: [[\"defaultTemplate\", \"\"], [\"imageTemplate\", \"\"], [\"initialsTemplate\", \"\"], [\"iconTemplate\", \"\"], [4, \"ngTemplateOutlet\"], [1, \"igx-avatar__image\"], [\"image\", \"\"]],\n    template: function IgxAvatarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, IgxAvatarComponent_ng_template_0_Template, 1, 0, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, IgxAvatarComponent_ng_template_2_Template, 2, 2, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(4, IgxAvatarComponent_ng_template_4_Template, 2, 1, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(6, IgxAvatarComponent_ng_template_6_Template, 2, 1, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(8, IgxAvatarComponent_ng_container_8_Template, 1, 0, \"ng-container\", 4);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(8);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template);\n      }\n    },\n    directives: [IgxIconComponent, i4.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return IgxAvatarComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxAvatarModule = /*#__PURE__*/(() => {\n  class IgxAvatarModule {}\n\n  IgxAvatarModule.ɵfac = function IgxAvatarModule_Factory(t) {\n    return new (t || IgxAvatarModule)();\n  };\n\n  IgxAvatarModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxAvatarModule\n  });\n  IgxAvatarModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, IgxIconModule]]\n  });\n  return IgxAvatarModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nconst IGX_EXPANSION_PANEL_COMPONENT = new InjectionToken('IgxExpansionPanelToken');\nlet IgxExpansionPanelBodyComponent = /*#__PURE__*/(() => {\n  class IgxExpansionPanelBodyComponent {\n    constructor(panel, element, cdr) {\n      this.panel = panel;\n      this.element = element;\n      this.cdr = cdr;\n      /**\n       * @hidden\n       */\n\n      this.cssClass = `igx-expansion-panel__body`;\n      /**\n       * Gets/sets the `role` attribute of the panel body\n       * Default is 'region';\n       * Get\n       * ```typescript\n       *  const currentRole = this.panel.body.role;\n       * ```\n       * Set\n       * ```typescript\n       *  this.panel.body.role = 'content';\n       * ```\n       * ```html\n       *  <igx-expansion-panel-body [role]=\"'custom'\"></igx-expansion-panel-body>\n       * ```\n       */\n\n      this.role = 'region';\n      this._labelledBy = '';\n      this._label = '';\n    }\n    /**\n     * Gets the `aria-label` attribute of the panel body\n     * Defaults to the panel id with '-region' in the end;\n     * Get\n     * ```typescript\n     *  const currentLabel = this.panel.body.label;\n     * ```\n     */\n\n\n    get label() {\n      return this._label || this.panel.id + '-region';\n    }\n    /**\n     * Sets the `aria-label` attribute of the panel body\n     * ```typescript\n     *  this.panel.body.label = 'my-custom-label';\n     * ```\n     * ```html\n     *  <igx-expansion-panel-body [label]=\"'my-custom-label'\"></igx-expansion-panel-body>\n     * ```\n     */\n\n\n    set label(val) {\n      this._label = val;\n    }\n    /**\n     * Gets the `aria-labelledby` attribute of the panel body\n     * Defaults to the panel header id;\n     * Get\n     * ```typescript\n     *  const currentLabel = this.panel.body.labelledBy;\n     * ```\n     */\n\n\n    get labelledBy() {\n      return this._labelledBy;\n    }\n    /**\n     * Sets the `aria-labelledby` attribute of the panel body\n     * ```typescript\n     *  this.panel.body.labelledBy = 'my-custom-id';\n     * ```\n     * ```html\n     *  <igx-expansion-panel-body [labelledBy]=\"'my-custom-id'\"></igx-expansion-panel-body>\n     * ```\n     */\n\n\n    set labelledBy(val) {\n      this._labelledBy = val;\n    }\n\n  }\n\n  IgxExpansionPanelBodyComponent.ɵfac = function IgxExpansionPanelBodyComponent_Factory(t) {\n    return new (t || IgxExpansionPanelBodyComponent)(i0.ɵɵdirectiveInject(IGX_EXPANSION_PANEL_COMPONENT), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  IgxExpansionPanelBodyComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxExpansionPanelBodyComponent,\n    selectors: [[\"igx-expansion-panel-body\"]],\n    hostVars: 5,\n    hostBindings: function IgxExpansionPanelBodyComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"aria-label\", ctx.label)(\"aria-labelledby\", ctx.labelledBy);\n        i0.ɵɵclassProp(\"igx-expansion-panel__body\", ctx.cssClass);\n      }\n    },\n    inputs: {\n      role: \"role\",\n      label: \"label\",\n      labelledBy: \"labelledBy\"\n    },\n    ngContentSelectors: _c8,\n    decls: 1,\n    vars: 0,\n    template: function IgxExpansionPanelBodyComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxExpansionPanelBodyComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden @internal\n */\n\n\nlet IgxExpansionPanelTitleDirective = /*#__PURE__*/(() => {\n  class IgxExpansionPanelTitleDirective {\n    constructor() {\n      this.cssClass = `igx-expansion-panel__header-title`;\n    }\n\n  }\n\n  IgxExpansionPanelTitleDirective.ɵfac = function IgxExpansionPanelTitleDirective_Factory(t) {\n    return new (t || IgxExpansionPanelTitleDirective)();\n  };\n\n  IgxExpansionPanelTitleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxExpansionPanelTitleDirective,\n    selectors: [[\"igx-expansion-panel-title\"]],\n    hostVars: 2,\n    hostBindings: function IgxExpansionPanelTitleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-expansion-panel__header-title\", ctx.cssClass);\n      }\n    }\n  });\n  return IgxExpansionPanelTitleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden @internal\n */\n\n\nlet IgxExpansionPanelDescriptionDirective = /*#__PURE__*/(() => {\n  class IgxExpansionPanelDescriptionDirective {\n    constructor() {\n      this.cssClass = `igx-expansion-panel__header-description`;\n    }\n\n  }\n\n  IgxExpansionPanelDescriptionDirective.ɵfac = function IgxExpansionPanelDescriptionDirective_Factory(t) {\n    return new (t || IgxExpansionPanelDescriptionDirective)();\n  };\n\n  IgxExpansionPanelDescriptionDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxExpansionPanelDescriptionDirective,\n    selectors: [[\"igx-expansion-panel-description\"]],\n    hostVars: 2,\n    hostBindings: function IgxExpansionPanelDescriptionDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-expansion-panel__header-description\", ctx.cssClass);\n      }\n    }\n  });\n  return IgxExpansionPanelDescriptionDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden @internal\n */\n\n\nlet IgxExpansionPanelIconDirective = /*#__PURE__*/(() => {\n  class IgxExpansionPanelIconDirective {}\n\n  IgxExpansionPanelIconDirective.ɵfac = function IgxExpansionPanelIconDirective_Factory(t) {\n    return new (t || IgxExpansionPanelIconDirective)();\n  };\n\n  IgxExpansionPanelIconDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxExpansionPanelIconDirective,\n    selectors: [[\"igx-expansion-panel-icon\"]]\n  });\n  return IgxExpansionPanelIconDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nconst ExpansionPanelHeaderIconPosition = mkenum({\n  LEFT: 'left',\n  NONE: 'none',\n  RIGHT: 'right'\n});\nlet IgxExpansionPanelHeaderComponent = /*#__PURE__*/(() => {\n  class IgxExpansionPanelHeaderComponent {\n    constructor(panel, cdr, elementRef) {\n      this.panel = panel;\n      this.cdr = cdr;\n      this.elementRef = elementRef;\n      /**\n       * Gets/sets the `aria-level` attribute of the header\n       * Get\n       * ```typescript\n       *  const currentAriaLevel = this.panel.header.lv;\n       * ```\n       * Set\n       * ```typescript\n       *  this.panel.header.lv = '5';\n       * ```\n       * ```html\n       *  <igx-expansion-panel-header [lv]=\"myCustomLevel\"></igx-expansion-panel-header>\n       * ```\n       */\n\n      this.lv = '3';\n      /**\n       * Gets/sets the `role` attribute of the header\n       * Get\n       * ```typescript\n       *  const currentRole = this.panel.header.role;\n       * ```\n       * Set\n       * ```typescript\n       *  this.panel.header.role = '5';\n       * ```\n       * ```html\n       *  <igx-expansion-panel-header [role]=\"'custom'\"></igx-expansion-panel-header>\n       * ```\n       */\n\n      this.role = 'heading';\n      /**\n       * Gets/sets the position of the expansion-panel-header expand/collapse icon\n       * Accepts `left`, `right` or `none`\n       * ```typescript\n       *  const currentIconPosition = this.panel.header.iconPosition;\n       * ```\n       * Set\n       * ```typescript\n       *  this.panel.header.iconPosition = 'left';\n       * ```\n       * ```html\n       *  <igx-expansion-panel-header [iconPosition]=\"'right'\"></igx-expansion-panel-header>\n       * ```\n       */\n\n      this.iconPosition = ExpansionPanelHeaderIconPosition.LEFT;\n      /**\n       * Emitted whenever a user interacts with the header host\n       * ```typescript\n       *  handleInteraction(event: IExpansionPanelCancelableEventArgs) {\n       *  ...\n       * }\n       * ```\n       * ```html\n       *  <igx-expansion-panel-header (interaction)=\"handleInteraction($event)\">\n       *      ...\n       *  </igx-expansion-panel-header>\n       * ```\n       */\n\n      this.interaction = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.cssClass = 'igx-expansion-panel__header';\n      /**\n       * Sets/gets the `id` of the expansion panel header.\n       * ```typescript\n       * let panelHeaderId =  this.panel.header.id;\n       * ```\n       *\n       * @memberof IgxExpansionPanelComponent\n       */\n\n      this.id = '';\n      /** @hidden @internal */\n\n      this.tabIndex = 0; // properties section\n\n      this._iconTemplate = false;\n      this._disabled = false;\n      this.id = `${this.panel.id}-header`;\n    }\n    /**\n     * Returns a reference to the `igx-expansion-panel-icon` element;\n     * If `iconPosition` is `NONE` - return null;\n     */\n\n\n    get iconRef() {\n      var _a;\n\n      const renderedTemplate = (_a = this.customIconRef) !== null && _a !== void 0 ? _a : this.defaultIconRef;\n      return this.iconPosition !== ExpansionPanelHeaderIconPosition.NONE ? renderedTemplate : null;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set iconTemplate(val) {\n      this._iconTemplate = val;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get iconTemplate() {\n      return this._iconTemplate;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get controls() {\n      return this.panel.id;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get innerElement() {\n      return this.elementRef.nativeElement.children[0];\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isExpanded() {\n      return !this.panel.collapsed;\n    }\n    /**\n     * Gets/sets the whether the header is disabled\n     * When disabled, the header will not handle user events and will stop their propagation\n     *\n     * ```typescript\n     *  const isDisabled = this.panel.header.disabled;\n     * ```\n     * Set\n     * ```typescript\n     *  this.panel.header.disabled = true;\n     * ```\n     * ```html\n     *  <igx-expansion-panel-header [disabled]=\"true\">\n     *     ...\n     *  </igx-expansion-panel-header>\n     * ```\n     */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n\n    set disabled(val) {\n      this._disabled = val;\n\n      if (val) {\n        // V.S. June 11th, 2021: #9696 TabIndex should be removed when panel is disabled\n        delete this.tabIndex;\n      } else {\n        this.tabIndex = 0;\n      }\n    }\n\n    /**\n     * @hidden\n     */\n    onAction(evt) {\n      if (this.disabled) {\n        evt.stopPropagation();\n        return;\n      }\n\n      const eventArgs = {\n        event: evt,\n        owner: this.panel,\n        cancel: false\n      };\n      this.interaction.emit(eventArgs);\n\n      if (eventArgs.cancel === true) {\n        return;\n      }\n\n      this.panel.toggle(evt);\n      evt.preventDefault();\n    }\n    /** @hidden @internal */\n\n\n    openPanel(event) {\n      if (event.altKey) {\n        const eventArgs = {\n          event,\n          owner: this.panel,\n          cancel: false\n        };\n        this.interaction.emit(eventArgs);\n\n        if (eventArgs.cancel === true) {\n          return;\n        }\n\n        this.panel.expand(event);\n      }\n    }\n    /** @hidden @internal */\n\n\n    closePanel(event) {\n      if (event.altKey) {\n        const eventArgs = {\n          event,\n          owner: this.panel,\n          cancel: false\n        };\n        this.interaction.emit(eventArgs);\n\n        if (eventArgs.cancel === true) {\n          return;\n        }\n\n        this.panel.collapse(event);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get iconPositionClass() {\n      switch (this.iconPosition) {\n        case ExpansionPanelHeaderIconPosition.LEFT:\n          return `igx-expansion-panel__header-icon--start`;\n\n        case ExpansionPanelHeaderIconPosition.RIGHT:\n          return `igx-expansion-panel__header-icon--end`;\n\n        case ExpansionPanelHeaderIconPosition.NONE:\n          return `igx-expansion-panel__header-icon--none`;\n\n        default:\n          return '';\n      }\n    }\n\n  }\n\n  IgxExpansionPanelHeaderComponent.ɵfac = function IgxExpansionPanelHeaderComponent_Factory(t) {\n    return new (t || IgxExpansionPanelHeaderComponent)(i0.ɵɵdirectiveInject(IGX_EXPANSION_PANEL_COMPONENT, 1), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxExpansionPanelHeaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxExpansionPanelHeaderComponent,\n    selectors: [[\"igx-expansion-panel-header\"]],\n    contentQueries: function IgxExpansionPanelHeaderComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxExpansionPanelIconDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, IgxExpansionPanelIconDirective, 5, ElementRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.iconTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.customIconRef = _t.first);\n      }\n    },\n    viewQuery: function IgxExpansionPanelHeaderComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxIconComponent, 5, ElementRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultIconRef = _t.first);\n      }\n    },\n    hostVars: 8,\n    hostBindings: function IgxExpansionPanelHeaderComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown.Enter\", function IgxExpansionPanelHeaderComponent_keydown_Enter_HostBindingHandler($event) {\n          return ctx.onAction($event);\n        })(\"keydown.Space\", function IgxExpansionPanelHeaderComponent_keydown_Space_HostBindingHandler($event) {\n          return ctx.onAction($event);\n        })(\"keydown.Spacebar\", function IgxExpansionPanelHeaderComponent_keydown_Spacebar_HostBindingHandler($event) {\n          return ctx.onAction($event);\n        })(\"click\", function IgxExpansionPanelHeaderComponent_click_HostBindingHandler($event) {\n          return ctx.onAction($event);\n        })(\"keydown.Alt.ArrowDown\", function IgxExpansionPanelHeaderComponent_keydown_Alt_ArrowDown_HostBindingHandler($event) {\n          return ctx.openPanel($event);\n        })(\"keydown.Alt.ArrowUp\", function IgxExpansionPanelHeaderComponent_keydown_Alt_ArrowUp_HostBindingHandler($event) {\n          return ctx.closePanel($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-level\", ctx.lv)(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"igx-expansion-panel__header\", ctx.cssClass)(\"igx-expansion-panel__header--expanded\", ctx.isExpanded)(\"igx-expansion-panel--disabled\", ctx.disabled);\n      }\n    },\n    inputs: {\n      lv: \"lv\",\n      role: \"role\",\n      iconPosition: \"iconPosition\",\n      disabled: \"disabled\"\n    },\n    outputs: {\n      interaction: \"interaction\"\n    },\n    ngContentSelectors: _c30,\n    decls: 8,\n    vars: 9,\n    consts: [[\"role\", \"button\", 1, \"igx-expansion-panel__header-inner\"], [1, \"igx-expansion-panel__title-wrapper\"], [4, \"ngIf\"]],\n    template: function IgxExpansionPanelHeaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c29);\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1);\n        i0.ɵɵprojection(2);\n        i0.ɵɵprojection(3, 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵprojection(4, 2);\n        i0.ɵɵelementStart(5, \"div\");\n        i0.ɵɵtemplate(6, IgxExpansionPanelHeaderComponent_ng_content_6_Template, 1, 0, \"ng-content\", 2);\n        i0.ɵɵtemplate(7, IgxExpansionPanelHeaderComponent_igx_icon_7_Template, 2, 1, \"igx-icon\", 2);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabindex\", ctx.tabIndex)(\"id\", ctx.id)(\"aria-disabled\", ctx.disabled)(\"aria-expanded\", ctx.isExpanded)(\"aria-controls\", ctx.controls);\n        i0.ɵɵadvance(5);\n        i0.ɵɵclassMap(ctx.iconPositionClass);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.iconTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.iconTemplate);\n      }\n    },\n    directives: [IgxIconComponent, i4.NgIf],\n    encapsulation: 2\n  });\n  return IgxExpansionPanelHeaderComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden @internal */\n\n\nvar ANIMATION_TYPE = /*#__PURE__*/(() => {\n  (function (ANIMATION_TYPE) {\n    ANIMATION_TYPE[\"OPEN\"] = \"open\";\n    ANIMATION_TYPE[\"CLOSE\"] = \"close\";\n  })(ANIMATION_TYPE || (ANIMATION_TYPE = {}));\n\n  return ANIMATION_TYPE;\n})();\n\n/**@hidden @internal */\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\nlet ToggleAnimationPlayer = /*#__PURE__*/(() => {\n  class ToggleAnimationPlayer {\n    constructor(builder) {\n      this.builder = builder;\n      /** @hidden @internal */\n\n      this.openAnimationDone = new EventEmitter();\n      /** @hidden @internal */\n\n      this.closeAnimationDone = new EventEmitter();\n      /** @hidden @internal */\n\n      this.openAnimationStart = new EventEmitter();\n      /** @hidden @internal */\n\n      this.closeAnimationStart = new EventEmitter();\n      /** @hidden @internal */\n\n      this.openAnimationPlayer = null;\n      /** @hidden @internal */\n\n      this.closeAnimationPlayer = null;\n      this.destroy$ = new Subject();\n      this.players = new Map();\n      this._animationSettings = {\n        openAnimation: growVerIn,\n        closeAnimation: growVerOut\n      };\n      this.closeInterrupted = false;\n      this.openInterrupted = false;\n      this._defaultClosedCallback = noop;\n      this._defaultOpenedCallback = noop;\n      this.onClosedCallback = this._defaultClosedCallback;\n      this.onOpenedCallback = this._defaultOpenedCallback;\n    }\n\n    get animationSettings() {\n      return this._animationSettings;\n    }\n\n    set animationSettings(value) {\n      this._animationSettings = value;\n    }\n    /** @hidden @internal */\n\n\n    playOpenAnimation(targetElement, onDone) {\n      this.startPlayer(ANIMATION_TYPE.OPEN, targetElement, onDone || this._defaultOpenedCallback);\n    }\n    /** @hidden @internal */\n\n\n    playCloseAnimation(targetElement, onDone) {\n      this.startPlayer(ANIMATION_TYPE.CLOSE, targetElement, onDone || this._defaultClosedCallback);\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n\n    startPlayer(type, targetElement, callback) {\n      if (!targetElement) {\n        // if no element is passed, there is nothing to animate\n        return;\n      }\n\n      let target = this.getPlayer(type);\n\n      if (!target) {\n        target = this.initializePlayer(type, targetElement, callback);\n      } // V.S. Jun 28th, 2021 #9783: player will NOT be initialized w/ null settings\n      // events will already be emitted\n\n\n      if (!target || target.hasStarted()) {\n        return;\n      }\n\n      const targetEmitter = type === ANIMATION_TYPE.OPEN ? this.openAnimationStart : this.closeAnimationStart;\n      targetEmitter.emit();\n\n      if (target) {\n        target.play();\n      }\n    }\n\n    initializePlayer(type, targetElement, callback) {\n      const oppositeType = type === ANIMATION_TYPE.OPEN ? ANIMATION_TYPE.CLOSE : ANIMATION_TYPE.OPEN; // V.S. Jun 28th, 2021 #9783: Treat falsy animation settings as disabled animations\n\n      const targetAnimationSettings = this.animationSettings || {\n        closeAnimation: null,\n        openAnimation: null\n      };\n      const animationSettings = type === ANIMATION_TYPE.OPEN ? targetAnimationSettings.openAnimation : targetAnimationSettings.closeAnimation; // V.S. Jun 28th, 2021 #9783: When no animation in target direction, emit start and done events and return\n\n      if (!animationSettings) {\n        this.setCallback(type, callback);\n        const targetEmitter = type === ANIMATION_TYPE.OPEN ? this.openAnimationStart : this.closeAnimationStart;\n        targetEmitter.emit();\n        this.onDoneHandler(type);\n        return;\n      }\n\n      const animation = useAnimation(animationSettings);\n      const animationBuilder = this.builder.build(animation);\n      const opposite = this.getPlayer(oppositeType);\n      let oppositePosition = 1;\n\n      if (opposite) {\n        if (opposite.hasStarted()) {\n          // .getPosition() still returns 0 sometimes, regardless of the fix for https://github.com/angular/angular/issues/18891;\n          const renderer = opposite._renderer;\n          oppositePosition = renderer.engine.players[renderer.engine.players.length - 1].getPosition();\n        }\n\n        this.cleanUpPlayer(oppositeType);\n      }\n\n      if (type === ANIMATION_TYPE.OPEN) {\n        this.openAnimationPlayer = animationBuilder.create(targetElement.nativeElement);\n      } else if (type === ANIMATION_TYPE.CLOSE) {\n        this.closeAnimationPlayer = animationBuilder.create(targetElement.nativeElement);\n      }\n\n      const target = this.getPlayer(type);\n      target.init();\n      this.getPlayer(type).setPosition(1 - oppositePosition);\n      this.setCallback(type, callback);\n      target.onDone(() => {\n        this.onDoneHandler(type);\n      });\n      return target;\n    }\n\n    onDoneHandler(type) {\n      const targetEmitter = type === ANIMATION_TYPE.OPEN ? this.openAnimationDone : this.closeAnimationDone;\n      const targetCallback = type === ANIMATION_TYPE.OPEN ? this.onOpenedCallback : this.onClosedCallback;\n      targetCallback();\n\n      if (!(type === ANIMATION_TYPE.OPEN ? this.openInterrupted : this.closeInterrupted)) {\n        targetEmitter.emit();\n      }\n\n      this.cleanUpPlayer(type);\n    }\n\n    setCallback(type, callback) {\n      if (type === ANIMATION_TYPE.OPEN) {\n        this.onOpenedCallback = callback;\n        this.openInterrupted = false;\n      } else if (type === ANIMATION_TYPE.CLOSE) {\n        this.onClosedCallback = callback;\n        this.closeInterrupted = false;\n      }\n    }\n\n    cleanUpPlayer(target) {\n      switch (target) {\n        case ANIMATION_TYPE.CLOSE:\n          if (this.closeAnimationPlayer != null) {\n            this.closeAnimationPlayer.reset();\n            this.closeAnimationPlayer.destroy();\n            this.closeAnimationPlayer = null;\n          }\n\n          this.closeInterrupted = true;\n          this.onClosedCallback = this._defaultClosedCallback;\n          break;\n\n        case ANIMATION_TYPE.OPEN:\n          if (this.openAnimationPlayer != null) {\n            this.openAnimationPlayer.reset();\n            this.openAnimationPlayer.destroy();\n            this.openAnimationPlayer = null;\n          }\n\n          this.openInterrupted = true;\n          this.onOpenedCallback = this._defaultOpenedCallback;\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    getPlayer(type) {\n      switch (type) {\n        case ANIMATION_TYPE.OPEN:\n          return this.openAnimationPlayer;\n\n        case ANIMATION_TYPE.CLOSE:\n          return this.closeAnimationPlayer;\n\n        default:\n          return null;\n      }\n    }\n\n  }\n\n  ToggleAnimationPlayer.ɵfac = function ToggleAnimationPlayer_Factory(t) {\n    return new (t || ToggleAnimationPlayer)(i0.ɵɵdirectiveInject(i1.AnimationBuilder));\n  };\n\n  ToggleAnimationPlayer.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ToggleAnimationPlayer\n  });\n  return ToggleAnimationPlayer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$o = 0;\nlet IgxExpansionPanelComponent = /*#__PURE__*/(() => {\n  class IgxExpansionPanelComponent extends ToggleAnimationPlayer {\n    constructor(cdr, builder, elementRef) {\n      super(builder);\n      this.cdr = cdr;\n      this.builder = builder;\n      this.elementRef = elementRef;\n      /**\n       * Sets/gets the `id` of the expansion panel component.\n       * If not set, `id` will have value `\"igx-expansion-panel-0\"`;\n       * ```html\n       * <igx-expansion-panel id = \"my-first-expansion-panel\"></igx-expansion-panel>\n       * ```\n       * ```typescript\n       * let panelId =  this.panel.id;\n       * ```\n       *\n       * @memberof IgxExpansionPanelComponent\n       */\n\n      this.id = `igx-expansion-panel-${NEXT_ID$o++}`;\n      /**\n       * @hidden\n       */\n\n      this.cssClass = 'igx-expansion-panel';\n      /**\n       * Gets/sets whether the component is collapsed (its content is hidden)\n       * Get\n       * ```typescript\n       *  const myPanelState: boolean = this.panel.collapsed;\n       * ```\n       * Set\n       * ```html\n       *  this.panel.collapsed = true;\n       * ```\n       *\n       * Two-way data binding:\n       * ```html\n       * <igx-expansion-panel [(collapsed)]=\"model.isCollapsed\"></igx-expansion-panel>\n       * ```\n       */\n\n      this.collapsed = true;\n      /**\n       * @hidden\n       */\n\n      this.collapsedChange = new EventEmitter();\n      /**\n       * Emitted when the expansion panel starts collapsing\n       * ```typescript\n       *  handleCollapsing(event: IExpansionPanelCancelableEventArgs)\n       * ```\n       * ```html\n       *  <igx-expansion-panel (contentCollapsing)=\"handleCollapsing($event)\">\n       *      ...\n       *  </igx-expansion-panel>\n       * ```\n       */\n\n      this.contentCollapsing = new EventEmitter();\n      /**\n       * Emitted when the expansion panel finishes collapsing\n       * ```typescript\n       *  handleCollapsed(event: IExpansionPanelEventArgs)\n       * ```\n       * ```html\n       *  <igx-expansion-panel (contentCollapsed)=\"handleCollapsed($event)\">\n       *      ...\n       *  </igx-expansion-panel>\n       * ```\n       */\n\n      this.contentCollapsed = new EventEmitter();\n      /**\n       * Emitted when the expansion panel starts expanding\n       * ```typescript\n       *  handleExpanding(event: IExpansionPanelCancelableEventArgs)\n       * ```\n       * ```html\n       *  <igx-expansion-panel (contentExpanding)=\"handleExpanding($event)\">\n       *      ...\n       *  </igx-expansion-panel>\n       * ```\n       */\n\n      this.contentExpanding = new EventEmitter();\n      /**\n       * Emitted when the expansion panel finishes expanding\n       * ```typescript\n       *  handleExpanded(event: IExpansionPanelEventArgs)\n       * ```\n       * ```html\n       *  <igx-expansion-panel (contentExpanded)=\"handleExpanded($event)\">\n       *      ...\n       *  </igx-expansion-panel>\n       * ```\n       */\n\n      this.contentExpanded = new EventEmitter();\n    }\n    /**\n     * Sets/gets the animation settings of the expansion panel component\n     * Open and Close animation should be passed\n     *\n     * Get\n     * ```typescript\n     *  const currentAnimations = this.panel.animationSettings;\n     * ```\n     * Set\n     * ```typescript\n     *  import { slideInLeft, slideOutRight } from 'igniteui-angular';\n     *  ...\n     *  this.panel.animationsSettings = {\n     *      openAnimation: slideInLeft,\n     *      closeAnimation: slideOutRight\n     * };\n     * ```\n     * or via template\n     * ```typescript\n     *  import { slideInLeft, slideOutRight } from 'igniteui-angular';\n     *  ...\n     *  myCustomAnimationObject = {\n     *      openAnimation: slideInLeft,\n     *      closeAnimation: slideOutRight\n     * };\n     * ```html\n     *  <igx-expansion-panel [animationSettings]='myCustomAnimationObject'>\n     *  ...\n     *  </igx-expansion-panel>\n     * ```\n     */\n\n\n    get animationSettings() {\n      return this._animationSettings;\n    }\n\n    set animationSettings(value) {\n      this._animationSettings = value;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get panelExpanded() {\n      return !this.collapsed;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get headerId() {\n      return this.header ? `${this.id}-header` : '';\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get nativeElement() {\n      return this.elementRef.nativeElement;\n    }\n    /** @hidden */\n\n\n    ngAfterContentInit() {\n      if (this.body && this.header) {\n        // schedule at end of turn:\n        Promise.resolve().then(() => {\n          this.body.labelledBy = this.body.labelledBy || this.headerId;\n          this.body.label = this.body.label || this.id + '-region';\n        });\n      }\n    }\n    /**\n     * Collapses the panel\n     *\n     * ```html\n     *  <igx-expansion-panel #myPanel>\n     *      ...\n     *  </igx-expansion-panel>\n     *  <button (click)=\"myPanel.collapse($event)\">Collpase Panel</button>\n     * ```\n     */\n\n\n    collapse(evt) {\n      var _a; // If expansion panel is already collapsed or is collapsing, do nothing\n\n\n      if (this.collapsed || this.closeAnimationPlayer) {\n        return;\n      }\n\n      const args = {\n        event: evt,\n        panel: this,\n        owner: this,\n        cancel: false\n      };\n      this.contentCollapsing.emit(args);\n\n      if (args.cancel === true) {\n        return;\n      }\n\n      this.playCloseAnimation((_a = this.body) === null || _a === void 0 ? void 0 : _a.element, () => {\n        this.contentCollapsed.emit({\n          event: evt,\n          owner: this\n        });\n        this.collapsed = true;\n        this.collapsedChange.emit(true);\n        this.cdr.markForCheck();\n      });\n    }\n    /**\n     * Expands the panel\n     *\n     * ```html\n     *  <igx-expansion-panel #myPanel>\n     *      ...\n     *  </igx-expansion-panel>\n     *  <button (click)=\"myPanel.expand($event)\">Expand Panel</button>\n     * ```\n     */\n\n\n    expand(evt) {\n      var _a;\n\n      if (!this.collapsed) {\n        // If the panel is already opened, do nothing\n        return;\n      }\n\n      const args = {\n        event: evt,\n        panel: this,\n        owner: this,\n        cancel: false\n      };\n      this.contentExpanding.emit(args);\n\n      if (args.cancel === true) {\n        return;\n      }\n\n      this.collapsed = false;\n      this.collapsedChange.emit(false);\n      this.cdr.detectChanges();\n      this.playOpenAnimation((_a = this.body) === null || _a === void 0 ? void 0 : _a.element, () => {\n        this.contentExpanded.emit({\n          event: evt,\n          owner: this\n        });\n      });\n    }\n    /**\n     * Toggles the panel\n     *\n     * ```html\n     *  <igx-expansion-panel #myPanel>\n     *      ...\n     *  </igx-expansion-panel>\n     *  <button (click)=\"myPanel.toggle($event)\">Expand Panel</button>\n     * ```\n     */\n\n\n    toggle(evt) {\n      if (this.collapsed) {\n        this.open(evt);\n      } else {\n        this.close(evt);\n      }\n    }\n\n    open(evt) {\n      this.expand(evt);\n    }\n\n    close(evt) {\n      this.collapse(evt);\n    }\n\n  }\n\n  IgxExpansionPanelComponent.ɵfac = function IgxExpansionPanelComponent_Factory(t) {\n    return new (t || IgxExpansionPanelComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.AnimationBuilder), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxExpansionPanelComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxExpansionPanelComponent,\n    selectors: [[\"igx-expansion-panel\"]],\n    contentQueries: function IgxExpansionPanelComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxExpansionPanelBodyComponent, 5, IgxExpansionPanelBodyComponent);\n        i0.ɵɵcontentQuery(dirIndex, IgxExpansionPanelHeaderComponent, 5, IgxExpansionPanelHeaderComponent);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.body = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.header = _t.first);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function IgxExpansionPanelComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id)(\"aria-expanded\", ctx.panelExpanded);\n        i0.ɵɵclassProp(\"igx-expansion-panel\", ctx.cssClass);\n      }\n    },\n    inputs: {\n      animationSettings: \"animationSettings\",\n      id: \"id\",\n      collapsed: \"collapsed\"\n    },\n    outputs: {\n      collapsedChange: \"collapsedChange\",\n      contentCollapsing: \"contentCollapsing\",\n      contentCollapsed: \"contentCollapsed\",\n      contentExpanding: \"contentExpanding\",\n      contentExpanded: \"contentExpanded\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IGX_EXPANSION_PANEL_COMPONENT,\n      useExisting: IgxExpansionPanelComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c32,\n    decls: 2,\n    vars: 1,\n    consts: [[4, \"ngIf\"]],\n    template: function IgxExpansionPanelComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c31);\n        i0.ɵɵprojection(0);\n        i0.ɵɵtemplate(1, IgxExpansionPanelComponent_ng_content_1_Template, 1, 0, \"ng-content\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.collapsed);\n      }\n    },\n    directives: [i4.NgIf],\n    encapsulation: 2\n  });\n  return IgxExpansionPanelComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxExpansionPanelModule = /*#__PURE__*/(() => {\n  class IgxExpansionPanelModule {}\n\n  IgxExpansionPanelModule.ɵfac = function IgxExpansionPanelModule_Factory(t) {\n    return new (t || IgxExpansionPanelModule)();\n  };\n\n  IgxExpansionPanelModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxExpansionPanelModule\n  });\n  IgxExpansionPanelModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, IgxRippleModule, IgxIconModule, IgxButtonModule, IgxAvatarModule]]\n  });\n  return IgxExpansionPanelModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$n = 0;\n/**\n * IgxAccordion is a container-based component that contains that can house multiple expansion panels.\n *\n * @igxModule IgxAccordionModule\n *\n * @igxKeywords accordion\n *\n * @igxGroup Layouts\n *\n * @remark\n * The Ignite UI for Angular Accordion component enables the user to navigate among multiple collapsing panels\n * displayed in a single container.\n * The accordion offers keyboard navigation and API to control the underlying panels' expansion state.\n *\n * @example\n * ```html\n * <igx-accordion>\n *   <igx-expansion-panel *ngFor=\"let panel of panels\">\n *       ...\n *   </igx-expansion-panel>\n * </igx-accordion>\n * ```\n */\n\nlet IgxAccordionComponent = /*#__PURE__*/(() => {\n  class IgxAccordionComponent {\n    constructor(cdr) {\n      this.cdr = cdr;\n      /**\n       * Get/Set the `id` of the accordion component.\n       * Default value is `\"igx-accordion-0\"`;\n       * ```html\n       * <igx-accordion id=\"my-first-accordion\"></igx-accordion>\n       * ```\n       * ```typescript\n       * const accordionId = this.accordion.id;\n       * ```\n       */\n\n      this.id = `igx-accordion-${NEXT_ID$n++}`;\n      /** @hidden @internal **/\n\n      this.cssClass = 'igx-accordion';\n      /** @hidden @internal **/\n\n      this.displayStyle = 'block';\n      /**\n       * Emitted before a panel is expanded.\n       *\n       * @remarks\n       * This event is cancelable.\n       *\n       * ```html\n       * <igx-accordion (panelExpanding)=\"handlePanelExpanding($event)\">\n       * </igx-accordion>\n       * ```\n       *\n       *```typescript\n       * public handlePanelExpanding(event: IExpansionPanelCancelableEventArgs){\n       *  const expandedPanel: IgxExpansionPanelComponent = event.panel;\n       *  if (expandedPanel.disabled) {\n       *      event.cancel = true;\n       *  }\n       * }\n       *```\n       */\n\n      this.panelExpanding = new EventEmitter();\n      /**\n       * Emitted after a panel has been expanded.\n       *\n       * ```html\n       * <igx-accordion (panelExpanded)=\"handlePanelExpanded($event)\">\n       * </igx-accordion>\n       * ```\n       *\n       *```typescript\n       * public handlePanelExpanded(event: IExpansionPanelCancelableEventArgs) {\n       *  const expandedPanel: IgxExpansionPanelComponent = event.panel;\n       *  console.log(\"Panel is expanded: \", expandedPanel.id);\n       * }\n       *```\n       */\n\n      this.panelExpanded = new EventEmitter();\n      /**\n       * Emitted before a panel is collapsed.\n       *\n       * @remarks\n       * This event is cancelable.\n       *\n       * ```html\n       * <igx-accordion (panelCollapsing)=\"handlePanelCollapsing($event)\">\n       * </igx-accordion>\n       * ```\n       */\n\n      this.panelCollapsing = new EventEmitter();\n      /**\n       * Emitted after a panel has been collapsed.\n       *\n       * ```html\n       * <igx-accordion (panelCollapsed)=\"handlePanelCollapsed($event)\">\n       * </igx-accordion>\n       * ```\n       */\n\n      this.panelCollapsed = new EventEmitter();\n      this._destroy$ = new Subject();\n      this._unsubChildren$ = new Subject();\n      this._singleBranchExpand = false;\n    }\n    /**\n     * Get/Set the animation settings that panels should use when expanding/collpasing.\n     *\n     * ```html\n     * <igx-accordion [animationSettings]=\"customAnimationSettings\"></igx-accordion>\n     * ```\n     *\n     * ```typescript\n     * const customAnimationSettings: ToggleAnimationSettings = {\n     *      openAnimation: growVerIn,\n     *      closeAnimation: growVerOut\n     * };\n     *\n     * this.accordion.animationSettings = customAnimationSettings;\n     * ```\n     */\n\n\n    get animationSettings() {\n      return this._animationSettings;\n    }\n\n    set animationSettings(value) {\n      this._animationSettings = value;\n      this.updatePanelsAnimation();\n    }\n    /**\n     * Get/Set how the accordion handles the expansion of the projected expansion panels.\n     * If set to `true`, only a single panel can be expanded at a time, collapsing all others\n     *\n     * ```html\n     * <igx-accordion [singleBranchExpand]=\"true\">\n     * ...\n     * </igx-accordion>\n     * ```\n     *\n     * ```typescript\n     * this.accordion.singleBranchExpand = false;\n     * ```\n     */\n\n\n    get singleBranchExpand() {\n      return this._singleBranchExpand;\n    }\n\n    set singleBranchExpand(val) {\n      this._singleBranchExpand = val;\n\n      if (val) {\n        this.collapseAllExceptLast();\n      }\n    }\n    /**\n     * Get all panels.\n     *\n     * ```typescript\n     * const panels: IgxExpansionPanelComponent[] = this.accordion.panels;\n     * ```\n     */\n\n\n    get panels() {\n      var _a;\n\n      return (_a = this._panels) === null || _a === void 0 ? void 0 : _a.toArray();\n    }\n    /** @hidden @internal **/\n\n\n    ngAfterContentInit() {\n      this.updatePanelsAnimation();\n\n      if (this.singleBranchExpand) {\n        this.collapseAllExceptLast();\n      }\n    }\n    /** @hidden @internal **/\n\n\n    ngAfterViewInit() {\n      this._expandedPanels = new Set(this._panels.filter(panel => !panel.collapsed));\n      this._expandingPanels = new Set();\n\n      this._panels.changes.pipe(takeUntil(this._destroy$)).subscribe(() => {\n        this.subToChanges();\n      });\n\n      this.subToChanges();\n    }\n    /** @hidden @internal */\n\n\n    ngOnDestroy() {\n      this._unsubChildren$.next();\n\n      this._unsubChildren$.complete();\n\n      this._destroy$.next();\n\n      this._destroy$.complete();\n    }\n    /**\n     * Expands all collapsed expansion panels.\n     *\n     * ```typescript\n     * accordion.expandAll();\n     * ```\n     */\n\n\n    expandAll() {\n      if (this.singleBranchExpand) {\n        for (let i = 0; i < this.panels.length - 1; i++) {\n          this.panels[i].collapse();\n        }\n\n        this._panels.last.expand();\n\n        return;\n      }\n\n      this.panels.forEach(panel => panel.expand());\n    }\n    /**\n     * Collapses all expanded expansion panels.\n     *\n     * ```typescript\n     * accordion.collapseAll();\n     * ```\n     */\n\n\n    collapseAll() {\n      this.panels.forEach(panel => panel.collapse());\n    }\n\n    collapseAllExceptLast() {\n      var _a, _b;\n\n      const lastExpanded = (_a = this.panels) === null || _a === void 0 ? void 0 : _a.filter(p => !p.collapsed && !p.header.disabled).pop();\n      (_b = this.panels) === null || _b === void 0 ? void 0 : _b.forEach(p => {\n        if (p !== lastExpanded && !p.header.disabled) {\n          p.collapsed = true;\n        }\n      });\n      this.cdr.detectChanges();\n    }\n\n    handleKeydown(event, panel) {\n      const key = event.key.toLowerCase();\n\n      if (!ACCORDION_NAVIGATION_KEYS.has(key)) {\n        return;\n      } // TO DO: if we ever want to improve the performance of the accordion,\n      // enabledPanels could be cached (by making a disabledChange emitter on the panel header)\n\n\n      this._enabledPanels = this._panels.filter(p => !p.header.disabled);\n      event.preventDefault();\n      this.handleNavigation(event, panel);\n    }\n\n    handleNavigation(event, panel) {\n      switch (event.key.toLowerCase()) {\n        case 'home':\n          this._enabledPanels[0].header.innerElement.focus();\n\n          break;\n\n        case 'end':\n          this._enabledPanels[this._enabledPanels.length - 1].header.innerElement.focus();\n\n          break;\n\n        case 'arrowup':\n        case 'up':\n          this.handleUpDownArrow(true, event, panel);\n          break;\n\n        case 'arrowdown':\n        case 'down':\n          this.handleUpDownArrow(false, event, panel);\n          break;\n      }\n    }\n\n    handleUpDownArrow(isUp, event, panel) {\n      if (!event.altKey) {\n        const focusedPanel = panel;\n        const next = this.getNextPanel(focusedPanel, isUp ? -1 : 1);\n\n        if (next === focusedPanel) {\n          return;\n        }\n\n        next.header.innerElement.focus();\n      }\n\n      if (event.altKey && event.shiftKey) {\n        if (isUp) {\n          this._enabledPanels.forEach(p => p.collapse());\n        } else {\n          if (this.singleBranchExpand) {\n            for (let i = 0; i < this._enabledPanels.length - 1; i++) {\n              this._enabledPanels[i].collapse();\n            }\n\n            this._enabledPanels[this._enabledPanels.length - 1].expand();\n\n            return;\n          }\n\n          this._enabledPanels.forEach(p => p.expand());\n        }\n      }\n    }\n\n    getNextPanel(panel, dir = 1) {\n      const panelIndex = this._enabledPanels.indexOf(panel);\n\n      return this._enabledPanels[panelIndex + dir] || panel;\n    }\n\n    subToChanges() {\n      this._unsubChildren$.next();\n\n      this._panels.forEach(panel => {\n        panel.contentExpanded.pipe(takeUntil(this._unsubChildren$)).subscribe(args => {\n          this._expandedPanels.add(args.owner);\n\n          this._expandingPanels.delete(args.owner);\n\n          const evArgs = Object.assign(Object.assign({}, args), {\n            owner: this,\n            panel: args.owner\n          });\n          this.panelExpanded.emit(evArgs);\n        });\n        panel.contentExpanding.pipe(takeUntil(this._unsubChildren$)).subscribe(args => {\n          if (args.cancel) {\n            return;\n          }\n\n          const evArgs = Object.assign(Object.assign({}, args), {\n            owner: this,\n            panel: args.owner\n          });\n          this.panelExpanding.emit(evArgs);\n\n          if (evArgs.cancel) {\n            args.cancel = true;\n            return;\n          }\n\n          if (this.singleBranchExpand) {\n            this._expandedPanels.forEach(p => {\n              if (!p.header.disabled) {\n                p.collapse();\n              }\n            });\n\n            this._expandingPanels.forEach(p => {\n              var _a, _b;\n\n              if (!p.header.disabled) {\n                if (!p.animationSettings.closeAnimation) {\n                  (_a = p.openAnimationPlayer) === null || _a === void 0 ? void 0 : _a.reset();\n                }\n\n                if (!p.animationSettings.openAnimation) {\n                  (_b = p.closeAnimationPlayer) === null || _b === void 0 ? void 0 : _b.reset();\n                }\n\n                p.collapse();\n              }\n            });\n\n            this._expandingPanels.add(args.owner);\n          }\n        });\n        panel.contentCollapsed.pipe(takeUntil(this._unsubChildren$)).subscribe(args => {\n          this._expandedPanels.delete(args.owner);\n\n          this._expandingPanels.delete(args.owner);\n\n          const evArgs = Object.assign(Object.assign({}, args), {\n            owner: this,\n            panel: args.owner\n          });\n          this.panelCollapsed.emit(evArgs);\n        });\n        panel.contentCollapsing.pipe(takeUntil(this._unsubChildren$)).subscribe(args => {\n          const evArgs = Object.assign(Object.assign({}, args), {\n            owner: this,\n            panel: args.owner\n          });\n          this.panelCollapsing.emit(evArgs);\n\n          if (evArgs.cancel) {\n            args.cancel = true;\n          }\n        });\n        fromEvent(panel.header.innerElement, 'keydown').pipe(takeUntil(this._unsubChildren$)).subscribe(e => {\n          this.handleKeydown(e, panel);\n        });\n      });\n    }\n\n    updatePanelsAnimation() {\n      var _a;\n\n      if (this.animationSettings !== undefined) {\n        (_a = this.panels) === null || _a === void 0 ? void 0 : _a.forEach(panel => panel.animationSettings = this.animationSettings);\n      }\n    }\n\n  }\n\n  IgxAccordionComponent.ɵfac = function IgxAccordionComponent_Factory(t) {\n    return new (t || IgxAccordionComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  IgxAccordionComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxAccordionComponent,\n    selectors: [[\"igx-accordion\"]],\n    contentQueries: function IgxAccordionComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxExpansionPanelComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._panels = _t);\n      }\n    },\n    hostVars: 5,\n    hostBindings: function IgxAccordionComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id);\n        i0.ɵɵstyleProp(\"display\", ctx.displayStyle);\n        i0.ɵɵclassProp(\"igx-accordion\", ctx.cssClass);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      animationSettings: \"animationSettings\",\n      singleBranchExpand: \"singleBranchExpand\"\n    },\n    outputs: {\n      panelExpanding: \"panelExpanding\",\n      panelExpanded: \"panelExpanded\",\n      panelCollapsing: \"panelCollapsing\",\n      panelCollapsed: \"panelCollapsed\"\n    },\n    ngContentSelectors: _c34,\n    decls: 1,\n    vars: 0,\n    template: function IgxAccordionComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c33);\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxAccordionComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxAccordionModule = /*#__PURE__*/(() => {\n  class IgxAccordionModule {}\n\n  IgxAccordionModule.ɵfac = function IgxAccordionModule_Factory(t) {\n    return new (t || IgxAccordionModule)();\n  };\n\n  IgxAccordionModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxAccordionModule\n  });\n  IgxAccordionModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[IgxExpansionPanelModule, CommonModule], IgxExpansionPanelModule]\n  });\n  return IgxAccordionModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$m = 0;\n/**\n * Determines the igxBadge type\n */\n\nconst IgxBadgeType = mkenum({\n  PRIMARY: 'primary',\n  INFO: 'info',\n  SUCCESS: 'success',\n  WARNING: 'warning',\n  ERROR: 'error'\n});\n/**\n * Badge provides visual notifications used to decorate avatars, menus, etc.\n *\n * @igxModule IgxBadgeModule\n *\n * @igxTheme igx-badge-theme\n *\n * @igxKeywords badge, icon, notification\n *\n * @igxGroup Data Entry & Display\n *\n * @remarks\n * The Ignite UI Badge is used to decorate avatars, navigation menus, or other components in the\n * application when visual notification is needed. They are usually designed as icons with a predefined\n * style to communicate information, success, warnings, or errors.\n *\n * @example\n * ```html\n * <igx-avatar>\n *   <igx-badge icon=\"check\" type=\"success\"></igx-badge>\n * </igx-avatar>\n */\n\nlet IgxBadgeComponent = /*#__PURE__*/(() => {\n  class IgxBadgeComponent {\n    constructor() {\n      /**\n       * Sets/gets the `id` of the badge.\n       *\n       * @remarks\n       * If not set, the `id` will have value `\"igx-badge-0\"`.\n       *\n       * @example\n       * ```html\n       * <igx-badge id=\"igx-badge-2\"></igx-badge>\n       * ```\n       */\n      this.id = `igx-badge-${NEXT_ID$m++}`;\n      /**\n       * Sets/gets the type of the badge.\n       *\n       * @remarks\n       * Allowed values are `primary`, `info`, `success`, `warning`, `error`.\n       * Providing an invalid value won't display a badge.\n       *\n       * @example\n       * ```html\n       * <igx-badge type=\"success\"></igx-badge>\n       * ```\n       */\n\n      this.type = IgxBadgeType.PRIMARY;\n      /**\n       * Sets/gets the value to be displayed inside the badge.\n       *\n       * @remarks\n       * If an `icon` property is already set the `icon` will be displayed.\n       * If neither a `value` nor an `icon` is set the content of the badge will be empty.\n       *\n       * @example\n       * ```html\n       * <igx-badge value=\"11\"></igx-badge>\n       * ```\n       */\n\n      this.value = '';\n      /**\n       * Sets/gets the role attribute value.\n       *\n       * @example\n       * ```typescript\n       * @ViewChild(\"MyBadge\", { read: IgxBadgeComponent })\n       * public badge: IgxBadgeComponent;\n       *\n       * badge.role = 'status';\n       * ```\n       */\n\n      this.role = 'status';\n      /**\n       * Sets/gets the the css class to use on the badge.\n       *\n       * @example\n       * ```typescript\n       * @ViewChild(\"MyBadge\", { read: IgxBadgeComponent })\n       * public badge: IgxBadgeComponent;\n       *\n       * badge.cssClass = 'my-badge-class';\n       * ```\n       */\n\n      this.cssClass = 'igx-badge';\n      /**\n       * Sets/gets the aria-label attribute value.\n       *\n       * @example\n       * ```typescript\n       * @ViewChild(\"MyBadge\", { read: IgxBadgeComponent })\n       * public badge: IgxBadgeComponent;\n       *\n       * badge.label = 'badge';\n       * ```\n       */\n\n      this.label = 'badge';\n    }\n    /**\n     * Defines a human-readable, accessor, author-localized description for\n     * the `type` and the `icon` or `value` of the element.\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    get roleDescription() {\n      if (this.icon) {\n        return this.type + ' type badge with icon type ' + this.icon;\n      } else if (this.value || this.value === 0) {\n        return this.type + ' badge type with value ' + this.value;\n      }\n\n      return this.type + ' badge type without value';\n    }\n\n    get infoClass() {\n      return this.type === IgxBadgeType.INFO;\n    }\n\n    get successClass() {\n      return this.type === IgxBadgeType.SUCCESS;\n    }\n\n    get warningClass() {\n      return this.type === IgxBadgeType.WARNING;\n    }\n\n    get errorClass() {\n      return this.type === IgxBadgeType.ERROR;\n    }\n\n  }\n\n  IgxBadgeComponent.ɵfac = function IgxBadgeComponent_Factory(t) {\n    return new (t || IgxBadgeComponent)();\n  };\n\n  IgxBadgeComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxBadgeComponent,\n    selectors: [[\"igx-badge\"]],\n    hostVars: 14,\n    hostBindings: function IgxBadgeComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id)(\"role\", ctx.role)(\"aria-label\", ctx.label)(\"aria-roledescription\", ctx.roleDescription);\n        i0.ɵɵclassProp(\"igx-badge\", ctx.cssClass)(\"igx-badge--info\", ctx.infoClass)(\"igx-badge--success\", ctx.successClass)(\"igx-badge--warning\", ctx.warningClass)(\"igx-badge--error\", ctx.errorClass);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      type: \"type\",\n      value: \"value\",\n      icon: \"icon\"\n    },\n    decls: 2,\n    vars: 2,\n    consts: [[\"class\", \"igx-badge__value\", 4, \"ngIf\"], [4, \"ngIf\"], [1, \"igx-badge__value\"]],\n    template: function IgxBadgeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxBadgeComponent_span_0_Template, 2, 1, \"span\", 0);\n        i0.ɵɵtemplate(1, IgxBadgeComponent_igx_icon_1_Template, 2, 1, \"igx-icon\", 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.icon);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.icon);\n      }\n    },\n    directives: [IgxIconComponent, i4.NgIf],\n    encapsulation: 2\n  });\n  return IgxBadgeComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxBadgeModule = /*#__PURE__*/(() => {\n  class IgxBadgeModule {}\n\n  IgxBadgeModule.ɵfac = function IgxBadgeModule_Factory(t) {\n    return new (t || IgxBadgeModule)();\n  };\n\n  IgxBadgeModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxBadgeModule\n  });\n  IgxBadgeModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, IgxIconModule]]\n  });\n  return IgxBadgeModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/* eslint-disable @angular-eslint/directive-selector */\n\n\nlet IgxBannerActionsDirective = /*#__PURE__*/(() => {\n  class IgxBannerActionsDirective {}\n\n  IgxBannerActionsDirective.ɵfac = function IgxBannerActionsDirective_Factory(t) {\n    return new (t || IgxBannerActionsDirective)();\n  };\n\n  IgxBannerActionsDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxBannerActionsDirective,\n    selectors: [[\"igx-banner-actions\"]]\n  });\n  return IgxBannerActionsDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * **Ignite UI for Angular Banner** -\n * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/banner.html)\n *\n * The Ignite UI Banner provides a highly template-able and easy to use banner that can be shown in your application.\n *\n * Usage:\n *\n * ```html\n * <igx-banner #banner>\n *   Our privacy settings have changed.\n *  <igx-banner-actions>\n *      <button igxButton=\"raised\">Read More</button>\n *      <button igxButton=\"raised\">Accept and Continue</button>\n *  </igx-banner-actions>\n * </igx-banner>\n * ```\n */\n\n\nlet IgxBannerComponent = /*#__PURE__*/(() => {\n  class IgxBannerComponent {\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n      /**\n       * Fires after the banner shows up\n       * ```typescript\n       * public handleOpened(event) {\n       *  ...\n       * }\n       * ```\n       * ```html\n       * <igx-banner (opened)=\"handleOpened($event)\"></igx-banner>\n       * ```\n       */\n\n      this.opened = new EventEmitter();\n      /**\n       * Fires before the banner shows up\n       * ```typescript\n       * public handleOpening(event) {\n       *  ...\n       * }\n       * ```\n       * ```html\n       * <igx-banner (opening)=\"handleOpening($event)\"></igx-banner>\n       * ```\n       */\n\n      this.opening = new EventEmitter();\n      /**\n       * Fires after the banner hides\n       * ```typescript\n       * public handleClosed(event) {\n       *  ...\n       * }\n       * ```\n       * ```html\n       * <igx-banner (closed)=\"handleClosed($event)\"></igx-banner>\n       * ```\n       */\n\n      this.closed = new EventEmitter();\n      /**\n       * Fires before the banner hides\n       * ```typescript\n       * public handleClosing(event) {\n       *  ...\n       * }\n       * ```\n       * ```html\n       * <igx-banner (closing)=\"handleClosing($event)\"></igx-banner>\n       * ```\n       */\n\n      this.closing = new EventEmitter();\n    }\n    /** @hidden */\n\n\n    get useDefaultTemplate() {\n      return !this._bannerActionTemplate;\n    }\n    /**\n     * Get the animation settings used by the banner open/close methods\n     * ```typescript\n     * let currentAnimations: ToggleAnimationSettings = banner.animationSettings\n     * ```\n     */\n\n\n    get animationSettings() {\n      return this._animationSettings ? this._animationSettings : this._expansionPanel.animationSettings;\n    }\n    /**\n     * Set the animation settings used by the banner open/close methods\n     * ```typescript\n     * import { slideInLeft, slideOutRight } from 'igniteui-angular';\n     * ...\n     * banner.animationSettings: ToggleAnimationSettings = { openAnimation: slideInLeft, closeAnimation: slideOutRight };\n     * ```\n     */\n\n\n    set animationSettings(settings) {\n      this._animationSettings = settings;\n    }\n    /**\n     * Gets whether banner is collapsed\n     *\n     * ```typescript\n     * const isCollapsed: boolean = banner.collapsed;\n     * ```\n     */\n\n\n    get collapsed() {\n      return this._expansionPanel.collapsed;\n    }\n    /**\n     * Returns the native element of the banner component\n     * ```typescript\n     *  const myBannerElement: HTMLElement = banner.element;\n     * ```\n     */\n\n\n    get element() {\n      return this.elementRef.nativeElement;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get displayStyle() {\n      return this.collapsed ? '' : 'block';\n    }\n    /**\n     * Opens the banner\n     *\n     * ```typescript\n     *  myBanner.open();\n     * ```\n     *\n     * ```html\n     * <igx-banner #banner>\n     * ...\n     * </igx-banner>\n     * <button (click)=\"banner.open()\">Open Banner</button>\n     * ```\n     */\n\n\n    open(event) {\n      this._bannerEvent = {\n        banner: this,\n        owner: this,\n        event\n      };\n      const openingArgs = {\n        banner: this,\n        owner: this,\n        event,\n        cancel: false\n      };\n      this.opening.emit(openingArgs);\n\n      if (openingArgs.cancel) {\n        return;\n      }\n\n      this._expansionPanel.open(event);\n    }\n    /**\n     * Closes the banner\n     *\n     * ```typescript\n     *  myBanner.close();\n     * ```\n     *\n     * ```html\n     * <igx-banner #banner>\n     * ...\n     * </igx-banner>\n     * <button (click)=\"banner.close()\">Close Banner</button>\n     * ```\n     */\n\n\n    close(event) {\n      this._bannerEvent = {\n        banner: this,\n        owner: this,\n        event\n      };\n      const closingArgs = {\n        banner: this,\n        owner: this,\n        event,\n        cancel: false\n      };\n      this.closing.emit(closingArgs);\n\n      if (closingArgs.cancel) {\n        return;\n      }\n\n      this._expansionPanel.close(event);\n    }\n    /**\n     * Toggles the banner\n     *\n     * ```typescript\n     *  myBanner.toggle();\n     * ```\n     *\n     * ```html\n     * <igx-banner #banner>\n     * ...\n     * </igx-banner>\n     * <button (click)=\"banner.toggle()\">Toggle Banner</button>\n     * ```\n     */\n\n\n    toggle(event) {\n      if (this.collapsed) {\n        this.open(event);\n      } else {\n        this.close(event);\n      }\n    }\n    /** @hidden */\n\n\n    onExpansionPanelOpen() {\n      this.opened.emit(this._bannerEvent);\n    }\n    /** @hidden */\n\n\n    onExpansionPanelClose() {\n      this.closed.emit(this._bannerEvent);\n    }\n\n  }\n\n  IgxBannerComponent.ɵfac = function IgxBannerComponent_Factory(t) {\n    return new (t || IgxBannerComponent)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxBannerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxBannerComponent,\n    selectors: [[\"igx-banner\"]],\n    contentQueries: function IgxBannerComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxIconComponent, 5);\n        i0.ɵɵcontentQuery(dirIndex, IgxBannerActionsDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.bannerIcon = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._bannerActionTemplate = _t.first);\n      }\n    },\n    viewQuery: function IgxBannerComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c35, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._expansionPanel = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function IgxBannerComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"display\", ctx.displayStyle);\n      }\n    },\n    inputs: {\n      animationSettings: \"animationSettings\"\n    },\n    outputs: {\n      opened: \"opened\",\n      opening: \"opening\",\n      closed: \"closed\",\n      closing: \"closing\"\n    },\n    ngContentSelectors: _c37,\n    decls: 12,\n    vars: 6,\n    consts: [[\"aria-live\", \"polite\", 3, \"animationSettings\", \"collapsed\", \"contentCollapsed\", \"contentExpanded\"], [\"expansionPanel\", \"\"], [1, \"igx-banner\"], [1, \"igx-banner__message\"], [\"class\", \"igx-banner__illustration\", 4, \"ngIf\"], [1, \"igx-banner__text\"], [1, \"igx-banner__actions\"], [1, \"igx-banner__row\"], [4, \"ngIf\"], [1, \"igx-banner__illustration\"], [\"igxButton\", \"flat\", \"igxRipple\", \"\", 3, \"click\"]],\n    template: function IgxBannerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c36);\n        i0.ɵɵelementStart(0, \"igx-expansion-panel\", 0, 1);\n        i0.ɵɵlistener(\"contentCollapsed\", function IgxBannerComponent_Template_igx_expansion_panel_contentCollapsed_0_listener() {\n          return ctx.onExpansionPanelClose();\n        })(\"contentExpanded\", function IgxBannerComponent_Template_igx_expansion_panel_contentExpanded_0_listener() {\n          return ctx.onExpansionPanelOpen();\n        });\n        i0.ɵɵelementStart(2, \"igx-expansion-panel-body\")(3, \"div\", 2)(4, \"div\", 3);\n        i0.ɵɵtemplate(5, IgxBannerComponent_div_5_Template, 2, 0, \"div\", 4);\n        i0.ɵɵelementStart(6, \"span\", 5);\n        i0.ɵɵprojection(7);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(8, \"div\", 6)(9, \"div\", 7);\n        i0.ɵɵtemplate(10, IgxBannerComponent_ng_container_10_Template, 3, 0, \"ng-container\", 8);\n        i0.ɵɵtemplate(11, IgxBannerComponent_ng_container_11_Template, 2, 0, \"ng-container\", 8);\n        i0.ɵɵelementEnd()()()()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"animationSettings\", ctx.animationSettings)(\"collapsed\", ctx.collapsed);\n        i0.ɵɵattribute(\"aria-hidden\", ctx.collapsed);\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"ngIf\", ctx.bannerIcon);\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"ngIf\", ctx.useDefaultTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.useDefaultTemplate);\n      }\n    },\n    directives: [IgxExpansionPanelComponent, IgxExpansionPanelBodyComponent, i4.NgIf, IgxButtonDirective, IgxRippleDirective],\n    encapsulation: 2\n  });\n  return IgxBannerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxBannerModule = /*#__PURE__*/(() => {\n  class IgxBannerModule {}\n\n  IgxBannerModule.ɵfac = function IgxBannerModule_Factory(t) {\n    return new (t || IgxBannerModule)();\n  };\n\n  IgxBannerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxBannerModule\n  });\n  IgxBannerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, IgxExpansionPanelModule, IgxIconModule, IgxButtonModule, IgxRippleModule]]\n  });\n  return IgxBannerModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Determines the Button Group alignment\n */\n\n\nconst ButtonGroupAlignment = mkenum({\n  horizontal: 'horizontal',\n  vertical: 'vertical'\n});\nlet NEXT_ID$l = 0;\n/**\n * **Ignite UI for Angular Button Group** -\n * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/buttongroup.html)\n *\n * The Ignite UI Button Group displays a group of buttons either vertically or horizontally.  The group supports\n * single, multiple and toggle selection.\n *\n * Example:\n * ```html\n * <igx-buttongroup multiSelection=\"true\" [values]=\"fontOptions\">\n * </igx-buttongroup>\n * ```\n * The `fontOptions` value shown above is defined as:\n * ```typescript\n * this.fontOptions = [\n *   { icon: 'format_bold', selected: false },\n *   { icon: 'format_italic', selected: false },\n *   { icon: 'format_underlined', selected: false }];\n * ```\n */\n\nlet IgxButtonGroupComponent = /*#__PURE__*/(() => {\n  class IgxButtonGroupComponent extends DisplayDensityBase {\n    constructor(_cdr, _renderer, _displayDensityOptions) {\n      super(_displayDensityOptions);\n      this._cdr = _cdr;\n      this._renderer = _renderer;\n      this._displayDensityOptions = _displayDensityOptions;\n      /**\n       * An @Input property that sets the value of the `id` attribute. If not set it will be automatically generated.\n       * ```html\n       *  <igx-buttongroup [id]=\"'igx-dialog-56'\" [multiSelection]=\"!multi\" [values]=\"alignOptions\">\n       * ```\n       */\n\n      this.id = `igx-buttongroup-${NEXT_ID$l++}`;\n      /**\n       * @hidden\n       */\n\n      this.zIndex = 0;\n      /**\n       * An @Input property that enables selecting multiple buttons. By default, multi-selection is false.\n       * ```html\n       * <igx-buttongroup [multiSelection]=\"false\" [alignment]=\"alignment\"></igx-buttongroup>\n       * ```\n       */\n\n      this.multiSelection = false;\n      /**\n       * An @Ouput property that emits an event when a button is selected.\n       * ```typescript\n       * @ViewChild(\"toast\")\n       * private toast: IgxToastComponent;\n       * public selectedHandler(buttongroup) {\n       *     this.toast.open()\n       * }\n       *  //...\n       * ```\n       * ```html\n       * <igx-buttongroup #MyChild [multiSelection]=\"!multi\" (selected)=\"selectedHandler($event)\"></igx-buttongroup>\n       * <igx-toast #toast>You have made a selection!</igx-toast>\n       * ```\n       */\n\n      this.selected = new EventEmitter();\n      /**\n       * An @Ouput property that emits an event when a button is deselected.\n       * ```typescript\n       *  @ViewChild(\"toast\")\n       *  private toast: IgxToastComponent;\n       *  public deselectedHandler(buttongroup){\n       *     this.toast.open()\n       * }\n       *  //...\n       * ```\n       * ```html\n       * <igx-buttongroup> #MyChild [multiSelection]=\"multi\" (deselected)=\"deselectedHandler($event)\"></igx-buttongroup>\n       * <igx-toast #toast>You have deselected a button!</igx-toast>\n       * ```\n       */\n\n      this.deselected = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.selectedIndexes = [];\n      this.buttonClickNotifier$ = new Subject();\n      this.buttonSelectedNotifier$ = new Subject();\n      this.queryListNotifier$ = new Subject();\n      this._disabled = false;\n    }\n    /**\n     * A collection containing all buttons inside the button group.\n     */\n\n\n    get buttons() {\n      return [...this.viewButtons.toArray(), ...this.templateButtons.toArray()];\n    }\n    /**\n     * Allows you to set a style using the `itemContentCssClass` input.\n     * The value should be the CSS class name that will be applied to the button group.\n     * ```typescript\n     * public style1 = \"styleClass\";\n     *  //..\n     * ```\n     *  ```html\n     * <igx-buttongroup [itemContentCssClass]=\"style1\" [multiSelection]=\"!multi\" [values]=\"alignOptions\">\n     * ```\n     */\n\n\n    set itemContentCssClass(value) {\n      this._itemContentCssClass = value || this._itemContentCssClass;\n    }\n    /**\n     * Returns the CSS class of the item content of the `IgxButtonGroup`.\n     * ```typescript\n     *  @ViewChild(\"MyChild\")\n     * public buttonG: IgxButtonGroupComponent;\n     * ngAfterViewInit(){\n     *    let buttonSelect = this.buttonG.itemContentCssClass;\n     * }\n     * ```\n     */\n\n\n    get itemContentCssClass() {\n      return this._itemContentCssClass;\n    }\n    /**\n     * An @Input property that allows you to disable the `igx-buttongroup` component. By default it's false.\n     * ```html\n     * <igx-buttongroup [disabled]=\"true\" [multiSelection]=\"multi\" [values]=\"fontOptions\"></igx-buttongroup>\n     * ```\n     */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n\n    set disabled(value) {\n      if (this._disabled !== value) {\n        this._disabled = value;\n\n        if (this.viewButtons && this.templateButtons) {\n          this.buttons.forEach(b => b.disabled = this._disabled);\n        }\n      }\n    }\n    /**\n     * Allows you to set the button group alignment.\n     * Available options are `ButtonGroupAlignment.horizontal` (default) and `ButtonGroupAlignment.vertical`.\n     * ```typescript\n     * public alignment = ButtonGroupAlignment.vertical;\n     * //..\n     * ```\n     * ```html\n     * <igx-buttongroup [multiSelection]=\"false\" [values]=\"cities\" [alignment]=\"alignment\"></igx-buttongroup>\n     * ```\n     */\n\n\n    set alignment(value) {\n      this._isVertical = value === ButtonGroupAlignment.vertical;\n    }\n    /**\n     * Returns the alignment of the `igx-buttongroup`.\n     * ```typescript\n     * @ViewChild(\"MyChild\")\n     * public buttonG: IgxButtonGroupComponent;\n     * ngAfterViewInit(){\n     *    let buttonAlignment = this.buttonG.alignment;\n     * }\n     * ```\n     */\n\n\n    get alignment() {\n      return this._isVertical ? ButtonGroupAlignment.vertical : ButtonGroupAlignment.horizontal;\n    }\n    /**\n     * Returns true if the `igx-buttongroup` alignment is vertical.\n     * Note that in order for the accessor to work correctly the property should be set explicitly.\n     * ```html\n     * <igx-buttongroup #MyChild [alignment]=\"alignment\" [values]=\"alignOptions\">\n     * ```\n     * ```typescript\n     * //...\n     * @ViewChild(\"MyChild\")\n     * private buttonG: IgxButtonGroupComponent;\n     * ngAfterViewInit(){\n     *    let orientation = this.buttonG.isVertical;\n     * }\n     * ```\n     */\n\n\n    get isVertical() {\n      return this._isVertical;\n    }\n    /**\n     * Gets the selected button/buttons.\n     * ```typescript\n     * @ViewChild(\"MyChild\")\n     * private buttonG: IgxButtonGroupComponent;\n     * ngAfterViewInit(){\n     *    let selectedButton = this.buttonG.selectedButtons;\n     * }\n     * ```\n     */\n\n\n    get selectedButtons() {\n      return this.buttons.filter((_, i) => this.selectedIndexes.indexOf(i) !== -1);\n    }\n    /**\n     * Selects a button by its index.\n     * ```typescript\n     * @ViewChild(\"MyChild\")\n     * private buttonG: IgxButtonGroupComponent;\n     * ngAfterViewInit(){\n     *    this.buttonG.selectButton(2);\n     *    this.cdr.detectChanges();\n     * }\n     * ```\n     *\n     * @memberOf {@link IgxButtonGroupComponent}\n     */\n\n\n    selectButton(index) {\n      if (index >= this.buttons.length || index < 0) {\n        return;\n      }\n\n      const button = this.buttons[index];\n      button.select();\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    updateSelected(index) {\n      const button = this.buttons[index];\n\n      if (this.selectedIndexes.indexOf(index) === -1) {\n        this.selectedIndexes.push(index);\n        this.selected.emit({\n          button,\n          index\n        });\n      }\n\n      this._renderer.setAttribute(button.nativeElement, 'aria-pressed', 'true');\n\n      this._renderer.addClass(button.nativeElement, 'igx-button-group__item--selected');\n\n      const indexInViewButtons = this.viewButtons.toArray().indexOf(button);\n\n      if (indexInViewButtons !== -1) {\n        this.values[indexInViewButtons].selected = true;\n      } // deselect other buttons if multiSelection is not enabled\n\n\n      if (!this.multiSelection && this.selectedIndexes.length > 1) {\n        this.buttons.forEach((_, i) => {\n          if (i !== index && this.selectedIndexes.indexOf(i) !== -1) {\n            this.deselectButton(i);\n          }\n        });\n      }\n    }\n    /**\n     * Deselects a button by its index.\n     * ```typescript\n     * @ViewChild(\"MyChild\")\n     * private buttonG: IgxButtonGroupComponent;\n     * ngAfterViewInit(){\n     *    this.buttonG.deselectButton(2);\n     *    this.cdr.detectChanges();\n     * }\n     * ```\n     *\n     * @memberOf {@link IgxButtonGroupComponent}\n     */\n\n\n    deselectButton(index) {\n      if (index >= this.buttons.length || index < 0) {\n        return;\n      }\n\n      const button = this.buttons[index];\n      this.selectedIndexes.splice(this.selectedIndexes.indexOf(index), 1);\n\n      this._renderer.setAttribute(button.nativeElement, 'aria-pressed', 'false');\n\n      this._renderer.removeClass(button.nativeElement, 'igx-button-group__item--selected');\n\n      button.deselect();\n      const indexInViewButtons = this.viewButtons.toArray().indexOf(button);\n\n      if (indexInViewButtons !== -1) {\n        this.values[indexInViewButtons].selected = false;\n      }\n\n      this.deselected.emit({\n        button,\n        index\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterContentInit() {\n      this.templateButtons.forEach(button => {\n        if (!button.initialDensity) {\n          button.displayDensity = this.displayDensity;\n        }\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterViewInit() {\n      const initButtons = () => {\n        // Cancel any existing buttonClick subscriptions\n        this.buttonClickNotifier$.next();\n        this.selectedIndexes.splice(0, this.selectedIndexes.length); // initial configuration\n\n        this.buttons.forEach((button, index) => {\n          const buttonElement = button.nativeElement;\n\n          this._renderer.addClass(buttonElement, 'igx-button-group__item');\n\n          if (this.disabled) {\n            button.disabled = true;\n          }\n\n          if (button.selected) {\n            this.updateSelected(index);\n          }\n\n          button.buttonClick.pipe(takeUntil(this.buttonClickNotifier$)).subscribe(_ => this._clickHandler(index));\n          button.buttonSelected.pipe(takeUntil(this.buttonSelectedNotifier$)).subscribe(_ => this.updateSelected(index));\n        });\n      };\n\n      this.viewButtons.changes.pipe(takeUntil(this.queryListNotifier$)).subscribe(() => initButtons());\n      this.templateButtons.changes.pipe(takeUntil(this.queryListNotifier$)).subscribe(() => initButtons());\n      initButtons();\n\n      this._cdr.detectChanges();\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      this.buttonClickNotifier$.next();\n      this.buttonClickNotifier$.complete();\n      this.buttonSelectedNotifier$.next();\n      this.buttonSelectedNotifier$.complete();\n      this.queryListNotifier$.next();\n      this.queryListNotifier$.complete();\n    }\n    /**\n     * @hidden\n     */\n\n\n    _clickHandler(i) {\n      if (this.selectedIndexes.indexOf(i) === -1) {\n        this.selectButton(i);\n      } else {\n        this.deselectButton(i);\n      }\n    }\n\n  }\n\n  IgxButtonGroupComponent.ɵfac = function IgxButtonGroupComponent_Factory(t) {\n    return new (t || IgxButtonGroupComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DisplayDensityToken, 8));\n  };\n\n  IgxButtonGroupComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxButtonGroupComponent,\n    selectors: [[\"igx-buttongroup\"]],\n    contentQueries: function IgxButtonGroupComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxButtonDirective, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.templateButtons = _t);\n      }\n    },\n    viewQuery: function IgxButtonGroupComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxButtonDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.viewButtons = _t);\n      }\n    },\n    hostVars: 3,\n    hostBindings: function IgxButtonGroupComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id);\n        i0.ɵɵstyleProp(\"z-index\", ctx.zIndex);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      itemContentCssClass: \"itemContentCssClass\",\n      multiSelection: \"multiSelection\",\n      values: \"values\",\n      disabled: \"disabled\",\n      alignment: \"alignment\"\n    },\n    outputs: {\n      selected: \"selected\",\n      deselected: \"deselected\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c8,\n    decls: 3,\n    vars: 3,\n    consts: [[\"role\", \"group\", 1, \"igx-button-group\"], [\"type\", \"button\", \"igxButton\", \"flat\", 3, \"displayDensity\", \"selected\", \"disabled\", \"igxButtonColor\", \"igxButtonBackground\", \"igxLabel\", \"igxRipple\", 4, \"ngFor\", \"ngForOf\"], [\"type\", \"button\", \"igxButton\", \"flat\", 3, \"displayDensity\", \"selected\", \"disabled\", \"igxButtonColor\", \"igxButtonBackground\", \"igxLabel\", \"igxRipple\"], [4, \"ngIf\"], [\"class\", \"igx-button-group__button-text\", 4, \"ngIf\"], [1, \"igx-button-group__button-text\"]],\n    template: function IgxButtonGroupComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵtemplate(1, IgxButtonGroupComponent_button_1_Template, 4, 13, \"button\", 1);\n        i0.ɵɵprojection(2);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-button-group--vertical\", ctx.isVertical);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.values);\n      }\n    },\n    directives: [IgxIconComponent, i4.NgForOf, IgxButtonDirective, IgxRippleDirective, i4.NgIf],\n    encapsulation: 2\n  });\n  return IgxButtonGroupComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxButtonGroupModule = /*#__PURE__*/(() => {\n  class IgxButtonGroupModule {}\n\n  IgxButtonGroupModule.ɵfac = function IgxButtonGroupModule_Factory(t) {\n    return new (t || IgxButtonGroupModule)();\n  };\n\n  IgxButtonGroupModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxButtonGroupModule\n  });\n  IgxButtonGroupModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[IgxButtonModule, CommonModule, IgxRippleModule, IgxIconModule]]\n  });\n  return IgxButtonGroupModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar DateRangeType = /*#__PURE__*/(() => {\n  (function (DateRangeType) {\n    DateRangeType[DateRangeType[\"After\"] = 0] = \"After\";\n    DateRangeType[DateRangeType[\"Before\"] = 1] = \"Before\";\n    DateRangeType[DateRangeType[\"Between\"] = 2] = \"Between\";\n    DateRangeType[DateRangeType[\"Specific\"] = 3] = \"Specific\";\n    DateRangeType[DateRangeType[\"Weekdays\"] = 4] = \"Weekdays\";\n    DateRangeType[DateRangeType[\"Weekends\"] = 5] = \"Weekends\";\n  })(DateRangeType || (DateRangeType = {}));\n\n  return DateRangeType;\n})();\n\n/**\n * @hidden\n */\nvar TimeDeltaInterval = /*#__PURE__*/(() => {\n  (function (TimeDeltaInterval) {\n    TimeDeltaInterval[\"Month\"] = \"month\";\n    TimeDeltaInterval[\"Year\"] = \"year\";\n  })(TimeDeltaInterval || (TimeDeltaInterval = {}));\n\n  return TimeDeltaInterval;\n})();\nconst MDAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst FEBRUARY = 1;\n\nconst range = (start = 0, stop, step = 1) => {\n  const res = [];\n  const cur = stop === undefined ? 0 : start;\n  const max = stop === undefined ? start : stop;\n\n  for (let i = cur; step < 0 ? i > max : i < max; i += step) {\n    res.push(i);\n  }\n\n  return res;\n};\n/**\n * Returns true for leap years, false for non-leap years.\n *\n * @export\n * @param year\n * @returns\n */\n\n\nconst isLeap = year => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n\nconst weekDay = (year, month, day) => new Date(year, month, day).getDay();\n/**\n * Return weekday and number of days for year, month.\n *\n * @export\n * @param year\n * @param month\n * @returns\n */\n\n\nconst monthRange = (year, month) => {\n  if (month < 0 || month > 11) {\n    throw new Error('Invalid month specified');\n  }\n\n  const day = weekDay(year, month, 1);\n  let nDays = MDAYS[month];\n\n  if (month === FEBRUARY && isLeap(year)) {\n    nDays++;\n  }\n\n  return [day, nDays];\n};\n\nconst isDateInRanges = (date, ranges) => {\n  date = new Date(date.getFullYear(), date.getMonth(), date.getDate());\n  const dateInMs = date.getTime();\n\n  if (!ranges) {\n    return false;\n  }\n\n  for (const descriptor of ranges) {\n    const dRanges = descriptor.dateRange ? descriptor.dateRange.map(r => new Date(r.getFullYear(), r.getMonth(), r.getDate())) : undefined;\n\n    switch (descriptor.type) {\n      case DateRangeType.After:\n        if (dateInMs > dRanges[0].getTime()) {\n          return true;\n        }\n\n        break;\n\n      case DateRangeType.Before:\n        if (dateInMs < dRanges[0].getTime()) {\n          return true;\n        }\n\n        break;\n\n      case DateRangeType.Between:\n        const dRange = dRanges.map(d => d.getTime());\n        const min = Math.min(dRange[0], dRange[1]);\n        const max = Math.max(dRange[0], dRange[1]);\n\n        if (dateInMs >= min && dateInMs <= max) {\n          return true;\n        }\n\n        break;\n\n      case DateRangeType.Specific:\n        const datesInMs = dRanges.map(d => d.getTime());\n\n        for (const specificDateInMs of datesInMs) {\n          if (dateInMs === specificDateInMs) {\n            return true;\n          }\n        }\n\n        break;\n\n      case DateRangeType.Weekdays:\n        const day = date.getDay();\n\n        if (day % 6 !== 0) {\n          return true;\n        }\n\n        break;\n\n      case DateRangeType.Weekends:\n        const weekday = date.getDay();\n\n        if (weekday % 6 === 0) {\n          return true;\n        }\n\n        break;\n\n      default:\n        return false;\n    }\n  }\n\n  return false;\n};\n\nvar WEEKDAYS = /*#__PURE__*/(() => {\n  (function (WEEKDAYS) {\n    WEEKDAYS[WEEKDAYS[\"SUNDAY\"] = 0] = \"SUNDAY\";\n    WEEKDAYS[WEEKDAYS[\"MONDAY\"] = 1] = \"MONDAY\";\n    WEEKDAYS[WEEKDAYS[\"TUESDAY\"] = 2] = \"TUESDAY\";\n    WEEKDAYS[WEEKDAYS[\"WEDNESDAY\"] = 3] = \"WEDNESDAY\";\n    WEEKDAYS[WEEKDAYS[\"THURSDAY\"] = 4] = \"THURSDAY\";\n    WEEKDAYS[WEEKDAYS[\"FRIDAY\"] = 5] = \"FRIDAY\";\n    WEEKDAYS[WEEKDAYS[\"SATURDAY\"] = 6] = \"SATURDAY\";\n  })(WEEKDAYS || (WEEKDAYS = {}));\n\n  return WEEKDAYS;\n})();\n\nclass Calendar {\n  constructor(firstWeekDay = WEEKDAYS.SUNDAY) {\n    this._firstWeekDay = firstWeekDay;\n  }\n\n  get firstWeekDay() {\n    return this._firstWeekDay % 7;\n  }\n\n  set firstWeekDay(value) {\n    this._firstWeekDay = value;\n  }\n  /**\n   * Returns an array of weekdays for one week starting\n   * with the currently set `firstWeekDay`\n   *\n   * this.firstWeekDay = 0 (Sunday) --> [0, 1, 2, 3, 4, 5, 6]\n   * this.firstWeekDay = 1 (Monday) --> [1, 2, 3, 4, 5, 6, 0]\n   *\n   * @returns\n   *\n   * @memberof Calendar\n   */\n\n\n  weekdays() {\n    const res = [];\n\n    for (const i of range(this.firstWeekDay, this.firstWeekDay + 7)) {\n      res.push(i % 7);\n    }\n\n    return res;\n  }\n  /**\n   * Returns the date values for one month. It will always iterate throught\n   * complete weeks, so it will contain dates outside the specified month.\n   *\n   * @param year\n   * @param month\n   * @param boolean\n   * @returns\n   *\n   * @memberof Calendar\n   */\n\n\n  monthdates(year, month, extraWeek = false) {\n    let date = new Date(year, month, 1);\n    let days = (date.getDay() - this.firstWeekDay) % 7;\n\n    if (days < 0) {\n      days = 7 - Math.abs(days);\n    }\n\n    date = this.timedelta(date, 'day', -days);\n    const res = [];\n    let value;\n\n    while (true) {\n      value = this.generateICalendarDate(date, year, month);\n      res.push(value);\n      date = this.timedelta(date, 'day', 1);\n\n      if (date.getMonth() !== month && date.getDay() === this.firstWeekDay) {\n        if (extraWeek && res.length <= 35) {\n          for (const _ of range(0, 7)) {\n            value = this.generateICalendarDate(date, year, month);\n            res.push(value);\n            date = this.timedelta(date, 'day', 1);\n          }\n        }\n\n        break;\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Returns a matrix (array of arrays) representing a month's calendar.\n   * Each row represents a full week; week entries are ICalendarDate objects.\n   *\n   * @param year\n   * @param month\n   * @returns\n   *\n   * @memberof Calendar\n   */\n\n\n  monthdatescalendar(year, month, extraWeek = false) {\n    const dates = this.monthdates(year, month, extraWeek);\n    const res = [];\n\n    for (const i of range(0, dates.length, 7)) {\n      res.push(dates.slice(i, i + 7));\n    }\n\n    return res;\n  }\n\n  timedelta(date, interval, units) {\n    const ret = new Date(date);\n\n    const checkRollover = () => {\n      if (ret.getDate() !== date.getDate()) {\n        ret.setDate(0);\n      }\n    };\n\n    switch (interval.toLowerCase()) {\n      case 'year':\n        ret.setFullYear(ret.getFullYear() + units);\n        checkRollover();\n        break;\n\n      case 'quarter':\n        ret.setMonth(ret.getMonth() + 3 * units);\n        checkRollover();\n        break;\n\n      case 'month':\n        ret.setMonth(ret.getMonth() + units);\n        checkRollover();\n        break;\n\n      case 'week':\n        ret.setDate(ret.getDate() + 7 * units);\n        break;\n\n      case 'day':\n        ret.setDate(ret.getDate() + units);\n        break;\n\n      case 'hour':\n        ret.setTime(ret.getTime() + units * 3600000);\n        break;\n\n      case 'minute':\n        ret.setTime(ret.getTime() + units * 60000);\n        break;\n\n      case 'second':\n        ret.setTime(ret.getTime() + units * 1000);\n        break;\n\n      default:\n        throw new Error('Invalid interval specifier');\n    }\n\n    return ret;\n  }\n\n  formatToParts(date, locale, options, parts) {\n    const formatter = new Intl.DateTimeFormat(locale, options);\n    const result = {\n      date,\n      full: formatter.format(date)\n    };\n\n    if (formatter.formatToParts) {\n      const formattedParts = formatter.formatToParts(date);\n\n      const toType = partType => {\n        const index = formattedParts.findIndex(({\n          type\n        }) => type === partType);\n        const o = {\n          value: '',\n          literal: '',\n          combined: ''\n        };\n\n        if (partType === 'era' && index > -1) {\n          o.value = formattedParts[index].value;\n          return o;\n        } else if (partType === 'era' && index === -1) {\n          return o;\n        }\n\n        o.value = formattedParts[index].value;\n        o.literal = formattedParts[index + 1] ? formattedParts[index + 1].value : '';\n        o.combined = [o.value, o.literal].join('');\n        return o;\n      };\n\n      for (const each of parts) {\n        result[each] = toType(each);\n      }\n    } else {\n      for (const each of parts) {\n        result[each] = {\n          value: '',\n          literal: '',\n          combined: ''\n        };\n      }\n    }\n\n    return result;\n  }\n\n  getFirstViewDate(date, interval, activeViewIdx) {\n    return this.timedelta(date, interval, -activeViewIdx);\n  }\n\n  getDateByView(date, interval, activeViewIdx) {\n    return this.timedelta(date, interval, activeViewIdx);\n  }\n\n  getNextMonth(date) {\n    return this.timedelta(date, TimeDeltaInterval.Month, 1);\n  }\n\n  getPrevMonth(date) {\n    return this.timedelta(date, TimeDeltaInterval.Month, -1);\n  }\n\n  getNextYear(date) {\n    return this.timedelta(date, TimeDeltaInterval.Year, 1);\n  }\n\n  getPrevYear(date) {\n    return this.timedelta(date, TimeDeltaInterval.Year, -1);\n  }\n\n  getWeekNumber(date) {\n    const firstJan = new Date(date.getFullYear(), 0, 1).getTime();\n    const today = new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime();\n    const dayInMilSeconds = 86400000;\n    const dayOfYear = (today - firstJan + 1) / dayInMilSeconds;\n    return Math.ceil(dayOfYear / 7);\n  }\n\n  generateICalendarDate(date, year, month) {\n    return {\n      date,\n      isCurrentMonth: date.getFullYear() === year && date.getMonth() === month,\n      isNextMonth: this.isNextMonth(date, year, month),\n      isPrevMonth: this.isPreviousMonth(date, year, month)\n    };\n  }\n\n  isPreviousMonth(date, year, month) {\n    if (date.getFullYear() === year) {\n      return date.getMonth() < month;\n    }\n\n    return date.getFullYear() < year;\n  }\n\n  isNextMonth(date, year, month) {\n    if (date.getFullYear() === year) {\n      return date.getMonth() > month;\n    }\n\n    return date.getFullYear() > year;\n  }\n\n}\n/**\n * Sets the selection type - single, multi or range.\n */\n\n\nconst CalendarSelection = mkenum({\n  SINGLE: 'single',\n  MULTI: 'multi',\n  RANGE: 'range'\n});\nvar ScrollMonth = /*#__PURE__*/(() => {\n  (function (ScrollMonth) {\n    ScrollMonth[\"PREV\"] = \"prev\";\n    ScrollMonth[\"NEXT\"] = \"next\";\n    ScrollMonth[\"NONE\"] = \"none\";\n  })(ScrollMonth || (ScrollMonth = {}));\n\n  return ScrollMonth;\n})();\n\n/** @hidden @internal */\nlet IgxCalendarBaseDirective = /*#__PURE__*/(() => {\n  class IgxCalendarBaseDirective {\n    /**\n     * @hidden\n     */\n    constructor(platform) {\n      this.platform = platform;\n      /**\n       * Sets/gets whether the outside dates (dates that are out of the current month) will be hidden.\n       * Default value is `false`.\n       * ```html\n       * <igx-calendar [hideOutsideDays] = \"true\"></igx-calendar>\n       * ```\n       * ```typescript\n       * let hideOutsideDays = this.calendar.hideOutsideDays;\n       * ```\n       */\n\n      this.hideOutsideDays = false;\n      /**\n       * Emits an event when a date is selected.\n       * Provides reference the `selectedDates` property.\n       */\n\n      this.selected = new EventEmitter();\n      /**\n       * Emits an event when the month in view is changed.\n       * ```html\n       * <igx-calendar (viewDateChanged)=\"viewDateChanged($event)\"></igx-calendar>\n       * ```\n       * ```typescript\n       * public viewDateChanged(event: IViewDateChangeEventArgs) {\n       *  let viewDate = event.currentValue;\n       * }\n       * ```\n       */\n\n      this.viewDateChanged = new EventEmitter();\n      /**\n       * Emits an event when the active view is changed.\n       * ```html\n       * <igx-calendar (activeViewChanged)=\"activeViewChanged($event)\"></igx-calendar>\n       * ```\n       * ```typescript\n       * public activeViewChanged(event: CalendarView) {\n       *  let activeView = event;\n       * }\n       * ```\n       */\n\n      this.activeViewChanged = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.rangeStarted = false;\n      /**\n       * @hidden\n       */\n\n      this.monthScrollDirection = ScrollMonth.NONE;\n      /**\n       * @hidden\n       */\n\n      this.scrollMonth$ = new Subject();\n      /**\n       * @hidden\n       */\n\n      this.stopMonthScroll$ = new Subject();\n      /**\n       * @hidden\n       */\n\n      this.startMonthScroll$ = new Subject();\n      /**\n       * @hidden\n       */\n\n      this._onTouchedCallback = noop;\n      /**\n       * @hidden\n       */\n\n      this._onChangeCallback = noop;\n      /**\n       * @hidden\n       */\n\n      this._locale = 'en';\n      /**\n       * @hidden\n       */\n\n      this._selection = CalendarSelection.SINGLE;\n      /** @hidden @internal */\n\n      this._resourceStrings = CurrentResourceStrings.CalendarResStrings;\n      /**\n       * @hidden\n       */\n\n      this._formatOptions = {\n        day: 'numeric',\n        month: 'short',\n        weekday: 'short',\n        year: 'numeric'\n      };\n      /**\n       * @hidden\n       */\n\n      this._formatViews = {\n        day: false,\n        month: true,\n        year: false\n      };\n      this.calendarModel = new Calendar();\n      this.viewDate = this.viewDate ? this.viewDate : new Date();\n      this.calendarModel.firstWeekDay = this.weekStart;\n      this.initFormatters();\n    }\n    /**\n     * An accessor that sets the resource strings.\n     * By default it uses EN resources.\n     */\n\n\n    set resourceStrings(value) {\n      this._resourceStrings = Object.assign({}, this._resourceStrings, value);\n    }\n    /**\n     * An accessor that returns the resource strings.\n     */\n\n\n    get resourceStrings() {\n      if (!this._resourceStrings) {\n        this._resourceStrings = CurrentResourceStrings.CalendarResStrings;\n      }\n\n      return this._resourceStrings;\n    }\n    /**\n     * Gets the start day of the week.\n     * Can return a numeric or an enum representation of the week day.\n     * Defaults to `Sunday` / `0`.\n     */\n\n\n    get weekStart() {\n      return this.calendarModel.firstWeekDay;\n    }\n    /**\n     * Sets the start day of the week.\n     * Can be assigned to a numeric value or to `WEEKDAYS` enum value.\n     */\n\n\n    set weekStart(value) {\n      this.calendarModel.firstWeekDay = value;\n    }\n    /**\n     * Gets the `locale` of the calendar.\n     * Default value is `\"en\"`.\n     */\n\n\n    get locale() {\n      return this._locale;\n    }\n    /**\n     * Sets the `locale` of the calendar.\n     * Expects a valid BCP 47 language tag.\n     * Default value is `\"en\"`.\n     */\n\n\n    set locale(value) {\n      this._locale = value;\n      this.initFormatters();\n    }\n    /**\n     * Gets the date format options of the days view.\n     */\n\n\n    get formatOptions() {\n      return this._formatOptions;\n    }\n    /**\n     * Sets the date format options of the days view.\n     * Default is { day: 'numeric', month: 'short', weekday: 'short', year: 'numeric' }\n     */\n\n\n    set formatOptions(formatOptions) {\n      this._formatOptions = Object.assign(this._formatOptions, formatOptions);\n      this.initFormatters();\n    }\n    /**\n     * Gets whether the `day`, `month` and `year` should be rendered\n     * according to the locale and formatOptions, if any.\n     */\n\n\n    get formatViews() {\n      return this._formatViews;\n    }\n    /**\n     * Gets whether the `day`, `month` and `year` should be rendered\n     * according to the locale and formatOptions, if any.\n     */\n\n\n    set formatViews(formatViews) {\n      this._formatViews = Object.assign(this._formatViews, formatViews);\n    }\n    /**\n     *\n     * Gets the selection type.\n     * Default value is `\"single\"`.\n     * Changing the type of selection resets the currently\n     * selected values if any.\n     */\n\n\n    get selection() {\n      return this._selection;\n    }\n    /**\n     * Sets the selection.\n     */\n\n\n    set selection(value) {\n      switch (value) {\n        case CalendarSelection.SINGLE:\n          this.selectedDates = null;\n          break;\n\n        case CalendarSelection.MULTI:\n        case CalendarSelection.RANGE:\n          this.selectedDates = [];\n          break;\n\n        default:\n          throw new Error('Invalid selection value');\n      }\n\n      this._onChangeCallback(this.selectedDates);\n\n      this.rangeStarted = false;\n      this._selection = value;\n    }\n    /**\n     * Gets the selected date(s).\n     *\n     * When selection is set to `single`, it returns\n     * a single `Date` object.\n     * Otherwise it is an array of `Date` objects.\n     */\n\n\n    get value() {\n      return this.selectedDates;\n    }\n    /**\n     * Sets the selected date(s).\n     *\n     * When selection is set to `single`, it accepts\n     * a single `Date` object.\n     * Otherwise it is an array of `Date` objects.\n     */\n\n\n    set value(value) {\n      if (!value || !!value && value.length === 0) {\n        this.selectedDatesWithoutFocus = new Date();\n        return;\n      }\n\n      if (!this.selectedDatesWithoutFocus) {\n        const valueDate = value[0] ? Math.min.apply(null, value) : value;\n        const date = this.getDateOnly(new Date(valueDate)).setDate(1);\n        this.viewDate = new Date(date);\n      }\n\n      this.selectDate(value);\n      this.selectedDatesWithoutFocus = value;\n    }\n    /**\n     * Gets the date that is presented.\n     * By default it is the current date.\n     */\n\n\n    get viewDate() {\n      return this._viewDate;\n    }\n    /**\n     * Sets the date that will be presented in the default view when the component renders.\n     */\n\n\n    set viewDate(value) {\n      if (Array.isArray(value)) {\n        return;\n      }\n\n      const validDate = this.validateDate(value);\n\n      if (this._viewDate) {\n        this.selectedDatesWithoutFocus = validDate;\n      }\n\n      const date = this.getDateOnly(validDate).setDate(1);\n      this._viewDate = new Date(date);\n    }\n    /**\n     * Gets the disabled dates descriptors.\n     */\n\n\n    get disabledDates() {\n      return this._disabledDates;\n    }\n    /**\n     * Sets the disabled dates' descriptors.\n     * ```typescript\n     * @ViewChild(\"MyCalendar\")\n     * public calendar: IgxCalendarComponent;\n     * ngOnInit(){\n     *    this.calendar.disabledDates = [\n     *     {type: DateRangeType.Between, dateRange: [new Date(\"2020-1-1\"), new Date(\"2020-1-15\")]},\n     *     {type: DateRangeType.Weekends}];\n     * }\n     * ```\n     */\n\n\n    set disabledDates(value) {\n      this._disabledDates = value;\n    }\n    /**\n     * Gets the special dates descriptors.\n     */\n\n\n    get specialDates() {\n      return this._specialDates;\n    }\n    /**\n     * Sets the special dates' descriptors.\n     * ```typescript\n     * @ViewChild(\"MyCalendar\")\n     * public calendar: IgxCalendarComponent;\n     * ngOnInit(){\n     *    this.calendar.specialDates = [\n     *     {type: DateRangeType.Between, dateRange: [new Date(\"2020-1-1\"), new Date(\"2020-1-15\")]},\n     *     {type: DateRangeType.Weekends}];\n     * }\n     * ```\n     */\n\n\n    set specialDates(value) {\n      this._specialDates = value;\n    }\n    /**\n     * Performs deselection of a single value, when selection is multi\n     * Usually performed by the selectMultiple method, but leads to bug when multiple months are in view\n     *\n     * @hidden\n     */\n\n\n    deselectMultipleInMonth(value) {\n      const valueDateOnly = this.getDateOnly(value);\n      this.selectedDates = this.selectedDates.filter(date => date.getTime() !== valueDateOnly.getTime());\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this._onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this._onTouchedCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      this.selectDate(value);\n    }\n    /**\n     * Checks whether a date is disabled.\n     *\n     * @hidden\n     */\n\n\n    isDateDisabled(date) {\n      if (this.disabledDates === null) {\n        return false;\n      }\n\n      return isDateInRanges(date, this.disabledDates);\n    }\n    /**\n     * Selects date(s) (based on the selection type).\n     */\n\n\n    selectDate(value) {\n      if (value === null || value === undefined || Array.isArray(value) && value.length === 0) {\n        return;\n      }\n\n      switch (this.selection) {\n        case CalendarSelection.SINGLE:\n          if (isDate(value) && !this.isDateDisabled(value)) {\n            this.selectSingle(value);\n          }\n\n          break;\n\n        case CalendarSelection.MULTI:\n          this.selectMultiple(value);\n          break;\n\n        case CalendarSelection.RANGE:\n          this.selectRange(value, true);\n          break;\n      }\n    }\n    /**\n     * Deselects date(s) (based on the selection type).\n     */\n\n\n    deselectDate(value) {\n      if (!this.selectedDates || this.selectedDates.length === 0) {\n        return;\n      }\n\n      if (value === null || value === undefined) {\n        this.selectedDates = this.selection === CalendarSelection.SINGLE ? null : [];\n        this.rangeStarted = false;\n\n        this._onChangeCallback(this.selectedDates);\n\n        return;\n      }\n\n      switch (this.selection) {\n        case CalendarSelection.SINGLE:\n          this.deselectSingle(value);\n          break;\n\n        case CalendarSelection.MULTI:\n          this.deselectMultiple(value);\n          break;\n\n        case CalendarSelection.RANGE:\n          this.deselectRange(value);\n          break;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    selectDateFromClient(value) {\n      switch (this.selection) {\n        case CalendarSelection.SINGLE:\n        case CalendarSelection.MULTI:\n          this.selectDate(value);\n          break;\n\n        case CalendarSelection.RANGE:\n          this.selectRange(value, true);\n          break;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    initFormatters() {\n      this.formatterDay = new Intl.DateTimeFormat(this._locale, {\n        day: this._formatOptions.day\n      });\n      this.formatterWeekday = new Intl.DateTimeFormat(this._locale, {\n        weekday: this._formatOptions.weekday\n      });\n      this.formatterMonth = new Intl.DateTimeFormat(this._locale, {\n        month: this._formatOptions.month\n      });\n      this.formatterYear = new Intl.DateTimeFormat(this._locale, {\n        year: this._formatOptions.year\n      });\n      this.formatterMonthday = new Intl.DateTimeFormat(this._locale, {\n        month: this._formatOptions.month,\n        day: this._formatOptions.day\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    getDateOnly(date) {\n      const validDate = this.validateDate(date);\n      return new Date(validDate.getFullYear(), validDate.getMonth(), validDate.getDate());\n    }\n    /**\n     * @hidden\n     */\n\n\n    getDateOnlyInMs(date) {\n      return this.getDateOnly(date).getTime();\n    }\n    /**\n     * @hidden\n     */\n\n\n    generateDateRange(start, end) {\n      const result = [];\n      start = this.getDateOnly(start);\n      end = this.getDateOnly(end);\n\n      while (start.getTime() < end.getTime()) {\n        start = this.calendarModel.timedelta(start, 'day', 1);\n        result.push(start);\n      }\n\n      return result;\n    }\n    /**\n     * Performs a single selection.\n     *\n     * @hidden\n     */\n\n\n    selectSingle(value) {\n      this.selectedDates = this.getDateOnly(value);\n\n      this._onChangeCallback(this.selectedDates);\n    }\n    /**\n     * Performs a multiple selection\n     *\n     * @hidden\n     */\n\n\n    selectMultiple(value) {\n      if (Array.isArray(value)) {\n        const newDates = value.map(v => this.getDateOnly(v).getTime());\n        const selDates = this.selectedDates.map(v => this.getDateOnly(v).getTime());\n\n        if (JSON.stringify(newDates) === JSON.stringify(selDates)) {\n          return;\n        }\n\n        this.selectedDates = Array.from(new Set([...newDates, ...selDates])).map(v => new Date(v));\n      } else {\n        const valueDateOnly = this.getDateOnly(value);\n        const newSelection = [];\n\n        if (this.selectedDates.every(date => date.getTime() !== valueDateOnly.getTime())) {\n          newSelection.push(valueDateOnly);\n        } else {\n          this.selectedDates = this.selectedDates.filter(date => date.getTime() !== valueDateOnly.getTime());\n        }\n\n        if (newSelection.length > 0) {\n          this.selectedDates = this.selectedDates.concat(newSelection);\n        }\n      }\n\n      this.selectedDates = this.selectedDates.filter(d => !this.isDateDisabled(d));\n      this.selectedDates.sort((a, b) => a.valueOf() - b.valueOf());\n\n      this._onChangeCallback(this.selectedDates);\n    }\n    /**\n     * @hidden\n     */\n\n\n    selectRange(value, excludeDisabledDates = false) {\n      let start;\n      let end;\n\n      if (Array.isArray(value)) {\n        // this.rangeStarted = false;\n        value.sort((a, b) => a.valueOf() - b.valueOf());\n        start = this.getDateOnly(value[0]);\n        end = this.getDateOnly(value[value.length - 1]);\n        this.selectedDates = [start, ...this.generateDateRange(start, end)];\n      } else {\n        if (!this.rangeStarted) {\n          this.rangeStarted = true;\n          this.selectedDates = [value];\n        } else {\n          this.rangeStarted = false;\n\n          if (this.selectedDates[0].getTime() === value.getTime()) {\n            this.selectedDates = [];\n\n            this._onChangeCallback(this.selectedDates);\n\n            return;\n          }\n\n          this.selectedDates.push(value);\n          this.selectedDates.sort((a, b) => a.valueOf() - b.valueOf());\n          start = this.selectedDates.shift();\n          end = this.selectedDates.pop();\n          this.selectedDates = [start, ...this.generateDateRange(start, end)];\n        }\n      }\n\n      if (excludeDisabledDates) {\n        this.selectedDates = this.selectedDates.filter(d => !this.isDateDisabled(d));\n      }\n\n      this._onChangeCallback(this.selectedDates);\n    }\n    /**\n     * Performs a single deselection.\n     *\n     * @hidden\n     */\n\n\n    deselectSingle(value) {\n      if (this.selectedDates !== null && this.getDateOnlyInMs(value) === this.getDateOnlyInMs(this.selectedDates)) {\n        this.selectedDates = null;\n\n        this._onChangeCallback(this.selectedDates);\n      }\n    }\n    /**\n     * Performs a multiple deselection.\n     *\n     * @hidden\n     */\n\n\n    deselectMultiple(value) {\n      value = value.filter(v => v !== null);\n      const selectedDatesCount = this.selectedDates.length;\n      const datesInMsToDeselect = new Set(value.map(v => this.getDateOnlyInMs(v)));\n\n      for (let i = this.selectedDates.length - 1; i >= 0; i--) {\n        if (datesInMsToDeselect.has(this.getDateOnlyInMs(this.selectedDates[i]))) {\n          this.selectedDates.splice(i, 1);\n        }\n      }\n\n      if (this.selectedDates.length !== selectedDatesCount) {\n        this._onChangeCallback(this.selectedDates);\n      }\n    }\n    /**\n     * Performs a range deselection.\n     *\n     * @hidden\n     */\n\n\n    deselectRange(value) {\n      value = value.filter(v => v !== null);\n\n      if (value.length < 1) {\n        return;\n      }\n\n      value.sort((a, b) => a.valueOf() - b.valueOf());\n      const valueStart = this.getDateOnlyInMs(value[0]);\n      const valueEnd = this.getDateOnlyInMs(value[value.length - 1]);\n      this.selectedDates.sort((a, b) => a.valueOf() - b.valueOf());\n      const selectedDatesStart = this.getDateOnlyInMs(this.selectedDates[0]);\n      const selectedDatesEnd = this.getDateOnlyInMs(this.selectedDates[this.selectedDates.length - 1]);\n\n      if (!(valueEnd < selectedDatesStart) && !(valueStart > selectedDatesEnd)) {\n        this.selectedDates = [];\n        this.rangeStarted = false;\n\n        this._onChangeCallback(this.selectedDates);\n      }\n    }\n\n    validateDate(value) {\n      return DateTimeUtil.isValidDate(value) ? value : new Date();\n    }\n\n  }\n\n  IgxCalendarBaseDirective.ɵfac = function IgxCalendarBaseDirective_Factory(t) {\n    return new (t || IgxCalendarBaseDirective)(i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxCalendarBaseDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxCalendarBaseDirective,\n    selectors: [[\"\", \"igxCalendarBase\", \"\"]],\n    inputs: {\n      hideOutsideDays: \"hideOutsideDays\",\n      resourceStrings: \"resourceStrings\",\n      weekStart: \"weekStart\",\n      locale: \"locale\",\n      formatOptions: \"formatOptions\",\n      formatViews: \"formatViews\",\n      selection: \"selection\",\n      value: \"value\",\n      viewDate: \"viewDate\",\n      disabledDates: \"disabledDates\",\n      specialDates: \"specialDates\"\n    },\n    outputs: {\n      selected: \"selected\",\n      viewDateChanged: \"viewDateChanged\",\n      activeViewChanged: \"activeViewChanged\"\n    }\n  });\n  return IgxCalendarBaseDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * This file contains all the directives used by the @link IgxCalendarComponent.\n * Except for the directives which are used for templating the calendar itself\n * you should generally not use them directly.\n *\n * @preferred\n */\n\n/**\n * @hidden\n */\n\n\nlet IgxCalendarYearDirective = /*#__PURE__*/(() => {\n  class IgxCalendarYearDirective {\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n      this.yearSelection = new EventEmitter();\n    }\n\n    get currentCSS() {\n      return this.isCurrentYear;\n    }\n\n    get role() {\n      return this.isCurrentYear ? 'spinbutton' : null;\n    }\n\n    get valuenow() {\n      return this.isCurrentYear ? this.date.getFullYear() : null;\n    }\n\n    get tabIndex() {\n      return this.isCurrentYear ? 0 : -1;\n    }\n\n    get isCurrentYear() {\n      return this.date.getFullYear() === this.value.getFullYear();\n    }\n\n    get nativeElement() {\n      return this.elementRef.nativeElement;\n    }\n\n    onClick() {\n      this.yearSelection.emit(this.value);\n    }\n\n  }\n\n  IgxCalendarYearDirective.ɵfac = function IgxCalendarYearDirective_Factory(t) {\n    return new (t || IgxCalendarYearDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxCalendarYearDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxCalendarYearDirective,\n    selectors: [[\"\", \"igxCalendarYear\", \"\"]],\n    hostVars: 5,\n    hostBindings: function IgxCalendarYearDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function IgxCalendarYearDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"aria-valuenow\", ctx.valuenow)(\"tabindex\", ctx.tabIndex);\n        i0.ɵɵclassProp(\"igx-calendar__year--current\", ctx.currentCSS);\n      }\n    },\n    inputs: {\n      value: [\"igxCalendarYear\", \"value\"],\n      date: \"date\"\n    },\n    outputs: {\n      yearSelection: \"yearSelection\"\n    }\n  });\n  return IgxCalendarYearDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxCalendarMonthDirective = /*#__PURE__*/(() => {\n  class IgxCalendarMonthDirective {\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n      this.monthSelection = new EventEmitter();\n    }\n\n    get currentCSS() {\n      return this.isCurrentMonth;\n    }\n\n    get isCurrentMonth() {\n      return this.date.getMonth() === this.value.getMonth();\n    }\n\n    get nativeElement() {\n      return this.elementRef.nativeElement;\n    }\n\n    onClick() {\n      const date = new Date(this.value.getFullYear(), this.value.getMonth(), this.date.getDate());\n      this.monthSelection.emit(date);\n    }\n\n  }\n\n  IgxCalendarMonthDirective.ɵfac = function IgxCalendarMonthDirective_Factory(t) {\n    return new (t || IgxCalendarMonthDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxCalendarMonthDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxCalendarMonthDirective,\n    selectors: [[\"\", \"igxCalendarMonth\", \"\"]],\n    hostVars: 2,\n    hostBindings: function IgxCalendarMonthDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function IgxCalendarMonthDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-calendar__month--current\", ctx.currentCSS);\n      }\n    },\n    inputs: {\n      value: [\"igxCalendarMonth\", \"value\"],\n      date: \"date\",\n      index: \"index\"\n    },\n    outputs: {\n      monthSelection: \"monthSelection\"\n    }\n  });\n  return IgxCalendarMonthDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxCalendarHeaderTemplateDirective = /*#__PURE__*/(() => {\n  class IgxCalendarHeaderTemplateDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxCalendarHeaderTemplateDirective.ɵfac = function IgxCalendarHeaderTemplateDirective_Factory(t) {\n    return new (t || IgxCalendarHeaderTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxCalendarHeaderTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxCalendarHeaderTemplateDirective,\n    selectors: [[\"\", \"igxCalendarHeader\", \"\"]]\n  });\n  return IgxCalendarHeaderTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxCalendarSubheaderTemplateDirective = /*#__PURE__*/(() => {\n  class IgxCalendarSubheaderTemplateDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxCalendarSubheaderTemplateDirective.ɵfac = function IgxCalendarSubheaderTemplateDirective_Factory(t) {\n    return new (t || IgxCalendarSubheaderTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxCalendarSubheaderTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxCalendarSubheaderTemplateDirective,\n    selectors: [[\"\", \"igxCalendarSubheader\", \"\"]]\n  });\n  return IgxCalendarSubheaderTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxCalendarScrollMonthDirective = /*#__PURE__*/(() => {\n  class IgxCalendarScrollMonthDirective {\n    constructor(element, zone, platform) {\n      this.element = element;\n      this.zone = zone;\n      this.platform = platform;\n      /**\n       * @hidden\n       */\n\n      this.destroy$ = new Subject();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onMouseDown() {\n      this.startScroll();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onMouseUp(event) {\n      this.stopScroll(event);\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterViewInit() {\n      fromEvent(this.element.nativeElement, 'keyup').pipe(debounce(() => interval(100)), takeUntil(this.destroy$)).subscribe(event => {\n        this.stopScroll(event);\n      });\n      this.zone.runOutsideAngular(() => {\n        fromEvent(this.element.nativeElement, 'keydown').pipe(tap(event => {\n          if (this.platform.isActivationKey(event)) {\n            event.preventDefault();\n            event.stopPropagation();\n          }\n        }), debounce(() => interval(100)), takeUntil(this.destroy$)).subscribe(event => {\n          if (this.platform.isActivationKey(event)) {\n            this.zone.run(() => this.startScroll(true));\n          }\n        });\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      this.destroy$.next(true);\n      this.destroy$.complete();\n    }\n\n  }\n\n  IgxCalendarScrollMonthDirective.ɵfac = function IgxCalendarScrollMonthDirective_Factory(t) {\n    return new (t || IgxCalendarScrollMonthDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxCalendarScrollMonthDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxCalendarScrollMonthDirective,\n    selectors: [[\"\", \"igxCalendarScrollMonth\", \"\"]],\n    hostBindings: function IgxCalendarScrollMonthDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"mousedown\", function IgxCalendarScrollMonthDirective_mousedown_HostBindingHandler() {\n          return ctx.onMouseDown();\n        })(\"mouseup\", function IgxCalendarScrollMonthDirective_mouseup_HostBindingHandler($event) {\n          return ctx.onMouseUp($event);\n        });\n      }\n    },\n    inputs: {\n      startScroll: \"startScroll\",\n      stopScroll: \"stopScroll\"\n    }\n  });\n  return IgxCalendarScrollMonthDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst IgxCalendarView = mkenum({\n  Month: 'month',\n  Year: 'year',\n  Decade: 'decade'\n});\n/**\n * @hidden\n */\n\nvar CalendarView = /*#__PURE__*/(() => {\n  (function (CalendarView) {\n    CalendarView[CalendarView[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    CalendarView[CalendarView[\"YEAR\"] = 1] = \"YEAR\";\n    CalendarView[CalendarView[\"DECADE\"] = 2] = \"DECADE\";\n  })(CalendarView || (CalendarView = {}));\n\n  return CalendarView;\n})();\nlet IgxMonthPickerBaseDirective = /*#__PURE__*/(() => {\n  class IgxMonthPickerBaseDirective extends IgxCalendarBaseDirective {\n    constructor() {\n      super(...arguments);\n      /**\n       * Holds month view index we are operating on.\n       */\n\n      this.activeViewIdx = 0;\n      /**\n       * @hidden\n       */\n\n      this._activeView = IgxCalendarView.Month;\n    }\n    /**\n     * Gets the current active view.\n     * ```typescript\n     * this.activeView = calendar.activeView;\n     * ```\n     */\n\n\n    get activeView() {\n      return this._activeView;\n    }\n    /**\n     * Sets the current active view.\n     * ```html\n     * <igx-calendar [activeView]=\"year\" #calendar></igx-calendar>\n     * ```\n     * ```typescript\n     * calendar.activeView = IgxCalendarView.YEAR;\n     * ```\n     */\n\n\n    set activeView(val) {\n      this._activeView = val;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isDefaultView() {\n      return this._activeView === CalendarView.DEFAULT || this._activeView === IgxCalendarView.Month;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isDecadeView() {\n      return this._activeView === CalendarView.DECADE || this._activeView === IgxCalendarView.Decade;\n    }\n    /**\n     * @hidden\n     */\n\n\n    changeYear(event) {\n      this.previousViewDate = this.viewDate;\n      this.viewDate = this.calendarModel.getFirstViewDate(event, 'month', this.activeViewIdx);\n      this.activeView = IgxCalendarView.Month;\n      requestAnimationFrame(() => {\n        if (this.yearsBtns && this.yearsBtns.length) {\n          this.yearsBtns.find((e, idx) => idx === this.activeViewIdx).nativeElement.focus();\n        }\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    activeViewDecade(activeViewIdx = 0) {\n      this.activeView = IgxCalendarView.Decade;\n      this.activeViewIdx = activeViewIdx;\n    }\n    /**\n     * @hidden\n     */\n\n\n    activeViewDecadeKB(event, activeViewIdx = 0) {\n      if (this.platform.isActivationKey(event)) {\n        event.preventDefault();\n        this.activeViewDecade(activeViewIdx);\n      }\n    }\n    /**\n     * Returns the locale representation of the year in the year view if enabled,\n     * otherwise returns the default `Date.getFullYear()` value.\n     *\n     * @hidden\n     */\n\n\n    formattedYear(value) {\n      if (this.formatViews.year) {\n        return this.formatterYear.format(value);\n      }\n\n      return `${value.getFullYear()}`;\n    }\n\n  }\n\n  IgxMonthPickerBaseDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxMonthPickerBaseDirective_BaseFactory;\n    return function IgxMonthPickerBaseDirective_Factory(t) {\n      return (ɵIgxMonthPickerBaseDirective_BaseFactory || (ɵIgxMonthPickerBaseDirective_BaseFactory = i0.ɵɵgetInheritedFactory(IgxMonthPickerBaseDirective)))(t || IgxMonthPickerBaseDirective);\n    };\n  }();\n\n  IgxMonthPickerBaseDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxMonthPickerBaseDirective,\n    selectors: [[\"\", \"igxMonthPickerBase\", \"\"]],\n    viewQuery: function IgxMonthPickerBaseDirective_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c38, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.yearsBtns = _t);\n      }\n    },\n    inputs: {\n      activeView: \"activeView\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return IgxMonthPickerBaseDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$k = 0;\nlet IgxMonthsViewComponent = /*#__PURE__*/(() => {\n  class IgxMonthsViewComponent {\n    constructor(el) {\n      this.el = el;\n      /**\n       * Sets/gets the `id` of the months view.\n       * If not set, the `id` will have value `\"igx-months-view-0\"`.\n       * ```html\n       * <igx-months-view id=\"my-months-view\"></igx-months-view>\n       * ```\n       * ```typescript\n       * let monthsViewId =  this.monthsView.id;\n       * ```\n       *\n       * @memberof IgxMonthsViewComponent\n       */\n\n      this.id = `igx-months-view-${NEXT_ID$k++}`;\n      /**\n       * Gets/sets whether the view should be rendered\n       * according to the locale and monthFormat, if any.\n       */\n\n      this.formatView = true;\n      /**\n       * Emits an event when a selection is made in the months view.\n       * Provides reference the `date` property in the `IgxMonthsViewComponent`.\n       * ```html\n       * <igx-months-view (selected)=\"onSelection($event)\"></igx-months-view>\n       * ```\n       *\n       * @memberof IgxMonthsViewComponent\n       */\n\n      this.selected = new EventEmitter();\n      /**\n       * The default css class applied to the component.\n       *\n       * @hidden\n       */\n\n      this.styleClass = true;\n      this._date = new Date();\n      /**\n       * @hidden\n       */\n\n      this._locale = 'en';\n      /**\n       * @hidden\n       */\n\n      this._monthFormat = 'short';\n      /**\n       * @hidden\n       */\n\n      this._onTouchedCallback = noop;\n      /**\n       * @hidden\n       */\n\n      this._onChangeCallback = noop;\n      this.initMonthFormatter();\n      this._calendarModel = new Calendar();\n    }\n    /**\n     * Gets/sets the selected date of the months view.\n     * By default it is the current date.\n     * ```html\n     * <igx-months-view [date]=\"myDate\"></igx-months-view>\n     * ```\n     * ```typescript\n     * let date =  this.monthsView.date;\n     * ```\n     *\n     * @memberof IgxMonthsViewComponent\n     */\n\n\n    set date(value) {\n      if (!(value instanceof Date)) {\n        return;\n      }\n\n      this._date = value;\n      this.activeMonth = this.date.getMonth();\n    }\n\n    get date() {\n      return this._date;\n    }\n    /**\n     * Gets the month format option of the months view.\n     * ```typescript\n     * let monthFormat = this.monthsView.monthFormat.\n     * ```\n     */\n\n\n    get monthFormat() {\n      return this._monthFormat;\n    }\n    /**\n     * Sets the month format option of the months view.\n     * ```html\n     * <igx-months-view> [monthFormat] = \"short'\"</igx-months-view>\n     * ```\n     *\n     * @memberof IgxMonthsViewComponent\n     */\n\n\n    set monthFormat(value) {\n      this._monthFormat = value;\n      this.initMonthFormatter();\n    }\n    /**\n     * Gets the `locale` of the months view.\n     * Default value is `\"en\"`.\n     * ```typescript\n     * let locale =  this.monthsView.locale;\n     * ```\n     *\n     * @memberof IgxMonthsViewComponent\n     */\n\n\n    get locale() {\n      return this._locale;\n    }\n    /**\n     * Sets the `locale` of the months view.\n     * Expects a valid BCP 47 language tag.\n     * Default value is `\"en\"`.\n     * ```html\n     * <igx-months-view [locale]=\"de\"></igx-months-view>\n     * ```\n     *\n     * @memberof IgxMonthsViewComponent\n     */\n\n\n    set locale(value) {\n      this._locale = value;\n      this.initMonthFormatter();\n    }\n    /**\n     * Returns an array of date objects which are then used to\n     * properly render the month names.\n     *\n     * Used in the template of the component\n     *\n     * @hidden\n     */\n\n\n    get months() {\n      let start = new Date(this.date.getFullYear(), 0, 1);\n      const result = [];\n\n      for (let i = 0; i < 12; i++) {\n        result.push(start);\n        start = this._calendarModel.timedelta(start, 'month', 1);\n      }\n\n      return result;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onKeydownArrowUp(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      const node = this.monthsRef.find(date => date.nativeElement === event.target);\n\n      if (!node) {\n        return;\n      }\n\n      const months = this.monthsRef.toArray();\n      const nodeRect = node.nativeElement.getBoundingClientRect();\n\n      for (let index = months.indexOf(node) - 1; index >= 0; index--) {\n        const nextNodeRect = months[index].nativeElement.getBoundingClientRect();\n        const tolerance = 6;\n\n        if (nodeRect.top !== nextNodeRect.top && nextNodeRect.left - nodeRect.left < tolerance) {\n          const month = months[index];\n          month.nativeElement.focus();\n          this.activeMonth = month.value.getMonth();\n          break;\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onKeydownArrowDown(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      const node = this.monthsRef.find(date => date.nativeElement === event.target);\n\n      if (!node) {\n        return;\n      }\n\n      const months = this.monthsRef.toArray();\n      const nodeRect = node.nativeElement.getBoundingClientRect();\n\n      for (let index = months.indexOf(node) + 1; index < months.length; index++) {\n        const nextNodeRect = months[index].nativeElement.getBoundingClientRect();\n        const tolerance = 6;\n\n        if (nextNodeRect.top !== nodeRect.top && nodeRect.left - nextNodeRect.left < tolerance) {\n          const month = months[index];\n          month.nativeElement.focus();\n          this.activeMonth = month.value.getMonth();\n          break;\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onKeydownArrowRight(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      const node = this.monthsRef.find(date => date.nativeElement === event.target);\n\n      if (!node) {\n        return;\n      }\n\n      const months = this.monthsRef.toArray();\n\n      if (months.indexOf(node) + 1 < months.length) {\n        const month = months[months.indexOf(node) + 1];\n        this.activeMonth = month.value.getMonth();\n        month.nativeElement.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onKeydownArrowLeft(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      const node = this.monthsRef.find(date => date.nativeElement === event.target);\n\n      if (!node) {\n        return;\n      }\n\n      const months = this.monthsRef.toArray();\n\n      if (months.indexOf(node) - 1 >= 0) {\n        const month = months[months.indexOf(node) - 1];\n        this.activeMonth = month.value.getMonth();\n        month.nativeElement.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onKeydownHome(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      const month = this.monthsRef.toArray()[0];\n      this.activeMonth = month.value.getMonth();\n      month.nativeElement.focus();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onKeydownEnd(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      const months = this.monthsRef.toArray();\n      const month = months[months.length - 1];\n      this.activeMonth = month.value.getMonth();\n      month.nativeElement.focus();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onKeydownEnter(event) {\n      const value = this.monthsRef.find(date => date.nativeElement === event.target).value;\n      this.date = new Date(value.getFullYear(), value.getMonth(), this.date.getDate());\n      this.activeMonth = this.date.getMonth();\n      this.selected.emit(this.date);\n\n      this._onChangeCallback(this.date);\n    }\n\n    resetActiveMonth() {\n      this.activeMonth = this.date.getMonth();\n    }\n    /**\n     * Returns the locale representation of the month in the months view.\n     *\n     * @hidden\n     */\n\n\n    formattedMonth(value) {\n      if (this.formatView) {\n        return this._formatterMonth.format(value);\n      }\n\n      return `${value.getMonth()}`;\n    }\n    /**\n     * @hidden\n     */\n\n\n    selectMonth(event) {\n      this.selected.emit(event);\n      this.date = event;\n      this.activeMonth = this.date.getMonth();\n\n      this._onChangeCallback(this.date);\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this._onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this._onTouchedCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      if (value) {\n        this.date = value;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    monthTracker(index, item) {\n      return `${item.getMonth()}}`;\n    }\n    /**\n     * @hidden\n     */\n\n\n    initMonthFormatter() {\n      this._formatterMonth = new Intl.DateTimeFormat(this._locale, {\n        month: this.monthFormat\n      });\n    }\n\n  }\n\n  IgxMonthsViewComponent.ɵfac = function IgxMonthsViewComponent_Factory(t) {\n    return new (t || IgxMonthsViewComponent)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxMonthsViewComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxMonthsViewComponent,\n    selectors: [[\"igx-months-view\"]],\n    viewQuery: function IgxMonthsViewComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxCalendarMonthDirective, 5, IgxCalendarMonthDirective);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.monthsRef = _t);\n      }\n    },\n    hostVars: 3,\n    hostBindings: function IgxMonthsViewComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown.arrowup\", function IgxMonthsViewComponent_keydown_arrowup_HostBindingHandler($event) {\n          return ctx.onKeydownArrowUp($event);\n        })(\"keydown.arrowdown\", function IgxMonthsViewComponent_keydown_arrowdown_HostBindingHandler($event) {\n          return ctx.onKeydownArrowDown($event);\n        })(\"keydown.arrowright\", function IgxMonthsViewComponent_keydown_arrowright_HostBindingHandler($event) {\n          return ctx.onKeydownArrowRight($event);\n        })(\"keydown.arrowleft\", function IgxMonthsViewComponent_keydown_arrowleft_HostBindingHandler($event) {\n          return ctx.onKeydownArrowLeft($event);\n        })(\"keydown.home\", function IgxMonthsViewComponent_keydown_home_HostBindingHandler($event) {\n          return ctx.onKeydownHome($event);\n        })(\"keydown.end\", function IgxMonthsViewComponent_keydown_end_HostBindingHandler($event) {\n          return ctx.onKeydownEnd($event);\n        })(\"keydown.enter\", function IgxMonthsViewComponent_keydown_enter_HostBindingHandler($event) {\n          return ctx.onKeydownEnter($event);\n        })(\"focusout\", function IgxMonthsViewComponent_focusout_HostBindingHandler() {\n          return ctx.resetActiveMonth();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id);\n        i0.ɵɵclassProp(\"igx-calendar\", ctx.styleClass);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      date: \"date\",\n      monthFormat: \"monthFormat\",\n      locale: \"locale\",\n      formatView: \"formatView\"\n    },\n    outputs: {\n      selected: \"selected\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: IgxMonthsViewComponent,\n      multi: true\n    }])],\n    decls: 3,\n    vars: 2,\n    consts: [[1, \"igx-calendar__body\"], [1, \"igx-calendar__body-row\", \"igx-calendar__body-row--wrap\"], [\"class\", \"igx-calendar__month\", \"role\", \"button\", 3, \"igxCalendarMonth\", \"date\", \"index\", \"monthSelection\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [\"role\", \"button\", 1, \"igx-calendar__month\", 3, \"igxCalendarMonth\", \"date\", \"index\", \"monthSelection\"]],\n    template: function IgxMonthsViewComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1);\n        i0.ɵɵtemplate(2, IgxMonthsViewComponent_span_2_Template, 4, 11, \"span\", 2);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngForOf\", ctx.months)(\"ngForTrackBy\", ctx.monthTracker);\n      }\n    },\n    directives: [i4.NgForOf, IgxCalendarMonthDirective],\n    pipes: [i4.DatePipe, i4.TitleCasePipe],\n    encapsulation: 2\n  });\n  return IgxMonthsViewComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet CalendarHammerConfig = /*#__PURE__*/(() => {\n  class CalendarHammerConfig extends HammerGestureConfig {\n    constructor() {\n      super(...arguments);\n      this.overrides = {\n        pan: {\n          direction: Hammer.DIRECTION_VERTICAL,\n          threshold: 1\n        }\n      };\n    }\n\n  }\n\n  CalendarHammerConfig.ɵfac = /* @__PURE__ */function () {\n    let ɵCalendarHammerConfig_BaseFactory;\n    return function CalendarHammerConfig_Factory(t) {\n      return (ɵCalendarHammerConfig_BaseFactory || (ɵCalendarHammerConfig_BaseFactory = i0.ɵɵgetInheritedFactory(CalendarHammerConfig)))(t || CalendarHammerConfig);\n    };\n  }();\n\n  CalendarHammerConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CalendarHammerConfig,\n    factory: CalendarHammerConfig.ɵfac\n  });\n  return CalendarHammerConfig;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxYearsViewComponent = /*#__PURE__*/(() => {\n  class IgxYearsViewComponent {\n    constructor(el) {\n      this.el = el;\n      /**\n       * Emits an event when a selection is made in the years view.\n       * Provides reference the `date` property in the `IgxYearsViewComponent`.\n       * ```html\n       * <igx-years-view (selected)=\"onSelection($event)\"></igx-years-view>\n       * ```\n       *\n       * @memberof IgxYearsViewComponent\n       */\n\n      this.selected = new EventEmitter();\n      /**\n       * The default css class applied to the component.\n       *\n       * @hidden\n       */\n\n      this.styleClass = true;\n      /**\n       * @hidden\n       */\n\n      this._locale = 'en';\n      /**\n       * @hidden\n       */\n\n      this._yearFormat = 'numeric';\n      /**\n       * @hidden\n       */\n\n      this._date = new Date();\n      /**\n       * @hidden\n       */\n\n      this._onTouchedCallback = noop;\n      /**\n       * @hidden\n       */\n\n      this._onChangeCallback = noop;\n      this.initYearFormatter();\n      this._calendarModel = new Calendar();\n    }\n    /**\n     * Gets/sets the selected date of the years view.\n     * By default it is the current date.\n     * ```html\n     * <igx-years-view [date]=\"myDate\"></igx-years-view>\n     * ```\n     * ```typescript\n     * let date =  this.yearsView.date;\n     * ```\n     *\n     * @memberof IgxYearsViewComponent\n     */\n\n\n    get date() {\n      return this._date;\n    }\n\n    set date(value) {\n      if (!(value instanceof Date)) {\n        return;\n      }\n\n      this._date = value;\n    }\n    /**\n     * Gets the year format option of the years view.\n     * ```typescript\n     * let yearFormat = this.yearsView.yearFormat.\n     * ```\n     */\n\n\n    get yearFormat() {\n      return this._yearFormat;\n    }\n    /**\n     * Sets the year format option of the years view.\n     * ```html\n     * <igx-years-view [yearFormat]=\"numeric\"></igx-years-view>\n     * ```\n     *\n     * @memberof IgxYearsViewComponent\n     */\n\n\n    set yearFormat(value) {\n      this._yearFormat = value;\n      this.initYearFormatter();\n    }\n    /**\n     * Gets the `locale` of the years view.\n     * Default value is `\"en\"`.\n     * ```typescript\n     * let locale =  this.yearsView.locale;\n     * ```\n     *\n     * @memberof IgxYearsViewComponent\n     */\n\n\n    get locale() {\n      return this._locale;\n    }\n    /**\n     * Sets the `locale` of the years view.\n     * Expects a valid BCP 47 language tag.\n     * Default value is `\"en\"`.\n     * ```html\n     * <igx-years-view [locale]=\"de\"></igx-years-view>\n     * ```\n     *\n     * @memberof IgxYearsViewComponent\n     */\n\n\n    set locale(value) {\n      this._locale = value;\n      this.initYearFormatter();\n    }\n    /**\n     * Returns an array of date objects which are then used to properly\n     * render the years.\n     *\n     * Used in the template of the component.\n     *\n     * @hidden\n     */\n\n\n    get decade() {\n      const result = [];\n      const start = this.date.getFullYear() - 3;\n      const end = this.date.getFullYear() + 4;\n\n      for (const year of range(start, end)) {\n        result.push(new Date(year, this.date.getMonth(), this.date.getDate()));\n      }\n\n      return result;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onKeydownArrowDown(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.generateYearRange(1);\n      this.calendarDir.find(date => date.isCurrentYear).nativeElement.nextElementSibling.focus();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onKeydownArrowUp(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.generateYearRange(-1);\n      this.calendarDir.find(date => date.isCurrentYear).nativeElement.previousElementSibling.focus();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onKeydownEnter() {\n      this.selected.emit(this.date);\n\n      this._onChangeCallback(this.date);\n    }\n    /**\n     * Returns the locale representation of the year in the years view.\n     *\n     * @hidden\n     */\n\n\n    formattedYear(value) {\n      if (this.formatView) {\n        return this._formatterYear.format(value);\n      }\n\n      return `${value.getFullYear()}`;\n    }\n    /**\n     * @hidden\n     */\n\n\n    selectYear(event) {\n      this.date = event;\n      this.selected.emit(this.date);\n\n      this._onChangeCallback(this.date);\n    }\n    /**\n     * @hidden\n     */\n\n\n    scroll(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      const delta = event.deltaY < 0 ? -1 : 1;\n      this.generateYearRange(delta);\n    }\n    /**\n     * @hidden\n     */\n\n\n    pan(event) {\n      const delta = event.deltaY < 0 ? 1 : -1;\n      this.generateYearRange(delta);\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this._onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this._onTouchedCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    yearTracker(index, item) {\n      return `${item.getFullYear()}}`;\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      if (value) {\n        this.date = value;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    initYearFormatter() {\n      this._formatterYear = new Intl.DateTimeFormat(this._locale, {\n        year: this.yearFormat\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    generateYearRange(delta) {\n      const currentYear = new Date().getFullYear();\n\n      if (delta > 0 && this.date.getFullYear() - currentYear >= 95 || delta < 0 && currentYear - this.date.getFullYear() >= 95) {\n        return;\n      }\n\n      this.date = this._calendarModel.timedelta(this.date, 'year', delta);\n    }\n\n  }\n\n  IgxYearsViewComponent.ɵfac = function IgxYearsViewComponent_Factory(t) {\n    return new (t || IgxYearsViewComponent)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxYearsViewComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxYearsViewComponent,\n    selectors: [[\"igx-years-view\"]],\n    viewQuery: function IgxYearsViewComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxCalendarYearDirective, 5, IgxCalendarYearDirective);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.calendarDir = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function IgxYearsViewComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown.arrowdown\", function IgxYearsViewComponent_keydown_arrowdown_HostBindingHandler($event) {\n          return ctx.onKeydownArrowDown($event);\n        })(\"keydown.arrowup\", function IgxYearsViewComponent_keydown_arrowup_HostBindingHandler($event) {\n          return ctx.onKeydownArrowUp($event);\n        })(\"keydown.enter\", function IgxYearsViewComponent_keydown_enter_HostBindingHandler() {\n          return ctx.onKeydownEnter();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-calendar\", ctx.styleClass);\n      }\n    },\n    inputs: {\n      formatView: \"formatView\",\n      date: \"date\",\n      yearFormat: \"yearFormat\",\n      locale: \"locale\"\n    },\n    outputs: {\n      selected: \"selected\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: IgxYearsViewComponent,\n      multi: true\n    }, {\n      provide: HAMMER_GESTURE_CONFIG,\n      useClass: CalendarHammerConfig\n    }])],\n    decls: 3,\n    vars: 2,\n    consts: [[1, \"igx-calendar__body\"], [1, \"igx-calendar__body-column\", 3, \"wheel\", \"pan\"], [\"class\", \"igx-calendar__year\", 3, \"igxCalendarYear\", \"date\", \"yearSelection\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [1, \"igx-calendar__year\", 3, \"igxCalendarYear\", \"date\", \"yearSelection\"]],\n    template: function IgxYearsViewComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1);\n        i0.ɵɵlistener(\"wheel\", function IgxYearsViewComponent_Template_div_wheel_1_listener($event) {\n          return ctx.scroll($event);\n        })(\"pan\", function IgxYearsViewComponent_Template_div_pan_1_listener($event) {\n          return ctx.pan($event);\n        });\n        i0.ɵɵtemplate(2, IgxYearsViewComponent_span_2_Template, 2, 3, \"span\", 2);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngForOf\", ctx.decade)(\"ngForTrackBy\", ctx.yearTracker);\n      }\n    },\n    directives: [i4.NgForOf, IgxCalendarYearDirective],\n    encapsulation: 2\n  });\n  return IgxYearsViewComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxDayItemComponent = /*#__PURE__*/(() => {\n  class IgxDayItemComponent {\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n      this.hideOutsideDays = false;\n      this.isLastInRange = false;\n      this.isFirstInRange = false;\n      this.isWithinRange = false;\n      this.dateSelection = new EventEmitter();\n      this._selected = false;\n    }\n    /**\n     * Returns boolean indicating if the day is selected\n     *\n     */\n\n\n    get selected() {\n      return this._selected;\n    }\n    /**\n     * Selects the day\n     */\n\n\n    set selected(value) {\n      this._selected = value;\n    }\n\n    get isCurrentMonth() {\n      return this.date.isCurrentMonth;\n    }\n\n    get isPreviousMonth() {\n      return this.date.isPrevMonth;\n    }\n\n    get isNextMonth() {\n      return this.date.isNextMonth;\n    }\n\n    get nativeElement() {\n      return this.elementRef.nativeElement;\n    }\n\n    get isSelectedCSS() {\n      return !this.isDisabled && this.selected;\n    }\n\n    get isInactive() {\n      return this.date.isNextMonth || this.date.isPrevMonth;\n    }\n\n    get isHidden() {\n      return this.hideOutsideDays && this.isInactive;\n    }\n\n    get isToday() {\n      const today = new Date(Date.now());\n      const date = this.date.date;\n\n      if (date.getDate() === today.getDate()) {\n        this.nativeElement.setAttribute('aria-current', 'date');\n      }\n\n      return date.getFullYear() === today.getFullYear() && date.getMonth() === today.getMonth() && date.getDate() === today.getDate();\n    }\n\n    get isWeekend() {\n      const day = this.date.date.getDay();\n      return day === 0 || day === 6;\n    }\n\n    get isDisabled() {\n      if (this.disabledDates === null) {\n        return false;\n      }\n\n      return isDateInRanges(this.date.date, this.disabledDates);\n    }\n\n    get isOutOfRange() {\n      if (!this.outOfRangeDates) {\n        return false;\n      }\n\n      return isDateInRanges(this.date.date, this.outOfRangeDates);\n    }\n\n    get isFocusable() {\n      return this.isCurrentMonth && !this.isHidden && !this.isDisabled && !this.isOutOfRange;\n    }\n\n    get isWithinRangeCSS() {\n      return !this.isSingleSelection && this.isWithinRange;\n    }\n\n    get isSpecial() {\n      if (this.specialDates === null) {\n        return false;\n      }\n\n      return isDateInRanges(this.date.date, this.specialDates);\n    }\n\n    get isDisabledCSS() {\n      return this.isHidden || this.isDisabled || this.isOutOfRange;\n    }\n\n    get isSingleSelection() {\n      return this.selection !== CalendarSelection.RANGE;\n    }\n\n    onSelect(event) {\n      event.stopPropagation();\n      this.dateSelection.emit(this.date);\n    }\n\n  }\n\n  IgxDayItemComponent.ɵfac = function IgxDayItemComponent_Factory(t) {\n    return new (t || IgxDayItemComponent)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxDayItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxDayItemComponent,\n    selectors: [[\"igx-day-item\"]],\n    hostVars: 22,\n    hostBindings: function IgxDayItemComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function IgxDayItemComponent_click_HostBindingHandler($event) {\n          return ctx.onSelect($event);\n        })(\"keydown.enter\", function IgxDayItemComponent_keydown_enter_HostBindingHandler($event) {\n          return ctx.onSelect($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-calendar__date--last\", ctx.isLastInRange)(\"igx-calendar__date--first\", ctx.isFirstInRange)(\"igx-calendar__date--selected\", ctx.isSelectedCSS)(\"igx-calendar__date--inactive\", ctx.isInactive)(\"igx-calendar__date--hidden\", ctx.isHidden)(\"igx-calendar__date--current\", ctx.isToday)(\"igx-calendar__date--weekend\", ctx.isWeekend)(\"igx-calendar__date--range\", ctx.isWithinRangeCSS)(\"igx-calendar__date--special\", ctx.isSpecial)(\"igx-calendar__date--disabled\", ctx.isDisabledCSS)(\"igx-calendar__date--single\", ctx.isSingleSelection);\n      }\n    },\n    inputs: {\n      date: \"date\",\n      selection: \"selection\",\n      selected: \"selected\",\n      disabledDates: \"disabledDates\",\n      outOfRangeDates: \"outOfRangeDates\",\n      specialDates: \"specialDates\",\n      hideOutsideDays: \"hideOutsideDays\",\n      isLastInRange: \"isLastInRange\",\n      isFirstInRange: \"isFirstInRange\",\n      isWithinRange: \"isWithinRange\"\n    },\n    outputs: {\n      dateSelection: \"dateSelection\"\n    },\n    ngContentSelectors: _c8,\n    decls: 2,\n    vars: 0,\n    consts: [[\"aria-hidden\", \"true\", 1, \"igx-calendar__date-content\"]],\n    template: function IgxDayItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"span\", 0);\n        i0.ɵɵprojection(1);\n        i0.ɵɵelementEnd();\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxDayItemComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar Direction$1 = /*#__PURE__*/(() => {\n  (function (Direction) {\n    Direction[\"Up\"] = \"ArrowUp\";\n    Direction[\"Down\"] = \"ArrowDown\";\n    Direction[\"Left\"] = \"ArrowLeft\";\n    Direction[\"Right\"] = \"ArrowRight\";\n  })(Direction$1 || (Direction$1 = {}));\n\n  return Direction$1;\n})();\nconst ARROW = 'Arrow';\n/** @hidden */\n\nlet IgxDaysViewNavigationService = /*#__PURE__*/(() => {\n  class IgxDaysViewNavigationService {\n    /**\n     * Implements kb navigation in all MoveDirections. nextDate and nextMonthView naming convention is used for both previous/next\n     *\n     * @hidden\n     */\n    focusNextDate(target, key, nextView = false) {\n      if (target.childElementCount === 0) {\n        target = target.parentElement;\n      }\n\n      if (key.indexOf('Arrow') === -1) {\n        key = ARROW.concat(key);\n      }\n\n      const monthView = this.monthView;\n      const node = monthView.dates.find(date => date.nativeElement === target);\n      let dates = monthView.dates.toArray();\n      let day;\n      let step;\n      let i;\n      let nextDate;\n      const index = dates.indexOf(node);\n\n      if (!node) {\n        return;\n      } // focus item in current month\n\n\n      switch (key) {\n        case Direction$1.Left:\n          {\n            step = -1;\n            nextDate = this.timedelta(node.date.date, step);\n\n            for (i = index; i > 0; i--) {\n              day = nextView ? dates[i] : dates[i - 1];\n              nextDate = day.date.date;\n\n              if (day.date.isPrevMonth) {\n                break;\n              }\n\n              if (day && day.isFocusable) {\n                day.nativeElement.focus();\n                return;\n              }\n            }\n\n            break;\n          }\n\n        case Direction$1.Right:\n          {\n            step = 1;\n            nextDate = this.timedelta(node.date.date, step);\n\n            for (i = index; i < dates.length - 1; i++) {\n              day = nextView ? dates[i] : dates[i + 1];\n              nextDate = day.date.date;\n\n              if (day.date.isNextMonth) {\n                break;\n              }\n\n              if (day && day.isFocusable) {\n                day.nativeElement.focus();\n                return;\n              }\n            }\n\n            break;\n          }\n\n        case Direction$1.Up:\n          {\n            step = -7;\n            nextDate = this.timedelta(node.date.date, step);\n\n            for (i = index; i - 7 > -1; i -= 7) {\n              day = nextView ? dates[i] : dates[i - 7];\n              nextDate = day.date.date;\n\n              if (day.date.isPrevMonth) {\n                break;\n              }\n\n              if (day && day.isFocusable) {\n                day.nativeElement.focus();\n                return;\n              }\n            }\n\n            break;\n          }\n\n        case Direction$1.Down:\n          {\n            step = 7;\n            nextDate = this.timedelta(node.date.date, step);\n\n            for (i = index; i + 7 < 42; i += 7) {\n              day = nextView ? dates[i] : dates[i + 7];\n              nextDate = day.date.date;\n\n              if (day.date.isNextMonth) {\n                break;\n              }\n\n              if (day && day.isFocusable) {\n                day.nativeElement.focus();\n                return;\n              }\n            }\n\n            break;\n          }\n      } // focus item in prev/next visible month\n\n\n      const nextMonthView = step > 0 ? monthView.nextMonthView : monthView.prevMonthView;\n\n      if (nextMonthView) {\n        dates = nextMonthView.dates.toArray();\n        day = dates.find(item => item.date.date.getTime() === nextDate.getTime());\n\n        if (day && day.isFocusable) {\n          day.nativeElement.focus();\n          return;\n        }\n\n        nextMonthView.daysNavService.focusNextDate(day.nativeElement, key);\n      } // if iterating in the visible prev/next moths above found a day that is not focusable, ie is disabled, hidden, etc\n      // then it is needed to recalculate the next day, which is going to be part of the prev/next months\n\n\n      if (day && !day.isFocusable) {\n        day = dates[i + step];\n\n        if (!day) {\n          nextDate = this.timedelta(node.date.date, step + i - index);\n        }\n      } // focus item in prev/next month, which is currently out of view\n\n\n      let dayIsNextMonth; // determine what we need to check for next date - if it belongs to prev or next month\n\n      if (day) {\n        dayIsNextMonth = step > 0 ? day.date.isNextMonth : day.date.isPrevMonth;\n      }\n\n      if (monthView.changeDaysView && !nextMonthView && (day && dayIsNextMonth || !day)) {\n        const monthAction = step > 0 ? ScrollMonth.NEXT : ScrollMonth.PREV;\n        monthView.viewChanging.emit({\n          monthAction,\n          key,\n          nextDate\n        });\n      }\n    }\n    /**\n     * Focuses first focusable day in the month. Will go to next visible month, if no day in the first month is focusable\n     *\n     * @hidden\n     */\n\n\n    focusHomeDate() {\n      let monthView = this.monthView;\n\n      while (!this.focusFirstDay(monthView) && monthView.nextMonthView) {\n        monthView = monthView.nextMonthView;\n      }\n    }\n    /**\n     * Focuses last focusable day in the month. Will go to previous visible month, if no day in the first month is focusable\n     *\n     * @hidden\n     */\n\n\n    focusEndDate() {\n      let monthView = this.monthView;\n\n      while (!this.focusLastDay(monthView) && monthView.prevMonthView) {\n        monthView = monthView.prevMonthView;\n      }\n    }\n\n    timedelta(date, units) {\n      const ret = new Date(date);\n      ret.setDate(ret.getDate() + units);\n      return ret;\n    }\n\n    focusFirstDay(monthView) {\n      const dates = monthView.dates.filter(d => d.isCurrentMonth);\n\n      for (const date of dates) {\n        if (date.isFocusable) {\n          date.nativeElement.focus();\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    focusLastDay(monthView) {\n      const dates = monthView.dates.filter(d => d.isCurrentMonth);\n\n      for (let i = dates.length - 1; i >= 0; i--) {\n        if (dates[i].isFocusable) {\n          dates[i].nativeElement.focus();\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n  }\n\n  IgxDaysViewNavigationService.ɵfac = function IgxDaysViewNavigationService_Factory(t) {\n    return new (t || IgxDaysViewNavigationService)();\n  };\n\n  IgxDaysViewNavigationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxDaysViewNavigationService,\n    factory: IgxDaysViewNavigationService.ɵfac\n  });\n  return IgxDaysViewNavigationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$j = 0;\nlet IgxDaysViewComponent = /*#__PURE__*/(() => {\n  class IgxDaysViewComponent extends IgxCalendarBaseDirective {\n    /**\n     * @hidden\n     */\n    constructor(daysNavService, platform) {\n      super(platform);\n      this.daysNavService = daysNavService;\n      this.platform = platform;\n      /**\n       * Sets/gets the `id` of the days view.\n       * If not set, the `id` will have value `\"igx-days-view-0\"`.\n       * ```html\n       * <igx-days-view id=\"my-days-view\"></igx-days-view>\n       * ```\n       * ```typescript\n       * let daysViewId =  this.daysView.id;\n       * ```\n       */\n\n      this.id = `igx-days-view-${NEXT_ID$j++}`;\n      /**\n       * @hidden\n       */\n\n      this.changeDaysView = false;\n      /**\n       * @hidden\n       */\n\n      this.dateSelection = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.viewChanging = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.activeDateChange = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.monthsViewBlur = new EventEmitter();\n      /**\n       * The default css class applied to the component.\n       *\n       * @hidden\n       */\n\n      this.styleClass = true;\n      /** @hidden */\n\n      this.shouldResetDate = true;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    set activeDate(value) {\n      this._activeDate = value;\n      this.activeDateChange.emit(this._activeDate);\n    }\n\n    get activeDate() {\n      return this._activeDate ? this._activeDate : this.viewDate.toLocaleDateString();\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    resetActiveMonth() {\n      if (this.shouldResetDate) {\n        const date = this.dates.find(day => day.selected && day.isCurrentMonth) || this.dates.find(day => day.isToday && day.isCurrentMonth) || this.dates.find(d => d.isFocusable);\n\n        if (date) {\n          this.activeDate = date.date.date.toLocaleDateString();\n        }\n\n        this.monthsViewBlur.emit();\n      }\n\n      this.shouldResetDate = true;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    pointerDown() {\n      this.shouldResetDate = false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onKeydownArrow(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.shouldResetDate = false;\n      this.daysNavService.focusNextDate(event.target, event.key);\n    }\n    /**\n     * @hidden\n     */\n\n\n    onKeydownHome(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.shouldResetDate = false;\n      this.getFirstMonthView().daysNavService.focusHomeDate();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onKeydownEnd(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.shouldResetDate = false;\n      this.getLastMonthView().daysNavService.focusEndDate();\n    }\n    /**\n     * @hidden\n     */\n\n\n    get getCalendarMonth() {\n      return this.calendarModel.monthdatescalendar(this.viewDate.getFullYear(), this.viewDate.getMonth(), true);\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      this.daysNavService.monthView = this;\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngDoCheck() {\n      if (!this.changeDaysView && this.dates) {\n        this.disableOutOfRangeDates();\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    tabIndex(day) {\n      return this.activeDate && this.activeDate === day.date.toLocaleDateString() && day.isCurrentMonth ? 0 : -1;\n    }\n    /**\n     * Returns the week number by date\n     *\n     * @hidden\n     */\n\n\n    getWeekNumber(date) {\n      return this.calendarModel.getWeekNumber(date);\n    }\n    /**\n     * Returns the locale representation of the date in the days view.\n     *\n     * @hidden\n     */\n\n\n    formattedDate(value) {\n      if (this.formatViews.day) {\n        return this.formatterDay.format(value);\n      }\n\n      return `${value.getDate()}`;\n    }\n    /**\n     * @hidden\n     */\n\n\n    generateWeekHeader() {\n      const dayNames = [];\n      const rv = this.calendarModel.monthdatescalendar(this.viewDate.getFullYear(), this.viewDate.getMonth())[0];\n\n      for (const day of rv) {\n        dayNames.push(this.formatterWeekday.format(day.date));\n      }\n\n      return dayNames;\n    }\n    /**\n     * @hidden\n     */\n\n\n    rowTracker(index, item) {\n      return `${item[index].date.getMonth()}${item[index].date.getDate()}`;\n    }\n    /**\n     * @hidden\n     */\n\n\n    dateTracker(index, item) {\n      return `${item.date.getMonth()}--${item.date.getDate()}`;\n    }\n    /**\n     * @hidden\n     */\n\n\n    isCurrentMonth(value) {\n      return this.viewDate.getMonth() === value.getMonth();\n    }\n    /**\n     * @hidden\n     */\n\n\n    isCurrentYear(value) {\n      return this.viewDate.getFullYear() === value.getFullYear();\n    }\n    /**\n     * @hidden\n     */\n\n\n    isSelected(date) {\n      let selectedDates;\n\n      if (this.isDateDisabled(date.date) || !this.value || Array.isArray(this.value) && this.value.length === 0) {\n        return false;\n      }\n\n      if (this.selection === CalendarSelection.SINGLE) {\n        selectedDates = this.value;\n        return this.getDateOnly(selectedDates).getTime() === date.date.getTime();\n      }\n\n      selectedDates = this.value;\n\n      if (this.selection === CalendarSelection.RANGE && selectedDates.length === 1) {\n        return this.getDateOnly(selectedDates[0]).getTime() === date.date.getTime();\n      }\n\n      if (this.selection === CalendarSelection.MULTI) {\n        const start = this.getDateOnly(selectedDates[0]);\n        const end = this.getDateOnly(selectedDates[selectedDates.length - 1]);\n\n        if (this.isWithinRange(date.date, false, start, end)) {\n          const currentDate = selectedDates.find(element => element.getTime() === date.date.getTime());\n          return !!currentDate;\n        } else {\n          return false;\n        }\n      } else {\n        return this.isWithinRange(date.date, true);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    isLastInRange(date) {\n      if (this.isSingleSelection || !this.value) {\n        return false;\n      }\n\n      const dates = this.value;\n      const lastDate = dates[dates.length - 1];\n      return isEqual(lastDate, date.date);\n    }\n    /**\n     * @hidden\n     */\n\n\n    isFirstInRange(date) {\n      if (this.isSingleSelection || !this.value) {\n        return false;\n      }\n\n      return isEqual(this.value[0], date.date);\n    }\n    /**\n     * @hidden\n     */\n\n\n    isWithinRange(date, checkForRange, min, max) {\n      if (checkForRange && !(Array.isArray(this.value) && this.value.length > 1)) {\n        return false;\n      }\n\n      min = min ? min : this.value[0];\n      max = max ? max : this.value[this.value.length - 1];\n      return isDateInRanges(date, [{\n        type: DateRangeType.Between,\n        dateRange: [min, max]\n      }]);\n    }\n    /**\n     * @hidden\n     */\n\n\n    focusActiveDate() {\n      let date = this.dates.find(d => d.selected);\n\n      if (!date) {\n        date = this.dates.find(d => d.isToday);\n      }\n\n      if (date.isFocusable) {\n        date.nativeElement.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    selectDay(event) {\n      this.selectDateFromClient(event.date);\n      this.dateSelection.emit(event);\n      this.selected.emit(this.selectedDates);\n    }\n    /**\n     * @hidden\n     */\n\n\n    getFirstMonthView() {\n      let monthView = this;\n\n      while (monthView.prevMonthView) {\n        monthView = monthView.prevMonthView;\n      }\n\n      return monthView;\n    }\n    /**\n     * @hidden\n     */\n\n\n    disableOutOfRangeDates() {\n      const dateRange = [];\n      this.dates.toArray().forEach(date => {\n        if (!date.isCurrentMonth) {\n          dateRange.push(date.date.date);\n        }\n      });\n      this.outOfRangeDates = [{\n        type: DateRangeType.Specific,\n        dateRange\n      }];\n    }\n    /**\n     * @hidden\n     */\n\n\n    getLastMonthView() {\n      let monthView = this;\n\n      while (monthView.nextMonthView) {\n        monthView = monthView.nextMonthView;\n      }\n\n      return monthView;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isSingleSelection() {\n      return this.selection !== CalendarSelection.RANGE;\n    }\n\n  }\n\n  IgxDaysViewComponent.ɵfac = function IgxDaysViewComponent_Factory(t) {\n    return new (t || IgxDaysViewComponent)(i0.ɵɵdirectiveInject(IgxDaysViewNavigationService), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxDaysViewComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxDaysViewComponent,\n    selectors: [[\"igx-days-view\"]],\n    viewQuery: function IgxDaysViewComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxDayItemComponent, 5, IgxDayItemComponent);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dates = _t);\n      }\n    },\n    hostVars: 3,\n    hostBindings: function IgxDaysViewComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focusout\", function IgxDaysViewComponent_focusout_HostBindingHandler() {\n          return ctx.resetActiveMonth();\n        })(\"keydown.pagedown\", function IgxDaysViewComponent_keydown_pagedown_HostBindingHandler() {\n          return ctx.pointerDown();\n        })(\"keydown.pageup\", function IgxDaysViewComponent_keydown_pageup_HostBindingHandler() {\n          return ctx.pointerDown();\n        })(\"keydown.shift.pagedown\", function IgxDaysViewComponent_keydown_shift_pagedown_HostBindingHandler() {\n          return ctx.pointerDown();\n        })(\"keydown.shift.pageup\", function IgxDaysViewComponent_keydown_shift_pageup_HostBindingHandler() {\n          return ctx.pointerDown();\n        })(\"pointerdown\", function IgxDaysViewComponent_pointerdown_HostBindingHandler() {\n          return ctx.pointerDown();\n        })(\"keydown.arrowleft\", function IgxDaysViewComponent_keydown_arrowleft_HostBindingHandler($event) {\n          return ctx.onKeydownArrow($event);\n        })(\"keydown.arrowright\", function IgxDaysViewComponent_keydown_arrowright_HostBindingHandler($event) {\n          return ctx.onKeydownArrow($event);\n        })(\"keydown.arrowup\", function IgxDaysViewComponent_keydown_arrowup_HostBindingHandler($event) {\n          return ctx.onKeydownArrow($event);\n        })(\"keydown.arrowdown\", function IgxDaysViewComponent_keydown_arrowdown_HostBindingHandler($event) {\n          return ctx.onKeydownArrow($event);\n        })(\"keydown.home\", function IgxDaysViewComponent_keydown_home_HostBindingHandler($event) {\n          return ctx.onKeydownHome($event);\n        })(\"keydown.end\", function IgxDaysViewComponent_keydown_end_HostBindingHandler($event) {\n          return ctx.onKeydownEnd($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id);\n        i0.ɵɵclassProp(\"igx-calendar\", ctx.styleClass);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      changeDaysView: \"changeDaysView\",\n      showWeekNumbers: \"showWeekNumbers\",\n      activeDate: \"activeDate\"\n    },\n    outputs: {\n      dateSelection: \"dateSelection\",\n      viewChanging: \"viewChanging\",\n      activeDateChange: \"activeDateChange\",\n      monthsViewBlur: \"monthsViewBlur\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: IgxDaysViewComponent\n    }, {\n      provide: IgxDaysViewNavigationService,\n      useClass: IgxDaysViewNavigationService\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 4,\n    vars: 4,\n    consts: [[\"role\", \"row\", 1, \"igx-calendar__body-row\"], [\"role\", \"columnheader\", \"class\", \"igx-calendar__label igx-calendar__label--week-number\", 4, \"ngIf\"], [\"role\", \"columnheader\", \"class\", \"igx-calendar__label\", 4, \"ngFor\", \"ngForOf\"], [\"class\", \"igx-calendar__body-row\", \"role\", \"row\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [\"role\", \"columnheader\", 1, \"igx-calendar__label\", \"igx-calendar__label--week-number\"], [\"role\", \"columnheader\", 1, \"igx-calendar__label\"], [\"class\", \"igx-calendar__date igx-calendar__date--week-number\", 4, \"ngIf\"], [\"class\", \"igx-calendar__date\", \"role\", \"gridcell\", 3, \"date\", \"selection\", \"selected\", \"isLastInRange\", \"isFirstInRange\", \"isWithinRange\", \"disabledDates\", \"specialDates\", \"outOfRangeDates\", \"hideOutsideDays\", \"focus\", \"dateSelection\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [1, \"igx-calendar__date\", \"igx-calendar__date--week-number\"], [\"role\", \"rowheader\", 1, \"igx-calendar__date-content\", \"igx-calendar__date-content--week-number\"], [\"role\", \"gridcell\", 1, \"igx-calendar__date\", 3, \"date\", \"selection\", \"selected\", \"isLastInRange\", \"isFirstInRange\", \"isWithinRange\", \"disabledDates\", \"specialDates\", \"outOfRangeDates\", \"hideOutsideDays\", \"focus\", \"dateSelection\"]],\n    template: function IgxDaysViewComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵtemplate(1, IgxDaysViewComponent_div_1_Template, 3, 0, \"div\", 1);\n        i0.ɵɵtemplate(2, IgxDaysViewComponent_span_2_Template, 3, 4, \"span\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, IgxDaysViewComponent_div_3_Template, 3, 3, \"div\", 3);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showWeekNumbers);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.generateWeekHeader());\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.getCalendarMonth)(\"ngForTrackBy\", ctx.rowTracker);\n      }\n    },\n    directives: [IgxDayItemComponent, i4.NgIf, i4.NgForOf],\n    pipes: [i4.TitleCasePipe],\n    encapsulation: 2\n  });\n  return IgxDaysViewComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxMonthViewSlotsCalendar = /*#__PURE__*/(() => {\n  class IgxMonthViewSlotsCalendar {\n    transform(monthViews) {\n      return new Array(monthViews);\n    }\n\n  }\n\n  IgxMonthViewSlotsCalendar.ɵfac = function IgxMonthViewSlotsCalendar_Factory(t) {\n    return new (t || IgxMonthViewSlotsCalendar)();\n  };\n\n  IgxMonthViewSlotsCalendar.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"IgxMonthViewSlots\",\n    type: IgxMonthViewSlotsCalendar,\n    pure: true\n  });\n  return IgxMonthViewSlotsCalendar;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGetViewDateCalendar = /*#__PURE__*/(() => {\n  class IgxGetViewDateCalendar {\n    constructor() {\n      this.calendar = new Calendar();\n    }\n\n    transform(index, viewDate, wholeDate = true) {\n      const date = this.calendar.timedelta(viewDate, 'month', index);\n      return wholeDate ? date : date.getMonth();\n    }\n\n  }\n\n  IgxGetViewDateCalendar.ɵfac = function IgxGetViewDateCalendar_Factory(t) {\n    return new (t || IgxGetViewDateCalendar)();\n  };\n\n  IgxGetViewDateCalendar.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"IgxGetViewDate\",\n    type: IgxGetViewDateCalendar,\n    pure: true\n  });\n  return IgxGetViewDateCalendar;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$i = 0;\n/**\n * Calendar provides a way to display date information.\n *\n * @igxModule IgxCalendarModule\n *\n * @igxTheme igx-calendar-theme, igx-icon-theme\n *\n * @igxKeywords calendar, datepicker, schedule, date\n *\n * @igxGroup Scheduling\n *\n * @remarks\n * The Ignite UI Calendar provides an easy way to display a calendar and allow users to select dates using single, multiple\n * or range selection.\n *\n * @example:\n * ```html\n * <igx-calendar selection=\"range\"></igx-calendar>\n * ```\n */\n\nlet IgxCalendarComponent = /*#__PURE__*/(() => {\n  class IgxCalendarComponent extends IgxMonthPickerBaseDirective {\n    constructor() {\n      super(...arguments);\n      /**\n       * Sets/gets the `id` of the calendar.\n       *\n       * @remarks\n       * If not set, the `id` will have value `\"igx-calendar-0\"`.\n       *\n       * @example\n       * ```html\n       * <igx-calendar id=\"my-first-calendar\"></igx-calendar>\n       * ```\n       * @memberof IgxCalendarComponent\n       */\n\n      this.id = `igx-calendar-${NEXT_ID$i++}`;\n      /**\n       * Sets/gets whether the calendar has header.\n       * Default value is `true`.\n       *\n       * @example\n       * ```html\n       * <igx-calendar [hasHeader]=\"false\"></igx-calendar>\n       * ```\n       */\n\n      this.hasHeader = true;\n      /**\n       * Sets/gets whether the calendar header will be in vertical position.\n       * Default value is `false`.\n       *\n       * @example\n       * ```html\n       * <igx-calendar [vertical] = \"true\"></igx-calendar>\n       * ```\n       */\n\n      this.vertical = false;\n      /**\n       * Show/hide week numbers\n       *\n       * @example\n       * ```html\n       * <igx-calendar [showWeekNumbers]=\"true\"></igx-calendar>\n       * ``\n       */\n\n      this.showWeekNumbers = false;\n      /**\n       * Apply the different states for the transitions of animateChange\n       *\n       * @hidden\n       * @internal\n       */\n\n      this.animationAction = '';\n      /**\n       * The default css class applied to the component.\n       *\n       * @hidden\n       * @internal\n       */\n\n      this.styleClass = true;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this.activeDate = new Date().toLocaleDateString();\n      /**\n       * Denote if the calendar view was changed with the keyboard\n       *\n       * @hidden\n       * @internal\n       */\n\n      this.isKeydownTrigger = false;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this._monthsViewNumber = 1;\n      /**\n       * Continious navigation through the previous months\n       *\n       * @hidden\n       * @internal\n       */\n\n      this.startPrevMonthScroll = (isKeydownTrigger = false) => {\n        this.startMonthScroll$.next();\n        this.monthScrollDirection = ScrollMonth.PREV;\n        this.animationAction = ScrollMonth.PREV;\n        this.previousMonth(isKeydownTrigger);\n      };\n      /**\n       * Continious navigation through the next months\n       *\n       * @hidden\n       * @internal\n       */\n\n\n      this.startNextMonthScroll = (isKeydownTrigger = false) => {\n        this.startMonthScroll$.next();\n        this.monthScrollDirection = ScrollMonth.NEXT;\n        this.animationAction = ScrollMonth.NEXT;\n        this.nextMonth(isKeydownTrigger);\n      };\n      /**\n       * Stop continuous navigation\n       *\n       * @hidden\n       * @internal\n       */\n\n\n      this.stopMonthScroll = event => {\n        event.stopPropagation(); // generally the scrolling is built on the calendar component\n        // and all start/stop scrolling methods are called on the calendar\n        // if we change below lines to call stopMonthScroll$ on the calendar instead of on the views,\n        // strange bug is introduced --> after changing number of months, continuous scrolling on mouse click does not happen\n\n        this.daysView.stopMonthScroll$.next(true);\n        this.daysView.stopMonthScroll$.complete();\n\n        if (this.monthScrollDirection === ScrollMonth.PREV) {\n          this.prevMonthBtn.nativeElement.focus();\n        } else if (this.monthScrollDirection === ScrollMonth.NEXT) {\n          this.nextMonthBtn.nativeElement.focus();\n        }\n\n        if (this.platform.isActivationKey(event)) {\n          this.resetActiveDate();\n        }\n\n        this.monthScrollDirection = ScrollMonth.NONE;\n      };\n    }\n    /**\n     * Sets/gets the number of month views displayed.\n     * Default value is `1`.\n     *\n     * @example\n     * ```html\n     * <igx-calendar [monthsViewNumber]=\"2\"></igx-calendar>\n     * ```\n     */\n\n\n    get monthsViewNumber() {\n      return this._monthsViewNumber;\n    }\n\n    set monthsViewNumber(val) {\n      if (val < 1) {\n        return;\n      }\n\n      this._monthsViewNumber = val;\n    }\n    /**\n     * The default css class applied to the component.\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    get styleVerticalClass() {\n      return this.vertical;\n    }\n    /**\n     * Denote if the year view is active.\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    get isYearView() {\n      return this.activeView === CalendarView.YEAR || this.activeView === IgxCalendarView.Year;\n    }\n    /**\n     * Gets the header template.\n     *\n     * @example\n     * ```typescript\n     * let headerTemplate =  this.calendar.headerTeamplate;\n     * ```\n     * @memberof IgxCalendarComponent\n     */\n\n\n    get headerTemplate() {\n      if (this.headerTemplateDirective) {\n        return this.headerTemplateDirective.template;\n      }\n\n      return null;\n    }\n    /**\n     * Sets the header template.\n     *\n     * @example\n     * ```html\n     * <igx-calendar headerTemplateDirective = \"igxCalendarHeader\"></igx-calendar>\n     * ```\n     * @memberof IgxCalendarComponent\n     */\n\n\n    set headerTemplate(directive) {\n      this.headerTemplateDirective = directive;\n    }\n    /**\n     * Gets the subheader template.\n     *\n     * @example\n     * ```typescript\n     * let subheaderTemplate = this.calendar.subheaderTemplate;\n     * ```\n     */\n\n\n    get subheaderTemplate() {\n      if (this.subheaderTemplateDirective) {\n        return this.subheaderTemplateDirective.template;\n      }\n\n      return null;\n    }\n    /**\n     * Sets the subheader template.\n     *\n     * @example\n     * ```html\n     * <igx-calendar subheaderTemplate = \"igxCalendarSubheader\"></igx-calendar>\n     * ```\n     * @memberof IgxCalendarComponent\n     */\n\n\n    set subheaderTemplate(directive) {\n      this.subheaderTemplateDirective = directive;\n    }\n    /**\n     * Gets the context for the template marked with the `igxCalendarHeader` directive.\n     *\n     * @example\n     * ```typescript\n     * let headerContext =  this.calendar.headerContext;\n     * ```\n     */\n\n\n    get headerContext() {\n      const date = this.headerDate;\n      return this.generateContext(date);\n    }\n    /**\n     * Gets the context for the template marked with either `igxCalendarSubHeaderMonth`\n     * or `igxCalendarSubHeaderYear` directive.\n     *\n     * @example\n     * ```typescript\n     * let context =  this.calendar.context;\n     * ```\n     */\n\n\n    get context() {\n      const date = this.viewDate;\n      return this.generateContext(date);\n    }\n    /**\n     * Date displayed in header\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    get headerDate() {\n      return this.selectedDates ? this.selectedDates : new Date();\n    }\n    /**\n     * Keyboard navigation of the calendar\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    onKeydownPageDown(event) {\n      event.preventDefault();\n\n      if (!this.isDefaultView) {\n        return;\n      }\n\n      const isPageDown = event.key === 'PageDown';\n      const step = isPageDown ? 1 : -1;\n      let monthView = this.daysView;\n      let activeDate;\n\n      while (!activeDate && monthView) {\n        activeDate = monthView.dates.find(date => date.nativeElement === document.activeElement);\n        monthView = monthView.nextMonthView;\n      }\n\n      if (activeDate) {\n        this.nextDate = new Date(activeDate.date.date);\n        let year = this.nextDate.getFullYear();\n        let month = this.nextDate.getMonth() + step;\n\n        if (isPageDown) {\n          if (month > 11) {\n            month = 0;\n            year += step;\n          }\n        } else {\n          if (month < 0) {\n            month = 11;\n            year += step;\n          }\n        }\n\n        const range = monthRange(this.nextDate.getFullYear(), month);\n        let day = this.nextDate.getDate();\n\n        if (day > range[1]) {\n          day = range[1];\n        }\n\n        this.nextDate.setDate(day);\n        this.nextDate.setMonth(month);\n        this.nextDate.setFullYear(year);\n\n        this.callback = next => {\n          monthView = this.daysView;\n          let dayItem;\n\n          while (!dayItem && monthView || dayItem && !dayItem.isCurrentMonth) {\n            dayItem = monthView.dates.find(d => d.date.date.getTime() === next.getTime());\n            monthView = monthView.nextMonthView;\n          }\n\n          if (dayItem && dayItem.isFocusable) {\n            dayItem.nativeElement.focus();\n          }\n        };\n      }\n\n      if (isPageDown) {\n        if (event.repeat) {\n          requestAnimationFrame(() => this.nextMonth(true));\n        } else {\n          this.nextMonth(true);\n        }\n      } else {\n        if (event.repeat) {\n          requestAnimationFrame(() => this.previousMonth(true));\n        } else {\n          this.previousMonth(true);\n        }\n      }\n    }\n    /**\n     * Keyboard navigation of the calendar\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    onKeydownShiftPageUp(event) {\n      event.preventDefault();\n\n      if (!this.isDefaultView) {\n        return;\n      }\n\n      const isPageDown = event.key === 'PageDown';\n      const step = isPageDown ? 1 : -1;\n      this.previousViewDate = this.viewDate;\n      this.viewDate = this.calendarModel.timedelta(this.viewDate, 'year', step);\n      this.animationAction = isPageDown ? ScrollMonth.NEXT : ScrollMonth.PREV;\n      this.isKeydownTrigger = true;\n      let monthView = this.daysView;\n      let activeDate;\n\n      while (!activeDate && monthView) {\n        activeDate = monthView.dates.find(date => date.nativeElement === document.activeElement);\n        monthView = monthView.nextMonthView;\n      }\n\n      if (activeDate) {\n        this.nextDate = new Date(activeDate.date.date);\n        const year = this.nextDate.getFullYear() + step;\n        const range = monthRange(year, this.nextDate.getMonth());\n        let day = this.nextDate.getDate();\n\n        if (day > range[1]) {\n          day = range[1];\n        }\n\n        this.nextDate.setDate(day);\n        this.nextDate.setFullYear(year);\n\n        this.callback = next => {\n          monthView = this.daysView;\n          let dayItem;\n\n          while (!dayItem && monthView || dayItem && !dayItem.isCurrentMonth) {\n            dayItem = monthView.dates.find(d => d.date.date.getTime() === next.getTime());\n            monthView = monthView.nextMonthView;\n          }\n\n          if (dayItem && dayItem.isFocusable) {\n            dayItem.nativeElement.focus();\n          }\n        };\n      }\n    }\n    /**\n     * Keyboard navigation of the calendar\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    onKeydownHome(event) {\n      if (this.daysView) {\n        this.daysView.onKeydownHome(event);\n      }\n    }\n    /**\n     * Keyboard navigation of the calendar\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    onKeydownEnd(event) {\n      if (this.daysView) {\n        this.daysView.onKeydownEnd(event);\n      }\n    }\n    /**\n     * Stop continuous navigation on mouseup event\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    onMouseUp(event) {\n      if (this.monthScrollDirection !== ScrollMonth.NONE) {\n        this.stopMonthScroll(event);\n      }\n    }\n\n    ngAfterViewInit() {\n      this.setSiblingMonths(this.monthViews);\n      this._monthViewsChanges$ = this.monthViews.changes.subscribe(c => {\n        this.setSiblingMonths(c);\n      });\n      this.startMonthScroll$.pipe(takeUntil(this.stopMonthScroll$), switchMap(() => this.scrollMonth$.pipe(skipLast(1), debounce(() => interval(300)), takeUntil(this.stopMonthScroll$)))).subscribe(() => {\n        switch (this.monthScrollDirection) {\n          case ScrollMonth.PREV:\n            this.previousMonth();\n            break;\n\n          case ScrollMonth.NEXT:\n            this.nextMonth();\n            break;\n\n          case ScrollMonth.NONE:\n          default:\n            break;\n        }\n      });\n    }\n    /**\n     * Returns the locale representation of the month in the month view if enabled,\n     * otherwise returns the default `Date.getMonth()` value.\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    formattedMonth(value) {\n      if (this.formatViews.month) {\n        return this.formatterMonth.format(value);\n      }\n\n      return `${value.getMonth()}`;\n    }\n    /**\n     * Change to previous month\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    previousMonth(isKeydownTrigger = false) {\n      if (isKeydownTrigger && this.animationAction === ScrollMonth.NEXT) {\n        return;\n      }\n\n      this.previousViewDate = this.viewDate;\n      this.viewDate = this.calendarModel.getPrevMonth(this.viewDate);\n      this.animationAction = ScrollMonth.PREV;\n      this.isKeydownTrigger = isKeydownTrigger;\n    }\n\n    suppressBlur() {\n      var _a;\n\n      (_a = this.monthViews) === null || _a === void 0 ? void 0 : _a.forEach(d => d.shouldResetDate = false);\n\n      if (this.daysView) {\n        this.daysView.shouldResetDate = false;\n      }\n    }\n    /**\n     * Change to next month\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    nextMonth(isKeydownTrigger = false) {\n      if (isKeydownTrigger && this.animationAction === 'prev') {\n        return;\n      }\n\n      this.isKeydownTrigger = isKeydownTrigger;\n      this.previousViewDate = this.viewDate;\n      this.viewDate = this.calendarModel.getNextMonth(this.viewDate);\n      this.animationAction = ScrollMonth.NEXT;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onActiveViewDecade(args, activeViewIdx) {\n      super.activeViewDecade(activeViewIdx);\n      requestAnimationFrame(() => {\n        if (this.dacadeView) {\n          this.dacadeView.date = args;\n          this.dacadeView.calendarDir.find(date => date.isCurrentYear).nativeElement.focus();\n        }\n      });\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onActiveViewDecadeKB(event, args, activeViewIdx) {\n      super.activeViewDecadeKB(event, activeViewIdx);\n      requestAnimationFrame(() => {\n        if (this.dacadeView) {\n          this.dacadeView.date = args;\n          this.dacadeView.calendarDir.find(date => date.isCurrentYear).nativeElement.focus();\n        }\n      });\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    getFormattedDate() {\n      const date = this.headerDate;\n      return {\n        monthday: this.formatterMonthday.format(date),\n        weekday: this.formatterWeekday.format(date)\n      };\n    }\n    /**\n     * Handles invoked on date selection\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    childClicked(instance) {\n      if (instance.isPrevMonth) {\n        this.previousMonth();\n      }\n\n      if (instance.isNextMonth) {\n        this.nextMonth();\n      }\n\n      this.selectDateFromClient(instance.date);\n\n      if (this.selection === 'multi') {\n        this.deselectDateInMonthViews(instance.date);\n      }\n\n      this.selected.emit(this.selectedDates);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    viewChanging(args) {\n      this.animationAction = args.monthAction;\n      this.isKeydownTrigger = true;\n      this.nextDate = args.nextDate;\n\n      this.callback = next => {\n        const day = this.daysView.dates.find(item => item.date.date.getTime() === next.getTime());\n\n        if (day) {\n          this.daysView.daysNavService.focusNextDate(day.nativeElement, args.key, true);\n        }\n      };\n\n      this.previousViewDate = this.viewDate;\n      this.viewDate = this.nextDate;\n    }\n    /**\n     * @hidden\n     * @intenal\n     */\n\n\n    changeMonth(event) {\n      this.previousViewDate = this.viewDate;\n      this.viewDate = this.calendarModel.getFirstViewDate(event, 'month', this.activeViewIdx);\n      this.activeView = IgxCalendarView.Month;\n      requestAnimationFrame(() => {\n        const elem = this.monthsBtns.find((e, idx) => idx === this.activeViewIdx);\n\n        if (elem) {\n          elem.nativeElement.focus();\n        }\n      });\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onActiveViewYear(args, activeViewIdx) {\n      this.activeView = IgxCalendarView.Year;\n      this.activeViewIdx = activeViewIdx;\n      requestAnimationFrame(() => {\n        this.monthsView.date = args;\n        this.focusMonth();\n      });\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onActiveViewYearKB(args, event, activeViewIdx) {\n      if (this.platform.isActivationKey(event)) {\n        event.preventDefault();\n        this.onActiveViewYear(args, activeViewIdx);\n      }\n    }\n    /**\n     * Deselects date(s) (based on the selection type).\n     *\n     * @example\n     * ```typescript\n     *  this.calendar.deselectDate(new Date(`2018-06-12`));\n     * ````\n     */\n\n\n    deselectDate(value) {\n      super.deselectDate(value);\n      this.monthViews.forEach(view => {\n        view.selectedDates = this.selectedDates;\n        view.rangeStarted = false;\n      });\n\n      this._onChangeCallback(this.selectedDates);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    getViewDate(i) {\n      const date = this.calendarModel.timedelta(this.viewDate, 'month', i);\n      return date;\n    }\n    /**\n     * Getter for the context object inside the calendar templates.\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    getContext(i) {\n      const date = this.getViewDate(i);\n      return this.generateContext(date, i);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    animationDone(event) {\n      if (event.fromState === ScrollMonth.NONE && (event.toState === ScrollMonth.PREV || event.toState === ScrollMonth.NEXT) || event.fromState === 'void' && event.toState === ScrollMonth.NONE) {\n        this.viewDateChanged.emit({\n          previousValue: this.previousViewDate,\n          currentValue: this.viewDate\n        });\n      }\n\n      if (!this.isKeydownTrigger) {\n        this.resetActiveDate();\n      }\n\n      if (this.monthScrollDirection !== ScrollMonth.NONE) {\n        this.scrollMonth$.next();\n      }\n\n      if (!this.isDefaultView) {\n        return;\n      }\n\n      let monthView = this.daysView;\n      let date = monthView.dates.find(d => d.selected);\n\n      while (!date && monthView.nextMonthView) {\n        monthView = monthView.nextMonthView;\n        date = monthView.dates.find(d => d.selected);\n      }\n\n      if (date && date.isFocusable && !this.isKeydownTrigger) {\n        setTimeout(() => {\n          date.nativeElement.focus();\n        }, parseInt(slideInRight.options.params.duration, 10));\n      } else if (this.callback && (event.toState === ScrollMonth.NEXT || event.toState === ScrollMonth.PREV)) {\n        this.callback(this.nextDate);\n      }\n\n      this.animationAction = ScrollMonth.NONE;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    viewRendered(event) {\n      if (event.fromState !== 'void') {\n        this.activeViewChanged.emit(this.activeView);\n\n        if (this.isDefaultView) {\n          this.resetActiveDate();\n        }\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    resetActiveDate() {\n      if (!this.monthViews) {\n        return;\n      }\n\n      let dates = [];\n      this.monthViews.map(mv => mv.dates).forEach(days => {\n        dates = dates.concat(days.toArray());\n      });\n      const date = dates.find(day => day.selected && day.isCurrentMonth) || dates.find(day => day.isToday && day.isCurrentMonth) || dates.find(d => d.isFocusable);\n\n      if (date) {\n        this.activeDate = date.date.date.toLocaleDateString();\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    ngOnDestroy() {\n      if (this._monthViewsChanges$) {\n        this._monthViewsChanges$.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    getPrevMonth(date) {\n      return this.calendarModel.getPrevMonth(date);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    getNextMonth(date, viewIndex) {\n      return this.calendarModel.getDateByView(date, 'Month', viewIndex);\n    }\n    /**\n     * Helper method building and returning the context object inside\n     * the calendar templates.\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    generateContext(value, i) {\n      const formatObject = Object.assign({\n        index: i,\n        monthView: () => this.onActiveViewYear(value, i),\n        yearView: () => this.onActiveViewDecade(value, i)\n      }, this.calendarModel.formatToParts(value, this.locale, this.formatOptions, ['era', 'year', 'month', 'day', 'weekday']));\n      return {\n        $implicit: formatObject\n      };\n    }\n    /**\n     * Helper method that sets references for prev/next months for each month in the view\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    setSiblingMonths(monthViews) {\n      monthViews.forEach((item, index) => {\n        const prevMonthView = this.getMonthView(index - 1);\n        const nextMonthView = this.getMonthView(index + 1);\n        item.nextMonthView = nextMonthView;\n        item.prevMonthView = prevMonthView;\n      });\n    }\n    /**\n     * Helper method returning previous/next day views\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    getMonthView(index) {\n      if (index === -1 || index === this.monthViews.length) {\n        return null;\n      } else {\n        return this.monthViews.toArray()[index];\n      }\n    }\n    /**\n     * Helper method that does deselection for all month views when selection is \"multi\"\n     * If not called, selection in other month views stays\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    deselectDateInMonthViews(value) {\n      this.monthViews.forEach(m => {\n        m.deselectMultipleInMonth(value);\n      });\n    }\n\n    focusMonth() {\n      const month = this.monthsView.monthsRef.find(e => e.index === this.monthsView.date.getMonth());\n\n      if (month) {\n        month.nativeElement.focus();\n      }\n    }\n\n  }\n\n  IgxCalendarComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxCalendarComponent_BaseFactory;\n    return function IgxCalendarComponent_Factory(t) {\n      return (ɵIgxCalendarComponent_BaseFactory || (ɵIgxCalendarComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxCalendarComponent)))(t || IgxCalendarComponent);\n    };\n  }();\n\n  IgxCalendarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxCalendarComponent,\n    selectors: [[\"igx-calendar\"]],\n    contentQueries: function IgxCalendarComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxCalendarHeaderTemplateDirective, 7, IgxCalendarHeaderTemplateDirective);\n        i0.ɵɵcontentQuery(dirIndex, IgxCalendarSubheaderTemplateDirective, 7, IgxCalendarSubheaderTemplateDirective);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplateDirective = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.subheaderTemplateDirective = _t.first);\n      }\n    },\n    viewQuery: function IgxCalendarComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c39, 5, IgxMonthsViewComponent);\n        i0.ɵɵviewQuery(_c40, 5, IgxYearsViewComponent);\n        i0.ɵɵviewQuery(_c41, 5, IgxDaysViewComponent);\n        i0.ɵɵviewQuery(_c42, 5);\n        i0.ɵɵviewQuery(_c43, 5);\n        i0.ɵɵviewQuery(_c44, 5);\n        i0.ɵɵviewQuery(_c41, 5, IgxDaysViewComponent);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.monthsView = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dacadeView = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.daysView = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.prevMonthBtn = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nextMonthBtn = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.monthsBtns = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.monthViews = _t);\n      }\n    },\n    hostVars: 5,\n    hostBindings: function IgxCalendarComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown.pagedown\", function IgxCalendarComponent_keydown_pagedown_HostBindingHandler($event) {\n          return ctx.onKeydownPageDown($event);\n        })(\"keydown.pageup\", function IgxCalendarComponent_keydown_pageup_HostBindingHandler($event) {\n          return ctx.onKeydownPageDown($event);\n        })(\"keydown.shift.pageup\", function IgxCalendarComponent_keydown_shift_pageup_HostBindingHandler($event) {\n          return ctx.onKeydownShiftPageUp($event);\n        })(\"keydown.shift.pagedown\", function IgxCalendarComponent_keydown_shift_pagedown_HostBindingHandler($event) {\n          return ctx.onKeydownShiftPageUp($event);\n        })(\"keydown.home\", function IgxCalendarComponent_keydown_home_HostBindingHandler($event) {\n          return ctx.onKeydownHome($event);\n        })(\"keydown.end\", function IgxCalendarComponent_keydown_end_HostBindingHandler($event) {\n          return ctx.onKeydownEnd($event);\n        })(\"mouseup\", function IgxCalendarComponent_mouseup_HostBindingHandler($event) {\n          return ctx.onMouseUp($event);\n        }, false, i0.ɵɵresolveDocument);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id);\n        i0.ɵɵclassProp(\"igx-calendar--vertical\", ctx.styleVerticalClass)(\"igx-calendar\", ctx.styleClass);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      hasHeader: \"hasHeader\",\n      vertical: \"vertical\",\n      monthsViewNumber: \"monthsViewNumber\",\n      showWeekNumbers: \"showWeekNumbers\",\n      animationAction: \"animationAction\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: IgxCalendarComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 8,\n    vars: 4,\n    consts: [[\"defaultHeader\", \"\"], [\"defaultMonth\", \"\"], [\"aria-labelledby\", \"igx-aria-calendar-title-month igx-aria-calendar-title-year\", \"class\", \"igx-calendar__header\", 4, \"ngIf\"], [\"class\", \"igx-calendar__body\", 3, \"swiperight\", \"swipeleft\", \"pointerdown\", 4, \"ngIf\"], [3, \"date\", \"locale\", \"formatView\", \"monthFormat\", \"selected\", 4, \"ngIf\"], [3, \"date\", \"locale\", \"formatView\", \"yearFormat\", \"selected\", 4, \"ngIf\"], [\"class\", \"igx-calendar__aria-off-screen\", \"aria-live\", \"polite\", 4, \"ngIf\"], [\"tabindex\", \"0\", \"role\", \"button\", 1, \"igx-calendar-picker__date\", 3, \"keydown\", \"click\"], [\"monthsBtn\", \"\"], [\"yearsBtn\", \"\"], [\"aria-live\", \"polite\", 1, \"igx-calendar__aria-off-screen\"], [\"aria-labelledby\", \"igx-aria-calendar-title-month igx-aria-calendar-title-year\", 1, \"igx-calendar__header\"], [\"id\", \"igx-aria-calendar-title-year\", 1, \"igx-calendar__header-year\"], [\"id\", \"igx-aria-calendar-title-month\", 1, \"igx-calendar__header-date\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"igx-calendar__body\", 3, \"swiperight\", \"swipeleft\", \"pointerdown\"], [1, \"igx-calendar-picker\"], [\"tabindex\", \"0\", 1, \"igx-calendar__aria-off-screen\"], [4, \"ngIf\"], [\"tabindex\", \"0\", \"role\", \"button\", \"data-action\", \"prev\", \"igxCalendarScrollMonth\", \"\", 1, \"igx-calendar-picker__prev\", 3, \"startScroll\", \"stopScroll\", \"ngStyle\"], [\"prevMonthBtn\", \"\"], [\"aria-hidden\", \"true\"], [\"class\", \"igx-calendar-picker__dates\", 3, \"width\", 4, \"ngFor\", \"ngForOf\"], [\"tabindex\", \"0\", \"role\", \"button\", \"data-action\", \"next\", \"igxCalendarScrollMonth\", \"\", 1, \"igx-calendar-picker__next\", 3, \"startScroll\", \"stopScroll\", \"ngStyle\"], [\"nextMonthBtn\", \"\"], [2, \"display\", \"flex\"], [\"role\", \"grid\", 3, \"changeDaysView\", \"selection\", \"locale\", \"value\", \"activeDate\", \"viewDate\", \"weekStart\", \"formatOptions\", \"formatViews\", \"disabledDates\", \"specialDates\", \"hideOutsideDays\", \"showWeekNumbers\", \"activeDateChange\", \"viewChanging\", \"dateSelection\", \"monthsViewBlur\", 4, \"ngFor\", \"ngForOf\"], [1, \"igx-calendar-picker__dates\"], [\"role\", \"grid\", 3, \"changeDaysView\", \"selection\", \"locale\", \"value\", \"activeDate\", \"viewDate\", \"weekStart\", \"formatOptions\", \"formatViews\", \"disabledDates\", \"specialDates\", \"hideOutsideDays\", \"showWeekNumbers\", \"activeDateChange\", \"viewChanging\", \"dateSelection\", \"monthsViewBlur\"], [\"days\", \"\"], [3, \"date\", \"locale\", \"formatView\", \"monthFormat\", \"selected\"], [\"months\", \"\"], [3, \"date\", \"locale\", \"formatView\", \"yearFormat\", \"selected\"], [\"decade\", \"\"]],\n    template: function IgxCalendarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxCalendarComponent_ng_template_0_Template, 4, 2, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, IgxCalendarComponent_ng_template_2_Template, 9, 11, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(4, IgxCalendarComponent_header_4_Template, 5, 3, \"header\", 2);\n        i0.ɵɵtemplate(5, IgxCalendarComponent_div_5_Template, 21, 29, \"div\", 3);\n        i0.ɵɵtemplate(6, IgxCalendarComponent_igx_months_view_6_Template, 2, 5, \"igx-months-view\", 4);\n        i0.ɵɵtemplate(7, IgxCalendarComponent_igx_years_view_7_Template, 2, 5, \"igx-years-view\", 5);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"ngIf\", ctx.selection === \"single\" && ctx.hasHeader);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isDefaultView);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isYearView);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isDecadeView);\n      }\n    },\n    directives: [IgxIconComponent, IgxDaysViewComponent, IgxMonthsViewComponent, IgxYearsViewComponent, i4.NgIf, i4.NgTemplateOutlet, IgxCalendarScrollMonthDirective, i4.NgStyle, i4.NgForOf],\n    pipes: [i4.DatePipe, IgxGetViewDateCalendar, IgxMonthViewSlotsCalendar],\n    encapsulation: 2,\n    data: {\n      animation: [trigger('animateView', [transition('void => 0', useAnimation(fadeIn)), transition('void => *', useAnimation(scaleInCenter, {\n        params: {\n          duration: '.2s',\n          fromScale: .9\n        }\n      }))]), trigger('animateChange', [transition('* => prev', useAnimation(slideInLeft, {\n        params: {\n          fromPosition: 'translateX(-30%)'\n        }\n      })), transition('* => next', useAnimation(slideInRight, {\n        params: {\n          fromPosition: 'translateX(30%)'\n        }\n      }))])]\n    }\n  });\n  return IgxCalendarComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$h = 0;\nlet IgxMonthPickerComponent = /*#__PURE__*/(() => {\n  class IgxMonthPickerComponent extends IgxMonthPickerBaseDirective {\n    constructor() {\n      super(...arguments);\n      /**\n       * Sets/gets the `id` of the month picker.\n       * If not set, the `id` will have value `\"igx-month-picker-0\"`.\n       */\n\n      this.id = `igx-month-picker-${NEXT_ID$h++}`;\n      /**\n       * The default css class applied to the component.\n       *\n       * @hidden\n       */\n\n      this.styleClass = true;\n      /**\n       * @hidden\n       */\n\n      this.yearAction = '';\n    }\n    /**\n     * @hidden\n     */\n\n\n    previousYear(event) {\n      event === null || event === void 0 ? void 0 : event.preventDefault();\n\n      if (event && this.yearAction === 'next') {\n        return;\n      }\n\n      this.yearAction = 'prev';\n      this.previousViewDate = this.viewDate;\n      this.viewDate = this.calendarModel.getPrevYear(this.viewDate);\n    }\n    /**\n     * @hidden\n     */\n\n\n    nextYear(event) {\n      event === null || event === void 0 ? void 0 : event.preventDefault();\n\n      if (event && this.yearAction === 'prev') {\n        return;\n      }\n\n      this.yearAction = 'next';\n      this.previousViewDate = this.viewDate;\n      this.viewDate = this.calendarModel.getNextYear(this.viewDate);\n    }\n    /**\n     * @hidden\n     */\n\n\n    onKeydownHome(event) {\n      if (this.monthsView) {\n        this.monthsView.el.nativeElement.focus();\n        this.monthsView.onKeydownHome(event);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onKeydownEnd(event) {\n      if (this.monthsView) {\n        this.monthsView.el.nativeElement.focus();\n        this.monthsView.onKeydownEnd(event);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    animationDone(event) {\n      if (event.fromState === 'void' && event.toState === '' || event.fromState === '' && (event.toState === ScrollMonth.PREV || event.toState === ScrollMonth.NEXT)) {\n        this.viewDateChanged.emit({\n          previousValue: this.previousViewDate,\n          currentValue: this.viewDate\n        });\n      }\n\n      this.yearAction = '';\n    }\n    /**\n     * @hidden\n     */\n\n\n    viewRendered(event) {\n      if (event.fromState !== 'void') {\n        this.activeViewChanged.emit(this.activeView);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    activeViewDecadeKB(event) {\n      super.activeViewDecadeKB(event);\n\n      if (event.key === this.platform.KEYMAP.ARROW_RIGHT) {\n        this.nextYear(event);\n      }\n\n      if (event.key === this.platform.KEYMAP.ARROW_LEFT) {\n        this.previousYear(event);\n      }\n\n      requestAnimationFrame(() => {\n        if (this.dacadeView) {\n          this.dacadeView.el.nativeElement.focus();\n        }\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    activeViewDecade() {\n      super.activeViewDecade();\n      requestAnimationFrame(() => {\n        this.dacadeView.el.nativeElement.focus();\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    changeYearKB(event, next = true) {\n      if (this.platform.isActivationKey(event)) {\n        event.stopPropagation();\n\n        if (next) {\n          this.nextYear();\n        } else {\n          this.previousYear();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    selectYear(event) {\n      this.previousViewDate = this.viewDate;\n      this.viewDate = new Date(event.getFullYear(), event.getMonth(), event.getDate());\n      this.activeView = IgxCalendarView.Month;\n      requestAnimationFrame(() => {\n        if (this.yearsBtn) {\n          this.yearsBtn.nativeElement.focus();\n        }\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    selectMonth(event) {\n      this.selectDate(event);\n      this.selected.emit(this.selectedDates);\n    }\n    /**\n     * Selects a date.\n     * ```typescript\n     *  this.monthPicker.selectDate(new Date(`2018-06-12`));\n     * ```\n     */\n\n\n    selectDate(value) {\n      if (!value) {\n        return new Date();\n      }\n\n      super.selectDate(value);\n      this.viewDate = value;\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      if (value) {\n        this.viewDate = this.selectedDates = value;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    getNextYear() {\n      return this.calendarModel.getNextYear(this.viewDate).getFullYear();\n    }\n    /**\n     * @hidden\n     */\n\n\n    getPreviousYear() {\n      return this.calendarModel.getPrevYear(this.viewDate).getFullYear();\n    }\n\n  }\n\n  IgxMonthPickerComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxMonthPickerComponent_BaseFactory;\n    return function IgxMonthPickerComponent_Factory(t) {\n      return (ɵIgxMonthPickerComponent_BaseFactory || (ɵIgxMonthPickerComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxMonthPickerComponent)))(t || IgxMonthPickerComponent);\n    };\n  }();\n\n  IgxMonthPickerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxMonthPickerComponent,\n    selectors: [[\"igx-month-picker\"]],\n    viewQuery: function IgxMonthPickerComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c39, 5, IgxMonthsViewComponent);\n        i0.ɵɵviewQuery(_c40, 5, IgxYearsViewComponent);\n        i0.ɵɵviewQuery(_c41, 5, IgxDaysViewComponent);\n        i0.ɵɵviewQuery(_c38, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.monthsView = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dacadeView = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.daysView = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.yearsBtn = _t.first);\n      }\n    },\n    hostVars: 3,\n    hostBindings: function IgxMonthPickerComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown.pageup\", function IgxMonthPickerComponent_keydown_pageup_HostBindingHandler($event) {\n          return ctx.previousYear($event);\n        })(\"keydown.pagedown\", function IgxMonthPickerComponent_keydown_pagedown_HostBindingHandler($event) {\n          return ctx.nextYear($event);\n        })(\"keydown.home\", function IgxMonthPickerComponent_keydown_home_HostBindingHandler($event) {\n          return ctx.onKeydownHome($event);\n        })(\"keydown.end\", function IgxMonthPickerComponent_keydown_end_HostBindingHandler($event) {\n          return ctx.onKeydownEnd($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id);\n        i0.ɵɵclassProp(\"igx-calendar\", ctx.styleClass);\n      }\n    },\n    inputs: {\n      id: \"id\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: IgxMonthPickerComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 2,\n    vars: 2,\n    consts: [[\"class\", \"igx-calendar__body\", 3, \"swiperight\", \"swipeleft\", 4, \"ngIf\"], [3, \"date\", \"locale\", \"formatView\", \"yearFormat\", \"selected\", 4, \"ngIf\"], [1, \"igx-calendar__body\", 3, \"swiperight\", \"swipeleft\"], [\"role\", \"rowheader\", 1, \"igx-calendar-picker\"], [\"tabindex\", \"0\", \"role\", \"button\", \"data-action\", \"prev\", 1, \"igx-calendar-picker__prev\", 3, \"ngStyle\", \"click\", \"keydown\"], [\"tabindex\", \"0\", \"aria-live\", \"polite\", 1, \"igx-calendar-picker__date\", 3, \"keydown\", \"click\"], [\"yearsBtn\", \"\"], [\"tabindex\", \"0\", \"role\", \"button\", \"data-action\", \"next\", 1, \"igx-calendar-picker__next\", 3, \"ngStyle\", \"click\", \"keydown\"], [3, \"date\", \"locale\", \"formatView\", \"monthFormat\", \"selected\"], [\"months\", \"\"], [3, \"date\", \"locale\", \"formatView\", \"yearFormat\", \"selected\"], [\"decade\", \"\"]],\n    template: function IgxMonthPickerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxMonthPickerComponent_div_0_Template, 14, 15, \"div\", 0);\n        i0.ɵɵtemplate(1, IgxMonthPickerComponent_igx_years_view_1_Template, 2, 5, \"igx-years-view\", 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.isDefaultView);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isDecadeView);\n      }\n    },\n    directives: [IgxIconComponent, IgxMonthsViewComponent, IgxYearsViewComponent, i4.NgIf, i4.NgStyle],\n    encapsulation: 2,\n    data: {\n      animation: [trigger('animateView', [transition('void => 0', useAnimation(fadeIn)), transition('void => *', useAnimation(scaleInCenter, {\n        params: {\n          duration: '.2s',\n          fromScale: .9\n        }\n      }))]), trigger('animateChange', [transition('* => prev', useAnimation(slideInLeft, {\n        params: {\n          fromPosition: 'translateX(-30%)'\n        }\n      })), transition('* => next', useAnimation(slideInRight, {\n        params: {\n          fromPosition: 'translateX(30%)'\n        }\n      }))])]\n    }\n  });\n  return IgxMonthPickerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxCalendarModule = /*#__PURE__*/(() => {\n  class IgxCalendarModule {}\n\n  IgxCalendarModule.ɵfac = function IgxCalendarModule_Factory(t) {\n    return new (t || IgxCalendarModule)();\n  };\n\n  IgxCalendarModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxCalendarModule\n  });\n  IgxCalendarModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, FormsModule, IgxIconModule]]\n  });\n  return IgxCalendarModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$g = 0;\n/**\n * IgxCardMedia is container for the card media section.\n * Use it to wrap images and videos.\n */\n\nlet IgxCardMediaDirective = /*#__PURE__*/(() => {\n  class IgxCardMediaDirective {\n    constructor() {\n      /** @hidden @internal */\n      this.cssClass = 'igx-card__media';\n      /**\n       * An @Input property that sets the `width` and `min-width` style property\n       * of the media container. If not provided it will be set to `auto`.\n       *\n       * @example\n       * ```html\n       * <igx-card-media width=\"300px\"></igx-card-media>\n       * ```\n       */\n\n      this.width = 'auto';\n      /**\n       * An @Input property that sets the `height` style property of the media container.\n       * If not provided it will be set to `auto`.\n       *\n       * @example\n       * ```html\n       * <igx-card-media height=\"50%\"></igx-card-media>\n       * ```\n       */\n\n      this.height = 'auto';\n      /**\n       * An @Input property that sets the `role` attribute of the media container.\n       */\n\n      this.role = 'img';\n    }\n\n  }\n\n  IgxCardMediaDirective.ɵfac = function IgxCardMediaDirective_Factory(t) {\n    return new (t || IgxCardMediaDirective)();\n  };\n\n  IgxCardMediaDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxCardMediaDirective,\n    selectors: [[\"igx-card-media\"]],\n    hostVars: 9,\n    hostBindings: function IgxCardMediaDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵstyleProp(\"width\", ctx.width)(\"min-width\", ctx.width)(\"height\", ctx.height);\n        i0.ɵɵclassProp(\"igx-card__media\", ctx.cssClass);\n      }\n    },\n    inputs: {\n      width: \"width\",\n      height: \"height\",\n      role: \"role\"\n    }\n  });\n  return IgxCardMediaDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * IgxCardHeader is container for the card header\n */\n\n\nlet IgxCardHeaderComponent = /*#__PURE__*/(() => {\n  class IgxCardHeaderComponent {\n    constructor() {\n      /** @hidden @internal */\n      this.cssClass = 'igx-card-header';\n      /**\n       * An @Input property that sets the layout style of the header.\n       * By default the header elements(thumbnail and title/subtitle) are aligned horizontally.\n       *\n       * @example\n       * ```html\n       * <igx-card-header [vertical]=\"true\"></igx-card-header>\n       * ```\n       */\n\n      this.vertical = false;\n      /**\n       * An @Input property that sets the value of the `role` attribute of the card header.\n       * By default the value is set to `header`.\n       *\n       * @example\n       * ```html\n       * <igx-card-header role=\"header\"></igx-card-header>\n       * ```\n       */\n\n      this.role = 'header';\n    }\n\n  }\n\n  IgxCardHeaderComponent.ɵfac = function IgxCardHeaderComponent_Factory(t) {\n    return new (t || IgxCardHeaderComponent)();\n  };\n\n  IgxCardHeaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxCardHeaderComponent,\n    selectors: [[\"igx-card-header\"]],\n    hostVars: 5,\n    hostBindings: function IgxCardHeaderComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"igx-card-header\", ctx.cssClass)(\"igx-card-header--vertical\", ctx.vertical);\n      }\n    },\n    inputs: {\n      vertical: \"vertical\"\n    },\n    ngContentSelectors: _c49,\n    decls: 5,\n    vars: 0,\n    consts: [[1, \"igx-card-header__thumbnail\"], [1, \"igx-card-header__titles\"]],\n    template: function IgxCardHeaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c48);\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵprojection(1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(2, \"div\", 1);\n        i0.ɵɵprojection(3, 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵprojection(4, 2);\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxCardHeaderComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * IgxCardThumbnail is container for the card thumbnail section.\n * Use it to wrap anything you want to be used as a thumbnail.\n */\n\n\nlet IgxCardThumbnailDirective = /*#__PURE__*/(() => {\n  class IgxCardThumbnailDirective {}\n\n  IgxCardThumbnailDirective.ɵfac = function IgxCardThumbnailDirective_Factory(t) {\n    return new (t || IgxCardThumbnailDirective)();\n  };\n\n  IgxCardThumbnailDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxCardThumbnailDirective,\n    selectors: [[\"\", \"igxCardThumbnail\", \"\"]]\n  });\n  return IgxCardThumbnailDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * igxCardHeaderTitle is used to denote the header title in a card.\n * Use it to tag text nodes.\n */\n\n\nlet IgxCardHeaderTitleDirective = /*#__PURE__*/(() => {\n  class IgxCardHeaderTitleDirective {\n    constructor() {\n      /** @hidden @internal */\n      this.cssClass = 'igx-card__header__title';\n    }\n\n  }\n\n  IgxCardHeaderTitleDirective.ɵfac = function IgxCardHeaderTitleDirective_Factory(t) {\n    return new (t || IgxCardHeaderTitleDirective)();\n  };\n\n  IgxCardHeaderTitleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxCardHeaderTitleDirective,\n    selectors: [[\"\", \"igxCardHeaderTitle\", \"\"]],\n    hostVars: 2,\n    hostBindings: function IgxCardHeaderTitleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-card-header__title\", ctx.cssClass);\n      }\n    }\n  });\n  return IgxCardHeaderTitleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * igxCardHeaderSubtitle is used to denote the header subtitle in a card.\n * Use it to tag text nodes.\n */\n\n\nlet IgxCardHeaderSubtitleDirective = /*#__PURE__*/(() => {\n  class IgxCardHeaderSubtitleDirective {\n    constructor() {\n      /** @hidden @internal */\n      this.cssClass = 'igx-card-header__subtitle';\n    }\n\n  }\n\n  IgxCardHeaderSubtitleDirective.ɵfac = function IgxCardHeaderSubtitleDirective_Factory(t) {\n    return new (t || IgxCardHeaderSubtitleDirective)();\n  };\n\n  IgxCardHeaderSubtitleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxCardHeaderSubtitleDirective,\n    selectors: [[\"\", \"igxCardHeaderSubtitle\", \"\"]],\n    hostVars: 2,\n    hostBindings: function IgxCardHeaderSubtitleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-card-header__subtitle\", ctx.cssClass);\n      }\n    }\n  });\n  return IgxCardHeaderSubtitleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * IgxCardContent is container for the card content.\n */\n\n\nlet IgxCardContentDirective = /*#__PURE__*/(() => {\n  class IgxCardContentDirective {\n    constructor() {\n      /** @hidden @internal */\n      this.cssClass = 'igx-card-content';\n    }\n\n  }\n\n  IgxCardContentDirective.ɵfac = function IgxCardContentDirective_Factory(t) {\n    return new (t || IgxCardContentDirective)();\n  };\n\n  IgxCardContentDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxCardContentDirective,\n    selectors: [[\"igx-card-content\"]],\n    hostVars: 2,\n    hostBindings: function IgxCardContentDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-card-content\", ctx.cssClass);\n      }\n    }\n  });\n  return IgxCardContentDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * IgxCardFooter is container for the card footer\n */\n\n\nlet IgxCardFooterDirective = /*#__PURE__*/(() => {\n  class IgxCardFooterDirective {\n    constructor() {\n      /**\n       * An @Input property that sets the value of the `role` attribute of the card footer.\n       * By default the value is set to `footer`.\n       *\n       * @example\n       * ```html\n       * <igx-card-footer role=\"footer\"></igx-card-footer>\n       * ```\n       */\n      this.role = 'footer';\n    }\n\n  }\n\n  IgxCardFooterDirective.ɵfac = function IgxCardFooterDirective_Factory(t) {\n    return new (t || IgxCardFooterDirective)();\n  };\n\n  IgxCardFooterDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxCardFooterDirective,\n    selectors: [[\"igx-card-footer\"]],\n    hostVars: 1,\n    hostBindings: function IgxCardFooterDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n      }\n    },\n    inputs: {\n      role: \"role\"\n    }\n  });\n  return IgxCardFooterDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Card provides a way to display organized content in appealing way.\n *\n * @igxModule IgxCardModule\n *\n * @igxTheme igx-card-theme, igx-icon-theme, igx-button-theme\n *\n * @igxKeywords card, button, avatar, icon\n *\n * @igxGroup Layouts\n *\n * @remarks\n * The Ignite UI Card serves as a container that allows custom content to be organized in an appealing way. There are\n * five sections in a card that you can use to organize your content. These are header, media, content, actions, and footer.\n *\n * @example\n * ```html\n * <igx-card>\n *   <igx-card-header>\n *     <h3 igxCardHeaderTitle>{{title}}</h3>\n *     <h5 igxCardHeaderSubtitle>{{subtitle}}</h5>\n *   </igx-card-header>\n *   <igx-card-actions>\n *       <button igxButton igxRipple>Share</button>\n *       <button igxButton igxRipple>Play Album</button>\n *   </igx-card-actions>\n * </igx-card>\n * ```\n */\n\n\nconst IgxCardType = mkenum({\n  ELEVATED: 'elevated',\n  OUTLINED: 'outlined'\n});\nlet IgxCardComponent = /*#__PURE__*/(() => {\n  class IgxCardComponent {\n    constructor() {\n      /**\n       * Sets/gets the `id` of the card.\n       * If not set, `id` will have value `\"igx-card-0\"`;\n       *\n       * @example\n       * ```html\n       * <igx-card id = \"my-first-card\"></igx-card>\n       * ```\n       * ```typescript\n       * let cardId =  this.card.id;\n       * ```\n       */\n      this.id = `igx-card-${NEXT_ID$g++}`;\n      /**\n       * An @Input property that sets the value of the `role` attribute of the card.\n       * By default the value is set to `group`.\n       *\n       * @example\n       * ```html\n       * <igx-card role=\"group\"></igx-card>\n       * ```\n       */\n\n      this.role = 'group';\n      /**\n       * An @Input property that sets the value of the `type` attribute of the card.\n       * By default the value is set to `elevated`. You can make the card use the\n       * outlined style by setting the value to `outlined`.\n       *\n       * @example\n       * ```html\n       * <igx-card type=\"outlined\"></igx-card>\n       * ```\n       */\n\n      this.type = IgxCardType.ELEVATED;\n      /**\n       * An @Input property that sets the value of the `horizontal` attribute of the card.\n       * Setting this to `true` will make the different card sections align horizontally,\n       * essentially flipping the card to the side.\n       *\n       * @example\n       * ```html\n       * <igx-card [horizontal]=\"true\"></igx-card>\n       * ```\n       */\n\n      this.horizontal = false;\n    }\n    /**\n     * A getter which will return true if the card type is `outlined`.\n     */\n\n\n    get isOutlinedCard() {\n      return this.type === IgxCardType.OUTLINED;\n    }\n\n  }\n\n  IgxCardComponent.ɵfac = function IgxCardComponent_Factory(t) {\n    return new (t || IgxCardComponent)();\n  };\n\n  IgxCardComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxCardComponent,\n    selectors: [[\"igx-card\"]],\n    hostVars: 8,\n    hostBindings: function IgxCardComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id)(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"igx-card\", ctx.type)(\"igx-card--outlined\", ctx.isOutlinedCard)(\"igx-card--horizontal\", ctx.horizontal);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      role: \"role\",\n      type: \"type\",\n      horizontal: \"horizontal\"\n    },\n    ngContentSelectors: _c8,\n    decls: 1,\n    vars: 0,\n    template: function IgxCardComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxCardComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst IgxCardActionsLayout = mkenum({\n  START: 'start',\n  JUSTIFY: 'justify'\n});\n/**\n * IgxCardActions is container for the card actions.\n */\n\nlet IgxCardActionsComponent = /*#__PURE__*/(() => {\n  class IgxCardActionsComponent {\n    constructor(card) {\n      this.card = card;\n      /**\n       * An @Input property that sets the layout style of the actions.\n       * By default icons and icon buttons, as well as regular buttons\n       * are split into two containers, which are then positioned on both ends\n       * of the card-actions area.\n       * You can justify the elements in those groups so they are positioned equally\n       * from one another taking up all the space available along the card actions axis.\n       *\n       * @example\n       * ```html\n       * <igx-card-actions layout=\"justify\"></igx-card-actions>\n       * ```\n       */\n\n      this.layout = IgxCardActionsLayout.START;\n      /**\n       * An @Input property that sets the vertical attribute of the actions.\n       * When set to `true` the actions will be layed out vertically.\n       */\n\n      this.vertical = false;\n      /**\n       * An @Input property that sets order of the buttons the actions area.\n       * By default all icons/icon buttons are placed at the end of the action\n       * area. Any regular buttons(flat, raised) will appear before the icons/icon buttons\n       * placed in the actions area.\n       * If you want to reverse their positions so that icons appear first, use the `reverse`\n       * attribute.\n       *\n       * @example\n       * ```html\n       * <igx-card-actions [reverse]=\"true\"></igx-card-actions>\n       * ```\n       */\n\n      this.reverse = false;\n      this.isVerticalSet = false;\n    }\n    /**\n     * A getter that returns `true` when the layout has been\n     * set to `justify`.\n     */\n\n\n    get isJustifyLayout() {\n      return this.layout === IgxCardActionsLayout.JUSTIFY;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    ngOnChanges(changes) {\n      for (const prop in changes) {\n        if (prop === 'vertical') {\n          this.isVerticalSet = true;\n        }\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    ngOnInit() {\n      if (!this.isVerticalSet && this.card.horizontal) {\n        this.vertical = true;\n      }\n\n      ;\n    }\n\n  }\n\n  IgxCardActionsComponent.ɵfac = function IgxCardActionsComponent_Factory(t) {\n    return new (t || IgxCardActionsComponent)(i0.ɵɵdirectiveInject(IgxCardComponent, 8));\n  };\n\n  IgxCardActionsComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxCardActionsComponent,\n    selectors: [[\"igx-card-actions\"]],\n    hostVars: 8,\n    hostBindings: function IgxCardActionsComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-card-actions\", ctx.layout)(\"igx-card-actions--vertical\", ctx.vertical)(\"igx-card-actions--justify\", ctx.isJustifyLayout)(\"igx-card-actions--reverse\", ctx.reverse);\n      }\n    },\n    inputs: {\n      layout: \"layout\",\n      vertical: \"vertical\",\n      reverse: \"reverse\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c51,\n    decls: 6,\n    vars: 0,\n    consts: [[1, \"igx-card-actions__icons\"], [1, \"igx-card-actions__buttons\"], [\"buttons\", \"\"]],\n    template: function IgxCardActionsComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c50);\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵprojection(1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(2, \"div\", 1, 2);\n        i0.ɵɵprojection(4, 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵprojection(5, 2);\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxCardActionsComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxCardModule = /*#__PURE__*/(() => {\n  class IgxCardModule {}\n\n  IgxCardModule.ɵfac = function IgxCardModule_Factory(t) {\n    return new (t || IgxCardModule)();\n  };\n\n  IgxCardModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxCardModule\n  });\n  IgxCardModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, IgxButtonModule]]\n  });\n  return IgxCardModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar Direction = /*#__PURE__*/(() => {\n  (function (Direction) {\n    Direction[Direction[\"NONE\"] = 0] = \"NONE\";\n    Direction[Direction[\"NEXT\"] = 1] = \"NEXT\";\n    Direction[Direction[\"PREV\"] = 2] = \"PREV\";\n  })(Direction || (Direction = {}));\n\n  return Direction;\n})();\nconst HorizontalAnimationType = mkenum({\n  none: 'none',\n  slide: 'slide',\n  fade: 'fade'\n});\n/** @hidden */\n\nclass IgxCarouselComponentBase {\n  constructor(builder, cdr) {\n    this.builder = builder;\n    this.cdr = cdr;\n    /** @hidden */\n\n    this.animationType = HorizontalAnimationType.slide;\n    /** @hidden @internal */\n\n    this.enterAnimationDone = new EventEmitter();\n    /** @hidden @internal */\n\n    this.leaveAnimationDone = new EventEmitter();\n    /** @hidden */\n\n    this.defaultAnimationDuration = 320;\n    /** @hidden */\n\n    this.animationPosition = 0;\n    /** @hidden */\n\n    this.newDuration = 0;\n  }\n  /** @hidden */\n\n\n  triggerAnimations() {\n    if (this.animationType !== HorizontalAnimationType.none) {\n      if (this.animationStarted(this.leaveAnimationPlayer) || this.animationStarted(this.enterAnimationPlayer)) {\n        requestAnimationFrame(() => {\n          this.resetAnimations();\n          this.playAnimations();\n        });\n      } else {\n        this.playAnimations();\n      }\n    }\n  }\n  /** @hidden */\n\n\n  animationStarted(animation) {\n    return animation && animation.hasStarted();\n  }\n  /** @hidden */\n\n\n  playAnimations() {\n    this.playLeaveAnimation();\n    this.playEnterAnimation();\n  }\n\n  resetAnimations() {\n    if (this.animationStarted(this.leaveAnimationPlayer)) {\n      this.leaveAnimationPlayer.reset();\n      this.leaveAnimationDone.emit();\n    }\n\n    if (this.animationStarted(this.enterAnimationPlayer)) {\n      this.enterAnimationPlayer.reset();\n      this.enterAnimationDone.emit();\n      this.cdr.markForCheck();\n    }\n  }\n\n  getAnimation() {\n    let duration;\n\n    if (this.newDuration) {\n      duration = this.animationPosition ? this.animationPosition * this.newDuration : this.newDuration;\n    } else {\n      duration = this.animationPosition ? this.animationPosition * this.defaultAnimationDuration : this.defaultAnimationDuration;\n    }\n\n    switch (this.animationType) {\n      case HorizontalAnimationType.slide:\n        const trans = this.animationPosition ? this.animationPosition * 100 : 100;\n        return {\n          enterAnimation: useAnimation(slideInLeft, {\n            params: {\n              delay: '0s',\n              duration: `${duration}ms`,\n              endOpacity: 1,\n              startOpacity: 1,\n              fromPosition: `translateX(${this.currentItem.direction === 1 ? trans : -trans}%)`,\n              toPosition: 'translateX(0%)'\n            }\n          }),\n          leaveAnimation: useAnimation(slideInLeft, {\n            params: {\n              delay: '0s',\n              duration: `${duration}ms`,\n              endOpacity: 1,\n              startOpacity: 1,\n              fromPosition: `translateX(0%)`,\n              toPosition: `translateX(${this.currentItem.direction === 1 ? -trans : trans}%)`\n            }\n          })\n        };\n\n      case HorizontalAnimationType.fade:\n        return {\n          enterAnimation: useAnimation(fadeIn, {\n            params: {\n              duration: `${duration}ms`,\n              startOpacity: `${this.animationPosition}`\n            }\n          }),\n          leaveAnimation: null\n        };\n    }\n\n    return {\n      enterAnimation: null,\n      leaveAnimation: null\n    };\n  }\n\n  playEnterAnimation() {\n    const animation = this.getAnimation().enterAnimation;\n\n    if (!animation) {\n      return;\n    }\n\n    const animationBuilder = this.builder.build(animation);\n    this.enterAnimationPlayer = animationBuilder.create(this.getCurrentElement());\n    this.enterAnimationPlayer.onDone(() => {\n      if (this.enterAnimationPlayer) {\n        this.enterAnimationPlayer.reset();\n        this.enterAnimationPlayer = null;\n      }\n\n      this.animationPosition = 0;\n      this.newDuration = 0;\n      this.previousItem.previous = false;\n      this.enterAnimationDone.emit();\n      this.cdr.markForCheck();\n    });\n    this.previousItem.previous = true;\n    this.enterAnimationPlayer.play();\n  }\n\n  playLeaveAnimation() {\n    const animation = this.getAnimation().leaveAnimation;\n\n    if (!animation) {\n      return;\n    }\n\n    const animationBuilder = this.builder.build(animation);\n    this.leaveAnimationPlayer = animationBuilder.create(this.getPreviousElement());\n    this.leaveAnimationPlayer.onDone(() => {\n      if (this.leaveAnimationPlayer) {\n        this.leaveAnimationPlayer.reset();\n        this.leaveAnimationPlayer = null;\n      }\n\n      this.animationPosition = 0;\n      this.newDuration = 0;\n      this.leaveAnimationDone.emit();\n    });\n    this.leaveAnimationPlayer.play();\n  }\n\n}\n\nlet IgxCarouselIndicatorDirective = /*#__PURE__*/(() => {\n  class IgxCarouselIndicatorDirective {}\n\n  IgxCarouselIndicatorDirective.ɵfac = function IgxCarouselIndicatorDirective_Factory(t) {\n    return new (t || IgxCarouselIndicatorDirective)();\n  };\n\n  IgxCarouselIndicatorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxCarouselIndicatorDirective,\n    selectors: [[\"\", \"igxCarouselIndicator\", \"\"]]\n  });\n  return IgxCarouselIndicatorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxCarouselNextButtonDirective = /*#__PURE__*/(() => {\n  class IgxCarouselNextButtonDirective {}\n\n  IgxCarouselNextButtonDirective.ɵfac = function IgxCarouselNextButtonDirective_Factory(t) {\n    return new (t || IgxCarouselNextButtonDirective)();\n  };\n\n  IgxCarouselNextButtonDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxCarouselNextButtonDirective,\n    selectors: [[\"\", \"igxCarouselNextButton\", \"\"]]\n  });\n  return IgxCarouselNextButtonDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxCarouselPrevButtonDirective = /*#__PURE__*/(() => {\n  class IgxCarouselPrevButtonDirective {}\n\n  IgxCarouselPrevButtonDirective.ɵfac = function IgxCarouselPrevButtonDirective_Factory(t) {\n    return new (t || IgxCarouselPrevButtonDirective)();\n  };\n\n  IgxCarouselPrevButtonDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxCarouselPrevButtonDirective,\n    selectors: [[\"\", \"igxCarouselPrevButton\", \"\"]]\n  });\n  return IgxCarouselPrevButtonDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A slide component that usually holds an image and/or a caption text.\n * IgxSlideComponent is usually a child component of an IgxCarouselComponent.\n *\n * ```\n * <igx-slide [input bindings] >\n *    <ng-content></ng-content>\n * </igx-slide>\n * ```\n *\n * @export\n */\n\n\nlet IgxSlideComponent = /*#__PURE__*/(() => {\n  class IgxSlideComponent {\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n      /**\n       * Returns the `role` of the slide component.\n       * By default is set to `tabpanel`\n       *\n       * @memberof IgxSlideComponent\n       */\n\n      this.tab = 'tabpanel';\n      /**\n       * Returns the class of the slide component.\n       * ```typescript\n       * let class =  this.slide.cssClass;\n       * ```\n       *\n       * @memberof IgxSlideComponent\n       */\n\n      this.cssClass = 'igx-slide';\n      this.previous = false;\n      /**\n       * @hidden\n       */\n\n      this.activeChange = new EventEmitter();\n      this._active = false;\n      this._destroy$ = new Subject();\n    }\n    /**\n     * Returns the `tabIndex` of the slide component.\n     * ```typescript\n     * let tabIndex =  this.carousel.tabIndex;\n     * ```\n     *\n     * @memberof IgxSlideComponent\n     */\n\n\n    get tabIndex() {\n      return this.active ? 0 : null;\n    }\n    /**\n     * Gets/sets the `active` state of the slide.\n     * ```html\n     * <igx-carousel>\n     *  <igx-slide [active] =\"false\"></igx-slide>\n     * <igx-carousel>\n     * ```\n     *\n     * Two-way data binding.\n     * ```html\n     * <igx-carousel>\n     *  <igx-slide [(active)] =\"model.isActive\"></igx-slide>\n     * <igx-carousel>\n     * ```\n     *\n     * @memberof IgxSlideComponent\n     */\n\n\n    get active() {\n      return this._active;\n    }\n\n    set active(value) {\n      this._active = !!value;\n      this.activeChange.emit(this._active);\n    }\n    /**\n     * Returns a reference to the carousel element in the DOM.\n     * ```typescript\n     * let nativeElement =  this.slide.nativeElement;\n     * ```\n     *\n     * @memberof IgxSlideComponent\n     */\n\n\n    get nativeElement() {\n      return this.elementRef.nativeElement;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isDestroyed() {\n      return this._destroy$;\n    }\n\n    ngAfterContentChecked() {\n      this.id = `panel-${this.index}`;\n      this.ariaLabelledBy = `tab-${this.index}-${this.total}`;\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      this._destroy$.next(true);\n\n      this._destroy$.complete();\n    }\n\n  }\n\n  IgxSlideComponent.ɵfac = function IgxSlideComponent_Factory(t) {\n    return new (t || IgxSlideComponent)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxSlideComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxSlideComponent,\n    selectors: [[\"igx-slide\"]],\n    hostVars: 10,\n    hostBindings: function IgxSlideComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabindex\", ctx.tabIndex)(\"id\", ctx.id)(\"role\", ctx.tab)(\"aria-labelledby\", ctx.ariaLabelledBy);\n        i0.ɵɵclassProp(\"igx-slide\", ctx.cssClass)(\"igx-slide--current\", ctx.active)(\"igx-slide--previous\", ctx.previous);\n      }\n    },\n    inputs: {\n      index: \"index\",\n      direction: \"direction\",\n      total: \"total\",\n      active: \"active\",\n      previous: \"previous\"\n    },\n    outputs: {\n      activeChange: \"activeChange\"\n    },\n    ngContentSelectors: _c8,\n    decls: 1,\n    vars: 0,\n    template: function IgxSlideComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxSlideComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$f = 0;\nconst CarouselIndicatorsOrientation = mkenum({\n  bottom: 'bottom',\n  top: 'top'\n});\nlet CarouselHammerConfig = /*#__PURE__*/(() => {\n  class CarouselHammerConfig extends HammerGestureConfig {\n    constructor() {\n      super(...arguments);\n      this.overrides = {\n        pan: {\n          direction: Hammer.DIRECTION_HORIZONTAL\n        }\n      };\n    }\n\n  }\n\n  CarouselHammerConfig.ɵfac = /* @__PURE__ */function () {\n    let ɵCarouselHammerConfig_BaseFactory;\n    return function CarouselHammerConfig_Factory(t) {\n      return (ɵCarouselHammerConfig_BaseFactory || (ɵCarouselHammerConfig_BaseFactory = i0.ɵɵgetInheritedFactory(CarouselHammerConfig)))(t || CarouselHammerConfig);\n    };\n  }();\n\n  CarouselHammerConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CarouselHammerConfig,\n    factory: CarouselHammerConfig.ɵfac\n  });\n  return CarouselHammerConfig;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * **Ignite UI for Angular Carousel** -\n * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/carousel.html)\n *\n * The Ignite UI Carousel is used to browse or navigate through a collection of slides. Slides can contain custom\n * content such as images or cards and be used for things such as on-boarding tutorials or page-based interfaces.\n * It can be used as a separate fullscreen element or inside another component.\n *\n * Example:\n * ```html\n * <igx-carousel>\n *   <igx-slide>\n *     <h3>First Slide Header</h3>\n *     <p>First slide Content</p>\n *   <igx-slide>\n *   <igx-slide>\n *     <h3>Second Slide Header</h3>\n *     <p>Second Slide Content</p>\n * </igx-carousel>\n * ```\n */\n\n\nlet IgxCarouselComponent = /*#__PURE__*/(() => {\n  class IgxCarouselComponent extends IgxCarouselComponentBase {\n    constructor(cdr, element, iterableDiffers, builder, platformUtil) {\n      super(builder, cdr);\n      this.element = element;\n      this.iterableDiffers = iterableDiffers;\n      this.platformUtil = platformUtil;\n      /**\n       * Sets the `id` of the carousel.\n       * If not set, the `id` of the first carousel component will be `\"igx-carousel-0\"`.\n       * ```html\n       * <igx-carousel id=\"my-first-carousel\"></igx-carousel>\n       * ```\n       *\n       * @memberof IgxCarouselComponent\n       */\n\n      this.id = `igx-carousel-${NEXT_ID$f++}`;\n      /**\n       * Returns the `role` attribute of the carousel.\n       * ```typescript\n       * let carouselRole =  this.carousel.role;\n       * ```\n       *\n       * @memberof IgxCarouselComponent\n       */\n\n      this.role = 'region';\n      /** @hidden */\n\n      this.roleDescription = 'carousel';\n      /**\n       * Returns the class of the carousel component.\n       * ```typescript\n       * let class =  this.carousel.cssClass;\n       * ```\n       *\n       * @memberof IgxCarouselComponent\n       */\n\n      this.cssClass = 'igx-carousel';\n      /**\n       * Sets whether the carousel should `loop` back to the first slide after reaching the last slide.\n       * Default value is `true`.\n       * ```html\n       * <igx-carousel [loop]=\"false\"></igx-carousel>\n       * ```\n       *\n       * @memberOf IgxCarouselComponent\n       */\n\n      this.loop = true;\n      /**\n       * Sets whether the carousel will `pause` the slide transitions on user interactions.\n       * Default value is `true`.\n       * ```html\n       *  <igx-carousel [pause]=\"false\"></igx-carousel>\n       * ```\n       *\n       * @memberOf IgxCarouselComponent\n       */\n\n      this.pause = true;\n      /**\n       * Controls whether the carousel should render the left/right `navigation` buttons.\n       * Default value is `true`.\n       * ```html\n       * <igx-carousel [navigation] = \"false\"></igx-carousel>\n       * ```\n       *\n       * @memberOf IgxCarouselComponent\n       */\n\n      this.navigation = true;\n      /**\n       * Controls whether the carousel should support keyboard navigation.\n       * Default value is `true`.\n       * ```html\n       * <igx-carousel [keyboardSupport] = \"false\"></igx-carousel>\n       * ```\n       *\n       * @memberOf IgxCarouselComponent\n       */\n\n      this.keyboardSupport = true;\n      /**\n       * Controls whether the carousel should support gestures.\n       * Default value is `true`.\n       * ```html\n       * <igx-carousel [gesturesSupport] = \"false\"></igx-carousel>\n       * ```\n       *\n       * @memberOf IgxCarouselComponent\n       */\n\n      this.gesturesSupport = true;\n      /**\n       * Controls the maximum indexes that can be shown.\n       * Default value is `5`.\n       * ```html\n       * <igx-carousel [maximumIndicatorsCount] = \"10\"></igx-carousel>\n       * ```\n       *\n       * @memberOf IgxCarouselComponent\n       */\n\n      this.maximumIndicatorsCount = 5;\n      /**\n       * Gets/sets the display mode of carousel indicators. It can be top or bottom.\n       * Default value is `bottom`.\n       * ```html\n       * <igx-carousel indicatorsOrientation='top'>\n       * <igx-carousel>\n       * ```\n       *\n       * @memberOf IgxSlideComponent\n       */\n\n      this.indicatorsOrientation = CarouselIndicatorsOrientation.bottom;\n      /**\n       * Gets/sets the animation type of carousel.\n       * Default value is `slide`.\n       * ```html\n       * <igx-carousel animationType='none'>\n       * <igx-carousel>\n       * ```\n       *\n       * @memberOf IgxSlideComponent\n       */\n\n      this.animationType = HorizontalAnimationType.slide;\n      /**\n       * The custom template, if any, that should be used when rendering carousel indicators\n       *\n       * ```typescript\n       * // Set in typescript\n       * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;\n       * myComponent.carousel.indicatorTemplate = myCustomTemplate;\n       * ```\n       * ```html\n       * <!-- Set in markup -->\n       *  <igx-carousel #carousel>\n       *      ...\n       *      <ng-template igxCarouselIndicator let-slide>\n       *         <igx-icon *ngIf=\"slide.active\">brightness_7</igx-icon>\n       *         <igx-icon *ngIf=\"!slide.active\">brightness_5</igx-icon>\n       *      </ng-template>\n       *  </igx-carousel>\n       * ```\n       */\n\n      this.indicatorTemplate = null;\n      /**\n       * The custom template, if any, that should be used when rendering carousel next button\n       *\n       * ```typescript\n       * // Set in typescript\n       * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;\n       * myComponent.carousel.nextButtonTemplate = myCustomTemplate;\n       * ```\n       * ```html\n       * <!-- Set in markup -->\n       *  <igx-carousel #carousel>\n       *      ...\n       *      <ng-template igxCarouselNextButton let-disabled>\n       *            <button igxButton=\"fab\" igxRipple=\"white\" [disabled]=\"disabled\">\n       *                <igx-icon>add</igx-icon>\n       *           </button>\n       *      </ng-template>\n       *  </igx-carousel>\n       * ```\n       */\n\n      this.nextButtonTemplate = null;\n      /**\n       * The custom template, if any, that should be used when rendering carousel previous button\n       *\n       * ```typescript\n       * // Set in typescript\n       * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;\n       * myComponent.carousel.nextButtonTemplate = myCustomTemplate;\n       * ```\n       * ```html\n       * <!-- Set in markup -->\n       *  <igx-carousel #carousel>\n       *      ...\n       *      <ng-template igxCarouselPrevButton let-disabled>\n       *            <button igxButton=\"fab\" igxRipple=\"white\" [disabled]=\"disabled\">\n       *                <igx-icon>remove</igx-icon>\n       *           </button>\n       *      </ng-template>\n       *  </igx-carousel>\n       * ```\n       */\n\n      this.prevButtonTemplate = null;\n      /**\n       * An event that is emitted after a slide transition has happened.\n       * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.\n       * ```html\n       * <igx-carousel (onSlideChanged)=\"onSlideChanged($event)\"></igx-carousel>\n       * ```\n       *\n       * @memberOf IgxCarouselComponent\n       */\n\n      this.onSlideChanged = new EventEmitter();\n      /**\n       * An event that is emitted after a slide has been added to the carousel.\n       * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.\n       * ```html\n       * <igx-carousel (onSlideAdded)=\"onSlideAdded($event)\"></igx-carousel>\n       * ```\n       *\n       * @memberOf IgxCarouselComponent\n       */\n\n      this.onSlideAdded = new EventEmitter();\n      /**\n       * An event that is emitted after a slide has been removed from the carousel.\n       * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.\n       * ```html\n       * <igx-carousel (onSlideRemoved)=\"onSlideRemoved($event)\"></igx-carousel>\n       * ```\n       *\n       * @memberOf IgxCarouselComponent\n       */\n\n      this.onSlideRemoved = new EventEmitter();\n      /**\n       * An event that is emitted after the carousel has been paused.\n       * Provides a reference to the `IgxCarouselComponent` as an event argument.\n       * ```html\n       * <igx-carousel (onCarouselPaused)=\"onCarouselPaused($event)\"></igx-carousel>\n       * ```\n       *\n       * @memberOf IgxCarouselComponent\n       */\n\n      this.onCarouselPaused = new EventEmitter();\n      /**\n       * An event that is emitted after the carousel has resumed transitioning between `slides`.\n       * Provides a reference to the `IgxCarouselComponent` as an event argument.\n       * ```html\n       * <igx-carousel (onCarouselPlaying)=\"onCarouselPlaying($event)\"></igx-carousel>\n       * ```\n       *\n       * @memberOf IgxCarouselComponent\n       */\n\n      this.onCarouselPlaying = new EventEmitter();\n      this._resourceStrings = CurrentResourceStrings.CarouselResStrings;\n      this.destroy$ = new Subject();\n      this.differ = null;\n      this.differ = this.iterableDiffers.find([]).create(null);\n    }\n    /** @hidden */\n\n\n    get labelId() {\n      return this.showIndicatorsLabel ? `${this.id}-label` : null;\n    }\n    /**\n     * Gets the `touch-action` style of the `list item`.\n     * ```typescript\n     * let touchAction = this.listItem.touchAction;\n     * ```\n     */\n\n\n    get touchAction() {\n      return this.gesturesSupport ? 'pan-y' : 'auto';\n    }\n    /**\n     * An accessor that sets the resource strings.\n     * By default it uses EN resources.\n     */\n\n\n    set resourceStrings(value) {\n      this._resourceStrings = Object.assign({}, this._resourceStrings, value);\n    }\n    /**\n     * An accessor that returns the resource strings.\n     */\n\n\n    get resourceStrings() {\n      return this._resourceStrings;\n    }\n    /** @hidden */\n\n\n    get getIndicatorTemplate() {\n      if (this.indicatorTemplate) {\n        return this.indicatorTemplate;\n      }\n\n      return this.defaultIndicator;\n    }\n    /** @hidden */\n\n\n    get getNextButtonTemplate() {\n      if (this.nextButtonTemplate) {\n        return this.nextButtonTemplate;\n      }\n\n      return this.defaultNextButton;\n    }\n    /** @hidden */\n\n\n    get getPrevButtonTemplate() {\n      if (this.prevButtonTemplate) {\n        return this.prevButtonTemplate;\n      }\n\n      return this.defaultPrevButton;\n    }\n    /** @hidden */\n\n\n    get indicatorsOrientationClass() {\n      return `igx-carousel-indicators--${this.indicatorsOrientation}`;\n    }\n    /** @hidden */\n\n\n    get showIndicators() {\n      return this.total <= this.maximumIndicatorsCount && this.total > 0;\n    }\n    /** @hidden */\n\n\n    get showIndicatorsLabel() {\n      return this.total > this.maximumIndicatorsCount;\n    }\n    /** @hidden */\n\n\n    get getCarouselLabel() {\n      return `${this.current + 1} ${this.resourceStrings.igx_carousel_of} ${this.total}`;\n    }\n    /**\n     * Returns the total number of `slides` in the carousel.\n     * ```typescript\n     * let slideCount =  this.carousel.total;\n     * ```\n     *\n     * @memberOf IgxCarouselComponent\n     */\n\n\n    get total() {\n      var _a;\n\n      return (_a = this.slides) === null || _a === void 0 ? void 0 : _a.length;\n    }\n    /**\n     * The index of the slide being currently shown.\n     * ```typescript\n     * let currentSlideNumber =  this.carousel.current;\n     * ```\n     *\n     * @memberOf IgxCarouselComponent\n     */\n\n\n    get current() {\n      return !this.currentItem ? 0 : this.currentItem.index;\n    }\n    /**\n     * Returns a boolean indicating if the carousel is playing.\n     * ```typescript\n     * let isPlaying =  this.carousel.isPlaying;\n     * ```\n     *\n     * @memberOf IgxCarouselComponent\n     */\n\n\n    get isPlaying() {\n      return this.playing;\n    }\n    /**\n     * Returns а boolean indicating if the carousel is destroyed.\n     * ```typescript\n     * let isDestroyed =  this.carousel.isDestroyed;\n     * ```\n     *\n     * @memberOf IgxCarouselComponent\n     */\n\n\n    get isDestroyed() {\n      return this.destroyed;\n    }\n    /**\n     * Returns a reference to the carousel element in the DOM.\n     * ```typescript\n     * let nativeElement =  this.carousel.nativeElement;\n     * ```\n     *\n     * @memberof IgxCarouselComponent\n     */\n\n\n    get nativeElement() {\n      return this.element.nativeElement;\n    }\n    /**\n     * Returns the time `interval` in milliseconds before the slide changes.\n     * ```typescript\n     * let timeInterval = this.carousel.interval;\n     * ```\n     *\n     * @memberof IgxCarouselComponent\n     */\n\n\n    get interval() {\n      return this._interval;\n    }\n    /**\n     * Sets the time `interval` in milliseconds before the slide changes.\n     * If not set, the carousel will not change `slides` automatically.\n     * ```html\n     * <igx-carousel [interval] = \"1000\"></igx-carousel>\n     * ```\n     *\n     * @memberof IgxCarouselComponent\n     */\n\n\n    set interval(value) {\n      this._interval = +value;\n      this.restartInterval();\n    }\n    /** @hidden */\n\n\n    onKeydownArrowRight(event) {\n      if (this.keyboardSupport) {\n        event.preventDefault();\n        this.next();\n        this.focusSlideElement();\n      }\n    }\n    /** @hidden */\n\n\n    onKeydownArrowLeft(event) {\n      if (this.keyboardSupport) {\n        event.preventDefault();\n        this.prev();\n        this.focusSlideElement();\n      }\n    }\n    /** @hidden */\n\n\n    onTap(event) {\n      // play pause only when tap on slide\n      if (event.target && event.target.classList.contains('igx-slide')) {\n        if (this.isPlaying) {\n          if (this.pause) {\n            this.stoppedByInteraction = true;\n          }\n\n          this.stop();\n        } else if (this.stoppedByInteraction) {\n          this.play();\n        }\n      }\n    }\n    /** @hidden */\n\n\n    onKeydownHome(event) {\n      if (this.keyboardSupport && this.slides.length > 0) {\n        event.preventDefault();\n        this.slides.first.active = true;\n        this.focusSlideElement();\n      }\n    }\n    /** @hidden */\n\n\n    onKeydownEnd(event) {\n      if (this.keyboardSupport && this.slides.length > 0) {\n        event.preventDefault();\n        this.slides.last.active = true;\n        this.focusSlideElement();\n      }\n    }\n    /** @hidden */\n\n\n    onMouseEnter() {\n      if (this.pause && this.isPlaying) {\n        this.stoppedByInteraction = true;\n      }\n\n      this.stop();\n    }\n    /** @hidden */\n\n\n    onMouseLeave() {\n      if (this.stoppedByInteraction) {\n        this.play();\n      }\n    }\n    /** @hidden */\n\n\n    onPanLeft(event) {\n      this.pan(event);\n    }\n    /** @hidden */\n\n\n    onPanRight(event) {\n      this.pan(event);\n    }\n    /**\n     * @hidden\n     */\n\n\n    onPanEnd(event) {\n      if (!this.gesturesSupport) {\n        return;\n      }\n\n      event.preventDefault();\n      const slideWidth = this.currentItem.nativeElement.offsetWidth;\n      const panOffset = slideWidth / 1000;\n      const deltaX = Math.abs(event.deltaX) + panOffset < slideWidth ? Math.abs(event.deltaX) : slideWidth - panOffset;\n      const velocity = Math.abs(event.velocity);\n      this.resetSlideStyles(this.currentItem);\n\n      if (this.incomingSlide) {\n        this.resetSlideStyles(this.incomingSlide);\n\n        if (slideWidth / 2 < deltaX || velocity > 1) {\n          this.incomingSlide.direction = event.deltaX < 0 ? Direction.NEXT : Direction.PREV;\n          this.incomingSlide.previous = false;\n          this.animationPosition = this.animationType === HorizontalAnimationType.fade ? deltaX / slideWidth : (slideWidth - deltaX) / slideWidth;\n\n          if (velocity > 1) {\n            this.newDuration = this.defaultAnimationDuration / velocity;\n          }\n\n          this.incomingSlide.active = true;\n        } else {\n          this.currentItem.direction = event.deltaX > 0 ? Direction.NEXT : Direction.PREV;\n          this.previousItem = this.incomingSlide;\n          this.previousItem.previous = true;\n          this.animationPosition = this.animationType === HorizontalAnimationType.fade ? Math.abs((slideWidth - deltaX) / slideWidth) : deltaX / slideWidth;\n          this.playAnimations();\n        }\n      }\n\n      if (this.stoppedByInteraction) {\n        this.play();\n      }\n    }\n    /** @hidden */\n\n\n    ngAfterContentInit() {\n      this.slides.changes.pipe(takeUntil(this.destroy$)).subscribe(change => this.initSlides(change));\n      this.initSlides(this.slides);\n    }\n    /** @hidden */\n\n\n    ngOnDestroy() {\n      this.destroy$.next(true);\n      this.destroy$.complete();\n      this.destroyed = true;\n\n      if (this.lastInterval) {\n        clearInterval(this.lastInterval);\n      }\n    }\n    /**\n     * Returns the slide corresponding to the provided `index` or null.\n     * ```typescript\n     * let slide1 =  this.carousel.get(1);\n     * ```\n     *\n     * @memberOf IgxCarouselComponent\n     */\n\n\n    get(index) {\n      return this.slides.find(slide => slide.index === index);\n    }\n    /**\n     * Adds a new slide to the carousel.\n     * ```typescript\n     * this.carousel.add(newSlide);\n     * ```\n     *\n     * @memberOf IgxCarouselComponent\n     */\n\n\n    add(slide) {\n      const newSlides = this.slides.toArray();\n      newSlides.push(slide);\n      this.slides.reset(newSlides);\n      this.slides.notifyOnChanges();\n    }\n    /**\n     * Removes a slide from the carousel.\n     * ```typescript\n     * this.carousel.remove(slide);\n     * ```\n     *\n     * @memberOf IgxCarouselComponent\n     */\n\n\n    remove(slide) {\n      if (slide && slide === this.get(slide.index)) {\n        // check if the requested slide for delete is present in the carousel\n        const newSlides = this.slides.toArray();\n        newSlides.splice(slide.index, 1);\n        this.slides.reset(newSlides);\n        this.slides.notifyOnChanges();\n      }\n    }\n    /**\n     * Kicks in a transition for a given slide with a given `direction`.\n     * ```typescript\n     * this.carousel.select(this.carousel.get(2), Direction.NEXT);\n     * ```\n     *\n     * @memberOf IgxCarouselComponent\n     */\n\n\n    select(slide, direction = Direction.NONE) {\n      if (slide && slide !== this.currentItem) {\n        slide.direction = direction;\n        slide.active = true;\n      }\n    }\n    /**\n     * Transitions to the next slide in the carousel.\n     * ```typescript\n     * this.carousel.next();\n     * ```\n     *\n     * @memberOf IgxCarouselComponent\n     */\n\n\n    next() {\n      const index = this.getNextIndex();\n\n      if (index === 0 && !this.loop) {\n        this.stop();\n        return;\n      }\n\n      return this.select(this.get(index), Direction.NEXT);\n    }\n    /**\n     * Transitions to the previous slide in the carousel.\n     * ```typescript\n     * this.carousel.prev();\n     * ```\n     *\n     * @memberOf IgxCarouselComponent\n     */\n\n\n    prev() {\n      const index = this.getPrevIndex();\n\n      if (!this.loop && index === this.total - 1) {\n        this.stop();\n        return;\n      }\n\n      return this.select(this.get(index), Direction.PREV);\n    }\n    /**\n     * Resumes playing of the carousel if in paused state.\n     * No operation otherwise.\n     * ```typescript\n     * this.carousel.play();\n     * }\n     * ```\n     *\n     * @memberOf IgxCarouselComponent\n     */\n\n\n    play() {\n      if (!this.playing) {\n        this.playing = true;\n        this.onCarouselPlaying.emit(this);\n        this.restartInterval();\n        this.stoppedByInteraction = false;\n      }\n    }\n    /**\n     * Stops slide transitions if the `pause` option is set to `true`.\n     * No operation otherwise.\n     * ```typescript\n     *  this.carousel.stop();\n     * }\n     * ```\n     *\n     * @memberOf IgxCarouselComponent\n     */\n\n\n    stop() {\n      if (this.pause) {\n        this.playing = false;\n        this.onCarouselPaused.emit(this);\n        this.resetInterval();\n      }\n    }\n\n    getPreviousElement() {\n      return this.previousItem.nativeElement;\n    }\n\n    getCurrentElement() {\n      return this.currentItem.nativeElement;\n    }\n\n    resetInterval() {\n      if (this.lastInterval) {\n        clearInterval(this.lastInterval);\n        this.lastInterval = null;\n      }\n    }\n\n    restartInterval() {\n      this.resetInterval();\n\n      if (!isNaN(this.interval) && this.interval > 0 && this.platformUtil.isBrowser) {\n        this.lastInterval = setInterval(() => {\n          const tick = +this.interval;\n\n          if (this.playing && this.total && !isNaN(tick) && tick > 0) {\n            this.next();\n          } else {\n            this.stop();\n          }\n        }, this.interval);\n      }\n    }\n    /** @hidden */\n\n\n    get nextButtonDisabled() {\n      return !this.loop && this.current === this.total - 1;\n    }\n    /** @hidden */\n\n\n    get prevButtonDisabled() {\n      return !this.loop && this.current === 0;\n    }\n\n    getNextIndex() {\n      return (this.current + 1) % this.total;\n    }\n\n    getPrevIndex() {\n      return this.current - 1 < 0 ? this.total - 1 : this.current - 1;\n    }\n\n    resetSlideStyles(slide) {\n      slide.nativeElement.style.transform = '';\n      slide.nativeElement.style.opacity = '';\n    }\n\n    pan(event) {\n      const slideWidth = this.currentItem.nativeElement.offsetWidth;\n      const panOffset = slideWidth / 1000;\n      const deltaX = event.deltaX;\n      const index = deltaX < 0 ? this.getNextIndex() : this.getPrevIndex();\n      const offset = deltaX < 0 ? slideWidth + deltaX : -slideWidth + deltaX;\n\n      if (!this.gesturesSupport || event.isFinal || Math.abs(deltaX) + panOffset >= slideWidth) {\n        return;\n      }\n\n      if (!this.loop && (this.current === 0 && deltaX > 0 || this.current === this.total - 1 && deltaX < 0)) {\n        this.incomingSlide = null;\n        return;\n      }\n\n      event.preventDefault();\n\n      if (this.isPlaying) {\n        this.stoppedByInteraction = true;\n        this.stop();\n      }\n\n      if (this.previousItem && this.previousItem.previous) {\n        this.previousItem.previous = false;\n      }\n\n      this.finishAnimations();\n\n      if (this.incomingSlide) {\n        if (index !== this.incomingSlide.index) {\n          this.resetSlideStyles(this.incomingSlide);\n          this.incomingSlide.previous = false;\n          this.incomingSlide = this.get(index);\n        }\n      } else {\n        this.incomingSlide = this.get(index);\n      }\n\n      this.incomingSlide.previous = true;\n\n      if (this.animationType === HorizontalAnimationType.fade) {\n        this.currentItem.nativeElement.style.opacity = `${Math.abs(offset) / slideWidth}`;\n      } else {\n        this.currentItem.nativeElement.style.transform = `translateX(${deltaX}px)`;\n        this.incomingSlide.nativeElement.style.transform = `translateX(${offset}px)`;\n      }\n    }\n\n    unsubscriber(slide) {\n      return merge(this.destroy$, slide.isDestroyed);\n    }\n\n    onSlideActivated(slide) {\n      if (slide.active && slide !== this.currentItem) {\n        if (slide.direction === Direction.NONE) {\n          const newIndex = slide.index;\n          slide.direction = newIndex > this.current ? Direction.NEXT : Direction.PREV;\n        }\n\n        if (this.currentItem) {\n          if (this.previousItem && this.previousItem.previous) {\n            this.previousItem.previous = false;\n          }\n\n          this.currentItem.direction = slide.direction;\n          this.currentItem.active = false;\n          this.previousItem = this.currentItem;\n          this.currentItem = slide;\n          this.triggerAnimations();\n        } else {\n          this.currentItem = slide;\n        }\n\n        this.onSlideChanged.emit({\n          carousel: this,\n          slide\n        });\n        this.restartInterval();\n      }\n    }\n\n    finishAnimations() {\n      if (this.animationStarted(this.leaveAnimationPlayer)) {\n        this.leaveAnimationPlayer.finish();\n      }\n\n      if (this.animationStarted(this.enterAnimationPlayer)) {\n        this.enterAnimationPlayer.finish();\n      }\n    }\n\n    initSlides(change) {\n      const diff = this.differ.diff(change.toArray());\n\n      if (diff) {\n        this.slides.reduce((any, c, ind) => c.index = ind, 0); // reset slides indexes\n\n        diff.forEachAddedItem(record => {\n          const slide = record.item;\n          slide.total = this.total;\n          this.onSlideAdded.emit({\n            carousel: this,\n            slide\n          });\n\n          if (slide.active) {\n            this.currentItem = slide;\n          }\n\n          slide.activeChange.pipe(takeUntil(this.unsubscriber(slide))).subscribe(() => this.onSlideActivated(slide));\n        });\n        diff.forEachRemovedItem(record => {\n          const slide = record.item;\n          this.onSlideRemoved.emit({\n            carousel: this,\n            slide\n          });\n\n          if (slide.active) {\n            slide.active = false;\n            this.currentItem = this.get(slide.index < this.total ? slide.index : this.total - 1);\n          }\n        });\n        this.updateSlidesSelection();\n      }\n    }\n\n    updateSlidesSelection() {\n      if (this.platformUtil.isBrowser) {\n        requestAnimationFrame(() => {\n          if (this.currentItem) {\n            this.currentItem.active = true;\n            const activeSlides = this.slides.filter(slide => slide.active && slide.index !== this.currentItem.index);\n            activeSlides.forEach(slide => slide.active = false);\n          } else if (this.total) {\n            this.slides.first.active = true;\n          }\n\n          this.play();\n        });\n      }\n    }\n\n    focusSlideElement() {\n      if (this.leaveAnimationPlayer) {\n        this.leaveAnimationPlayer.onDone(() => {\n          this.slides.find(s => s.active).nativeElement.focus();\n        });\n      } else {\n        requestAnimationFrame(() => this.slides.find(s => s.active).nativeElement.focus());\n      }\n    }\n\n  }\n\n  IgxCarouselComponent.ɵfac = function IgxCarouselComponent_Factory(t) {\n    return new (t || IgxCarouselComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i1.AnimationBuilder), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxCarouselComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxCarouselComponent,\n    selectors: [[\"igx-carousel\"]],\n    contentQueries: function IgxCarouselComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxCarouselIndicatorDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxCarouselNextButtonDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxCarouselPrevButtonDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxSlideComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.indicatorTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nextButtonTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.prevButtonTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.slides = _t);\n      }\n    },\n    viewQuery: function IgxCarouselComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c52, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c53, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c54, 7, TemplateRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultIndicator = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultNextButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultPrevButton = _t.first);\n      }\n    },\n    hostVars: 8,\n    hostBindings: function IgxCarouselComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown.arrowright\", function IgxCarouselComponent_keydown_arrowright_HostBindingHandler($event) {\n          return ctx.onKeydownArrowRight($event);\n        })(\"keydown.arrowleft\", function IgxCarouselComponent_keydown_arrowleft_HostBindingHandler($event) {\n          return ctx.onKeydownArrowLeft($event);\n        })(\"tap\", function IgxCarouselComponent_tap_HostBindingHandler($event) {\n          return ctx.onTap($event);\n        })(\"keydown.home\", function IgxCarouselComponent_keydown_home_HostBindingHandler($event) {\n          return ctx.onKeydownHome($event);\n        })(\"keydown.end\", function IgxCarouselComponent_keydown_end_HostBindingHandler($event) {\n          return ctx.onKeydownEnd($event);\n        })(\"mouseenter\", function IgxCarouselComponent_mouseenter_HostBindingHandler() {\n          return ctx.onMouseEnter();\n        })(\"mouseleave\", function IgxCarouselComponent_mouseleave_HostBindingHandler() {\n          return ctx.onMouseLeave();\n        })(\"panleft\", function IgxCarouselComponent_panleft_HostBindingHandler($event) {\n          return ctx.onPanLeft($event);\n        })(\"panright\", function IgxCarouselComponent_panright_HostBindingHandler($event) {\n          return ctx.onPanRight($event);\n        })(\"panend\", function IgxCarouselComponent_panend_HostBindingHandler($event) {\n          return ctx.onPanEnd($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id)(\"role\", ctx.role)(\"aria-roledescription\", ctx.roleDescription)(\"aria-labelledby\", ctx.labelId);\n        i0.ɵɵstyleProp(\"touch-action\", ctx.touchAction);\n        i0.ɵɵclassProp(\"igx-carousel\", ctx.cssClass);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      loop: \"loop\",\n      pause: \"pause\",\n      navigation: \"navigation\",\n      keyboardSupport: \"keyboardSupport\",\n      gesturesSupport: \"gesturesSupport\",\n      maximumIndicatorsCount: \"maximumIndicatorsCount\",\n      indicatorsOrientation: \"indicatorsOrientation\",\n      animationType: \"animationType\",\n      resourceStrings: \"resourceStrings\",\n      interval: \"interval\"\n    },\n    outputs: {\n      onSlideChanged: \"onSlideChanged\",\n      onSlideAdded: \"onSlideAdded\",\n      onSlideRemoved: \"onSlideRemoved\",\n      onCarouselPaused: \"onCarouselPaused\",\n      onCarouselPlaying: \"onCarouselPlaying\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: HAMMER_GESTURE_CONFIG,\n      useClass: CarouselHammerConfig\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c8,\n    decls: 12,\n    vars: 5,\n    consts: [[\"defaultIndicator\", \"\"], [\"defaultNextButton\", \"\"], [\"defaultPrevButton\", \"\"], [3, \"ngClass\", 4, \"ngIf\"], [1, \"igx-carousel__inner\"], [\"role\", \"button\", \"tabindex\", \"0\", \"class\", \"igx-carousel__arrow--prev\", 3, \"keydown.enter\", \"click\", 4, \"ngIf\"], [\"role\", \"button\", \"tabindex\", \"0\", \"class\", \"igx-carousel__arrow--next\", 3, \"keydown.enter\", \"click\", 4, \"ngIf\"], [1, \"igx-nav-dot\"], [1, \"igx-nav-arrow\"], [3, \"ngClass\"], [\"class\", \"igx-carousel-indicators__indicator\", 3, \"id\", \"click\", 4, \"ngFor\", \"ngForOf\"], [1, \"igx-carousel-indicators__indicator\", 3, \"id\", \"click\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"igx-carousel__label\", 3, \"id\"], [\"role\", \"button\", \"tabindex\", \"0\", 1, \"igx-carousel__arrow--prev\", 3, \"keydown.enter\", \"click\"], [\"role\", \"button\", \"tabindex\", \"0\", 1, \"igx-carousel__arrow--next\", 3, \"keydown.enter\", \"click\"]],\n    template: function IgxCarouselComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, IgxCarouselComponent_ng_template_0_Template, 1, 2, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, IgxCarouselComponent_ng_template_2_Template, 3, 2, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(4, IgxCarouselComponent_ng_template_4_Template, 3, 2, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(6, IgxCarouselComponent_div_6_Template, 2, 3, \"div\", 3);\n        i0.ɵɵtemplate(7, IgxCarouselComponent_div_7_Template, 3, 3, \"div\", 3);\n        i0.ɵɵelementStart(8, \"div\", 4);\n        i0.ɵɵprojection(9);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(10, IgxCarouselComponent_div_10_Template, 2, 5, \"div\", 5);\n        i0.ɵɵtemplate(11, IgxCarouselComponent_div_11_Template, 2, 5, \"div\", 6);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(6);\n        i0.ɵɵproperty(\"ngIf\", ctx.showIndicators);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showIndicatorsLabel);\n        i0.ɵɵadvance(1);\n        i0.ɵɵattribute(\"aria-live\", !ctx.interval || ctx.stoppedByInteraction ? \"polite\" : \"off\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.navigation && ctx.slides.length);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.navigation && ctx.slides.length);\n      }\n    },\n    directives: [IgxIconComponent, i4.NgIf, i4.NgClass, i4.NgForOf, i4.NgTemplateOutlet],\n    styles: [\"[_nghost-%COMP%]{display:block;outline-style:none}\"]\n  });\n  return IgxCarouselComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxCarouselModule = /*#__PURE__*/(() => {\n  class IgxCarouselModule {}\n\n  IgxCarouselModule.ɵfac = function IgxCarouselModule_Factory(t) {\n    return new (t || IgxCarouselModule)();\n  };\n\n  IgxCarouselModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxCarouselModule\n  });\n  IgxCarouselModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, IgxIconModule]]\n  });\n  return IgxCarouselModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet CHIP_ID = 0;\n/**\n * Chip is compact visual component that displays information in an obround.\n *\n * @igxModule IgxChipsModule\n *\n * @igxTheme igx-chip-theme\n *\n * @igxKeywords chip\n *\n * @igxGroup display\n *\n * @remarks\n * The Ignite UI Chip can be templated, deleted, and selected.\n * Multiple chips can be reordered and visually connected to each other.\n * Chips reside in a container called chips area which is responsible for managing the interactions between the chips.\n *\n * @example\n * ```html\n * <igx-chip class=\"chipStyle\" [id]=\"901\" [draggable]=\"true\" [removable]=\"true\" (remove)=\"chipRemoved($event)\">\n *    <igx-avatar class=\"chip-avatar-resized\" igxPrefix [roundShape]=\"true\"></igx-avatar>\n * </igx-chip>\n * ```\n */\n\nlet IgxChipComponent = /*#__PURE__*/(() => {\n  class IgxChipComponent extends DisplayDensityBase {\n    constructor(cdr, ref, renderer, _displayDensityOptions) {\n      super(_displayDensityOptions);\n      this.cdr = cdr;\n      this.ref = ref;\n      this.renderer = renderer;\n      this._displayDensityOptions = _displayDensityOptions;\n      /**\n       * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.\n       *\n       * @example\n       * ```html\n       * <igx-chip [id]=\"'igx-chip-1'\"></igx-chip>\n       * ```\n       */\n\n      this.id = `igx-chip-${CHIP_ID++}`;\n      /**\n       * Returns the `role` attribute of the chip.\n       *\n       * @example\n       * ```typescript\n       * let chipRole = this.chip.role;\n       * ```\n       */\n\n      this.role = 'option';\n      /**\n       * An @Input property that defines if the `IgxChipComponent` can be dragged in order to change it's position.\n       * By default it is set to false.\n       *\n       * @example\n       * ```html\n       * <igx-chip [id]=\"'igx-chip-1'\" [draggable]=\"true\"></igx-chip>\n       * ```\n       */\n\n      this.draggable = false;\n      /**\n       * An @Input property that enables/disables the draggable element animation when the element is released.\n       * By default it's set to true.\n       *\n       * @example\n       * ```html\n       * <igx-chip [id]=\"'igx-chip-1'\" [draggable]=\"true\" [animateOnRelease]=\"false\"></igx-chip>\n       * ```\n       */\n\n      this.animateOnRelease = true;\n      /**\n       * An @Input property that enables/disables the hiding of the base element that has been dragged.\n       * By default it's set to true.\n       *\n       * @example\n       * ```html\n       * <igx-chip [id]=\"'igx-chip-1'\" [draggable]=\"true\" [hideBaseOnDrag]=\"false\"></igx-chip>\n       * ```\n       */\n\n      this.hideBaseOnDrag = true;\n      /**\n       * An @Input property that defines if the `IgxChipComponent` should render remove button and throw remove events.\n       * By default it is set to false.\n       *\n       * @example\n       * ```html\n       * <igx-chip [id]=\"'igx-chip-1'\" [draggable]=\"true\" [removable]=\"true\"></igx-chip>\n       * ```\n       */\n\n      this.removable = false;\n      /**\n       * An @Input property that defines if the `IgxChipComponent` can be selected on click or through navigation,\n       * By default it is set to false.\n       *\n       * @example\n       * ```html\n       * <igx-chip [id]=\"chip.id\" [draggable]=\"true\" [removable]=\"true\" [selectable]=\"true\"></igx-chip>\n       * ```\n       */\n\n      this.selectable = false;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this.class = '';\n      /**\n       * An @Input property that defines if the `IgxChipComponent` is disabled. When disabled it restricts user interactions\n       * like focusing on click or tab, selection on click or Space, dragging.\n       * By default it is set to false.\n       *\n       * @example\n       * ```html\n       * <igx-chip [id]=\"chip.id\" [disabled]=\"true\"></igx-chip>\n       * ```\n       */\n\n      this.disabled = false;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this.selectedChange = new EventEmitter();\n      /**\n       * Emits an event when the `IgxChipComponent` moving starts.\n       * Returns the moving `IgxChipComponent`.\n       *\n       * @example\n       * ```html\n       * <igx-chip #myChip [id]=\"'igx-chip-1'\" [draggable]=\"true\" (moveStart)=\"moveStarted($event)\">\n       * ```\n       */\n\n      this.moveStart = new EventEmitter();\n      /**\n       * Emits an event when the `IgxChipComponent` moving ends.\n       * Returns the moved `IgxChipComponent`.\n       *\n       * @example\n       * ```html\n       * <igx-chip #myChip [id]=\"'igx-chip-1'\" [draggable]=\"true\" (moveEnd)=\"moveEnded($event)\">\n       * ```\n       */\n\n      this.moveEnd = new EventEmitter();\n      /**\n       * Emits an event when the `IgxChipComponent` is removed.\n       * Returns the removed `IgxChipComponent`.\n       *\n       * @example\n       * ```html\n       * <igx-chip #myChip [id]=\"'igx-chip-1'\" [draggable]=\"true\" (remove)=\"remove($event)\">\n       * ```\n       */\n\n      this.remove = new EventEmitter();\n      /**\n       * Emits an event when the `IgxChipComponent` is clicked.\n       * Returns the clicked `IgxChipComponent`, whether the event should be canceled.\n       *\n       * @example\n       * ```html\n       * <igx-chip #myChip [id]=\"'igx-chip-1'\" [draggable]=\"true\" (click)=\"chipClick($event)\">\n       * ```\n       */\n\n      this.chipClick = new EventEmitter();\n      /**\n       * Emits event when the `IgxChipComponent` is selected/deselected.\n       * Returns the selected chip reference, whether the event should be canceled, what is the next selection state and\n       * when the event is triggered by interaction `originalEvent` is provided, otherwise `originalEvent` is `null`.\n       *\n       * @example\n       * ```html\n       * <igx-chip #myChip [id]=\"'igx-chip-1'\" [selectable]=\"true\" (selectedChanging)=\"chipSelect($event)\">\n       * ```\n       */\n\n      this.selectedChanging = new EventEmitter();\n      /**\n       * Emits event when the `IgxChipComponent` is selected/deselected and any related animations and transitions also end.\n       *\n       * @example\n       * ```html\n       * <igx-chip #myChip [id]=\"'igx-chip-1'\" [selectable]=\"true\" (selectedChanged)=\"chipSelectEnd($event)\">\n       * ```\n       */\n\n      this.selectedChanged = new EventEmitter();\n      /**\n       * Emits an event when the `IgxChipComponent` keyboard navigation is being used.\n       * Returns the focused/selected `IgxChipComponent`, whether the event should be canceled,\n       * if the `alt`, `shift` or `control` key is pressed and the pressed key name.\n       *\n       * @example\n       * ```html\n       * <igx-chip #myChip [id]=\"'igx-chip-1'\" [draggable]=\"true\" (keyDown)=\"chipKeyDown($event)\">\n       * ```\n       */\n\n      this.keyDown = new EventEmitter();\n      /**\n       * Emits an event when the `IgxChipComponent` has entered the `IgxChipsAreaComponent`.\n       * Returns the target `IgxChipComponent`, the drag `IgxChipComponent`, as  well as\n       * the original drop event arguments.\n       *\n       * @example\n       * ```html\n       * <igx-chip #myChip [id]=\"'igx-chip-1'\" [draggable]=\"true\" (dragEnter)=\"chipEnter($event)\">\n       * ```\n       */\n\n      this.dragEnter = new EventEmitter();\n      /**\n       * Emits an event when the `IgxChipComponent` has left the `IgxChipsAreaComponent`.\n       * Returns the target `IgxChipComponent`, the drag `IgxChipComponent`, as  well as\n       * the original drop event arguments.\n       *\n       * @example\n       * ```html\n       * <igx-chip #myChip [id]=\"'igx-chip-1'\" [draggable]=\"true\" (dragLeave)=\"chipLeave($event)\">\n       * ```\n       */\n\n      this.dragLeave = new EventEmitter();\n      /**\n       * Emits an event when the `IgxChipComponent` is over the `IgxChipsAreaComponent`.\n       * Returns the target `IgxChipComponent`, the drag `IgxChipComponent`, as  well as\n       * the original drop event arguments.\n       *\n       * @example\n       * ```html\n       * <igx-chip #myChip [id]=\"'igx-chip-1'\" [draggable]=\"true\" (dragOver)=\"chipOver($event)\">\n       * ```\n       */\n\n      this.dragOver = new EventEmitter();\n      /**\n       * Emits an event when the `IgxChipComponent` has been dropped in the `IgxChipsAreaComponent`.\n       * Returns the target `IgxChipComponent`, the drag `IgxChipComponent`, as  well as\n       * the original drop event arguments.\n       *\n       * @example\n       * ```html\n       * <igx-chip #myChip [id]=\"'igx-chip-1'\" [draggable]=\"true\" (dragDrop)=\"chipLeave($event)\">\n       * ```\n       */\n\n      this.dragDrop = new EventEmitter();\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this.hideBaseElement = false;\n      this._tabIndex = null;\n      this._selected = false;\n      this._selectedItemClass = 'igx-chip__item--selected';\n      this._movedWhileRemoving = false;\n      this._resourceStrings = CurrentResourceStrings.ChipResStrings;\n    }\n    /**\n     * An @Input property that sets the value of `tabindex` attribute. If not provided it will use the element's tabindex if set.\n     *\n     * @example\n     * ```html\n     * <igx-chip [id]=\"'igx-chip-1'\" [tabIndex]=\"1\"></igx-chip>\n     * ```\n     */\n\n\n    set tabIndex(value) {\n      this._tabIndex = value;\n    }\n\n    get tabIndex() {\n      if (this._tabIndex !== null) {\n        return this._tabIndex;\n      }\n\n      return !this.disabled ? 0 : null;\n    }\n    /**\n     * Sets the `IgxChipComponent` selected state.\n     *\n     * @example\n     * ```html\n     * <igx-chip #myChip [id]=\"'igx-chip-1'\" [selectable]=\"true\" [selected]=\"true\">\n     * ```\n     *\n     * Two-way data binding:\n     * ```html\n     * <igx-chip #myChip [id]=\"'igx-chip-1'\" [selectable]=\"true\" [(selected)]=\"model.isSelected\">\n     * ```\n     */\n\n\n    set selected(newValue) {\n      this.changeSelection(newValue);\n    }\n    /**\n     * Returns if the `IgxChipComponent` is selected.\n     *\n     * @example\n     * ```typescript\n     * @ViewChild('myChip')\n     * public chip: IgxChipComponent;\n     * selectedChip(){\n     *     let selectedChip = this.chip.selected;\n     * }\n     * ```\n     */\n\n\n    get selected() {\n      return this._selected;\n    }\n    /**\n     * An @Input property that sets the `IgxChipComponent` background color.\n     * The `color` property supports string, rgb, hex.\n     *\n     * @example\n     * ```html\n     * <igx-chip #myChip [id]=\"'igx-chip-1'\" [color]=\"'#ff0000'\"></igx-chip>\n     * ```\n     */\n\n\n    set color(newColor) {\n      this.chipArea.nativeElement.style.backgroundColor = newColor;\n    }\n    /**\n     * Returns the background color of the `IgxChipComponent`.\n     *\n     * @example\n     * ```typescript\n     * @ViewChild('myChip')\n     * public chip: IgxChipComponent;\n     * ngAfterViewInit(){\n     *     let chipColor = this.chip.color;\n     * }\n     * ```\n     */\n\n\n    get color() {\n      return this.chipArea.nativeElement.style.backgroundColor;\n    }\n    /**\n     * An accessor that sets the resource strings.\n     * By default it uses EN resources.\n     */\n\n\n    set resourceStrings(value) {\n      this._resourceStrings = Object.assign({}, this._resourceStrings, value);\n    }\n    /**\n     * An accessor that returns the resource strings.\n     */\n\n\n    get resourceStrings() {\n      return this._resourceStrings;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get hostClass() {\n      const classes = [this.getComponentDensityClass('igx-chip')]; // Add the base class first for each density\n\n      if (!classes.includes('igx-chip')) {\n        classes.unshift('igx-chip');\n      }\n\n      classes.push(this.disabled ? 'igx-chip--disabled' : ''); // The custom classes should be at the end.\n\n      classes.push(this.class);\n      return classes.join(' ').toString().trim();\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get removeButtonTemplate() {\n      return this.removeIcon || this.defaultRemoveIcon;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get selectIconTemplate() {\n      return this.selectIcon || this.defaultSelectIcon;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get ghostClass() {\n      return this.getComponentDensityClass('igx-chip__ghost');\n    }\n    /** @hidden @internal */\n\n\n    get nativeElement() {\n      return this.ref.nativeElement;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    keyEvent(event) {\n      this.onChipKeyDown(event);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    selectClass(condition) {\n      const SELECT_CLASS = 'igx-chip__select';\n      return {\n        [SELECT_CLASS]: condition,\n        [`${SELECT_CLASS}--hidden`]: !condition\n      };\n    }\n\n    onSelectTransitionDone(event) {\n      if (!!event.target.tagName) {\n        // Trigger onSelectionDone on when `width` property is changed and the target is valid element(not comment).\n        this.selectedChanged.emit({\n          owner: this,\n          originalEvent: event\n        });\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onChipKeyDown(event) {\n      const keyDownArgs = {\n        originalEvent: event,\n        owner: this,\n        cancel: false\n      };\n      this.keyDown.emit(keyDownArgs);\n\n      if (keyDownArgs.cancel) {\n        return;\n      }\n\n      if ((event.key === 'Delete' || event.key === 'Del') && this.removable) {\n        this.remove.emit({\n          originalEvent: event,\n          owner: this\n        });\n      }\n\n      if ((event.key === ' ' || event.key === 'Spacebar') && this.selectable && !this.disabled) {\n        this.changeSelection(!this.selected, event);\n      }\n\n      if (event.key !== 'Tab') {\n        event.preventDefault();\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onRemoveBtnKeyDown(event) {\n      if (event.key === ' ' || event.key === 'Spacebar' || event.key === 'Enter') {\n        this.remove.emit({\n          originalEvent: event,\n          owner: this\n        });\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n\n    onRemoveMouseDown(event) {\n      event.stopPropagation();\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onRemoveClick(event) {\n      this.remove.emit({\n        originalEvent: event,\n        owner: this\n      });\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onRemoveTouchMove() {\n      // We don't remove chip if user starting touch interacting on the remove button moves the chip\n      this._movedWhileRemoving = true;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onRemoveTouchEnd(event) {\n      if (!this._movedWhileRemoving) {\n        this.onRemoveClick(event);\n      }\n\n      this._movedWhileRemoving = false;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n    // -----------------------------\n    // Start chip igxDrag behavior\n\n\n    onChipDragStart(event) {\n      this.moveStart.emit({\n        originalEvent: event,\n        owner: this\n      });\n      event.cancel = !this.draggable || this.disabled;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onChipDragEnd() {\n      if (this.animateOnRelease) {\n        this.dragDirective.transitionToOrigin();\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onChipMoveEnd(event) {\n      // moveEnd is triggered after return animation has finished. This happen when we drag and release the chip.\n      this.moveEnd.emit({\n        originalEvent: event,\n        owner: this\n      });\n\n      if (this.selected) {\n        this.chipArea.nativeElement.focus();\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onChipGhostCreate() {\n      this.hideBaseElement = this.hideBaseOnDrag;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onChipGhostDestroy() {\n      this.hideBaseElement = false;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onChipDragClicked(event) {\n      const clickEventArgs = {\n        originalEvent: event,\n        owner: this,\n        cancel: false\n      };\n      this.chipClick.emit(clickEventArgs);\n\n      if (!clickEventArgs.cancel && this.selectable && !this.disabled) {\n        this.changeSelection(!this.selected, event);\n      }\n    } // End chip igxDrag behavior\n\n    /**\n     * @hidden\n     * @internal\n     */\n    // -----------------------------\n    // Start chip igxDrop behavior\n\n\n    onChipDragEnterHandler(event) {\n      var _a;\n\n      if (this.dragDirective === event.drag) {\n        return;\n      }\n\n      const eventArgs = {\n        owner: this,\n        dragChip: (_a = event.drag.data) === null || _a === void 0 ? void 0 : _a.chip,\n        originalEvent: event\n      };\n      this.dragEnter.emit(eventArgs);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onChipDragLeaveHandler(event) {\n      var _a;\n\n      if (this.dragDirective === event.drag) {\n        return;\n      }\n\n      const eventArgs = {\n        owner: this,\n        dragChip: (_a = event.drag.data) === null || _a === void 0 ? void 0 : _a.chip,\n        originalEvent: event\n      };\n      this.dragLeave.emit(eventArgs);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onChipDrop(event) {\n      var _a; // Cancel the default drop logic\n\n\n      event.cancel = true;\n\n      if (this.dragDirective === event.drag) {\n        return;\n      }\n\n      const eventArgs = {\n        owner: this,\n        dragChip: (_a = event.drag.data) === null || _a === void 0 ? void 0 : _a.chip,\n        originalEvent: event\n      };\n      this.dragDrop.emit(eventArgs);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onChipOverHandler(event) {\n      var _a;\n\n      if (this.dragDirective === event.drag) {\n        return;\n      }\n\n      const eventArgs = {\n        owner: this,\n        dragChip: (_a = event.drag.data) === null || _a === void 0 ? void 0 : _a.chip,\n        originalEvent: event\n      };\n      this.dragOver.emit(eventArgs);\n    } // End chip igxDrop behavior\n\n\n    changeSelection(newValue, srcEvent = null) {\n      const onSelectArgs = {\n        originalEvent: srcEvent,\n        owner: this,\n        selected: false,\n        cancel: false\n      };\n      fromEvent(this.selectContainer.nativeElement, 'transitionend').pipe(filter(event => event.propertyName === 'width'), take(1)).subscribe(event => this.onSelectTransitionDone(event));\n\n      if (newValue && !this._selected) {\n        onSelectArgs.selected = true;\n        this.selectedChanging.emit(onSelectArgs);\n\n        if (!onSelectArgs.cancel) {\n          this.renderer.addClass(this.chipArea.nativeElement, this._selectedItemClass);\n          this._selected = newValue;\n          this.selectedChange.emit(this._selected);\n        }\n      } else if (!newValue && this._selected) {\n        this.selectedChanging.emit(onSelectArgs);\n\n        if (!onSelectArgs.cancel) {\n          this.renderer.removeClass(this.chipArea.nativeElement, this._selectedItemClass);\n          this._selected = newValue;\n          this.selectedChange.emit(this._selected);\n        }\n      }\n    }\n\n  }\n\n  IgxChipComponent.ɵfac = function IgxChipComponent_Factory(t) {\n    return new (t || IgxChipComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DisplayDensityToken, 8));\n  };\n\n  IgxChipComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxChipComponent,\n    selectors: [[\"igx-chip\"]],\n    viewQuery: function IgxChipComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c55, 7, IgxDragDirective);\n        i0.ɵɵviewQuery(_c55, 7, ElementRef);\n        i0.ɵɵviewQuery(_c56, 7, ElementRef);\n        i0.ɵɵviewQuery(_c57, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c58, 7, TemplateRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dragDirective = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chipArea = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.selectContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultRemoveIcon = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultSelectIcon = _t.first);\n      }\n    },\n    hostVars: 5,\n    hostBindings: function IgxChipComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function IgxChipComponent_keydown_HostBindingHandler($event) {\n          return ctx.keyEvent($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id)(\"role\", ctx.role)(\"tabIndex\", ctx.tabIndex)(\"aria-selected\", ctx.selected)(\"class\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      tabIndex: \"tabIndex\",\n      data: \"data\",\n      draggable: \"draggable\",\n      animateOnRelease: \"animateOnRelease\",\n      hideBaseOnDrag: \"hideBaseOnDrag\",\n      removable: \"removable\",\n      removeIcon: \"removeIcon\",\n      selectable: \"selectable\",\n      selectIcon: \"selectIcon\",\n      class: \"class\",\n      disabled: \"disabled\",\n      selected: \"selected\",\n      color: \"color\",\n      resourceStrings: \"resourceStrings\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\",\n      moveStart: \"moveStart\",\n      moveEnd: \"moveEnd\",\n      remove: \"remove\",\n      chipClick: \"chipClick\",\n      selectedChanging: \"selectedChanging\",\n      selectedChanged: \"selectedChanged\",\n      keyDown: \"keyDown\",\n      dragEnter: \"dragEnter\",\n      dragLeave: \"dragLeave\",\n      dragOver: \"dragOver\",\n      dragDrop: \"dragDrop\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c61,\n    decls: 14,\n    vars: 9,\n    consts: [[\"igxDrop\", \"\", 1, \"igx-chip__item\", 3, \"igxDrag\", \"ghostClass\", \"dragStart\", \"ghostCreate\", \"ghostDestroy\", \"dragEnd\", \"transitioned\", \"dragClick\", \"enter\", \"leave\", \"over\", \"dropped\"], [\"chipArea\", \"\"], [3, \"ngClass\"], [\"selectContainer\", \"\"], [4, \"ngTemplateOutlet\"], [1, \"igx-chip__content\"], [\"class\", \"igx-chip__remove\", 3, \"keydown\", \"pointerdown\", \"mousedown\", \"click\", \"touchmove\", \"touchend\", 4, \"ngIf\"], [\"defaultSelectIcon\", \"\"], [\"defaultRemoveIcon\", \"\"], [1, \"igx-chip__remove\", 3, \"keydown\", \"pointerdown\", \"mousedown\", \"click\", \"touchmove\", \"touchend\"]],\n    template: function IgxChipComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c59);\n        i0.ɵɵelementStart(0, \"div\", 0, 1);\n        i0.ɵɵlistener(\"dragStart\", function IgxChipComponent_Template_div_dragStart_0_listener($event) {\n          return ctx.onChipDragStart($event);\n        })(\"ghostCreate\", function IgxChipComponent_Template_div_ghostCreate_0_listener() {\n          return ctx.onChipGhostCreate();\n        })(\"ghostDestroy\", function IgxChipComponent_Template_div_ghostDestroy_0_listener() {\n          return ctx.onChipGhostDestroy();\n        })(\"dragEnd\", function IgxChipComponent_Template_div_dragEnd_0_listener() {\n          return ctx.onChipDragEnd();\n        })(\"transitioned\", function IgxChipComponent_Template_div_transitioned_0_listener($event) {\n          return ctx.onChipMoveEnd($event);\n        })(\"dragClick\", function IgxChipComponent_Template_div_dragClick_0_listener($event) {\n          return ctx.onChipDragClicked($event);\n        })(\"enter\", function IgxChipComponent_Template_div_enter_0_listener($event) {\n          return ctx.onChipDragEnterHandler($event);\n        })(\"leave\", function IgxChipComponent_Template_div_leave_0_listener($event) {\n          return ctx.onChipDragLeaveHandler($event);\n        })(\"over\", function IgxChipComponent_Template_div_over_0_listener($event) {\n          return ctx.onChipOverHandler($event);\n        })(\"dropped\", function IgxChipComponent_Template_div_dropped_0_listener($event) {\n          return ctx.onChipDrop($event);\n        });\n        i0.ɵɵelementStart(2, \"div\", 2, 3);\n        i0.ɵɵtemplate(4, IgxChipComponent_ng_container_4_Template, 1, 0, \"ng-container\", 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵprojection(5);\n        i0.ɵɵelementStart(6, \"div\", 5);\n        i0.ɵɵprojection(7, 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵprojection(8, 2);\n        i0.ɵɵtemplate(9, IgxChipComponent_div_9_Template, 2, 2, \"div\", 6);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(10, IgxChipComponent_ng_template_10_Template, 2, 1, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(12, IgxChipComponent_ng_template_12_Template, 2, 1, \"ng-template\", null, 8, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"visibility\", ctx.hideBaseElement ? \"hidden\" : \"visible\");\n        i0.ɵɵproperty(\"igxDrag\", i0.ɵɵpureFunction1(7, _c60, ctx))(\"ghostClass\", ctx.ghostClass);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngClass\", ctx.selectClass(ctx.selected));\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.selectIconTemplate);\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"ngIf\", ctx.removable);\n      }\n    },\n    directives: [IgxIconComponent, IgxDropDirective, IgxDragDirective, i4.NgClass, i4.NgTemplateOutlet, i4.NgIf],\n    encapsulation: 2\n  });\n  return IgxChipComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The chip area allows you to perform more complex scenarios with chips that require interaction,\n * like dragging, selection, navigation, etc.\n *\n * @igxModule IgxChipsModule\n *\n * @igxTheme igx-chip-theme\n *\n * @igxKeywords chip area, chip\n *\n * @igxGroup display\n *\n * @example\n * ```html\n * <igx-chips-area>\n *    <igx-chip *ngFor=\"let chip of chipList\" [id]=\"chip.id\">\n *        <span>{{chip.text}}</span>\n *    </igx-chip>\n * </igx-chips-area>\n * ```\n */\n\n\nlet IgxChipsAreaComponent = /*#__PURE__*/(() => {\n  class IgxChipsAreaComponent {\n    constructor(cdr, element, _iterableDiffers) {\n      this.cdr = cdr;\n      this.element = element;\n      this._iterableDiffers = _iterableDiffers;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this.class = '';\n      /**\n       * Returns the `role` attribute of the chips area.\n       *\n       * @example\n       * ```typescript\n       * let chipsAreaRole = this.chipsArea.role;\n       * ```\n       */\n\n      this.role = 'listbox';\n      /**\n       * Returns the `aria-label` attribute of the chips area.\n       *\n       * @example\n       * ```typescript\n       * let ariaLabel = this.chipsArea.ariaLabel;\n       * ```\n       *\n       */\n\n      this.ariaLabel = 'chip area';\n      /**\n       * Emits an event when `IgxChipComponent`s in the `IgxChipsAreaComponent` should be reordered.\n       * Returns an array of `IgxChipComponent`s.\n       *\n       * @example\n       * ```html\n       * <igx-chips-area #chipsArea [width]=\"'300'\" [height]=\"'10'\" (onReorder)=\"changedOrder($event)\"></igx-chips-area>\n       * ```\n       */\n\n      this.reorder = new EventEmitter();\n      /**\n       * Emits an event when an `IgxChipComponent` in the `IgxChipsAreaComponent` is selected/deselected.\n       * Fired after the chips area is initialized if there are initially selected chips as well.\n       * Returns an array of selected `IgxChipComponent`s and the `IgxChipAreaComponent`.\n       *\n       * @example\n       * ```html\n       * <igx-chips-area #chipsArea [width]=\"'300'\" [height]=\"'10'\" (selectionChange)=\"selection($event)\"></igx-chips-area>\n       * ```\n       */\n\n      this.selectionChange = new EventEmitter();\n      /**\n       * Emits an event when an `IgxChipComponent` in the `IgxChipsAreaComponent` is moved.\n       *\n       * @example\n       * ```html\n       * <igx-chips-area #chipsArea [width]=\"'300'\" [height]=\"'10'\" (moveStart)=\"moveStart($event)\"></igx-chips-area>\n       * ```\n       */\n\n      this.moveStart = new EventEmitter();\n      /**\n       * Emits an event after an `IgxChipComponent` in the `IgxChipsAreaComponent` is moved.\n       *\n       * @example\n       * ```html\n       * <igx-chips-area #chipsArea [width]=\"'300'\" [height]=\"'10'\" (moveEnd)=\"moveEnd($event)\"></igx-chips-area>\n       * ```\n       */\n\n      this.moveEnd = new EventEmitter();\n      this.destroy$ = new Subject();\n      this._differ = null;\n      this._differ = this._iterableDiffers.find([]).create(null);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get hostClass() {\n      const classes = ['igx-chip-area'];\n      classes.push(this.class);\n      return classes.join(' ');\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    ngAfterViewInit() {\n      // If we have initially selected chips through their inputs, we need to get them, because we cannot listen to their events yet.\n      if (this.chipsList.length) {\n        const selectedChips = this.chipsList.filter(item => item.selected);\n\n        if (selectedChips.length) {\n          this.selectionChange.emit({\n            originalEvent: null,\n            newSelection: selectedChips,\n            owner: this\n          });\n        }\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    ngDoCheck() {\n      if (this.chipsList) {\n        const changes = this._differ.diff(this.chipsList.toArray());\n\n        if (changes) {\n          changes.forEachAddedItem(addedChip => {\n            addedChip.item.moveStart.pipe(takeUntil(this.destroy$)).subscribe(args => {\n              this.onChipMoveStart(args);\n            });\n            addedChip.item.moveEnd.pipe(takeUntil(this.destroy$)).subscribe(args => {\n              this.onChipMoveEnd(args);\n            });\n            addedChip.item.dragEnter.pipe(takeUntil(this.destroy$)).subscribe(args => {\n              this.onChipDragEnter(args);\n            });\n            addedChip.item.keyDown.pipe(takeUntil(this.destroy$)).subscribe(args => {\n              this.onChipKeyDown(args);\n            });\n\n            if (addedChip.item.selectable) {\n              addedChip.item.selectedChanging.pipe(takeUntil(this.destroy$)).subscribe(args => {\n                this.onChipSelectionChange(args);\n              });\n            }\n          });\n          this.modifiedChipsArray = this.chipsList.toArray();\n        }\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    ngOnDestroy() {\n      this.destroy$.next(true);\n      this.destroy$.complete();\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onChipKeyDown(event) {\n      let orderChanged = false;\n      const chipsArray = this.chipsList.toArray();\n      const dragChipIndex = chipsArray.findIndex(el => el === event.owner);\n\n      if (event.originalEvent.shiftKey === true) {\n        if (event.originalEvent.key === 'ArrowLeft' || event.originalEvent.key === 'Left') {\n          orderChanged = this.positionChipAtIndex(dragChipIndex, dragChipIndex - 1, false, event.originalEvent);\n\n          if (orderChanged) {\n            setTimeout(() => {\n              this.chipsList.get(dragChipIndex - 1).nativeElement.focus();\n            });\n          }\n        } else if (event.originalEvent.key === 'ArrowRight' || event.originalEvent.key === 'Right') {\n          orderChanged = this.positionChipAtIndex(dragChipIndex, dragChipIndex + 1, true, event.originalEvent);\n        }\n      } else {\n        if ((event.originalEvent.key === 'ArrowLeft' || event.originalEvent.key === 'Left') && dragChipIndex > 0) {\n          chipsArray[dragChipIndex - 1].nativeElement.focus();\n        } else if ((event.originalEvent.key === 'ArrowRight' || event.originalEvent.key === 'Right') && dragChipIndex < chipsArray.length - 1) {\n          chipsArray[dragChipIndex + 1].nativeElement.focus();\n        }\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onChipMoveStart(event) {\n      this.moveStart.emit({\n        originalEvent: event.originalEvent,\n        owner: this\n      });\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onChipMoveEnd(event) {\n      this.moveEnd.emit({\n        originalEvent: event.originalEvent,\n        owner: this\n      });\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onChipDragEnter(event) {\n      const dropChipIndex = this.chipsList.toArray().findIndex(el => el === event.owner);\n      const dragChipIndex = this.chipsList.toArray().findIndex(el => el === event.dragChip);\n\n      if (dragChipIndex < dropChipIndex) {\n        // from the left to right\n        this.positionChipAtIndex(dragChipIndex, dropChipIndex, true, event.originalEvent);\n      } else {\n        // from the right to left\n        this.positionChipAtIndex(dragChipIndex, dropChipIndex, false, event.originalEvent);\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    positionChipAtIndex(chipIndex, targetIndex, shiftRestLeft, originalEvent) {\n      if (chipIndex < 0 || this.chipsList.length <= chipIndex || targetIndex < 0 || this.chipsList.length <= targetIndex) {\n        return false;\n      }\n\n      const chipsArray = this.chipsList.toArray();\n      const result = [];\n\n      for (let i = 0; i < chipsArray.length; i++) {\n        if (shiftRestLeft) {\n          if (chipIndex <= i && i < targetIndex) {\n            result.push(chipsArray[i + 1]);\n          } else if (i === targetIndex) {\n            result.push(chipsArray[chipIndex]);\n          } else {\n            result.push(chipsArray[i]);\n          }\n        } else {\n          if (targetIndex < i && i <= chipIndex) {\n            result.push(chipsArray[i - 1]);\n          } else if (i === targetIndex) {\n            result.push(chipsArray[chipIndex]);\n          } else {\n            result.push(chipsArray[i]);\n          }\n        }\n      }\n\n      this.modifiedChipsArray = result;\n      const eventData = {\n        chipsArray: this.modifiedChipsArray,\n        originalEvent,\n        owner: this\n      };\n      this.reorder.emit(eventData);\n      return true;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onChipSelectionChange(event) {\n      let selectedChips = this.chipsList.filter(chip => chip.selected);\n\n      if (event.selected && !selectedChips.includes(event.owner)) {\n        selectedChips.push(event.owner);\n      } else if (!event.selected && selectedChips.includes(event.owner)) {\n        selectedChips = selectedChips.filter(chip => chip.id !== event.owner.id);\n      }\n\n      this.selectionChange.emit({\n        originalEvent: event.originalEvent,\n        newSelection: selectedChips,\n        owner: this\n      });\n    }\n\n  }\n\n  IgxChipsAreaComponent.ɵfac = function IgxChipsAreaComponent_Factory(t) {\n    return new (t || IgxChipsAreaComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.IterableDiffers));\n  };\n\n  IgxChipsAreaComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxChipsAreaComponent,\n    selectors: [[\"igx-chips-area\"]],\n    contentQueries: function IgxChipsAreaComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxChipComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chipsList = _t);\n      }\n    },\n    hostVars: 7,\n    hostBindings: function IgxChipsAreaComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"class\", ctx.hostClass)(\"role\", ctx.role)(\"aria-label\", ctx.ariaLabel);\n        i0.ɵɵstyleProp(\"width\", ctx.width, \"px\")(\"height\", ctx.height, \"px\");\n      }\n    },\n    inputs: {\n      class: \"class\",\n      width: \"width\",\n      height: \"height\"\n    },\n    outputs: {\n      reorder: \"reorder\",\n      selectionChange: \"selectionChange\",\n      moveStart: \"moveStart\",\n      moveEnd: \"moveEnd\"\n    },\n    ngContentSelectors: _c8,\n    decls: 1,\n    vars: 0,\n    template: function IgxChipsAreaComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxChipsAreaComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxChipsModule = /*#__PURE__*/(() => {\n  class IgxChipsModule {}\n\n  IgxChipsModule.ɵfac = function IgxChipsModule_Factory(t) {\n    return new (t || IgxChipsModule)();\n  };\n\n  IgxChipsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxChipsModule\n  });\n  IgxChipsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, IgxRippleModule, IgxIconModule, IgxButtonModule, IgxAvatarModule, IgxDragDropModule, IgxPrefixModule, IgxSuffixModule]]\n  });\n  return IgxChipsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxComboHeaderDirective = /*#__PURE__*/(() => {\n  class IgxComboHeaderDirective {}\n\n  IgxComboHeaderDirective.ɵfac = function IgxComboHeaderDirective_Factory(t) {\n    return new (t || IgxComboHeaderDirective)();\n  };\n\n  IgxComboHeaderDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxComboHeaderDirective,\n    selectors: [[\"\", \"igxComboHeader\", \"\"]]\n  });\n  return IgxComboHeaderDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxComboFooterDirective = /*#__PURE__*/(() => {\n  class IgxComboFooterDirective {}\n\n  IgxComboFooterDirective.ɵfac = function IgxComboFooterDirective_Factory(t) {\n    return new (t || IgxComboFooterDirective)();\n  };\n\n  IgxComboFooterDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxComboFooterDirective,\n    selectors: [[\"\", \"igxComboFooter\", \"\"]]\n  });\n  return IgxComboFooterDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxComboItemDirective = /*#__PURE__*/(() => {\n  class IgxComboItemDirective {}\n\n  IgxComboItemDirective.ɵfac = function IgxComboItemDirective_Factory(t) {\n    return new (t || IgxComboItemDirective)();\n  };\n\n  IgxComboItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxComboItemDirective,\n    selectors: [[\"\", \"igxComboItem\", \"\"]]\n  });\n  return IgxComboItemDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxComboEmptyDirective = /*#__PURE__*/(() => {\n  class IgxComboEmptyDirective {}\n\n  IgxComboEmptyDirective.ɵfac = function IgxComboEmptyDirective_Factory(t) {\n    return new (t || IgxComboEmptyDirective)();\n  };\n\n  IgxComboEmptyDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxComboEmptyDirective,\n    selectors: [[\"\", \"igxComboEmpty\", \"\"]]\n  });\n  return IgxComboEmptyDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxComboHeaderItemDirective = /*#__PURE__*/(() => {\n  class IgxComboHeaderItemDirective {}\n\n  IgxComboHeaderItemDirective.ɵfac = function IgxComboHeaderItemDirective_Factory(t) {\n    return new (t || IgxComboHeaderItemDirective)();\n  };\n\n  IgxComboHeaderItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxComboHeaderItemDirective,\n    selectors: [[\"\", \"igxComboHeaderItem\", \"\"]]\n  });\n  return IgxComboHeaderItemDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxComboAddItemDirective = /*#__PURE__*/(() => {\n  class IgxComboAddItemDirective {}\n\n  IgxComboAddItemDirective.ɵfac = function IgxComboAddItemDirective_Factory(t) {\n    return new (t || IgxComboAddItemDirective)();\n  };\n\n  IgxComboAddItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxComboAddItemDirective,\n    selectors: [[\"\", \"igxComboAddItem\", \"\"]]\n  });\n  return IgxComboAddItemDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxComboToggleIconDirective = /*#__PURE__*/(() => {\n  class IgxComboToggleIconDirective {}\n\n  IgxComboToggleIconDirective.ɵfac = function IgxComboToggleIconDirective_Factory(t) {\n    return new (t || IgxComboToggleIconDirective)();\n  };\n\n  IgxComboToggleIconDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxComboToggleIconDirective,\n    selectors: [[\"\", \"igxComboToggleIcon\", \"\"]]\n  });\n  return IgxComboToggleIconDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxComboClearIconDirective = /*#__PURE__*/(() => {\n  class IgxComboClearIconDirective {}\n\n  IgxComboClearIconDirective.ɵfac = function IgxComboClearIconDirective_Factory(t) {\n    return new (t || IgxComboClearIconDirective)();\n  };\n\n  IgxComboClearIconDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxComboClearIconDirective,\n    selectors: [[\"\", \"igxComboClearIcon\", \"\"]]\n  });\n  return IgxComboClearIconDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxComboAPIService = /*#__PURE__*/(() => {\n  class IgxComboAPIService {\n    constructor() {\n      this.disableTransitions = false;\n    }\n\n    get valueKey() {\n      return this.combo.valueKey !== null && this.combo.valueKey !== undefined ? this.combo.valueKey : null;\n    }\n\n    get item_focusable() {\n      return false;\n    }\n\n    get isRemote() {\n      return this.combo.isRemote;\n    }\n\n    get comboID() {\n      return this.combo.id;\n    }\n\n    register(combo) {\n      this.combo = combo;\n    }\n\n    clear() {\n      this.combo = null;\n    }\n\n    add_custom_item() {\n      if (!this.combo) {\n        return;\n      }\n\n      this.combo.addItemToCollection();\n    }\n\n    set_selected_item(itemID, event) {\n      const selected = this.combo.isItemSelected(itemID);\n\n      if (!itemID && itemID !== 0) {\n        return;\n      }\n\n      if (!selected) {\n        this.combo.select([itemID], false, event);\n      } else {\n        this.combo.deselect([itemID], event);\n      }\n    }\n\n    is_item_selected(itemID) {\n      return this.combo.isItemSelected(itemID);\n    }\n\n  }\n\n  IgxComboAPIService.ɵfac = function IgxComboAPIService_Factory(t) {\n    return new (t || IgxComboAPIService)();\n  };\n\n  IgxComboAPIService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxComboAPIService,\n    factory: IgxComboAPIService.ɵfac\n  });\n  return IgxComboAPIService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxComboItemComponent = /*#__PURE__*/(() => {\n  class IgxComboItemComponent extends IgxDropDownItemComponent {\n    constructor(comboAPI, dropDown, elementRef, selection) {\n      super(dropDown, elementRef, null, selection);\n      this.comboAPI = comboAPI;\n      this.dropDown = dropDown;\n      this.elementRef = elementRef;\n      this.selection = selection;\n      /**\n       * Gets the height of a list item\n       *\n       * @hidden\n       */\n\n      this.itemHeight = '';\n    }\n    /**\n     * @hidden\n     */\n\n\n    get itemID() {\n      const valueKey = this.comboAPI.valueKey;\n      return valueKey !== null ? this.value[valueKey] : this.value;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get comboID() {\n      return this.comboAPI.comboID;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get disableTransitions() {\n      return this.comboAPI.disableTransitions;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get selected() {\n      return this.comboAPI.is_item_selected(this.itemID);\n    }\n\n    set selected(value) {\n      if (this.isHeader) {\n        return;\n      }\n\n      this._selected = value;\n    }\n    /**\n     * @hidden\n     */\n\n\n    isVisible(direction) {\n      const rect = this.element.nativeElement.getBoundingClientRect();\n      const parentDiv = this.element.nativeElement.parentElement.parentElement.getBoundingClientRect();\n\n      if (direction === Navigate.Down) {\n        return rect.y + rect.height <= parentDiv.y + parentDiv.height;\n      }\n\n      return rect.y >= parentDiv.y;\n    }\n    /**\n     * @inheritdoc\n     */\n\n\n    clicked(event) {\n      this.comboAPI.disableTransitions = false;\n\n      if (!this.isSelectable) {\n        return;\n      }\n\n      this.dropDown.navigateItem(this.index);\n      this.comboAPI.set_selected_item(this.itemID, event);\n    }\n    /**\n     * @hidden\n     * @internal\n     * The event that is prevented is the click on the checkbox label element.\n     * That is the only visible element that a user can interact with.\n     * The click propagates to the host and the preventDefault is to stop it from\n     * switching focus to the input it's base on.\n     * The toggle happens in an internal handler in the drop-down on the next task queue cycle.\n     */\n\n\n    disableCheck(event) {\n      event.preventDefault();\n    }\n\n  }\n\n  IgxComboItemComponent.ɵfac = function IgxComboItemComponent_Factory(t) {\n    return new (t || IgxComboItemComponent)(i0.ɵɵdirectiveInject(IgxComboAPIService), i0.ɵɵdirectiveInject(IGX_DROPDOWN_BASE), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(IgxSelectionAPIService));\n  };\n\n  IgxComboItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxComboItemComponent,\n    selectors: [[\"igx-combo-item\"]],\n    hostVars: 2,\n    hostBindings: function IgxComboItemComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"height\", ctx.itemHeight, \"px\");\n      }\n    },\n    inputs: {\n      itemHeight: \"itemHeight\",\n      singleMode: \"singleMode\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c8,\n    decls: 3,\n    vars: 1,\n    consts: [[4, \"ngIf\"], [1, \"igx-drop-down__inner\"], [1, \"igx-combo__checkbox\", 3, \"checked\", \"readonly\", \"disableRipple\", \"disableTransitions\", \"tabindex\", \"click\"]],\n    template: function IgxComboItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, IgxComboItemComponent_ng_container_0_Template, 2, 5, \"ng-container\", 0);\n        i0.ɵɵelementStart(1, \"span\", 1);\n        i0.ɵɵprojection(2);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.isHeader && !ctx.singleMode);\n      }\n    },\n    directives: [IgxCheckboxComponent, i4.NgIf],\n    encapsulation: 2\n  });\n  return IgxComboItemComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst IGX_COMBO_COMPONENT = new InjectionToken('IgxComboComponentToken');\nlet NEXT_ID$e = 0;\n/**\n * @hidden\n * The default number of items that should be in the combo's\n * drop-down list if no `[itemsMaxHeight]` is specified\n */\n\nconst itemsInContainer = 10; // TODO: make private readonly\n\n/** @hidden @internal */\n\nconst ItemHeights = {\n  comfortable: 40,\n  cosy: 32,\n  compact: 28\n};\n/** @hidden @internal */\n\nvar DataTypes = /*#__PURE__*/(() => {\n  (function (DataTypes) {\n    DataTypes[\"EMPTY\"] = \"empty\";\n    DataTypes[\"PRIMITIVE\"] = \"primitive\";\n    DataTypes[\"COMPLEX\"] = \"complex\";\n    DataTypes[\"PRIMARYKEY\"] = \"valueKey\";\n  })(DataTypes || (DataTypes = {}));\n\n  return DataTypes;\n})();\nvar IgxComboState = /*#__PURE__*/(() => {\n  (function (IgxComboState) {\n    /**\n     * Combo with initial state.\n     */\n    IgxComboState[IgxComboState[\"INITIAL\"] = 0] = \"INITIAL\";\n    /**\n     * Combo with valid state.\n     */\n\n    IgxComboState[IgxComboState[\"VALID\"] = 1] = \"VALID\";\n    /**\n     * Combo with invalid state.\n     */\n\n    IgxComboState[IgxComboState[\"INVALID\"] = 2] = \"INVALID\";\n  })(IgxComboState || (IgxComboState = {}));\n\n  return IgxComboState;\n})();\nlet IgxComboBaseDirective = /*#__PURE__*/(() => {\n  class IgxComboBaseDirective extends DisplayDensityBase {\n    constructor(elementRef, cdr, selectionService, comboAPI, _iconService, _displayDensityOptions, _inputGroupType, _injector) {\n      super(_displayDensityOptions);\n      this.elementRef = elementRef;\n      this.cdr = cdr;\n      this.selectionService = selectionService;\n      this.comboAPI = comboAPI;\n      this._iconService = _iconService;\n      this._displayDensityOptions = _displayDensityOptions;\n      this._inputGroupType = _inputGroupType;\n      this._injector = _injector;\n      /**\n       * Defines whether the caseSensitive icon should be shown in the search input\n       *\n       * ```typescript\n       * // get\n       * let myComboShowSearchCaseIcon = this.combo.showSearchCaseIcon;\n       * ```\n       *\n       * ```html\n       * <!--set-->\n       * <igx-combo [showSearchCaseIcon]='true'></igx-combo>\n       * ```\n       */\n\n      this.showSearchCaseIcon = false;\n      /**\n       * Set custom overlay settings that control how the combo's list of items is displayed.\n       * Set:\n       * ```html\n       * <igx-combo [overlaySettings] = \"customOverlaySettings\"></igx-combo>\n       * ```\n       *\n       * ```typescript\n       *  const customSettings = { positionStrategy: { settings: { target: myTarget } } };\n       *  combo.overlaySettings = customSettings;\n       * ```\n       * Get any custom overlay settings used by the combo:\n       * ```typescript\n       *  const comboOverlaySettings: OverlaySettings = myCombo.overlaySettings;\n       * ```\n       */\n\n      this.overlaySettings = null;\n      /**\n       * Gets/gets combo id.\n       *\n       * ```typescript\n       * // get\n       * let id = this.combo.id;\n       * ```\n       *\n       * ```html\n       * <!--set-->\n       * <igx-combo [id]='combo1'></igx-combo>\n       * ```\n       */\n\n      this.id = `igx-combo-${NEXT_ID$e++}`;\n      /**\n       * Controls whether custom values can be added to the collection\n       *\n       * ```typescript\n       * // get\n       * let comboAllowsCustomValues = this.combo.allowCustomValues;\n       * ```\n       *\n       * ```html\n       * <!--set-->\n       * <igx-combo [allowCustomValues]='true'></igx-combo>\n       * ```\n       */\n\n      this.allowCustomValues = false;\n      /**\n       * Determines which column in the data source is used to determine the value.\n       *\n       * ```typescript\n       * // get\n       * let myComboValueKey = this.combo.valueKey;\n       * ```\n       *\n       * ```html\n       * <!--set-->\n       * <igx-combo [valueKey]='myKey'></igx-combo>\n       * ```\n       */\n\n      this.valueKey = null;\n      /** @hidden @internal */\n\n      this.cssClass = 'igx-combo'; // Independent of display density for the time being\n\n      /** @hidden @internal */\n\n      this.role = 'combobox';\n      /**\n       * An @Input property that enabled/disables combo. The default is `false`.\n       * ```html\n       * <igx-combo [disabled]=\"'true'\">\n       * ```\n       */\n\n      this.disabled = false;\n      /**\n       * Emitted before the dropdown is opened\n       *\n       * ```html\n       * <igx-combo opening='handleOpening($event)'></igx-combo>\n       * ```\n       */\n\n      this.opening = new EventEmitter();\n      /**\n       * Emitted after the dropdown is opened\n       *\n       * ```html\n       * <igx-combo (opened)='handleOpened($event)'></igx-combo>\n       * ```\n       */\n\n      this.opened = new EventEmitter();\n      /**\n       * Emitted before the dropdown is closed\n       *\n       * ```html\n       * <igx-combo (closing)='handleClosing($event)'></igx-combo>\n       * ```\n       */\n\n      this.closing = new EventEmitter();\n      /**\n       * Emitted after the dropdown is closed\n       *\n       * ```html\n       * <igx-combo (closed)='handleClosed($event)'></igx-combo>\n       * ```\n       */\n\n      this.closed = new EventEmitter();\n      /**\n       * Emitted when an item is being added to the data collection\n       *\n       * ```html\n       * <igx-combo (addition)='handleAdditionEvent($event)'></igx-combo>\n       * ```\n       */\n\n      this.addition = new EventEmitter();\n      /**\n       * Emitted when the value of the search input changes (e.g. typing, pasting, clear, etc.)\n       *\n       * ```html\n       * <igx-combo (searchInputUpdate)='handleSearchInputEvent($event)'></igx-combo>\n       * ```\n       */\n\n      this.searchInputUpdate = new EventEmitter();\n      /**\n       * Emitted when new chunk of data is loaded from the virtualization\n       *\n       * ```html\n       * <igx-combo (dataPreLoad)='handleDataPreloadEvent($event)'></igx-combo>\n       * ```\n       */\n\n      this.dataPreLoad = new EventEmitter();\n      /**\n       * The custom template, if any, that should be used when rendering ITEMS in the combo list\n       *\n       * ```typescript\n       * // Set in typescript\n       * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;\n       * myComponent.combo.itemTemplate = myCustomTemplate;\n       * ```\n       * ```html\n       * <!-- Set in markup -->\n       *  <igx-combo #combo>\n       *      ...\n       *      <ng-template igxComboItem>\n       *          <div class=\"custom-item\" let-item let-key=\"valueKey\">\n       *              <div class=\"custom-item__name\">{{ item[key] }}</div>\n       *              <div class=\"custom-item__cost\">{{ item.cost }}</div>\n       *          </div>\n       *      </ng-template>\n       *  </igx-combo>\n       * ```\n       */\n\n      this.itemTemplate = null;\n      /**\n       * The custom template, if any, that should be used when rendering the HEADER for the combo items list\n       *\n       * ```typescript\n       * // Set in typescript\n       * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;\n       * myComponent.combo.headerTemplate = myCustomTemplate;\n       * ```\n       * ```html\n       * <!-- Set in markup -->\n       *  <igx-combo #combo>\n       *      ...\n       *      <ng-template igxComboHeader>\n       *          <div class=\"combo__header\">\n       *              This is a custom header\n       *          </div>\n       *      </ng-template>\n       *  </igx-combo>\n       * ```\n       */\n\n      this.headerTemplate = null;\n      /**\n       * The custom template, if any, that should be used when rendering the FOOTER for the combo items list\n       *\n       * ```typescript\n       * // Set in typescript\n       * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;\n       * myComponent.combo.footerTemplate = myCustomTemplate;\n       * ```\n       * ```html\n       * <!-- Set in markup -->\n       *  <igx-combo #combo>\n       *      ...\n       *      <ng-template igxComboFooter>\n       *          <div class=\"combo__footer\">\n       *              This is a custom footer\n       *          </div>\n       *      </ng-template>\n       *  </igx-combo>\n       * ```\n       */\n\n      this.footerTemplate = null;\n      /**\n       * The custom template, if any, that should be used when rendering HEADER ITEMS for groups in the combo list\n       *\n       * ```typescript\n       * // Set in typescript\n       * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;\n       * myComponent.combo.headerItemTemplate = myCustomTemplate;\n       * ```\n       * ```html\n       * <!-- Set in markup -->\n       *  <igx-combo #combo>\n       *      ...\n       *      <ng-template igxComboHeaderItem let-item let-key=\"groupKey\">\n       *          <div class=\"custom-item--group\">Group header for {{ item[key] }}</div>\n       *      </ng-template>\n       *  </igx-combo>\n       * ```\n       */\n\n      this.headerItemTemplate = null;\n      /**\n       * The custom template, if any, that should be used when rendering the ADD BUTTON in the combo drop down\n       *\n       * ```typescript\n       * // Set in typescript\n       * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;\n       * myComponent.combo.addItemTemplate = myCustomTemplate;\n       * ```\n       * ```html\n       * <!-- Set in markup -->\n       *  <igx-combo #combo>\n       *      ...\n       *      <ng-template igxComboAddItem>\n       *          <button class=\"combo__add-button\">\n       *              Click to add item\n       *          </button>\n       *      </ng-template>\n       *  </igx-combo>\n       * ```\n       */\n\n      this.addItemTemplate = null;\n      /**\n       * The custom template, if any, that should be used when rendering the ADD BUTTON in the combo drop down\n       *\n       * ```typescript\n       * // Set in typescript\n       * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;\n       * myComponent.combo.emptyTemplate = myCustomTemplate;\n       * ```\n       * ```html\n       * <!-- Set in markup -->\n       *  <igx-combo #combo>\n       *      ...\n       *      <ng-template igxComboEmpty>\n       *          <div class=\"combo--empty\">\n       *              There are no items to display\n       *          </div>\n       *      </ng-template>\n       *  </igx-combo>\n       * ```\n       */\n\n      this.emptyTemplate = null;\n      /**\n       * The custom template, if any, that should be used when rendering the combo TOGGLE(open/close) button\n       *\n       * ```typescript\n       * // Set in typescript\n       * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;\n       * myComponent.combo.toggleIconTemplate = myCustomTemplate;\n       * ```\n       * ```html\n       * <!-- Set in markup -->\n       *  <igx-combo #combo>\n       *      ...\n       *      <ng-template igxComboToggleIcon let-collapsed>\n       *          <igx-icon>{{ collapsed ? 'remove_circle' : 'remove_circle_outline'}}</igx-icon>\n       *      </ng-template>\n       *  </igx-combo>\n       * ```\n       */\n\n      this.toggleIconTemplate = null;\n      /**\n       * The custom template, if any, that should be used when rendering the combo CLEAR button\n       *\n       * ```typescript\n       * // Set in typescript\n       * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;\n       * myComponent.combo.clearIconTemplate = myCustomTemplate;\n       * ```\n       * ```html\n       * <!-- Set in markup -->\n       *  <igx-combo #combo>\n       *      ...\n       *      <ng-template igxComboClearIcon>\n       *          <igx-icon>clear</igx-icon>\n       *      </ng-template>\n       *  </igx-combo>\n       * ```\n       */\n\n      this.clearIconTemplate = null;\n      /** @hidden @internal */\n\n      this.searchInput = null;\n      this.dropdownContainer = null;\n      /** @hidden @internal */\n\n      this.customValueFlag = true;\n      /** @hidden @internal */\n\n      this.filterValue = '';\n      /** @hidden @internal */\n\n      this.defaultFallbackGroup = 'Other';\n      /** @hidden @internal */\n\n      this.filteringOptions = {\n        caseSensitive: false\n      };\n      this._data = [];\n      this._value = '';\n      this._groupKey = '';\n      this._searchValue = '';\n      this._filteredData = [];\n      this._remoteSelection = {};\n      this._valid = IgxComboState.INITIAL;\n      this.ngControl = null;\n      this.destroy$ = new Subject();\n      this._onTouchedCallback = noop;\n      this._onChangeCallback = noop;\n      this._type = null;\n      this._dataType = '';\n      this._itemHeight = null;\n      this._itemsMaxHeight = null;\n      this._groupSortingDirection = SortingDirection.Asc;\n\n      this.onStatusChanged = () => {\n        if ((this.ngControl.control.touched || this.ngControl.control.dirty) && (this.ngControl.control.validator || this.ngControl.control.asyncValidator)) {\n          if (!this.collapsed || this.inputGroup.isFocused) {\n            this.valid = this.ngControl.invalid ? IgxComboState.INVALID : IgxComboState.VALID;\n          } else {\n            this.valid = this.ngControl.invalid ? IgxComboState.INVALID : IgxComboState.INITIAL;\n          }\n        } else {\n          // B.P. 18 May 2021: IgxDatePicker does not reset its state upon resetForm #9526\n          this.valid = IgxComboState.INITIAL;\n        }\n\n        this.manageRequiredAsterisk();\n      };\n\n      this.findMatch = element => {\n        const value = this.displayKey ? element[this.displayKey] : element;\n        return (value === null || value === void 0 ? void 0 : value.toString().toLowerCase()) === this.searchValue.trim().toLowerCase();\n      };\n    }\n    /**\n     * Configures the drop down list height\n     *\n     * ```typescript\n     * // get\n     * let myComboItemsMaxHeight = this.combo.itemsMaxHeight;\n     * ```\n     *\n     * ```html\n     * <!--set-->\n     * <igx-combo [itemsMaxHeight]='320'></igx-combo>\n     * ```\n     */\n\n\n    get itemsMaxHeight() {\n      if (this._itemsMaxHeight === null || this._itemsMaxHeight === undefined) {\n        return this.itemHeight * itemsInContainer;\n      }\n\n      return this._itemsMaxHeight;\n    }\n\n    set itemsMaxHeight(val) {\n      this._itemsMaxHeight = val;\n    }\n    /**\n     * Configures the drop down list item height\n     *\n     * ```typescript\n     * // get\n     * let myComboItemHeight = this.combo.itemHeight;\n     * ```\n     *\n     * ```html\n     * <!--set-->\n     * <igx-combo [itemHeight]='32'></igx-combo>\n     * ```\n     */\n\n\n    get itemHeight() {\n      if (this._itemHeight === null || this._itemHeight === undefined) {\n        return ItemHeights[this.displayDensity];\n      }\n\n      return this._itemHeight;\n    }\n\n    set itemHeight(val) {\n      this._itemHeight = val;\n    }\n    /**\n     * Combo data source.\n     *\n     * ```html\n     * <!--set-->\n     * <igx-combo [data]='items'></igx-combo>\n     * ```\n     */\n\n\n    get data() {\n      return this._data;\n    }\n\n    set data(val) {\n      this._data = val ? val : [];\n    }\n\n    set displayKey(val) {\n      this._displayKey = val;\n    }\n    /**\n     * Determines which column in the data source is used to determine the display value.\n     *\n     * ```typescript\n     * // get\n     * let myComboDisplayKey = this.combo.displayKey;\n     *\n     * // set\n     * this.combo.displayKey = 'val';\n     *\n     * ```\n     *\n     * ```html\n     * <!--set-->\n     * <igx-combo [displayKey]='myDisplayKey'></igx-combo>\n     * ```\n     */\n\n\n    get displayKey() {\n      return this._displayKey ? this._displayKey : this.valueKey;\n    }\n    /**\n     * The item property by which items should be grouped inside the items list. Not usable if data is not of type Object[].\n     *\n     * ```html\n     * <!--set-->\n     * <igx-combo [groupKey]='newGroupKey'></igx-combo>\n     * ```\n     */\n\n\n    set groupKey(val) {\n      this._groupKey = val;\n    }\n    /**\n     * The item property by which items should be grouped inside the items list. Not usable if data is not of type Object[].\n     *\n     * ```typescript\n     * // get\n     * let currentGroupKey = this.combo.groupKey;\n     * ```\n     */\n\n\n    get groupKey() {\n      return this._groupKey;\n    }\n    /**\n     * An @Input property that sets groups sorting order.\n     *\n     * @example\n     * ```html\n     * <igx-combo [groupSortingDirection]=\"groupSortingDirection\"></igx-combo>\n     * ```\n     * ```typescript\n     * public groupSortingDirection = SortingDirection.Asc;\n     * ```\n     */\n\n\n    get groupSortingDirection() {\n      return this._groupSortingDirection;\n    }\n\n    set groupSortingDirection(val) {\n      this._groupSortingDirection = val;\n    }\n    /** @hidden @internal */\n\n\n    get ariaExpanded() {\n      return !this.dropdown.collapsed;\n    }\n    /** @hidden @internal */\n\n\n    get hasPopUp() {\n      return 'listbox';\n    }\n    /** @hidden @internal */\n\n\n    get ariaOwns() {\n      return this.dropdown.id;\n    }\n    /**\n     * An @Input property that sets how the combo will be styled.\n     * The allowed values are `line`, `box`, `border` and `search`. The default is `box`.\n     * ```html\n     * <igx-combo [type]=\"'line'\">\n     * ```\n     */\n\n\n    get type() {\n      return this._type || this._inputGroupType || 'box';\n    }\n\n    set type(val) {\n      this._type = val;\n    }\n    /** @hidden @internal */\n\n\n    get searchValue() {\n      return this._searchValue;\n    }\n\n    set searchValue(val) {\n      this.filterValue = val;\n      this._searchValue = val;\n    }\n    /** @hidden @internal */\n\n\n    get isRemote() {\n      return this.totalItemCount > 0 && this.valueKey && this.dataType === DataTypes.COMPLEX;\n    }\n    /** @hidden @internal */\n\n\n    get dataType() {\n      if (this.displayKey) {\n        return DataTypes.COMPLEX;\n      }\n\n      return DataTypes.PRIMITIVE;\n    }\n    /**\n     * Gets if control is valid, when used in a form\n     *\n     * ```typescript\n     * // get\n     * let valid = this.combo.valid;\n     * ```\n     */\n\n\n    get valid() {\n      return this._valid;\n    }\n    /**\n     * Sets if control is valid, when used in a form\n     *\n     * ```typescript\n     * // set\n     * this.combo.valid = IgxComboState.INVALID;\n     * ```\n     */\n\n\n    set valid(valid) {\n      this._valid = valid;\n      this.comboInput.valid = IgxInputState[IgxComboState[valid]];\n    }\n    /**\n     * The text displayed in the combo input\n     *\n     * ```typescript\n     * // get\n     * let comboValue = this.combo.value;\n     * ```\n     */\n\n\n    get value() {\n      return this._value;\n    }\n    /**\n     * Defines the current state of the virtualized data. It contains `startIndex` and `chunkSize`\n     *\n     * ```typescript\n     * // get\n     * let state = this.combo.virtualizationState;\n     * ```\n     */\n\n\n    get virtualizationState() {\n      return this.virtDir.state;\n    }\n    /**\n     * Sets the current state of the virtualized data.\n     *\n     * ```typescript\n     * // set\n     * this.combo.virtualizationState(state);\n     * ```\n     */\n\n\n    set virtualizationState(state) {\n      this.virtDir.state = state;\n    }\n    /**\n     * Gets drop down state.\n     *\n     * ```typescript\n     * let state = this.combo.collapsed;\n     * ```\n     */\n\n\n    get collapsed() {\n      return this.dropdown.collapsed;\n    }\n    /**\n     * Gets total count of the virtual data items, when using remote service.\n     *\n     * ```typescript\n     * // get\n     * let count = this.combo.totalItemCount;\n     * ```\n     */\n\n\n    get totalItemCount() {\n      return this.virtDir.totalItemCount;\n    }\n    /**\n     * Sets total count of the virtual data items, when using remote service.\n     *\n     * ```typescript\n     * // set\n     * this.combo.totalItemCount(remoteService.count);\n     * ```\n     */\n\n\n    set totalItemCount(count) {\n      this.virtDir.totalItemCount = count;\n    }\n    /** @hidden @internal */\n\n\n    get template() {\n      this._dataType = this.dataType;\n\n      if (this.itemTemplate) {\n        return this.itemTemplate;\n      }\n\n      if (this._dataType === DataTypes.COMPLEX) {\n        return this.complexTemplate;\n      }\n\n      return this.primitiveTemplate;\n    }\n    /** @hidden @internal */\n\n\n    onArrowDown(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.open();\n    }\n    /** @hidden @internal */\n\n\n    ngOnInit() {\n      this.ngControl = this._injector.get(NgControl, null);\n      const targetElement = this.elementRef.nativeElement;\n      this._overlaySettings = {\n        target: targetElement,\n        scrollStrategy: new AbsoluteScrollStrategy(),\n        positionStrategy: new AutoPositionStrategy(),\n        modal: false,\n        closeOnOutsideClick: true,\n        excludeFromOutsideClick: [targetElement]\n      };\n      this.selectionService.set(this.id, new Set());\n\n      this._iconService.addSvgIconFromText(caseSensitive.name, caseSensitive.value, 'imx-icons');\n    }\n    /** @hidden @internal */\n\n\n    ngAfterViewInit() {\n      this.filteredData = [...this.data];\n\n      if (this.ngControl) {\n        this.ngControl.statusChanges.pipe(takeUntil(this.destroy$)).subscribe(this.onStatusChanged);\n        this.manageRequiredAsterisk();\n        this.cdr.detectChanges();\n      }\n\n      this.virtDir.chunkPreload.pipe(takeUntil(this.destroy$)).subscribe(e => {\n        const eventArgs = Object.assign({}, e, {\n          owner: this\n        });\n        this.dataPreLoad.emit(eventArgs);\n      });\n    }\n    /** @hidden @internal */\n\n\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n      this.comboAPI.clear();\n      this.selectionService.clear(this.id);\n    }\n    /**\n     * A method that opens/closes the combo.\n     *\n     * ```html\n     * <button (click)=\"combo.toggle()\">Toggle Combo</button>\n     * <igx-combo #combo></igx-combo>\n     * ```\n     */\n\n\n    toggle() {\n      const overlaySettings = Object.assign({}, this._overlaySettings, this.overlaySettings);\n      this.dropdown.toggle(overlaySettings);\n    }\n    /**\n     * A method that opens the combo.\n     *\n     * ```html\n     * <button (click)=\"combo.open()\">Open Combo</button>\n     * <igx-combo #combo></igx-combo>\n     * ```\n     */\n\n\n    open() {\n      const overlaySettings = Object.assign({}, this._overlaySettings, this.overlaySettings);\n      this.dropdown.open(overlaySettings);\n    }\n    /**\n     * A method that closes the combo.\n     *\n     * ```html\n     * <button (click)=\"combo.close()\">Close Combo</button>\n     * <igx-combo #combo></igx-combo>\n     * ```\n     */\n\n\n    close() {\n      this.dropdown.close();\n    }\n    /**\n     * Triggers change detection on the combo view\n     */\n\n\n    triggerCheck() {\n      this.cdr.detectChanges();\n    }\n    /**\n     * Get current selection state\n     *\n     * @returns Array of selected items\n     * ```typescript\n     * let mySelection = this.combo.selection;\n     * ```\n     */\n\n\n    get selection() {\n      const items = Array.from(this.selectionService.get(this.id));\n      return items;\n    }\n    /**\n     * Returns if the specified itemID is selected\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    isItemSelected(item) {\n      return this.selectionService.is_item_selected(this.id, item);\n    }\n    /** @hidden @internal */\n\n\n    addItemToCollection() {\n      var _a;\n\n      if (!this.searchValue) {\n        return;\n      }\n\n      const newValue = this.searchValue.trim();\n      const addedItem = this.displayKey ? {\n        [this.valueKey]: newValue,\n        [this.displayKey]: newValue\n      } : newValue;\n\n      if (this.groupKey) {\n        Object.assign(addedItem, {\n          [this.groupKey]: this.defaultFallbackGroup\n        });\n      } // expose shallow copy instead of this.data in event args so this.data can't be mutated\n\n\n      const oldCollection = [...this.data];\n      const newCollection = [...this.data, addedItem];\n      const args = {\n        oldCollection,\n        addedItem,\n        newCollection,\n        owner: this,\n        cancel: false\n      };\n      this.addition.emit(args);\n\n      if (args.cancel) {\n        return;\n      }\n\n      this.data.push(args.addedItem); // trigger re-render\n\n      this.data = cloneArray(this.data);\n      this.select(this.valueKey !== null && this.valueKey !== undefined ? [args.addedItem[this.valueKey]] : [args.addedItem], false);\n      this.customValueFlag = false;\n      (_a = this.searchInput) === null || _a === void 0 ? void 0 : _a.nativeElement.focus();\n      this.dropdown.focusedItem = null;\n      this.virtDir.scrollTo(0);\n    }\n    /** @hidden @internal */\n\n\n    isAddButtonVisible() {\n      // This should always return a boolean value. If this.searchValue was '', it returns '' instead of false;\n      return this.searchValue !== '' && this.customValueFlag;\n    }\n    /** @hidden @internal */\n\n\n    handleInputChange(event) {\n      if (event !== undefined) {\n        const args = {\n          searchText: typeof event === 'string' ? event : event.target.value,\n          owner: this,\n          cancel: false\n        };\n        this.searchInputUpdate.emit(args);\n\n        if (args.cancel) {\n          this.filterValue = null;\n        }\n      }\n\n      this.checkMatch();\n    }\n    /**\n     * Event handlers\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    handleOpening(e) {\n      const args = {\n        owner: this,\n        event: e.event,\n        cancel: e.cancel\n      };\n      this.opening.emit(args);\n      e.cancel = args.cancel;\n    }\n    /** @hidden @internal */\n\n\n    handleClosing(e) {\n      var _a;\n\n      const args = {\n        owner: this,\n        event: e.event,\n        cancel: e.cancel\n      };\n      this.closing.emit(args);\n      e.cancel = args.cancel;\n\n      if (e.cancel) {\n        return;\n      }\n\n      this.searchValue = '';\n\n      if (!e.event) {\n        (_a = this.comboInput) === null || _a === void 0 ? void 0 : _a.nativeElement.focus();\n      }\n    }\n    /** @hidden @internal */\n\n\n    handleClosed() {\n      this.closed.emit({\n        owner: this\n      });\n    }\n    /** @hidden @internal */\n\n\n    handleKeyDown(event) {\n      if (event.key === 'ArrowUp' || event.key === 'Up') {\n        event.preventDefault();\n        event.stopPropagation();\n        this.close();\n      }\n    }\n    /** @hidden @internal */\n\n\n    registerOnChange(fn) {\n      this._onChangeCallback = fn;\n    }\n    /** @hidden @internal */\n\n\n    registerOnTouched(fn) {\n      this._onTouchedCallback = fn;\n    }\n    /** @hidden @internal */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n    /** @hidden @internal */\n\n\n    onClick(event) {\n      event.stopPropagation();\n      event.preventDefault();\n\n      if (!this.disabled) {\n        this.toggle();\n      }\n    }\n    /** @hidden @internal */\n\n\n    onBlur() {\n      if (this.collapsed) {\n        this._onTouchedCallback();\n\n        if (this.ngControl && this.ngControl.invalid) {\n          this.valid = IgxComboState.INVALID;\n        } else {\n          this.valid = IgxComboState.INITIAL;\n        }\n      }\n    }\n    /** @hidden @internal */\n\n\n    toggleCaseSensitive() {\n      this.filteringOptions = {\n        caseSensitive: !this.filteringOptions.caseSensitive\n      };\n    }\n    /** if there is a valueKey - map the keys to data items, else - just return the keys */\n\n\n    convertKeysToItems(keys) {\n      if (this.comboAPI.valueKey === null) {\n        return keys;\n      } // map keys vs. filter data to retain the order of the selected items\n\n\n      return keys.map(key => this.data.find(entry => entry[this.valueKey] === key)).filter(e => e !== undefined);\n    }\n\n    checkMatch() {\n      const itemMatch = this.filteredData.some(this.findMatch);\n      this.customValueFlag = this.allowCustomValues && !itemMatch;\n    }\n\n    manageRequiredAsterisk() {\n      if (this.ngControl) {\n        if (this.ngControl.control.validator) {\n          // Run the validation with empty object to check if required is enabled.\n          const error = this.ngControl.control.validator({});\n          this.inputGroup.isRequired = error && error.required;\n        } else {\n          // P.M. 18 May 2022: IgxCombo's asterisk not removed when removing required validator dynamically in reactive form #11543\n          this.inputGroup.isRequired = false;\n        }\n      }\n    }\n    /** Contains key-value pairs of the selected valueKeys and their resp. displayKeys */\n\n\n    registerRemoteEntries(ids, add = true) {\n      if (add) {\n        const selection = this.getValueDisplayPairs(ids);\n\n        for (const entry of selection) {\n          this._remoteSelection[entry[this.valueKey]] = entry[this.displayKey];\n        }\n      } else {\n        for (const entry of ids) {\n          delete this._remoteSelection[entry];\n        }\n      }\n    }\n    /**\n     * For `id: any[]` returns a mapped `{ [combo.valueKey]: any, [combo.displayKey]: any }[]`\n     */\n\n\n    getValueDisplayPairs(ids) {\n      return this.data.filter(entry => ids.indexOf(entry[this.valueKey]) > -1).map(e => ({\n        [this.valueKey]: e[this.valueKey],\n        [this.displayKey]: e[this.displayKey]\n      }));\n    }\n\n    getRemoteSelection(newSelection, oldSelection) {\n      if (!newSelection.length) {\n        // If new selection is empty, clear all items\n        this.registerRemoteEntries(oldSelection, false);\n        return '';\n      }\n\n      const removedItems = oldSelection.filter(e => newSelection.indexOf(e) < 0);\n      const addedItems = newSelection.filter(e => oldSelection.indexOf(e) < 0);\n      this.registerRemoteEntries(addedItems);\n      this.registerRemoteEntries(removedItems, false);\n      return Object.keys(this._remoteSelection).map(e => this._remoteSelection[e]).join(', ');\n    }\n\n  }\n\n  IgxComboBaseDirective.ɵfac = function IgxComboBaseDirective_Factory(t) {\n    return new (t || IgxComboBaseDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(IgxSelectionAPIService), i0.ɵɵdirectiveInject(IgxComboAPIService), i0.ɵɵdirectiveInject(IgxIconService), i0.ɵɵdirectiveInject(DisplayDensityToken, 8), i0.ɵɵdirectiveInject(IGX_INPUT_GROUP_TYPE, 8), i0.ɵɵdirectiveInject(i0.Injector, 8));\n  };\n\n  IgxComboBaseDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxComboBaseDirective,\n    contentQueries: function IgxComboBaseDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxComboItemDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxComboHeaderDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxComboFooterDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxComboHeaderItemDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxComboAddItemDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxComboEmptyDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxComboToggleIconDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxComboClearIconDirective, 5, TemplateRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerItemTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.addItemTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.emptyTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toggleIconTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.clearIconTemplate = _t.first);\n      }\n    },\n    viewQuery: function IgxComboBaseDirective_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c62, 7, IgxInputGroupComponent);\n        i0.ɵɵviewQuery(_c63, 7, IgxInputDirective);\n        i0.ɵɵviewQuery(_c64, 5);\n        i0.ɵɵviewQuery(IgxForOfDirective, 7);\n        i0.ɵɵviewQuery(IgxForOfDirective, 7, IgxForOfDirective);\n        i0.ɵɵviewQuery(_c65, 7);\n        i0.ɵɵviewQuery(_c66, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c67, 7, TemplateRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputGroup = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.comboInput = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.searchInput = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.virtualScrollContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.virtDir = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropdownContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.primitiveTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.complexTemplate = _t.first);\n      }\n    },\n    hostVars: 10,\n    hostBindings: function IgxComboBaseDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown.ArrowDown\", function IgxComboBaseDirective_keydown_ArrowDown_HostBindingHandler($event) {\n          return ctx.onArrowDown($event);\n        })(\"keydown.Alt.ArrowDown\", function IgxComboBaseDirective_keydown_Alt_ArrowDown_HostBindingHandler($event) {\n          return ctx.onArrowDown($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id)(\"aria-labelledby\", ctx.ariaLabelledBy)(\"role\", ctx.role)(\"aria-expanded\", ctx.ariaExpanded)(\"aria-haspopup\", ctx.hasPopUp)(\"aria-owns\", ctx.ariaOwns);\n        i0.ɵɵstyleProp(\"width\", ctx.width);\n        i0.ɵɵclassProp(\"igx-combo\", ctx.cssClass);\n      }\n    },\n    inputs: {\n      showSearchCaseIcon: \"showSearchCaseIcon\",\n      overlaySettings: \"overlaySettings\",\n      id: \"id\",\n      width: \"width\",\n      allowCustomValues: \"allowCustomValues\",\n      itemsMaxHeight: \"itemsMaxHeight\",\n      itemHeight: \"itemHeight\",\n      itemsWidth: \"itemsWidth\",\n      placeholder: \"placeholder\",\n      data: \"data\",\n      valueKey: \"valueKey\",\n      displayKey: \"displayKey\",\n      groupKey: \"groupKey\",\n      groupSortingDirection: \"groupSortingDirection\",\n      ariaLabelledBy: \"ariaLabelledBy\",\n      disabled: \"disabled\",\n      type: \"type\"\n    },\n    outputs: {\n      opening: \"opening\",\n      opened: \"opened\",\n      closing: \"closing\",\n      closed: \"closed\",\n      addition: \"addition\",\n      searchInputUpdate: \"searchInputUpdate\",\n      dataPreLoad: \"dataPreLoad\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return IgxComboBaseDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxComboAddItemComponent = /*#__PURE__*/(() => {\n  class IgxComboAddItemComponent extends IgxComboItemComponent {\n    get selected() {\n      return false;\n    }\n\n    set selected(value) {}\n    /**\n     * @inheritdoc\n     */\n\n\n    clicked(event) {\n      this.comboAPI.disableTransitions = false;\n      this.comboAPI.add_custom_item();\n    }\n\n  }\n\n  IgxComboAddItemComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxComboAddItemComponent_BaseFactory;\n    return function IgxComboAddItemComponent_Factory(t) {\n      return (ɵIgxComboAddItemComponent_BaseFactory || (ɵIgxComboAddItemComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxComboAddItemComponent)))(t || IgxComboAddItemComponent);\n    };\n  }();\n\n  IgxComboAddItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxComboAddItemComponent,\n    selectors: [[\"igx-combo-add-item\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxComboItemComponent,\n      useExisting: IgxComboAddItemComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c8,\n    decls: 1,\n    vars: 0,\n    template: function IgxComboAddItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxComboAddItemComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxComboDropDownComponent = /*#__PURE__*/(() => {\n  class IgxComboDropDownComponent extends IgxDropDownComponent {\n    constructor(elementRef, cdr, selection, combo, comboAPI, _displayDensityOptions) {\n      super(elementRef, cdr, selection, _displayDensityOptions);\n      this.elementRef = elementRef;\n      this.cdr = cdr;\n      this.selection = selection;\n      this.combo = combo;\n      this.comboAPI = comboAPI;\n      this._displayDensityOptions = _displayDensityOptions;\n      /** @hidden @internal */\n\n      this.singleMode = false;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this.children = null;\n\n      this.scrollHandler = () => {\n        this.comboAPI.disableTransitions = true;\n      };\n    }\n    /** @hidden @internal */\n\n\n    get scrollContainer() {\n      return this.virtDir.dc.location.nativeElement;\n    }\n\n    get isScrolledToLast() {\n      const scrollTop = this.virtDir.scrollPosition;\n      const scrollHeight = this.virtDir.getScroll().scrollHeight;\n      return Math.floor(scrollTop + this.virtDir.igxForContainerSize) === scrollHeight;\n    }\n\n    get lastVisibleIndex() {\n      return this.combo.totalItemCount ? Math.floor(this.combo.itemsMaxHeight / this.combo.itemHeight) : this.items.length - 1;\n    }\n\n    get sortedChildren() {\n      if (this.children !== undefined) {\n        return this.children.toArray().sort((a, b) => a.index - b.index);\n      }\n\n      return null;\n    }\n    /**\n     * Get all non-header items\n     *\n     * ```typescript\n     * let myDropDownItems = this.dropdown.items;\n     * ```\n     */\n\n\n    get items() {\n      const items = [];\n\n      if (this.children !== undefined) {\n        const sortedChildren = this.sortedChildren;\n\n        for (const child of sortedChildren) {\n          if (!child.isHeader) {\n            items.push(child);\n          }\n        }\n      }\n\n      return items;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onFocus() {\n      this.focusedItem = this._focusedItem || this.items[0];\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onBlur(_evt) {\n      this.focusedItem = null;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onToggleOpened() {\n      this.opened.emit();\n    }\n    /**\n     * @hidden\n     */\n\n\n    navigateFirst() {\n      this.navigateItem(this.virtDir.igxForOf.findIndex(e => !e.isHeader));\n    }\n    /**\n     * @hidden\n     */\n\n\n    navigatePrev() {\n      if (this._focusedItem && this._focusedItem.index === 0 && this.virtDir.state.startIndex === 0) {\n        this.combo.focusSearchInput(false);\n      } else {\n        super.navigatePrev();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    navigateNext() {\n      const lastIndex = this.combo.totalItemCount ? this.combo.totalItemCount - 1 : this.virtDir.igxForOf.length - 1;\n\n      if (this._focusedItem && this._focusedItem.index === lastIndex) {\n        this.focusAddItemButton();\n      } else {\n        super.navigateNext();\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    selectItem(item) {\n      if (item === null || item === undefined) {\n        return;\n      }\n\n      this.comboAPI.set_selected_item(item.itemID);\n      this._focusedItem = item;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    updateScrollPosition() {\n      this.virtDir.getScroll().scrollTop = this._scrollPosition;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onItemActionKey(key) {\n      switch (key) {\n        case DropDownActionKey.ENTER:\n          this.handleEnter();\n          break;\n\n        case DropDownActionKey.SPACE:\n          this.handleSpace();\n          break;\n\n        case DropDownActionKey.ESCAPE:\n          this.close();\n      }\n    }\n\n    ngAfterViewInit() {\n      this.virtDir.getScroll().addEventListener('scroll', this.scrollHandler);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    ngOnDestroy() {\n      this.virtDir.getScroll().removeEventListener('scroll', this.scrollHandler);\n      this.destroy$.next(true);\n      this.destroy$.complete();\n    }\n\n    scrollToHiddenItem(_newItem) {}\n\n    handleEnter() {\n      if (this.isAddItemFocused()) {\n        this.combo.addItemToCollection();\n        return;\n      }\n\n      if (this.singleMode && this.focusedItem) {\n        this.combo.select(this.focusedItem.itemID);\n      }\n\n      this.close();\n    }\n\n    handleSpace() {\n      if (this.isAddItemFocused()) {\n        return;\n      } else {\n        this.selectItem(this.focusedItem);\n      }\n    }\n\n    isAddItemFocused() {\n      return this.focusedItem instanceof IgxComboAddItemComponent;\n    }\n\n    focusAddItemButton() {\n      if (this.combo.isAddButtonVisible()) {\n        this.focusedItem = this.items[this.items.length - 1];\n      }\n    }\n\n  }\n\n  IgxComboDropDownComponent.ɵfac = function IgxComboDropDownComponent_Factory(t) {\n    return new (t || IgxComboDropDownComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(IgxSelectionAPIService), i0.ɵɵdirectiveInject(IGX_COMBO_COMPONENT), i0.ɵɵdirectiveInject(IgxComboAPIService), i0.ɵɵdirectiveInject(DisplayDensityToken, 8));\n  };\n\n  IgxComboDropDownComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxComboDropDownComponent,\n    selectors: [[\"igx-combo-drop-down\"]],\n    contentQueries: function IgxComboDropDownComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxComboItemComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.children = _t);\n      }\n    },\n    inputs: {\n      singleMode: \"singleMode\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IGX_DROPDOWN_BASE,\n      useExisting: IgxComboDropDownComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c8,\n    decls: 4,\n    vars: 9,\n    consts: [[\"igxToggle\", \"\", 1, \"igx-drop-down__list\", 3, \"appended\", \"opening\", \"opened\", \"closing\", \"closed\"], [\"role\", \"listbox\", 1, \"igx-drop-down__list-scroll\"], [\"scrollContainer\", \"\"], [4, \"ngIf\"]],\n    template: function IgxComboDropDownComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵlistener(\"appended\", function IgxComboDropDownComponent_Template_div_appended_0_listener($event) {\n          return ctx.onToggleContentAppended($event);\n        })(\"opening\", function IgxComboDropDownComponent_Template_div_opening_0_listener($event) {\n          return ctx.onToggleOpening($event);\n        })(\"opened\", function IgxComboDropDownComponent_Template_div_opened_0_listener() {\n          return ctx.onToggleOpened();\n        })(\"closing\", function IgxComboDropDownComponent_Template_div_closing_0_listener($event) {\n          return ctx.onToggleClosing($event);\n        })(\"closed\", function IgxComboDropDownComponent_Template_div_closed_0_listener() {\n          return ctx.onToggleClosed();\n        });\n        i0.ɵɵelementStart(1, \"div\", 1, 2);\n        i0.ɵɵtemplate(3, IgxComboDropDownComponent_ng_container_3_Template, 2, 0, \"ng-container\", 3);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"width\", ctx.width);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"height\", ctx.height)(\"max-height\", ctx.maxHeight);\n        i0.ɵɵattribute(\"id\", ctx.listId)(\"aria-label\", ctx.listId);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", !ctx.collapsed);\n      }\n    },\n    directives: [IgxToggleDirective, i4.NgIf],\n    encapsulation: 2\n  });\n  return IgxComboDropDownComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxComboCleanPipe = /*#__PURE__*/(() => {\n  class IgxComboCleanPipe {\n    transform(collection) {\n      return collection.filter(e => !!e);\n    }\n\n  }\n\n  IgxComboCleanPipe.ɵfac = function IgxComboCleanPipe_Factory(t) {\n    return new (t || IgxComboCleanPipe)();\n  };\n\n  IgxComboCleanPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"comboClean\",\n    type: IgxComboCleanPipe,\n    pure: true\n  });\n  return IgxComboCleanPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxComboFilteringPipe = /*#__PURE__*/(() => {\n  class IgxComboFilteringPipe {\n    transform(collection, searchValue, displayKey, filteringOptions, shouldFilter = false) {\n      if (!collection) {\n        return [];\n      }\n\n      if (!searchValue || !shouldFilter) {\n        return collection;\n      } else {\n        const searchTerm = filteringOptions.caseSensitive ? searchValue.trim() : searchValue.toLowerCase().trim();\n\n        if (displayKey != null) {\n          return collection.filter(e => {\n            var _a, _b;\n\n            return filteringOptions.caseSensitive ? (_a = e[displayKey]) === null || _a === void 0 ? void 0 : _a.includes(searchTerm) : (_b = e[displayKey]) === null || _b === void 0 ? void 0 : _b.toString().toLowerCase().includes(searchTerm);\n          });\n        } else {\n          return collection.filter(e => filteringOptions.caseSensitive ? e.includes(searchTerm) : e.toString().toLowerCase().includes(searchTerm));\n        }\n      }\n    }\n\n  }\n\n  IgxComboFilteringPipe.ɵfac = function IgxComboFilteringPipe_Factory(t) {\n    return new (t || IgxComboFilteringPipe)();\n  };\n\n  IgxComboFilteringPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"comboFiltering\",\n    type: IgxComboFilteringPipe,\n    pure: true\n  });\n  return IgxComboFilteringPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxComboGroupingPipe = /*#__PURE__*/(() => {\n  class IgxComboGroupingPipe {\n    constructor(combo) {\n      this.combo = combo;\n    }\n\n    transform(collection, groupKey, valueKey, sortingDirection) {\n      this.combo.filteredData = collection;\n\n      if (!groupKey && groupKey !== 0 || !collection.length) {\n        return collection;\n      }\n\n      const sorted = DataUtil.sort(cloneArray(collection), [{\n        fieldName: groupKey,\n        dir: sortingDirection,\n        ignoreCase: true,\n        strategy: DefaultSortingStrategy.instance()\n      }]);\n      const data = cloneArray(sorted);\n      let inserts = 0;\n      let currentHeader = null;\n\n      for (let i = 0; i < sorted.length; i++) {\n        let insertFlag = 0;\n\n        if (currentHeader !== sorted[i][groupKey]) {\n          currentHeader = sorted[i][groupKey];\n          insertFlag = 1;\n        }\n\n        if (insertFlag) {\n          data.splice(i + inserts, 0, {\n            [valueKey]: currentHeader,\n            [groupKey]: currentHeader,\n            isHeader: true\n          });\n          inserts++;\n        }\n      }\n\n      return data;\n    }\n\n  }\n\n  IgxComboGroupingPipe.ɵfac = function IgxComboGroupingPipe_Factory(t) {\n    return new (t || IgxComboGroupingPipe)(i0.ɵɵdirectiveInject(IGX_COMBO_COMPONENT, 16));\n  };\n\n  IgxComboGroupingPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"comboGrouping\",\n    type: IgxComboGroupingPipe,\n    pure: true\n  });\n  return IgxComboGroupingPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * When called with sets A & B, returns A - B (as array);\n *\n * @hidden\n */\n\n\nconst diffInSets = (set1, set2) => {\n  const results = [];\n  set1.forEach(entry => {\n    if (!set2.has(entry)) {\n      results.push(entry);\n    }\n  });\n  return results;\n};\n/**\n *  Represents a drop-down list that provides editable functionalities, allowing users to choose an option from a predefined list.\n *\n * @igxModule IgxComboModule\n * @igxTheme igx-combo-theme\n * @igxKeywords combobox, combo selection\n * @igxGroup Grids & Lists\n *\n * @remarks\n * It provides the ability to filter items as well as perform selection with the provided data.\n * Additionally, it exposes keyboard navigation and custom styling capabilities.\n * @example\n * ```html\n * <igx-combo [itemsMaxHeight]=\"250\" [data]=\"locationData\"\n *  [displayKey]=\"'field'\" [valueKey]=\"'field'\"\n *  placeholder=\"Location(s)\" searchPlaceholder=\"Search...\">\n * </igx-combo>\n * ```\n */\n\n\nlet IgxComboComponent = /*#__PURE__*/(() => {\n  class IgxComboComponent extends IgxComboBaseDirective {\n    constructor(elementRef, cdr, selectionService, comboAPI, _iconService, _displayDensityOptions, _inputGroupType, _injector) {\n      super(elementRef, cdr, selectionService, comboAPI, _iconService, _displayDensityOptions, _inputGroupType, _injector);\n      this.elementRef = elementRef;\n      this.cdr = cdr;\n      this.selectionService = selectionService;\n      this.comboAPI = comboAPI;\n      this._iconService = _iconService;\n      this._displayDensityOptions = _displayDensityOptions;\n      this._inputGroupType = _inputGroupType;\n      this._injector = _injector;\n      /**\n       * An @Input property that controls whether the combo's search box\n       * should be focused after the `opened` event is called\n       * When `false`, the combo's list item container will be focused instead\n       */\n\n      this.autoFocusSearch = true;\n      /**\n       * An @Input property that enabled/disables filtering in the list. The default is `true`.\n       * ```html\n       * <igx-combo [filterable]=\"false\">\n       * ```\n       */\n\n      this.filterable = true;\n      /**\n       * Defines the placeholder value for the combo dropdown search field\n       *\n       * ```typescript\n       * // get\n       * let myComboSearchPlaceholder = this.combo.searchPlaceholder;\n       * ```\n       *\n       * ```html\n       * <!--set-->\n       * <igx-combo [searchPlaceholder]='newPlaceHolder'></igx-combo>\n       * ```\n       */\n\n      this.searchPlaceholder = 'Enter a Search Term';\n      /**\n       * Emitted when item selection is changing, before the selection completes\n       *\n       * ```html\n       * <igx-combo (selectionChanging)='handleSelection()'></igx-combo>\n       * ```\n       */\n\n      this.selectionChanging = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.filteringLogic = FilteringLogic.Or;\n      this.stringFilters = IgxStringFilteringOperand;\n      this.booleanFilters = IgxBooleanFilteringOperand;\n      this._prevInputValue = '';\n      this.comboAPI.register(this);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get inputEmpty() {\n      return !this.value && !this.placeholder;\n    }\n    /** @hidden @internal */\n\n\n    get filteredData() {\n      return this.filterable ? this._filteredData : this.data;\n    }\n    /** @hidden @internal */\n\n\n    set filteredData(val) {\n      this._filteredData = this.groupKey ? (val || []).filter(e => e.isHeader !== true) : val;\n      this.checkMatch();\n    }\n    /** @hidden @internal */\n\n\n    get displaySearchInput() {\n      return this.filterable || this.allowCustomValues;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    handleKeyUp(event) {\n      // TODO: use PlatformUtil for keyboard navigation\n      if (event.key === 'ArrowDown' || event.key === 'Down') {\n        this.dropdown.focusedItem = this.dropdown.items[0];\n        this.dropdownContainer.nativeElement.focus();\n      } else if (event.key === 'Escape' || event.key === 'Esc') {\n        this.toggle();\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    handleSelectAll(evt) {\n      if (evt.checked) {\n        this.selectAllItems();\n      } else {\n        this.deselectAllItems();\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    writeValue(value) {\n      const selection = Array.isArray(value) ? value : [];\n      const oldSelection = this.selection;\n      this.selectionService.select_items(this.id, selection, true);\n      this.cdr.markForCheck();\n      this._value = this.createDisplayText(this.selection, oldSelection);\n    }\n    /**\n     * @hidden\n     */\n\n\n    getEditElement() {\n      return this.comboInput.nativeElement;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get context() {\n      return {\n        $implicit: this\n      };\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    handleClearItems(event) {\n      if (this.disabled) {\n        return;\n      }\n\n      this.deselectAllItems(true, event);\n\n      if (this.collapsed) {\n        this.getEditElement().focus();\n      } else {\n        this.focusSearchInput(true);\n      }\n\n      event.stopPropagation();\n    }\n    /**\n     * Select defined items\n     *\n     * @param newItems new items to be selected\n     * @param clearCurrentSelection if true clear previous selected items\n     * ```typescript\n     * this.combo.select([\"New York\", \"New Jersey\"]);\n     * ```\n     */\n\n\n    select(newItems, clearCurrentSelection, event) {\n      if (newItems) {\n        const newSelection = this.selectionService.add_items(this.id, newItems, clearCurrentSelection);\n        this.setSelection(newSelection, event);\n      }\n    }\n    /**\n     * Deselect defined items\n     *\n     * @param items items to deselected\n     * ```typescript\n     * this.combo.deselect([\"New York\", \"New Jersey\"]);\n     * ```\n     */\n\n\n    deselect(items, event) {\n      if (items) {\n        const newSelection = this.selectionService.delete_items(this.id, items);\n        this.setSelection(newSelection, event);\n      }\n    }\n    /**\n     * Select all (filtered) items\n     *\n     * @param ignoreFilter if set to true, selects all items, otherwise selects only the filtered ones.\n     * ```typescript\n     * this.combo.selectAllItems();\n     * ```\n     */\n\n\n    selectAllItems(ignoreFilter, event) {\n      const allVisible = this.selectionService.get_all_ids(ignoreFilter ? this.data : this.filteredData, this.valueKey);\n      const newSelection = this.selectionService.add_items(this.id, allVisible);\n      this.setSelection(newSelection, event);\n    }\n    /**\n     * Deselect all (filtered) items\n     *\n     * @param ignoreFilter if set to true, deselects all items, otherwise deselects only the filtered ones.\n     * ```typescript\n     * this.combo.deselectAllItems();\n     * ```\n     */\n\n\n    deselectAllItems(ignoreFilter, event) {\n      let newSelection = this.selectionService.get_empty();\n\n      if (this.filteredData.length !== this.data.length && !ignoreFilter) {\n        newSelection = this.selectionService.delete_items(this.id, this.selectionService.get_all_ids(this.filteredData, this.valueKey));\n      }\n\n      this.setSelection(newSelection, event);\n    }\n    /**\n     * Selects/Deselects a single item\n     *\n     * @param itemID the itemID of the specific item\n     * @param select If the item should be selected (true) or deselected (false)\n     *\n     * Without specified valueKey;\n     * ```typescript\n     * this.combo.valueKey = null;\n     * const items: { field: string, region: string}[] = data;\n     * this.combo.setSelectedItem(items[0], true);\n     * ```\n     * With specified valueKey;\n     * ```typescript\n     * this.combo.valueKey = 'field';\n     * const items: { field: string, region: string}[] = data;\n     * this.combo.setSelectedItem('Connecticut', true);\n     * ```\n     */\n\n\n    setSelectedItem(itemID, select = true, event) {\n      if (itemID === null || itemID === undefined) {\n        return;\n      }\n\n      if (select) {\n        this.select([itemID], false, event);\n      } else {\n        this.deselect([itemID], event);\n      }\n    }\n    /** @hidden @internal */\n\n\n    handleOpened() {\n      this.triggerCheck(); // Disabling focus of the search input should happen only when drop down opens.\n      // During keyboard navigation input should receive focus, even the autoFocusSearch is disabled.\n      // That is why in such cases focusing of the dropdownContainer happens outside focusSearchInput method.\n\n      if (this.autoFocusSearch) {\n        this.focusSearchInput(true);\n      } else {\n        this.dropdownContainer.nativeElement.focus();\n      }\n\n      this.opened.emit({\n        owner: this\n      });\n    }\n    /** @hidden @internal */\n\n\n    focusSearchInput(opening) {\n      if (this.displaySearchInput && this.searchInput) {\n        this.searchInput.nativeElement.focus();\n      } else {\n        if (opening) {\n          this.dropdownContainer.nativeElement.focus();\n        } else {\n          this.comboInput.nativeElement.focus();\n          this.toggle();\n        }\n      }\n    }\n\n    setSelection(newSelection, event) {\n      const removed = diffInSets(this.selectionService.get(this.id), newSelection);\n      const added = diffInSets(newSelection, this.selectionService.get(this.id));\n      const newSelectionAsArray = Array.from(newSelection);\n      const oldSelectionAsArray = Array.from(this.selectionService.get(this.id) || []);\n      const displayText = this.createDisplayText(newSelectionAsArray, oldSelectionAsArray);\n      const args = {\n        newSelection: newSelectionAsArray,\n        oldSelection: oldSelectionAsArray,\n        added,\n        removed,\n        event,\n        owner: this,\n        displayText,\n        cancel: false\n      };\n      this.selectionChanging.emit(args);\n\n      if (!args.cancel) {\n        this.selectionService.select_items(this.id, args.newSelection, true);\n\n        if (displayText !== args.displayText) {\n          this._value = args.displayText;\n        } else {\n          this._value = this.createDisplayText(args.newSelection, args.oldSelection);\n        }\n\n        this._onChangeCallback(args.newSelection);\n      }\n    }\n\n    createDisplayText(newSelection, oldSelection) {\n      return this.isRemote ? this.getRemoteSelection(newSelection, oldSelection) : this.concatDisplayText(newSelection);\n    }\n    /** Returns a string that should be populated in the combo's text box */\n\n\n    concatDisplayText(selection) {\n      const value = this.displayKey !== null && this.displayKey !== undefined ? this.convertKeysToItems(selection).map(entry => entry[this.displayKey]).join(', ') : selection.join(', ');\n      return value;\n    }\n\n  }\n\n  IgxComboComponent.ɵfac = function IgxComboComponent_Factory(t) {\n    return new (t || IgxComboComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(IgxSelectionAPIService), i0.ɵɵdirectiveInject(IgxComboAPIService), i0.ɵɵdirectiveInject(IgxIconService), i0.ɵɵdirectiveInject(DisplayDensityToken, 8), i0.ɵɵdirectiveInject(IGX_INPUT_GROUP_TYPE, 8), i0.ɵɵdirectiveInject(i0.Injector, 8));\n  };\n\n  IgxComboComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxComboComponent,\n    selectors: [[\"igx-combo\"]],\n    viewQuery: function IgxComboComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxComboDropDownComponent, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropdown = _t.first);\n      }\n    },\n    inputs: {\n      autoFocusSearch: \"autoFocusSearch\",\n      filterable: \"filterable\",\n      searchPlaceholder: \"searchPlaceholder\"\n    },\n    outputs: {\n      selectionChanging: \"selectionChanging\"\n    },\n    features: [i0.ɵɵProvidersFeature([IgxComboAPIService, {\n      provide: IGX_COMBO_COMPONENT,\n      useExisting: IgxComboComponent\n    }, {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: IgxComboComponent,\n      multi: true\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c72,\n    decls: 37,\n    vars: 42,\n    consts: [[3, \"displayDensity\", \"type\", \"click\"], [\"inputGroup\", \"\"], [\"ngProjectAs\", \"[igxLabel]\", 5, [\"\", \"igxLabel\", \"\"]], [\"ngProjectAs\", \"igx-prefix\", 5, [\"igx-prefix\"]], [\"ngProjectAs\", \"igx-hint, [igxHint]\", 5, [\"igx-hint\"]], [\"igxInput\", \"\", \"name\", \"comboInput\", \"type\", \"text\", \"readonly\", \"\", 3, \"value\", \"disabled\", \"blur\"], [\"comboInput\", \"\"], [\"ngProjectAs\", \"igx-suffix\", 5, [\"igx-suffix\"]], [\"aria-label\", \"Clear Selection\", \"class\", \"igx-combo__clear-button\", 3, \"click\", 4, \"ngIf\"], [1, \"igx-combo__toggle-button\"], [4, \"ngIf\"], [1, \"igx-combo__drop-down\", 3, \"displayDensity\", \"width\", \"opening\", \"closing\", \"opened\", \"closed\"], [\"igxComboDropDown\", \"\"], [\"theme\", \"material\", \"class\", \"igx-combo__search\", 3, \"displayDensity\", 4, \"ngIf\"], [4, \"ngTemplateOutlet\"], [\"role\", \"listbox\", 1, \"igx-combo__content\", 3, \"igxDropDownItemNavigation\", \"tabindex\", \"focus\"], [\"dropdownItemContainer\", \"\"], [\"role\", \"option\", 3, \"itemHeight\", \"value\", \"isHeader\", \"index\", 4, \"igxFor\", \"igxForOf\", \"igxForContainerSize\", \"igxForScrollOrientation\", \"igxForItemSize\"], [\"class\", \"igx-combo__add\", 4, \"ngIf\"], [\"complex\", \"\"], [\"primitive\", \"\"], [\"empty\", \"\"], [\"addItemDefault\", \"\"], [\"headerItemBase\", \"\"], [\"aria-label\", \"Clear Selection\", 1, \"igx-combo__clear-button\", 3, \"click\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"theme\", \"material\", 1, \"igx-combo__search\", 3, \"displayDensity\"], [\"igxInput\", \"\", \"name\", \"searchInput\", \"autocomplete\", \"off\", \"type\", \"text\", \"aria-autocomplete\", \"both\", 1, \"igx-combo-input\", 3, \"ngModel\", \"ngModelChange\", \"keyup\", \"keydown\", \"focus\"], [\"searchInput\", \"\"], [\"family\", \"imx-icons\", \"name\", \"case-sensitive\", 3, \"active\", \"click\"], [\"role\", \"option\", 3, \"itemHeight\", \"value\", \"isHeader\", \"index\"], [\"listItem\", \"\"], [1, \"igx-combo__add\"], [\"class\", \"igx-combo__empty\", 4, \"ngIf\"], [\"class\", \"igx-combo__add-item\", \"role\", \"button\", \"aria-label\", \"Add Item\", 3, \"itemHeight\", \"tabindex\", \"index\", 4, \"ngIf\"], [1, \"igx-combo__empty\"], [\"role\", \"button\", \"aria-label\", \"Add Item\", 1, \"igx-combo__add-item\", 3, \"itemHeight\", \"tabindex\", \"index\"], [\"igxButton\", \"flat\", \"igxRipple\", \"\"]],\n    template: function IgxComboComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c70);\n        i0.ɵɵelementStart(0, \"igx-input-group\", 0, 1);\n        i0.ɵɵlistener(\"click\", function IgxComboComponent_Template_igx_input_group_click_0_listener($event) {\n          return ctx.onClick($event);\n        });\n        i0.ɵɵelementContainerStart(2, 2);\n        i0.ɵɵprojection(3);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementContainerStart(4, 3);\n        i0.ɵɵprojection(5, 1);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementContainerStart(6, 4);\n        i0.ɵɵprojection(7, 2);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementStart(8, \"input\", 5, 6);\n        i0.ɵɵlistener(\"blur\", function IgxComboComponent_Template_input_blur_8_listener() {\n          return ctx.onBlur();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementContainerStart(10, 7);\n        i0.ɵɵprojection(11, 3);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵtemplate(12, IgxComboComponent_igx_suffix_12_Template, 3, 2, \"igx-suffix\", 8);\n        i0.ɵɵelementStart(13, \"igx-suffix\", 9);\n        i0.ɵɵtemplate(14, IgxComboComponent_ng_container_14_Template, 2, 4, \"ng-container\", 10);\n        i0.ɵɵtemplate(15, IgxComboComponent_igx_icon_15_Template, 2, 1, \"igx-icon\", 10);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(16, \"igx-combo-drop-down\", 11, 12);\n        i0.ɵɵlistener(\"opening\", function IgxComboComponent_Template_igx_combo_drop_down_opening_16_listener($event) {\n          return ctx.handleOpening($event);\n        })(\"closing\", function IgxComboComponent_Template_igx_combo_drop_down_closing_16_listener($event) {\n          return ctx.handleClosing($event);\n        })(\"opened\", function IgxComboComponent_Template_igx_combo_drop_down_opened_16_listener() {\n          return ctx.handleOpened();\n        })(\"closed\", function IgxComboComponent_Template_igx_combo_drop_down_closed_16_listener() {\n          return ctx.handleClosed();\n        });\n        i0.ɵɵtemplate(18, IgxComboComponent_igx_input_group_18_Template, 4, 6, \"igx-input-group\", 13);\n        i0.ɵɵtemplate(19, IgxComboComponent_ng_container_19_Template, 1, 0, \"ng-container\", 14);\n        i0.ɵɵelementStart(20, \"div\", 15, 16);\n        i0.ɵɵlistener(\"focus\", function IgxComboComponent_Template_div_focus_20_listener() {\n          return ctx.dropdown.onFocus();\n        });\n        i0.ɵɵtemplate(22, IgxComboComponent_igx_combo_item_22_Template, 3, 6, \"igx-combo-item\", 17);\n        i0.ɵɵpipe(23, \"comboGrouping\");\n        i0.ɵɵpipe(24, \"comboFiltering\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(25, IgxComboComponent_div_25_Template, 3, 2, \"div\", 18);\n        i0.ɵɵtemplate(26, IgxComboComponent_ng_container_26_Template, 1, 0, \"ng-container\", 14);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(27, IgxComboComponent_ng_template_27_Template, 1, 1, \"ng-template\", null, 19, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(29, IgxComboComponent_ng_template_29_Template, 1, 1, \"ng-template\", null, 20, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(31, IgxComboComponent_ng_template_31_Template, 2, 0, \"ng-template\", null, 21, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(33, IgxComboComponent_ng_template_33_Template, 2, 0, \"ng-template\", null, 22, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(35, IgxComboComponent_ng_template_35_Template, 1, 1, \"ng-template\", null, 23, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"displayDensity\", ctx.displayDensity)(\"type\", ctx.type);\n        i0.ɵɵadvance(8);\n        i0.ɵɵproperty(\"value\", ctx.value)(\"disabled\", ctx.disabled);\n        i0.ɵɵattribute(\"placeholder\", ctx.placeholder);\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"ngIf\", ctx.value.length);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.toggleIconTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.toggleIconTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"displayDensity\", ctx.displayDensity)(\"width\", ctx.itemsWidth || \"100%\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.displaySearchInput);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.headerTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"overflow\", \"hidden\")(\"max-height\", ctx.itemsMaxHeight, \"px\");\n        i0.ɵɵproperty(\"igxDropDownItemNavigation\", ctx.dropdown)(\"tabindex\", ctx.dropdown.collapsed ? -1 : 0);\n        i0.ɵɵattribute(\"id\", ctx.dropdown.id);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"igxForOf\", i0.ɵɵpipeBind4(23, 25, i0.ɵɵpipeBindV(24, 30, i0.ɵɵpureFunction5(36, _c71, ctx.data, ctx.filterValue, ctx.displayKey, ctx.filteringOptions, ctx.filterable)), ctx.groupKey, ctx.valueKey, ctx.groupSortingDirection))(\"igxForContainerSize\", ctx.itemsMaxHeight)(\"igxForScrollOrientation\", \"vertical\")(\"igxForItemSize\", ctx.itemHeight);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.filteredData.length === 0 || ctx.isAddButtonVisible());\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.footerTemplate);\n      }\n    },\n    directives: function () {\n      return [IgxInputGroupComponent, IgxIconComponent, IgxComboDropDownComponent, IgxComboItemComponent, IgxComboAddItemComponent, IgxInputDirective, i4.NgIf, IgxSuffixDirective, i4.NgTemplateOutlet, i12.DefaultValueAccessor, i12.NgControlStatus, i12.NgModel, IgxDropDownItemNavigationDirective, IgxForOfDirective, IgxButtonDirective, IgxRippleDirective];\n    },\n    pipes: function () {\n      return [IgxComboGroupingPipe, IgxComboFilteringPipe];\n    },\n    encapsulation: 2\n  });\n  return IgxComboComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxComboModule = /*#__PURE__*/(() => {\n  class IgxComboModule {}\n\n  IgxComboModule.ɵfac = function IgxComboModule_Factory(t) {\n    return new (t || IgxComboModule)();\n  };\n\n  IgxComboModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxComboModule\n  });\n  IgxComboModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, FormsModule, IgxButtonModule, IgxCheckboxModule, IgxDropDownModule, IgxForOfModule, IgxIconModule, IgxInputGroupModule, IgxRippleModule, IgxToggleModule, ReactiveFormsModule], IgxInputGroupModule]\n  });\n  return IgxComboModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a drop-down list that provides filtering functionality, allowing users to choose a single option from a predefined list.\n *\n * @igxModule IgxSimpleComboModule\n * @igxTheme igx-combo-theme\n * @igxKeywords combobox, single combo selection\n * @igxGroup Grids & Lists\n *\n * @remarks\n * It provides the ability to filter items as well as perform single selection on the provided data.\n * Additionally, it exposes keyboard navigation and custom styling capabilities.\n * @example\n * ```html\n * <igx-simple-combo [itemsMaxHeight]=\"250\" [data]=\"locationData\"\n *  [displayKey]=\"'field'\" [valueKey]=\"'field'\"\n *  placeholder=\"Location\" searchPlaceholder=\"Search...\">\n * </igx-simple-combo>\n * ```\n */\n\n\nlet IgxSimpleComboComponent = /*#__PURE__*/(() => {\n  class IgxSimpleComboComponent extends IgxComboBaseDirective {\n    constructor(elementRef, cdr, selectionService, comboAPI, _iconService, platformUtil, _displayDensityOptions, _inputGroupType, _injector) {\n      super(elementRef, cdr, selectionService, comboAPI, _iconService, _displayDensityOptions, _inputGroupType, _injector);\n      this.elementRef = elementRef;\n      this.cdr = cdr;\n      this.selectionService = selectionService;\n      this.comboAPI = comboAPI;\n      this._iconService = _iconService;\n      this.platformUtil = platformUtil;\n      this._displayDensityOptions = _displayDensityOptions;\n      this._inputGroupType = _inputGroupType;\n      this._injector = _injector;\n      /**\n       * Emitted when item selection is changing, before the selection completes\n       *\n       * ```html\n       * <igx-simple-combo (selectionChanging)='handleSelection()'></igx-simple-combo>\n       * ```\n       */\n\n      this.selectionChanging = new EventEmitter();\n      /** @hidden @internal */\n\n      this.composing = false;\n      this._updateInput = true; // stores the last filtered value - move to common?\n\n      this._internalFilter = '';\n\n      this.findMatch = element => {\n        const value = this.displayKey ? element[this.displayKey] : element;\n\n        if (value === null || value === undefined || value === '') {\n          // we can accept null, undefined and empty strings as empty display values\n          return true;\n        }\n\n        const searchValue = this.searchValue || this.comboInput.value;\n        return !!searchValue && value.toString().toLowerCase().includes(searchValue.trim().toLowerCase());\n      };\n\n      this.comboAPI.register(this);\n    }\n    /** @hidden @internal */\n\n\n    get filteredData() {\n      return this._filteredData;\n    }\n    /** @hidden @internal */\n\n\n    set filteredData(val) {\n      this._filteredData = this.groupKey ? (val || []).filter(e => e.isHeader !== true) : val;\n      this.checkMatch();\n    }\n    /** @hidden @internal */\n\n\n    get searchValue() {\n      return this._searchValue;\n    }\n\n    set searchValue(val) {\n      this._searchValue = val;\n    }\n\n    get selectedItem() {\n      return this.selectionService.get(this.id).values().next().value;\n    }\n    /** @hidden @internal */\n\n\n    onArrowDown(event) {\n      if (this.collapsed) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.open();\n      } else {\n        if (this.virtDir.igxForOf.length > 0) {\n          this.dropdown.navigateFirst();\n          this.dropdownContainer.nativeElement.focus();\n        } else if (this.allowCustomValues) {\n          this.addItem.element.nativeElement.focus();\n        }\n      }\n    }\n    /**\n     * Select a defined item\n     *\n     * @param item the item to be selected\n     * ```typescript\n     * this.combo.select(\"New York\");\n     * ```\n     */\n\n\n    select(item) {\n      if (item !== null && item !== undefined) {\n        const newSelection = this.selectionService.add_items(this.id, item instanceof Array ? item : [item], true);\n        this.setSelection(newSelection);\n      }\n    }\n    /**\n     * Deselect the currently selected item\n     *\n     * @param item the items to be deselected\n     * ```typescript\n     * this.combo.deselect(\"New York\");\n     * ```\n     */\n\n\n    deselect() {\n      this.clearSelection();\n    }\n    /** @hidden @internal */\n\n\n    writeValue(value) {\n      const oldSelection = this.selection;\n      this.selectionService.select_items(this.id, value ? [value] : [], true);\n      this.cdr.markForCheck();\n      this._value = this.createDisplayText(this.selection, oldSelection);\n    }\n    /** @hidden @internal */\n\n\n    ngAfterViewInit() {\n      this.virtDir.contentSizeChange.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        if (this.selection.length > 0) {\n          const index = this.virtDir.igxForOf.findIndex(e => {\n            let current = e[this.valueKey];\n\n            if (this.valueKey === null || this.valueKey === undefined) {\n              current = e;\n            }\n\n            return current === this.selection[0];\n          });\n          this.dropdown.navigateItem(index);\n        }\n      });\n      this.dropdown.opening.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        const filtered = this.filteredData.find(this.findMatch);\n\n        if (filtered === undefined || filtered === null) {\n          this.filterValue = this.searchValue = this.comboInput.value;\n          return;\n        }\n\n        this.filterValue = this.searchValue = '';\n      });\n      this.dropdown.opened.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        if (this.composing) {\n          this.comboInput.focus();\n        }\n\n        this._internalFilter = this.comboInput.value;\n      });\n      this.dropdown.closing.pipe(takeUntil(this.destroy$)).subscribe(args => {\n        if (this.getEditElement() && !args.event) {\n          this.comboInput.focus();\n        } else {\n          this.clearOnBlur();\n\n          this._onTouchedCallback();\n        }\n      });\n      this.dropdown.closed.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        this.filterValue = this._internalFilter = this.comboInput.value;\n      });\n      super.ngAfterViewInit();\n    }\n    /** @hidden @internal */\n\n\n    handleInputChange(event) {\n      if (event !== undefined) {\n        this.filterValue = this._internalFilter = this.searchValue = typeof event === 'string' ? event : event.target.value;\n      }\n\n      this._onChangeCallback(this.searchValue);\n\n      if (this.collapsed && this.comboInput.focused) {\n        this.open();\n      }\n\n      if (!this.comboInput.value.trim()) {\n        // handle clearing of input by space\n        this.clearSelection();\n\n        this._onChangeCallback(null);\n      } // when filtering the focused item should be the first item or the currently selected item\n\n\n      if (!this.dropdown.focusedItem || this.dropdown.focusedItem.id !== this.dropdown.items[0].id) {\n        this.dropdown.navigateFirst();\n      }\n\n      super.handleInputChange(event);\n      this.composing = true;\n    }\n    /** @hidden @internal */\n\n\n    handleKeyDown(event) {\n      if (event.key === this.platformUtil.KEYMAP.ENTER) {\n        const filtered = this.filteredData.find(this.findMatch);\n\n        if (filtered === null || filtered === undefined) {\n          return;\n        }\n\n        this.select(this.dropdown.focusedItem.itemID);\n        event.preventDefault();\n        event.stopPropagation();\n        this.close(); // manually trigger text selection as it will not be triggered during editing\n\n        this.textSelection.trigger();\n        this.filterValue = this.getElementVal(filtered);\n        return;\n      }\n\n      if (event.key === this.platformUtil.KEYMAP.BACKSPACE || event.key === this.platformUtil.KEYMAP.DELETE) {\n        this._updateInput = false;\n        this.clearSelection(true);\n      }\n\n      if (!this.collapsed && event.key === this.platformUtil.KEYMAP.TAB) {\n        this.clearOnBlur();\n      }\n\n      this.composing = false;\n      super.handleKeyDown(event);\n    }\n    /** @hidden @internal */\n\n\n    handleKeyUp(event) {\n      if (event.key === this.platformUtil.KEYMAP.ARROW_DOWN) {\n        const firstItem = this.selectionService.first_item(this.id);\n        this.dropdown.focusedItem = firstItem && this.filteredData.length > 0 ? this.dropdown.items.find(i => i.itemID === firstItem) : this.dropdown.items[0];\n        this.dropdownContainer.nativeElement.focus();\n      }\n    }\n    /** @hidden @internal */\n\n\n    handleItemKeyDown(event) {\n      if (event.key === this.platformUtil.KEYMAP.ARROW_UP && event.altKey) {\n        this.close();\n        this.comboInput.focus();\n        return;\n      }\n\n      if (event.key === this.platformUtil.KEYMAP.ENTER) {\n        this.comboInput.focus();\n      }\n    }\n    /** @hidden @internal */\n\n\n    handleItemClick() {\n      this.close();\n      this.comboInput.focus();\n    }\n    /** @hidden @internal */\n\n\n    onBlur() {\n      if (this.collapsed) {\n        this.clearOnBlur();\n      }\n\n      super.onBlur();\n    }\n    /** @hidden @internal */\n\n\n    onFocus() {\n      this._internalFilter = this.comboInput.value || '';\n    }\n    /** @hidden @internal */\n\n\n    getEditElement() {\n      return this.comboInput.nativeElement;\n    }\n    /** @hidden @internal */\n\n\n    handleClear(event) {\n      if (this.disabled) {\n        return;\n      }\n\n      this.clearSelection(true);\n\n      if (this.collapsed) {\n        this.open();\n        this.dropdown.navigateFirst();\n      } else {\n        this.focusSearchInput(true);\n      }\n\n      event.stopPropagation();\n      this.comboInput.value = this.filterValue = this.searchValue = '';\n      this.dropdown.focusedItem = null;\n      this.composing = false;\n      this.comboInput.focus();\n    }\n    /** @hidden @internal */\n\n\n    handleOpened() {\n      this.triggerCheck();\n      this.dropdownContainer.nativeElement.focus();\n      this.opened.emit({\n        owner: this\n      });\n    }\n    /** @hidden @internal */\n\n\n    handleClosing(e) {\n      const args = {\n        owner: this,\n        event: e.event,\n        cancel: e.cancel\n      };\n      this.closing.emit(args);\n      e.cancel = args.cancel;\n\n      if (e.cancel) {\n        return;\n      }\n\n      this.composing = false; // explicitly update selection and trigger text selection so that we don't have to force CD\n\n      this.textSelection.selected = true;\n      this.textSelection.trigger();\n    }\n    /** @hidden @internal */\n\n\n    focusSearchInput(opening) {\n      if (opening) {\n        this.dropdownContainer.nativeElement.focus();\n      } else {\n        this.comboInput.nativeElement.focus();\n        this.toggle();\n      }\n    }\n    /** @hidden @internal */\n\n\n    onClick(event) {\n      super.onClick(event);\n\n      if (this.comboInput.value.length === 0) {\n        this.virtDir.scrollTo(0);\n      }\n    }\n\n    setSelection(newSelection) {\n      const newSelectionAsArray = newSelection ? Array.from(newSelection) : [];\n      const oldSelectionAsArray = Array.from(this.selectionService.get(this.id) || []);\n      const displayText = this.createDisplayText(newSelectionAsArray, oldSelectionAsArray);\n      const args = {\n        newSelection: newSelectionAsArray[0],\n        oldSelection: oldSelectionAsArray[0],\n        displayText,\n        owner: this,\n        cancel: false\n      };\n      this.selectionChanging.emit(args);\n\n      if (!args.cancel) {\n        let argsSelection = args.newSelection !== undefined && args.newSelection !== null ? args.newSelection : [];\n        argsSelection = Array.isArray(argsSelection) ? argsSelection : [argsSelection];\n        this.selectionService.select_items(this.id, argsSelection, true);\n\n        if (this._updateInput) {\n          this.comboInput.value = this._internalFilter = this._value = displayText !== args.displayText ? args.displayText : this.createDisplayText(argsSelection, [args.oldSelection]);\n        }\n\n        this._onChangeCallback(args.newSelection);\n\n        this._updateInput = true;\n      }\n    }\n\n    createDisplayText(newSelection, oldSelection) {\n      if (this.isRemote) {\n        return this.getRemoteSelection(newSelection, oldSelection);\n      }\n\n      if (this.displayKey !== null && this.displayKey !== undefined && newSelection.length > 0) {\n        return this.convertKeysToItems(newSelection).map(e => e[this.displayKey])[0];\n      }\n\n      return newSelection[0] || '';\n    }\n\n    clearSelection(ignoreFilter) {\n      let newSelection = this.selectionService.get_empty();\n\n      if (this.filteredData.length !== this.data.length && !ignoreFilter) {\n        newSelection = this.selectionService.delete_items(this.id, this.selectionService.get_all_ids(this.filteredData, this.valueKey));\n      }\n\n      this.setSelection(newSelection);\n    }\n\n    clearOnBlur() {\n      const filtered = this.filteredData.find(this.findMatch);\n\n      if (filtered === undefined || filtered === null || !this.selectedItem) {\n        this.clearAndClose();\n        return;\n      }\n\n      if (this.isPartialMatch(filtered) || this.getElementVal(filtered) !== this._internalFilter) {\n        this.clearAndClose();\n      }\n    }\n\n    isPartialMatch(filtered) {\n      return !!this._internalFilter && this._internalFilter.length !== this.getElementVal(filtered).length;\n    }\n\n    getElementVal(element) {\n      if (!element) {\n        return null;\n      }\n\n      const elementVal = this.displayKey ? element[this.displayKey] : element;\n      return (elementVal === 0 ? '0' : elementVal) || '';\n    }\n\n    clearAndClose() {\n      this.clearSelection(true);\n      this._internalFilter = '';\n      this.searchValue = '';\n\n      if (!this.collapsed) {\n        this.close();\n      }\n    }\n\n  }\n\n  IgxSimpleComboComponent.ɵfac = function IgxSimpleComboComponent_Factory(t) {\n    return new (t || IgxSimpleComboComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(IgxSelectionAPIService), i0.ɵɵdirectiveInject(IgxComboAPIService), i0.ɵɵdirectiveInject(IgxIconService), i0.ɵɵdirectiveInject(PlatformUtil), i0.ɵɵdirectiveInject(DisplayDensityToken, 8), i0.ɵɵdirectiveInject(IGX_INPUT_GROUP_TYPE, 8), i0.ɵɵdirectiveInject(i0.Injector, 8));\n  };\n\n  IgxSimpleComboComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxSimpleComboComponent,\n    selectors: [[\"igx-simple-combo\"]],\n    viewQuery: function IgxSimpleComboComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxComboDropDownComponent, 7);\n        i0.ɵɵviewQuery(IgxComboAddItemComponent, 5);\n        i0.ɵɵviewQuery(IgxTextSelectionDirective, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropdown = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.addItem = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.textSelection = _t.first);\n      }\n    },\n    hostBindings: function IgxSimpleComboComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown.ArrowDown\", function IgxSimpleComboComponent_keydown_ArrowDown_HostBindingHandler($event) {\n          return ctx.onArrowDown($event);\n        })(\"keydown.Alt.ArrowDown\", function IgxSimpleComboComponent_keydown_Alt_ArrowDown_HostBindingHandler($event) {\n          return ctx.onArrowDown($event);\n        });\n      }\n    },\n    outputs: {\n      selectionChanging: \"selectionChanging\"\n    },\n    features: [i0.ɵɵProvidersFeature([IgxComboAPIService, {\n      provide: IGX_COMBO_COMPONENT,\n      useExisting: IgxSimpleComboComponent\n    }, {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: IgxSimpleComboComponent,\n      multi: true\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c72,\n    decls: 38,\n    vars: 48,\n    consts: [[3, \"displayDensity\", \"suppressInputAutofocus\", \"type\"], [\"inputGroup\", \"\"], [\"ngProjectAs\", \"[igxLabel]\", 5, [\"\", \"igxLabel\", \"\"]], [\"ngProjectAs\", \"igx-prefix\", 5, [\"igx-prefix\"]], [\"ngProjectAs\", \"igx-hint, [igxHint]\", 5, [\"igx-hint\"]], [\"igxInput\", \"\", \"aria-autocomplete\", \"both\", 3, \"value\", \"disabled\", \"igxTextSelection\", \"focus\", \"input\", \"keyup\", \"keydown\", \"blur\"], [\"comboInput\", \"\"], [\"ngProjectAs\", \"igx-suffix\", 5, [\"igx-suffix\"]], [\"aria-label\", \"Clear Selection\", \"class\", \"igx-combo__clear-button\", 3, \"click\", 4, \"ngIf\"], [4, \"ngIf\"], [1, \"igx-combo__toggle-button\"], [3, \"click\", 4, \"ngIf\"], [1, \"igx-combo__drop-down\", 3, \"displayDensity\", \"width\", \"singleMode\", \"opening\", \"closing\", \"opened\", \"closed\"], [\"igxComboDropDown\", \"\"], [4, \"ngTemplateOutlet\"], [\"role\", \"listbox\", 1, \"igx-combo__content\", 3, \"igxDropDownItemNavigation\", \"tabindex\", \"focus\", \"keydown\"], [\"dropdownItemContainer\", \"\"], [\"role\", \"option\", 3, \"singleMode\", \"itemHeight\", \"value\", \"isHeader\", \"index\", \"click\", 4, \"igxFor\", \"igxForOf\", \"igxForContainerSize\", \"igxForScrollOrientation\", \"igxForItemSize\"], [\"class\", \"igx-combo__add\", 4, \"ngIf\"], [\"complex\", \"\"], [\"primitive\", \"\"], [\"empty\", \"\"], [\"addItemDefault\", \"\"], [\"headerItemBase\", \"\"], [\"aria-label\", \"Clear Selection\", 1, \"igx-combo__clear-button\", 3, \"click\"], [\"family\", \"imx-icons\", \"name\", \"case-sensitive\", 3, \"active\", \"click\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [3, \"click\"], [\"role\", \"option\", 3, \"singleMode\", \"itemHeight\", \"value\", \"isHeader\", \"index\", \"click\"], [\"listItem\", \"\"], [1, \"igx-combo__add\"], [\"class\", \"igx-combo__empty\", 4, \"ngIf\"], [\"class\", \"igx-combo__add-item\", \"role\", \"button\", \"aria-label\", \"Add Item\", 3, \"itemHeight\", \"tabindex\", \"index\", 4, \"ngIf\"], [1, \"igx-combo__empty\"], [\"role\", \"button\", \"aria-label\", \"Add Item\", 1, \"igx-combo__add-item\", 3, \"itemHeight\", \"tabindex\", \"index\"], [\"addItem\", \"\"], [\"igxButton\", \"flat\", \"igxRipple\", \"\"]],\n    template: function IgxSimpleComboComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c70);\n        i0.ɵɵelementStart(0, \"igx-input-group\", 0, 1);\n        i0.ɵɵelementContainerStart(2, 2);\n        i0.ɵɵprojection(3);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementContainerStart(4, 3);\n        i0.ɵɵprojection(5, 1);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementContainerStart(6, 4);\n        i0.ɵɵprojection(7, 2);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementStart(8, \"input\", 5, 6);\n        i0.ɵɵlistener(\"focus\", function IgxSimpleComboComponent_Template_input_focus_8_listener() {\n          return ctx.onFocus();\n        })(\"input\", function IgxSimpleComboComponent_Template_input_input_8_listener($event) {\n          return ctx.handleInputChange($event);\n        })(\"keyup\", function IgxSimpleComboComponent_Template_input_keyup_8_listener($event) {\n          return ctx.handleKeyUp($event);\n        })(\"keydown\", function IgxSimpleComboComponent_Template_input_keydown_8_listener($event) {\n          return ctx.handleKeyDown($event);\n        })(\"blur\", function IgxSimpleComboComponent_Template_input_blur_8_listener() {\n          return ctx.onBlur();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementContainerStart(10, 7);\n        i0.ɵɵprojection(11, 3);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵtemplate(12, IgxSimpleComboComponent_igx_suffix_12_Template, 3, 2, \"igx-suffix\", 8);\n        i0.ɵɵtemplate(13, IgxSimpleComboComponent_igx_suffix_13_Template, 2, 1, \"igx-suffix\", 9);\n        i0.ɵɵelementStart(14, \"igx-suffix\", 10);\n        i0.ɵɵtemplate(15, IgxSimpleComboComponent_ng_container_15_Template, 2, 4, \"ng-container\", 9);\n        i0.ɵɵtemplate(16, IgxSimpleComboComponent_igx_icon_16_Template, 2, 1, \"igx-icon\", 11);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(17, \"igx-combo-drop-down\", 12, 13);\n        i0.ɵɵlistener(\"opening\", function IgxSimpleComboComponent_Template_igx_combo_drop_down_opening_17_listener($event) {\n          return ctx.handleOpening($event);\n        })(\"closing\", function IgxSimpleComboComponent_Template_igx_combo_drop_down_closing_17_listener($event) {\n          return ctx.handleClosing($event);\n        })(\"opened\", function IgxSimpleComboComponent_Template_igx_combo_drop_down_opened_17_listener() {\n          return ctx.handleOpened();\n        })(\"closed\", function IgxSimpleComboComponent_Template_igx_combo_drop_down_closed_17_listener() {\n          return ctx.handleClosed();\n        });\n        i0.ɵɵtemplate(19, IgxSimpleComboComponent_ng_container_19_Template, 1, 0, \"ng-container\", 14);\n        i0.ɵɵelementStart(20, \"div\", 15, 16);\n        i0.ɵɵlistener(\"focus\", function IgxSimpleComboComponent_Template_div_focus_20_listener() {\n          return ctx.dropdown.onFocus();\n        })(\"keydown\", function IgxSimpleComboComponent_Template_div_keydown_20_listener($event) {\n          return ctx.handleItemKeyDown($event);\n        });\n        i0.ɵɵtemplate(22, IgxSimpleComboComponent_igx_combo_item_22_Template, 3, 7, \"igx-combo-item\", 17);\n        i0.ɵɵpipe(23, \"comboGrouping\");\n        i0.ɵɵpipe(24, \"comboFiltering\");\n        i0.ɵɵpipe(25, \"comboClean\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(26, IgxSimpleComboComponent_div_26_Template, 3, 2, \"div\", 18);\n        i0.ɵɵtemplate(27, IgxSimpleComboComponent_ng_container_27_Template, 1, 0, \"ng-container\", 14);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(28, IgxSimpleComboComponent_ng_template_28_Template, 1, 1, \"ng-template\", null, 19, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(30, IgxSimpleComboComponent_ng_template_30_Template, 1, 1, \"ng-template\", null, 20, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(32, IgxSimpleComboComponent_ng_template_32_Template, 2, 0, \"ng-template\", null, 21, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(34, IgxSimpleComboComponent_ng_template_34_Template, 2, 0, \"ng-template\", null, 22, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(36, IgxSimpleComboComponent_ng_template_36_Template, 1, 1, \"ng-template\", null, 23, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        const _r1 = i0.ɵɵreference(9);\n\n        i0.ɵɵproperty(\"displayDensity\", ctx.displayDensity)(\"suppressInputAutofocus\", true)(\"type\", ctx.type);\n        i0.ɵɵadvance(8);\n        i0.ɵɵproperty(\"value\", ctx.value)(\"disabled\", ctx.disabled)(\"igxTextSelection\", !ctx.composing);\n        i0.ɵɵattribute(\"placeholder\", ctx.placeholder)(\"aria-owns\", ctx.dropdown.id)(\"aria-labelledby\", ctx.ariaLabelledBy);\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"ngIf\", _r1.value.length);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showSearchCaseIcon);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.toggleIconTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.toggleIconTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"displayDensity\", ctx.displayDensity)(\"width\", ctx.itemsWidth || \"100%\")(\"singleMode\", true);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.headerTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"overflow\", \"hidden\")(\"max-height\", ctx.itemsMaxHeight, \"px\");\n        i0.ɵɵproperty(\"igxDropDownItemNavigation\", ctx.dropdown)(\"tabindex\", ctx.dropdown.collapsed ? -1 : 0);\n        i0.ɵɵattribute(\"id\", ctx.dropdown.id);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"igxForOf\", i0.ɵɵpipeBind4(23, 30, i0.ɵɵpipeBindV(24, 35, i0.ɵɵpureFunction4(43, _c73, i0.ɵɵpipeBind1(25, 41, ctx.data), ctx.filterValue, ctx.displayKey, ctx.filteringOptions)), ctx.groupKey, ctx.valueKey, ctx.groupSortingDirection))(\"igxForContainerSize\", ctx.itemsMaxHeight)(\"igxForScrollOrientation\", \"vertical\")(\"igxForItemSize\", ctx.itemHeight);\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"ngIf\", ctx.filteredData.length === 0 || ctx.isAddButtonVisible());\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.footerTemplate);\n      }\n    },\n    directives: [IgxInputGroupComponent, IgxIconComponent, IgxComboDropDownComponent, IgxComboItemComponent, IgxComboAddItemComponent, IgxInputDirective, IgxTextSelectionDirective, i4.NgIf, IgxSuffixDirective, i4.NgTemplateOutlet, IgxDropDownItemNavigationDirective, IgxForOfDirective, IgxButtonDirective, IgxRippleDirective],\n    pipes: [IgxComboGroupingPipe, IgxComboFilteringPipe, IgxComboCleanPipe],\n    encapsulation: 2\n  });\n  return IgxSimpleComboComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxSimpleComboModule = /*#__PURE__*/(() => {\n  class IgxSimpleComboModule {}\n\n  IgxSimpleComboModule.ɵfac = function IgxSimpleComboModule_Factory(t) {\n    return new (t || IgxSimpleComboModule)();\n  };\n\n  IgxSimpleComboModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxSimpleComboModule\n  });\n  IgxSimpleComboModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[IgxComboModule, IgxRippleModule, CommonModule, IgxInputGroupModule, FormsModule, ReactiveFormsModule, IgxForOfModule, IgxToggleModule, IgxCheckboxModule, IgxDropDownModule, IgxButtonModule, IgxIconModule, IgxTextSelectionModule], IgxComboModule]\n  });\n  return IgxSimpleComboModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** Header orientation in `dialog` mode. */\n\n\nconst PickerHeaderOrientation = mkenum({\n  Horizontal: 'horizontal',\n  Vertical: 'vertical'\n});\n/**\n * This enumeration is used to configure whether the date/time picker has an editable input with drop down\n * or is readonly - the date/time is selected only through a dialog.\n */\n\nconst PickerInteractionMode = mkenum({\n  DropDown: 'dropdown',\n  Dialog: 'dialog'\n});\n/** @hidden */\n\nlet IgxCalendarContainerComponent = /*#__PURE__*/(() => {\n  class IgxCalendarContainerComponent {\n    constructor() {\n      this.calendarClose = new EventEmitter();\n      this.todaySelection = new EventEmitter();\n      this.styleClass = 'igx-date-picker';\n      this.vertical = false;\n      this.mode = PickerInteractionMode.DropDown;\n    }\n\n    get dropdownCSS() {\n      return this.mode === PickerInteractionMode.DropDown;\n    }\n\n    get verticalCSS() {\n      return this.vertical && this.mode === PickerInteractionMode.Dialog;\n    }\n\n    onEscape(event) {\n      event.preventDefault();\n      this.calendarClose.emit();\n    }\n\n    get isReadonly() {\n      return this.mode === PickerInteractionMode.Dialog;\n    }\n\n  }\n\n  IgxCalendarContainerComponent.ɵfac = function IgxCalendarContainerComponent_Factory(t) {\n    return new (t || IgxCalendarContainerComponent)();\n  };\n\n  IgxCalendarContainerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxCalendarContainerComponent,\n    selectors: [[\"igx-calendar-container\"]],\n    viewQuery: function IgxCalendarContainerComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxCalendarComponent, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.calendar = _t.first);\n      }\n    },\n    hostVars: 6,\n    hostBindings: function IgxCalendarContainerComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown.alt.arrowup\", function IgxCalendarContainerComponent_keydown_alt_arrowup_HostBindingHandler($event) {\n          return ctx.onEscape($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-date-picker\", ctx.styleClass)(\"igx-date-picker--dropdown\", ctx.dropdownCSS)(\"igx-date-picker--vertical\", ctx.verticalCSS);\n      }\n    },\n    outputs: {\n      calendarClose: \"calendarClose\",\n      todaySelection: \"todaySelection\"\n    },\n    decls: 4,\n    vars: 4,\n    consts: [[\"defaultPickerActions\", \"\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"class\", \"igx-date-picker__buttons\", 4, \"ngIf\"], [1, \"igx-date-picker__buttons\"], [\"igxButton\", \"flat\", \"igxRipple\", \"\", 3, \"click\", 4, \"ngIf\"], [\"igxButton\", \"flat\", \"igxRipple\", \"\", 3, \"click\"], [\"closeButton\", \"\"], [\"todayButton\", \"\"]],\n    template: function IgxCalendarContainerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxCalendarContainerComponent_ng_template_0_Template, 1, 1, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelement(2, \"igx-calendar\");\n        i0.ɵɵtemplate(3, IgxCalendarContainerComponent_ng_container_3_Template, 1, 0, \"ng-container\", 1);\n      }\n\n      if (rf & 2) {\n        const _r0 = i0.ɵɵreference(1);\n\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", (ctx.pickerActions == null ? null : ctx.pickerActions.template) || _r0)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c24, ctx.calendar));\n      }\n    },\n    directives: [IgxCalendarComponent, i4.NgIf, IgxButtonDirective, IgxRippleDirective, i4.NgTemplateOutlet],\n    styles: [\"[_nghost-%COMP%]{display:block}\"]\n  });\n  return IgxCalendarContainerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxCalendarContainerModule = /*#__PURE__*/(() => {\n  class IgxCalendarContainerModule {}\n\n  IgxCalendarContainerModule.ɵfac = function IgxCalendarContainerModule_Factory(t) {\n    return new (t || IgxCalendarContainerModule)();\n  };\n\n  IgxCalendarContainerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxCalendarContainerModule\n  });\n  IgxCalendarContainerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, IgxButtonModule, IgxRippleModule, IgxCalendarModule]]\n  });\n  return IgxCalendarContainerModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Templates the default toggle icon in the picker.\n *\n * @remarks Can be applied to IgxDatePickerComponent, IgxTimePickerComponent, IgxDateRangePickerComponent\n *\n * @example\n * ```html\n * <igx-date-range-picker>\n *   <igx-picker-toggle igxSuffix>\n *      <igx-icon>calendar_view_day</igx-icon>\n *   </igx-picker-toggle>\n * </igx-date-range-picker>\n * ```\n */\n\n\nlet IgxPickerToggleComponent = /*#__PURE__*/(() => {\n  class IgxPickerToggleComponent {\n    constructor() {\n      this.clicked = new EventEmitter();\n    }\n\n    onClick(event) {\n      // do not focus input on click\n      event.stopPropagation();\n      this.clicked.emit();\n    }\n\n  }\n\n  IgxPickerToggleComponent.ɵfac = function IgxPickerToggleComponent_Factory(t) {\n    return new (t || IgxPickerToggleComponent)();\n  };\n\n  IgxPickerToggleComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxPickerToggleComponent,\n    selectors: [[\"igx-picker-toggle\"]],\n    hostBindings: function IgxPickerToggleComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function IgxPickerToggleComponent_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n    },\n    outputs: {\n      clicked: \"clicked\"\n    },\n    ngContentSelectors: _c8,\n    decls: 1,\n    vars: 0,\n    template: function IgxPickerToggleComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxPickerToggleComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Templates the default clear icon in the picker.\n *\n * @remarks Can be applied to IgxDatePickerComponent, IgxTimePickerComponent, IgxDateRangePickerComponent\n *\n * @example\n * ```html\n * <igx-date-picker>\n *   <igx-picker-clear igxSuffix>\n *      <igx-icon>delete</igx-icon>\n *   </igx-picker-clear>\n * </igx-date-picker>\n * ```\n */\n\n\nlet IgxPickerClearComponent = /*#__PURE__*/(() => {\n  class IgxPickerClearComponent extends IgxPickerToggleComponent {}\n\n  IgxPickerClearComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxPickerClearComponent_BaseFactory;\n    return function IgxPickerClearComponent_Factory(t) {\n      return (ɵIgxPickerClearComponent_BaseFactory || (ɵIgxPickerClearComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxPickerClearComponent)))(t || IgxPickerClearComponent);\n    };\n  }();\n\n  IgxPickerClearComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxPickerClearComponent,\n    selectors: [[\"igx-picker-clear\"]],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c8,\n    decls: 1,\n    vars: 0,\n    template: function IgxPickerClearComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxPickerClearComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * IgxPickerActionsDirective can be used to re-template the dropdown/dialog action buttons.\n *\n * @remarks Can be applied to IgxDatePickerComponent, IgxTimePickerComponent, IgxDateRangePickerComponent\n *\n */\n\n\nlet IgxPickerActionsDirective = /*#__PURE__*/(() => {\n  class IgxPickerActionsDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxPickerActionsDirective.ɵfac = function IgxPickerActionsDirective_Factory(t) {\n    return new (t || IgxPickerActionsDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxPickerActionsDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxPickerActionsDirective,\n    selectors: [[\"\", \"igxPickerActions\", \"\"]]\n  });\n  return IgxPickerActionsDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxPickersCommonModule = /*#__PURE__*/(() => {\n  class IgxPickersCommonModule {}\n\n  IgxPickersCommonModule.ɵfac = function IgxPickersCommonModule_Factory(t) {\n    return new (t || IgxPickersCommonModule)();\n  };\n\n  IgxPickersCommonModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxPickersCommonModule\n  });\n  IgxPickersCommonModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return IgxPickersCommonModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet PickerBaseDirective = /*#__PURE__*/(() => {\n  class PickerBaseDirective extends DisplayDensityBase {\n    constructor(element, _localeId, _displayDensityOptions, _inputGroupType) {\n      super(_displayDensityOptions || {\n        displayDensity: 'comfortable'\n      });\n      this.element = element;\n      this._localeId = _localeId;\n      this._displayDensityOptions = _displayDensityOptions;\n      this._inputGroupType = _inputGroupType;\n      /**\n       * Sets the `placeholder` of the picker's input.\n       *\n       * @example\n       * ```html\n       * <igx-date-picker [placeholder]=\"'Choose your date'\"></igx-date-picker>\n       * ```\n       */\n\n      this.placeholder = '';\n      /**\n       * Can be `dropdown` with editable input field or `dialog` with readonly input field.\n       *\n       * @remarks\n       * Default mode is `dropdown`\n       *\n       * @example\n       * ```html\n       * <igx-date-picker mode=\"dialog\"></igx-date-picker>\n       * ```\n       */\n\n      this.mode = PickerInteractionMode.DropDown;\n      /**\n       * Enables or disables the picker.\n       *\n       * @example\n       * ```html\n       * <igx-date-picker [disabled]=\"'true'\"></igx-date-picker>\n       * ```\n       */\n\n      this.disabled = false;\n      /**\n       * Emitted when the calendar has started opening, cancelable.\n       *\n       * @example\n       * ```html\n       * <igx-date-picker (opening)=\"handleOpening($event)\"></igx-date-picker>\n       * ```\n       */\n\n      this.opening = new EventEmitter();\n      /**\n       * Emitted after the calendar has opened.\n       *\n       * @example\n       * ```html\n       * <igx-date-picker (opened)=\"handleOpened($event)\"></igx-date-picker>\n       * ```\n       */\n\n      this.opened = new EventEmitter();\n      /**\n       * Emitted when the calendar has started closing, cancelable.\n       *\n       * @example\n       * ```html\n       * <igx-date-picker (closing)=\"handleClosing($event)\"></igx-date-picker>\n       * ```\n       */\n\n      this.closing = new EventEmitter();\n      /**\n       * Emitted after the calendar has closed.\n       *\n       * @example\n       * ```html\n       * <igx-date-picker (closed)=\"handleClosed($event)\"></igx-date-picker>\n       * ```\n       */\n\n      this.closed = new EventEmitter();\n      this._collapsed = true;\n      this._destroy$ = new Subject();\n      this.locale = this.locale || this._localeId;\n    }\n    /**\n     * Determines how the picker's input will be styled.\n     *\n     * @remarks\n     * Default is `box`.\n     *\n     * @example\n     * ```html\n     * <igx-date-picker [type]=\"'line'\"></igx-date-picker>\n     * ```\n     */\n\n\n    set type(val) {\n      this._type = val;\n    }\n\n    get type() {\n      return this._type || this._inputGroupType;\n    }\n    /**\n     * Gets the picker's pop-up state.\n     *\n     * @example\n     * ```typescript\n     * const state = this.picker.collapsed;\n     * ```\n     */\n\n\n    get collapsed() {\n      return this._collapsed;\n    }\n    /** @hidden @internal */\n\n\n    get isDropdown() {\n      return this.mode === PickerInteractionMode.DropDown;\n    }\n    /** @hidden @internal */\n\n\n    ngAfterViewInit() {\n      this.subToIconsClicked(this.toggleComponents, () => this.open());\n      this.toggleComponents.changes.pipe(takeUntil(this._destroy$)).subscribe(() => this.subToIconsClicked(this.toggleComponents, () => this.open()));\n    }\n    /** @hidden @internal */\n\n\n    ngOnDestroy() {\n      this._destroy$.next();\n\n      this._destroy$.complete();\n    }\n    /** Subscribes to the click events of toggle/clear icons in a query */\n\n\n    subToIconsClicked(components, next) {\n      components.forEach(toggle => {\n        toggle.clicked.pipe(takeUntil(merge(components.changes, this._destroy$))).subscribe(next);\n      });\n    }\n\n  }\n\n  PickerBaseDirective.ɵfac = function PickerBaseDirective_Factory(t) {\n    return new (t || PickerBaseDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(LOCALE_ID), i0.ɵɵdirectiveInject(DisplayDensityToken, 8), i0.ɵɵdirectiveInject(IGX_INPUT_GROUP_TYPE, 8));\n  };\n\n  PickerBaseDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PickerBaseDirective,\n    contentQueries: function PickerBaseDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxPickerToggleComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toggleComponents = _t);\n      }\n    },\n    inputs: {\n      inputFormat: \"inputFormat\",\n      displayFormat: \"displayFormat\",\n      placeholder: \"placeholder\",\n      mode: \"mode\",\n      overlaySettings: \"overlaySettings\",\n      disabled: \"disabled\",\n      locale: \"locale\",\n      outlet: \"outlet\",\n      type: \"type\",\n      tabIndex: \"tabIndex\"\n    },\n    outputs: {\n      opening: \"opening\",\n      opened: \"opened\",\n      closing: \"closing\",\n      closed: \"closed\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return PickerBaseDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$d = 0;\n/**\n * Date Picker displays a popup calendar that lets users select a single date.\n *\n * @igxModule IgxDatePickerModule\n * @igxTheme igx-calendar-theme, igx-icon-theme\n * @igxGroup Scheduling\n * @igxKeywords datepicker, calendar, schedule, date\n * @example\n * ```html\n * <igx-date-picker [(ngModel)]=\"selectedDate\"></igx-date-picker>\n * ```\n */\n\nlet IgxDatePickerComponent = /*#__PURE__*/(() => {\n  class IgxDatePickerComponent extends PickerBaseDirective {\n    constructor(element, _localeId, _overlayService, _moduleRef, _injector, _renderer, platform, cdr, _displayDensityOptions, _inputGroupType) {\n      super(element, _localeId, _displayDensityOptions, _inputGroupType);\n      this.element = element;\n      this._localeId = _localeId;\n      this._overlayService = _overlayService;\n      this._moduleRef = _moduleRef;\n      this._injector = _injector;\n      this._renderer = _renderer;\n      this.platform = platform;\n      this.cdr = cdr;\n      this._displayDensityOptions = _displayDensityOptions;\n      this._inputGroupType = _inputGroupType;\n      /**\n       * Gets/Sets on which day the week starts.\n       *\n       * @example\n       * ```html\n       * <igx-date-picker [weekStart]=\"4\" cancelButtonLabel=\"cancel\" todayButtonLabel=\"today\"></igx-date-picker>\n       * ```\n       */\n\n      this.weekStart = WEEKDAYS.SUNDAY;\n      /**\n       * Gets/Sets the number of month views displayed.\n       *\n       * @remarks\n       * Default value is `1`.\n       *\n       * @example\n       * ```html\n       * <igx-date-picker [displayMonthsCount]=\"2\"></igx-date-picker>\n       * ```\n       * @example\n       * ```typescript\n       * let monthViewsDisplayed = this.datePicker.displayMonthsCount;\n       * ```\n       */\n\n      this.displayMonthsCount = 1;\n      /**\n       * Gets/Sets the orientation of the `IgxDatePickerComponent` header.\n       *\n       *  @example\n       * ```html\n       * <igx-date-picker headerOrientation=\"vertical\"></igx-date-picker>\n       * ```\n       */\n\n      this.headerOrientation = PickerHeaderOrientation.Horizontal;\n      /**\n       * Specify if the currently spun date segment should loop over.\n       *\n       *  @example\n       * ```html\n       * <igx-date-picker [spinLoop]=\"false\"></igx-date-picker>\n       * ```\n       */\n\n      this.spinLoop = true;\n      /**\n       * Gets/Sets the value of `id` attribute.\n       *\n       * @remarks If not provided it will be automatically generated.\n       * @example\n       * ```html\n       * <igx-date-picker [id]=\"'igx-date-picker-3'\" cancelButtonLabel=\"cancel\" todayButtonLabel=\"today\"></igx-date-picker>\n       * ```\n       */\n\n      this.id = `igx-date-picker-${NEXT_ID$d++}`;\n      /** @hidden @internal */\n\n      this.readOnly = false;\n      /**\n       * Emitted when the picker's value changes.\n       *\n       * @remarks\n       * Used for `two-way` bindings.\n       *\n       * @example\n       * ```html\n       * <igx-date-picker [(value)]=\"date\"></igx-date-picker>\n       * ```\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * Emitted when the user types/spins invalid date in the date-picker editor.\n       *\n       *  @example\n       * ```html\n       * <igx-date-picker (validationFailed)=\"onValidationFailed($event)\"></igx-date-picker>\n       * ```\n       */\n\n      this.validationFailed = new EventEmitter();\n      /** @hidden @internal */\n\n      this.displayValue = {\n        transform: date => this.formatter(date)\n      };\n      this._resourceStrings = CurrentResourceStrings.DatePickerResourceStrings;\n      this._ngControl = null;\n      this._specialDates = null;\n      this._disabledDates = null;\n      this._overlaySubFilter = [filter(x => x.id === this._overlayId), takeUntil(this._destroy$)];\n      this._dropDownOverlaySettings = {\n        target: this.inputGroupElement,\n        closeOnOutsideClick: true,\n        modal: false,\n        closeOnEscape: true,\n        scrollStrategy: new AbsoluteScrollStrategy(),\n        positionStrategy: new AutoPositionStrategy({\n          openAnimation: fadeIn,\n          closeAnimation: fadeOut\n        })\n      };\n      this._dialogOverlaySettings = {\n        closeOnOutsideClick: true,\n        modal: true,\n        closeOnEscape: true\n      };\n      this._calendarFormat = {\n        day: 'numeric',\n        month: 'short',\n        weekday: 'short',\n        year: 'numeric'\n      };\n      this._defFormatViews = {\n        day: false,\n        month: true,\n        year: false\n      };\n      this._onChangeCallback = noop;\n      this._onTouchedCallback = noop;\n      this._onValidatorChange = noop;\n\n      this.onStatusChanged = () => {\n        this.updateValidity();\n        this.inputGroup.isRequired = this.required;\n      };\n    }\n    /**\n     * Gets/Sets the disabled dates descriptors.\n     *\n     * @example\n     * ```typescript\n     * let disabledDates = this.datepicker.disabledDates;\n     * this.datePicker.disabledDates = [ {type: DateRangeType.Weekends}, ...];\n     * ```\n     */\n\n\n    get disabledDates() {\n      return this._disabledDates;\n    }\n\n    set disabledDates(value) {\n      this._disabledDates = value;\n\n      this._onValidatorChange();\n    }\n    /**\n     * Gets/Sets the special dates descriptors.\n     *\n     * @example\n     * ```typescript\n     * let specialDates = this.datepicker.specialDates;\n     * this.datePicker.specialDates = [ {type: DateRangeType.Weekends}, ... ];\n     * ```\n     */\n\n\n    get specialDates() {\n      return this._specialDates;\n    }\n\n    set specialDates(value) {\n      this._specialDates = value;\n    } //#endregion\n\n    /**\n     * Gets/Sets the selected date.\n     *\n     *  @example\n     * ```html\n     * <igx-date-picker [value]=\"date\"></igx-date-picker>\n     * ```\n     */\n\n\n    get value() {\n      return this._value;\n    }\n\n    set value(date) {\n      this._value = date;\n      this.setDateValue(date);\n\n      if (this.dateTimeEditor.value !== date) {\n        this.dateTimeEditor.value = this._dateValue;\n      }\n\n      this.valueChange.emit(this.dateValue);\n\n      this._onChangeCallback(this.dateValue);\n    }\n    /**\n     * The minimum value the picker will accept.\n     *\n     * @example\n     * <igx-date-picker [minValue]=\"minDate\"></igx-date-picker>\n     */\n\n\n    set minValue(value) {\n      this._minValue = value;\n\n      this._onValidatorChange();\n    }\n\n    get minValue() {\n      return this._minValue;\n    }\n    /**\n     * The maximum value the picker will accept.\n     *\n     * @example\n     * <igx-date-picker [maxValue]=\"maxDate\"></igx-date-picker>\n     */\n\n\n    set maxValue(value) {\n      this._maxValue = value;\n\n      this._onValidatorChange();\n    }\n\n    get maxValue() {\n      return this._maxValue;\n    }\n\n    get dialogOverlaySettings() {\n      return Object.assign({}, this._dialogOverlaySettings, this.overlaySettings);\n    }\n\n    get dropDownOverlaySettings() {\n      return Object.assign({}, this._dropDownOverlaySettings, this.overlaySettings);\n    }\n\n    get inputGroupElement() {\n      var _a;\n\n      return (_a = this.inputGroup) === null || _a === void 0 ? void 0 : _a.element.nativeElement;\n    }\n\n    get dateValue() {\n      return this._dateValue;\n    }\n\n    get pickerFormatViews() {\n      return Object.assign({}, this._defFormatViews, this.formatViews);\n    }\n\n    get pickerCalendarFormat() {\n      return Object.assign({}, this._calendarFormat, this.calendarFormat);\n    }\n    /** @hidden @internal */\n\n\n    get required() {\n      if (this._ngControl && this._ngControl.control && this._ngControl.control.validator) {\n        // Run the validation with empty object to check if required is enabled.\n        const error = this._ngControl.control.validator({});\n\n        return error && error.required;\n      }\n\n      return false;\n    }\n    /** @hidden @internal */\n\n\n    get pickerResourceStrings() {\n      return Object.assign({}, this._resourceStrings, this.resourceStrings);\n    }\n    /** @hidden @internal */\n\n\n    onKeyDown(event) {\n      switch (event.key) {\n        case this.platform.KEYMAP.ARROW_UP:\n          if (event.altKey) {\n            this.close();\n          }\n\n          break;\n\n        case this.platform.KEYMAP.ARROW_DOWN:\n          if (event.altKey) {\n            this.open();\n          }\n\n          break;\n\n        case this.platform.KEYMAP.SPACE:\n          event.preventDefault();\n          this.open();\n          break;\n      }\n    }\n    /**\n     * Opens the picker's dropdown or dialog.\n     *\n     * @example\n     * ```html\n     * <igx-date-picker #picker></igx-date-picker>\n     *\n     * <button (click)=\"picker.open()\">Open Dialog</button>\n     * ```\n     */\n\n\n    open(settings) {\n      if (!this.collapsed || this.disabled) {\n        return;\n      }\n\n      const overlaySettings = Object.assign({}, this.isDropdown ? this.dropDownOverlaySettings : this.dialogOverlaySettings, settings);\n\n      if (this.isDropdown && this.inputGroupElement) {\n        overlaySettings.target = this.inputGroupElement;\n      }\n\n      if (this.outlet) {\n        overlaySettings.outlet = this.outlet;\n      }\n\n      this._overlayId = this._overlayService.attach(IgxCalendarContainerComponent, overlaySettings, this._moduleRef);\n\n      this._overlayService.show(this._overlayId);\n    }\n    /**\n     * Toggles the picker's dropdown or dialog\n     *\n     * @example\n     * ```html\n     * <igx-date-picker #picker></igx-date-picker>\n     *\n     * <button (click)=\"picker.toggle()\">Toggle Dialog</button>\n     * ```\n     */\n\n\n    toggle(settings) {\n      if (this.collapsed) {\n        this.open(settings);\n      } else {\n        this.close();\n      }\n    }\n    /**\n     * Closes the picker's dropdown or dialog.\n     *\n     * @example\n     * ```html\n     * <igx-date-picker #picker></igx-date-picker>\n     *\n     * <button (click)=\"picker.close()\">Close Dialog</button>\n     * ```\n     */\n\n\n    close() {\n      if (!this.collapsed) {\n        this._overlayService.hide(this._overlayId);\n      }\n    }\n    /**\n     * Selects a date.\n     *\n     * @remarks Updates the value in the input field.\n     *\n     * @example\n     * ```typescript\n     * this.datePicker.select(date);\n     * ```\n     * @param date passed date that has to be set to the calendar.\n     */\n\n\n    select(value) {\n      this.value = value;\n    }\n    /**\n     * Selects today's date and closes the picker.\n     *\n     * @example\n     * ```html\n     * <igx-date-picker #picker></igx-date-picker>\n     *\n     * <button (click)=\"picker.selectToday()\">Select Today</button>\n     * ```\n     * */\n\n\n    selectToday() {\n      const today = new Date();\n      today.setHours(0);\n      today.setMinutes(0);\n      today.setSeconds(0);\n      today.setMilliseconds(0);\n      this.select(today);\n      this.close();\n    }\n    /**\n     * Clears the input field and the picker's value.\n     *\n     * @example\n     * ```typescript\n     * this.datePicker.clear();\n     * ```\n     */\n\n\n    clear() {\n      var _a;\n\n      if (!this.disabled) {\n        (_a = this._calendar) === null || _a === void 0 ? void 0 : _a.deselectDate();\n        this.dateTimeEditor.clear();\n      }\n    }\n    /**\n     * Increment a specified `DatePart`.\n     *\n     * @param datePart The optional DatePart to increment. Defaults to Date.\n     * @param delta The optional delta to increment by. Overrides `spinDelta`.\n     * @example\n     * ```typescript\n     * this.datePicker.increment(DatePart.Date);\n     * ```\n     */\n\n\n    increment(datePart, delta) {\n      this.dateTimeEditor.increment(datePart, delta);\n    }\n    /**\n     * Decrement a specified `DatePart`\n     *\n     * @param datePart The optional DatePart to decrement. Defaults to Date.\n     * @param delta The optional delta to decrement by. Overrides `spinDelta`.\n     * @example\n     * ```typescript\n     * this.datePicker.decrement(DatePart.Date);\n     * ```\n     */\n\n\n    decrement(datePart, delta) {\n      this.dateTimeEditor.decrement(datePart, delta);\n    } //#region Control Value Accessor\n\n    /** @hidden @internal */\n\n\n    writeValue(value) {\n      this._value = value;\n      this.setDateValue(value);\n\n      if (this.dateTimeEditor.value !== value) {\n        this.dateTimeEditor.value = this._dateValue;\n      }\n    }\n    /** @hidden @internal */\n\n\n    registerOnChange(fn) {\n      this._onChangeCallback = fn;\n    }\n    /** @hidden @internal */\n\n\n    registerOnTouched(fn) {\n      this._onTouchedCallback = fn;\n    }\n    /** @hidden @internal */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    } //#endregion\n    //#region Validator\n\n    /** @hidden @internal */\n\n\n    registerOnValidatorChange(fn) {\n      this._onValidatorChange = fn;\n    }\n    /** @hidden @internal */\n\n\n    validate(control) {\n      if (!control.value) {\n        return null;\n      } // InvalidDate handling\n\n\n      if (isDate(control.value) && !DateTimeUtil.isValidDate(control.value)) {\n        return {\n          value: true\n        };\n      }\n\n      const errors = {};\n      const value = DateTimeUtil.isValidDate(control.value) ? control.value : DateTimeUtil.parseIsoDate(control.value);\n\n      if (value && this.disabledDates && isDateInRanges(value, this.disabledDates)) {\n        Object.assign(errors, {\n          dateIsDisabled: true\n        });\n      }\n\n      Object.assign(errors, DateTimeUtil.validateMinMax(value, this.minValue, this.maxValue, false));\n      return Object.keys(errors).length > 0 ? errors : null;\n    } //#endregion\n\n    /** @hidden @internal */\n\n\n    ngOnInit() {\n      this._ngControl = this._injector.get(NgControl, null);\n    }\n    /** @hidden @internal */\n\n\n    ngAfterViewInit() {\n      super.ngAfterViewInit();\n      this.subscribeToClick();\n      this.subscribeToOverlayEvents();\n      this.subscribeToDateEditorEvents();\n      this.subToIconsClicked(this.clearComponents, () => this.clear());\n      this.clearComponents.changes.pipe(takeUntil(this._destroy$)).subscribe(() => this.subToIconsClicked(this.clearComponents, () => this.clear()));\n      this._dropDownOverlaySettings.excludeFromOutsideClick = [this.inputGroup.element.nativeElement];\n      fromEvent(this.inputDirective.nativeElement, 'blur').pipe(takeUntil(this._destroy$)).subscribe(() => {\n        if (this.collapsed) {\n          this._onTouchedCallback();\n\n          this.updateValidity();\n        }\n      });\n\n      if (this._ngControl) {\n        this._statusChanges$ = this._ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));\n\n        if (this._ngControl.control.validator) {\n          this.inputGroup.isRequired = this.required;\n          this.cdr.detectChanges();\n        }\n      }\n    }\n    /** @hidden @internal */\n\n\n    ngAfterViewChecked() {\n      if (this.labelDirective) {\n        this._renderer.setAttribute(this.inputDirective.nativeElement, 'aria-labelledby', this.labelDirective.id);\n      }\n    }\n    /** @hidden @internal */\n\n\n    ngOnDestroy() {\n      super.ngOnDestroy();\n\n      if (this._statusChanges$) {\n        this._statusChanges$.unsubscribe();\n      }\n\n      if (this._overlayId) {\n        this._overlayService.detach(this._overlayId);\n\n        delete this._overlayId;\n      }\n    }\n    /** @hidden @internal */\n\n\n    getEditElement() {\n      return this.inputDirective.nativeElement;\n    }\n\n    subscribeToClick() {\n      fromEvent(this.getEditElement(), 'click').pipe(takeUntil(this._destroy$)).subscribe(() => {\n        if (!this.isDropdown) {\n          this.toggle();\n        }\n      });\n    }\n\n    setDateValue(value) {\n      if (isDate(value) && isNaN(value.getTime())) {\n        this._dateValue = value;\n        return;\n      }\n\n      this._dateValue = DateTimeUtil.isValidDate(value) ? value : DateTimeUtil.parseIsoDate(value);\n    }\n\n    updateValidity() {\n      // B.P. 18 May 2021: IgxDatePicker does not reset its state upon resetForm #9526\n      if (this._ngControl && !this.disabled && this.isTouchedOrDirty) {\n        if (this.inputGroup.isFocused) {\n          this.inputDirective.valid = this._ngControl.valid ? IgxInputState.VALID : IgxInputState.INVALID;\n        } else {\n          this.inputDirective.valid = this._ngControl.valid ? IgxInputState.INITIAL : IgxInputState.INVALID;\n        }\n      } else {\n        this.inputDirective.valid = IgxInputState.INITIAL;\n      }\n    }\n\n    get isTouchedOrDirty() {\n      return (this._ngControl.control.touched || this._ngControl.control.dirty) && (!!this._ngControl.control.validator || !!this._ngControl.control.asyncValidator);\n    }\n\n    handleSelection(date) {\n      if (this.dateValue && DateTimeUtil.isValidDate(this.dateValue)) {\n        date.setHours(this.dateValue.getHours());\n        date.setMinutes(this.dateValue.getMinutes());\n        date.setSeconds(this.dateValue.getSeconds());\n        date.setMilliseconds(this.dateValue.getMilliseconds());\n      }\n\n      this.value = date;\n      this._calendar.viewDate = date;\n      this.close();\n    }\n\n    subscribeToDateEditorEvents() {\n      this.dateTimeEditor.valueChange.pipe(takeUntil(this._destroy$)).subscribe(val => {\n        this.value = val;\n      });\n      this.dateTimeEditor.validationFailed.pipe(takeUntil(this._destroy$)).subscribe(event => {\n        this.validationFailed.emit({\n          owner: this,\n          prevValue: event.oldValue,\n          currentValue: this.value\n        });\n      });\n    }\n\n    subscribeToOverlayEvents() {\n      this._overlayService.opening.pipe(...this._overlaySubFilter).subscribe(e => {\n        const args = {\n          owner: this,\n          event: e.event,\n          cancel: e.cancel\n        };\n        this.opening.emit(args);\n        e.cancel = args.cancel;\n\n        if (args.cancel) {\n          this._overlayService.detach(this._overlayId);\n\n          return;\n        }\n\n        this._initializeCalendarContainer(e.componentRef.instance);\n\n        this._collapsed = false;\n      });\n\n      this._overlayService.opened.pipe(...this._overlaySubFilter).subscribe(() => {\n        var _a, _b, _c, _d, _e, _f, _g;\n\n        this.opened.emit({\n          owner: this\n        });\n\n        if ((_b = (_a = this._calendar) === null || _a === void 0 ? void 0 : _a.daysView) === null || _b === void 0 ? void 0 : _b.selectedDates) {\n          (_d = (_c = this._calendar) === null || _c === void 0 ? void 0 : _c.daysView) === null || _d === void 0 ? void 0 : _d.focusActiveDate();\n          return;\n        }\n\n        if (this._targetViewDate) {\n          this._targetViewDate.setHours(0, 0, 0, 0);\n\n          (_g = (_f = (_e = this._calendar) === null || _e === void 0 ? void 0 : _e.daysView) === null || _f === void 0 ? void 0 : _f.dates.find(d => d.date.date.getTime() === this._targetViewDate.getTime())) === null || _g === void 0 ? void 0 : _g.nativeElement.focus();\n        }\n      });\n\n      this._overlayService.closing.pipe(...this._overlaySubFilter).subscribe(e => {\n        const args = {\n          owner: this,\n          event: e.event,\n          cancel: e.cancel\n        };\n        this.closing.emit(args);\n        e.cancel = args.cancel;\n\n        if (args.cancel) {\n          return;\n        } // do not focus the input if clicking outside in dropdown mode\n\n\n        if (this.getEditElement() && !(args.event && this.isDropdown)) {\n          this.inputDirective.focus();\n        } else {\n          this._onTouchedCallback();\n\n          this.updateValidity();\n        }\n      });\n\n      this._overlayService.closed.pipe(...this._overlaySubFilter).subscribe(() => {\n        this.closed.emit({\n          owner: this\n        });\n\n        this._overlayService.detach(this._overlayId);\n\n        this._collapsed = true;\n        this._overlayId = null;\n      });\n    }\n\n    getMinMaxDates() {\n      const minValue = DateTimeUtil.isValidDate(this.minValue) ? this.minValue : DateTimeUtil.parseIsoDate(this.minValue);\n      const maxValue = DateTimeUtil.isValidDate(this.maxValue) ? this.maxValue : DateTimeUtil.parseIsoDate(this.maxValue);\n      return {\n        minValue,\n        maxValue\n      };\n    }\n\n    setDisabledDates() {\n      this._calendar.disabledDates = this.disabledDates ? [...this.disabledDates] : [];\n      const {\n        minValue,\n        maxValue\n      } = this.getMinMaxDates();\n\n      if (minValue) {\n        this._calendar.disabledDates.push({\n          type: DateRangeType.Before,\n          dateRange: [minValue]\n        });\n      }\n\n      if (maxValue) {\n        this._calendar.disabledDates.push({\n          type: DateRangeType.After,\n          dateRange: [maxValue]\n        });\n      }\n    }\n\n    _initializeCalendarContainer(componentInstance) {\n      this._calendar = componentInstance.calendar;\n      const isVertical = this.headerOrientation === PickerHeaderOrientation.Vertical;\n      this._calendar.hasHeader = !this.isDropdown;\n      this._calendar.formatOptions = this.pickerCalendarFormat;\n      this._calendar.formatViews = this.pickerFormatViews;\n      this._calendar.locale = this.locale;\n      this._calendar.vertical = isVertical;\n      this._calendar.weekStart = this.weekStart;\n      this._calendar.specialDates = this.specialDates;\n      this._calendar.headerTemplate = this.headerTemplate;\n      this._calendar.subheaderTemplate = this.subheaderTemplate;\n      this._calendar.hideOutsideDays = this.hideOutsideDays;\n      this._calendar.monthsViewNumber = this.displayMonthsCount;\n      this._calendar.showWeekNumbers = this.showWeekNumbers;\n\n      this._calendar.selected.pipe(takeUntil(this._destroy$)).subscribe(ev => this.handleSelection(ev));\n\n      this.setDisabledDates();\n\n      if (DateTimeUtil.isValidDate(this.dateValue)) {\n        // calendar will throw if the picker's value is InvalidDate #9208\n        this._calendar.value = this.dateValue;\n      }\n\n      this.setCalendarViewDate();\n      componentInstance.mode = this.mode;\n      componentInstance.vertical = isVertical;\n      componentInstance.closeButtonLabel = this.cancelButtonLabel;\n      componentInstance.todayButtonLabel = this.todayButtonLabel;\n      componentInstance.pickerActions = this.pickerActions;\n      componentInstance.calendarClose.pipe(takeUntil(this._destroy$)).subscribe(() => this.close());\n      componentInstance.todaySelection.pipe(takeUntil(this._destroy$)).subscribe(() => this.selectToday());\n    }\n\n    setCalendarViewDate() {\n      const {\n        minValue,\n        maxValue\n      } = this.getMinMaxDates();\n      this._dateValue = this.dateValue || new Date();\n\n      if (minValue && DateTimeUtil.lessThanMinValue(this.dateValue, minValue)) {\n        this._calendar.viewDate = this._targetViewDate = minValue;\n        return;\n      }\n\n      if (maxValue && DateTimeUtil.greaterThanMaxValue(this.dateValue, maxValue)) {\n        this._calendar.viewDate = this._targetViewDate = maxValue;\n        return;\n      }\n\n      this._calendar.viewDate = this._targetViewDate = this.dateValue;\n    }\n\n  }\n\n  IgxDatePickerComponent.ɵfac = function IgxDatePickerComponent_Factory(t) {\n    return new (t || IgxDatePickerComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(LOCALE_ID), i0.ɵɵdirectiveInject(IgxOverlayService), i0.ɵɵdirectiveInject(i0.NgModuleRef), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(PlatformUtil), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(DisplayDensityToken, 8), i0.ɵɵdirectiveInject(IGX_INPUT_GROUP_TYPE, 8));\n  };\n\n  IgxDatePickerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxDatePickerComponent,\n    selectors: [[\"igx-date-picker\"]],\n    contentQueries: function IgxDatePickerComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxLabelDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, IgxCalendarHeaderTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, IgxCalendarSubheaderTemplateDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, IgxPickerActionsDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, IgxPickerClearComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.label = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.subheaderTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.pickerActions = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.clearComponents = _t);\n      }\n    },\n    viewQuery: function IgxDatePickerComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxDateTimeEditorDirective, 7);\n        i0.ɵɵviewQuery(IgxInputGroupComponent, 5);\n        i0.ɵɵviewQuery(IgxLabelDirective, 5);\n        i0.ɵɵviewQuery(IgxInputDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dateTimeEditor = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputGroup = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.labelDirective = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputDirective = _t.first);\n      }\n    },\n    hostVars: 1,\n    hostBindings: function IgxDatePickerComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function IgxDatePickerComponent_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id);\n      }\n    },\n    inputs: {\n      weekStart: \"weekStart\",\n      hideOutsideDays: \"hideOutsideDays\",\n      displayMonthsCount: \"displayMonthsCount\",\n      showWeekNumbers: \"showWeekNumbers\",\n      formatter: \"formatter\",\n      headerOrientation: \"headerOrientation\",\n      todayButtonLabel: \"todayButtonLabel\",\n      cancelButtonLabel: \"cancelButtonLabel\",\n      spinLoop: \"spinLoop\",\n      spinDelta: \"spinDelta\",\n      outlet: \"outlet\",\n      id: \"id\",\n      formatViews: \"formatViews\",\n      disabledDates: \"disabledDates\",\n      specialDates: \"specialDates\",\n      calendarFormat: \"calendarFormat\",\n      value: \"value\",\n      minValue: \"minValue\",\n      maxValue: \"maxValue\",\n      resourceStrings: \"resourceStrings\",\n      readOnly: \"readOnly\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      validationFailed: \"validationFailed\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: IgxDatePickerComponent,\n      multi: true\n    }, {\n      provide: NG_VALIDATORS,\n      useExisting: IgxDatePickerComponent,\n      multi: true\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c75,\n    decls: 12,\n    vars: 19,\n    consts: [[3, \"displayDensity\", \"type\", \"suppressInputAutofocus\"], [3, \"click\", 4, \"ngIf\"], [\"igxInput\", \"\", \"aria-haspopup\", \"dialog\", \"aria-autocomplete\", \"none\", \"role\", \"combobox\", 1, \"igx-date-picker__input-date\", 3, \"displayValuePipe\", \"igxDateTimeEditor\", \"displayFormat\", \"minValue\", \"maxValue\", \"spinDelta\", \"spinLoop\", \"disabled\", \"placeholder\", \"readonly\", \"igxTextSelection\", \"locale\"], [\"ngProjectAs\", \"[igxLabel]\", 5, [\"\", \"igxLabel\", \"\"]], [\"ngProjectAs\", \"igx-prefix\", 5, [\"igx-prefix\"]], [\"ngProjectAs\", \"igx-suffix\", 5, [\"igx-suffix\"]], [\"ngProjectAs\", \"igx-hint\", 5, [\"igx-hint\"]], [3, \"click\"], [3, \"title\"]],\n    template: function IgxDatePickerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c74);\n        i0.ɵɵelementStart(0, \"igx-input-group\", 0);\n        i0.ɵɵtemplate(1, IgxDatePickerComponent_igx_prefix_1_Template, 3, 1, \"igx-prefix\", 1);\n        i0.ɵɵelement(2, \"input\", 2);\n        i0.ɵɵtemplate(3, IgxDatePickerComponent_igx_suffix_3_Template, 3, 0, \"igx-suffix\", 1);\n        i0.ɵɵelementContainerStart(4, 3);\n        i0.ɵɵprojection(5);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementContainerStart(6, 4);\n        i0.ɵɵprojection(7, 1);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementContainerStart(8, 5);\n        i0.ɵɵprojection(9, 2);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementContainerStart(10, 6);\n        i0.ɵɵprojection(11, 3);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"displayDensity\", ctx.displayDensity)(\"type\", ctx.type)(\"suppressInputAutofocus\", true);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.toggleComponents.length);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"displayValuePipe\", ctx.formatter ? ctx.displayValue : null)(\"igxDateTimeEditor\", ctx.inputFormat)(\"displayFormat\", ctx.displayFormat)(\"minValue\", ctx.minValue)(\"maxValue\", ctx.maxValue)(\"spinDelta\", ctx.spinDelta)(\"spinLoop\", ctx.spinLoop)(\"disabled\", ctx.disabled)(\"placeholder\", ctx.placeholder)(\"readonly\", !ctx.isDropdown || ctx.readOnly)(\"igxTextSelection\", ctx.isDropdown && !ctx.readOnly)(\"locale\", ctx.locale);\n        i0.ɵɵattribute(\"aria-expanded\", !ctx.collapsed)(\"aria-labelledby\", ctx.label == null ? null : ctx.label.id);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.clearComponents.length && ctx.value);\n      }\n    },\n    directives: [IgxInputGroupComponent, IgxIconComponent, i4.NgIf, IgxPrefixDirective, IgxInputDirective, IgxDateTimeEditorDirective, IgxTextSelectionDirective, IgxSuffixDirective],\n    styles: [\"[_nghost-%COMP%]{display:block}\"]\n  });\n  return IgxDatePickerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxDatePickerModule = /*#__PURE__*/(() => {\n  class IgxDatePickerModule {}\n\n  IgxDatePickerModule.ɵfac = function IgxDatePickerModule_Factory(t) {\n    return new (t || IgxDatePickerModule)();\n  };\n\n  IgxDatePickerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxDatePickerModule\n  });\n  IgxDatePickerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[FormsModule, CommonModule, IgxIconModule, IgxMaskModule, IgxCalendarModule, IgxInputGroupModule, IgxPickersCommonModule, IgxTextSelectionModule, IgxDateTimeEditorModule, IgxCalendarContainerModule], IgxPickersCommonModule]\n  });\n  return IgxDatePickerModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxDialogTitleDirective = /*#__PURE__*/(() => {\n  class IgxDialogTitleDirective {\n    constructor() {\n      this.defaultStyle = true;\n    }\n\n  }\n\n  IgxDialogTitleDirective.ɵfac = function IgxDialogTitleDirective_Factory(t) {\n    return new (t || IgxDialogTitleDirective)();\n  };\n\n  IgxDialogTitleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxDialogTitleDirective,\n    selectors: [[\"igx-dialog-title\"], [\"\", \"igxDialogTitle\", \"\"]],\n    hostVars: 2,\n    hostBindings: function IgxDialogTitleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-dialog__window-title\", ctx.defaultStyle);\n      }\n    }\n  });\n  return IgxDialogTitleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxDialogActionsDirective = /*#__PURE__*/(() => {\n  class IgxDialogActionsDirective {\n    constructor() {\n      this.defaultClass = true;\n    }\n\n  }\n\n  IgxDialogActionsDirective.ɵfac = function IgxDialogActionsDirective_Factory(t) {\n    return new (t || IgxDialogActionsDirective)();\n  };\n\n  IgxDialogActionsDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxDialogActionsDirective,\n    selectors: [[\"igx-dialog-actions\"], [\"\", \"igxDialogActions\", \"\"]],\n    hostVars: 2,\n    hostBindings: function IgxDialogActionsDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-dialog__window-actions\", ctx.defaultClass);\n      }\n    }\n  });\n  return IgxDialogActionsDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DIALOG_ID = 0;\n/**\n * **Ignite UI for Angular Dialog Window** -\n * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/dialog.html)\n *\n * The Ignite UI Dialog Window presents a dialog window to the user which can simply display messages or display\n * more complicated visuals such as a user sign-in form.  It also provides a right and left button\n * which can be used for custom actions.\n *\n * Example:\n * ```html\n * <button (click)=\"form.open()\">Show Dialog</button>\n * <igx-dialog #form title=\"Sign In\" rightButtonLabel=\"OK\">\n *   <div>\n *     <igx-input-group>\n *       <input type=\"text\" igxInput/>\n *       <label igxLabel>Username</label>\n *     </igx-input-group>\n *   </div>\n *   <div>\n *     <igx-input-group>\n *       <input type=\"password\" igxInput/>\n *       <label igxLabel>Password</label>\n *     </igx-input-group>\n *   </div>\n * </igx-dialog>\n * ```\n */\n\nlet IgxDialogComponent = /*#__PURE__*/(() => {\n  class IgxDialogComponent {\n    constructor(elementRef, navService) {\n      this.elementRef = elementRef;\n      this.navService = navService;\n      /**\n       * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.\n       * ```html\n       * <igx-dialog [id]=\"'igx-dialog-56'\" #alert title=\"Notification\"\n       *  leftButtonLabel=\"OK\" (leftButtonSelect)=\"alert.close()\">\n       * </igx-dialog>\n       * ```\n       */\n\n      this.id = `igx-dialog-${DIALOG_ID++}`;\n      /**\n       * An @Input property to set whether the Tab key focus is trapped within the dialog when opened.\n       * Defaults to `true`.\n       * ```html\n       * <igx-dialog focusTrap=\"false\"\"></igx-dialog>\n       * ```\n       */\n\n      this.focusTrap = true;\n      /**\n       * An @Input property controlling the `title` of the dialog.\n       * ```html\n       * <igx-dialog title=\"Notification\" #alert leftButtonLabel=\"OK\" (leftButtonSelect)=\"alert.close()\"></igx-dialog>\n       * ```\n       */\n\n      this.title = '';\n      /**\n       *  An @Input property controlling the `message` of the dialog.\n       * ```html\n       * <igx-dialog message=\"Your email was sent!\" #alert leftButtonLabel=\"OK\" (leftButtonSelect)=\"alert.close()\"></igx-dialog>\n       * ```\n       */\n\n      this.message = '';\n      /**\n       * An @Input property to set the `label` of the left button of the dialog.\n       * ```html\n       * <igx-dialog leftButtonLabel=\"OKAY\" #alert title=\"Notification\"  (leftButtonSelect)=\"alert.close()\"></igx-dialog>\n       * ```\n       */\n\n      this.leftButtonLabel = '';\n      /**\n       * An @Input property to set the left button `type`. The types are `flat`, `raised` and `fab`.\n       * The `flat` type button is a rectangle and doesn't have a shadow. <br>\n       * The `raised` type button is also a rectangle but has a shadow. <br>\n       * The `fab` type button is a circle with a shadow. <br>\n       * The default value is `flat`.\n       * ```html\n       * <igx-dialog leftButtonType=\"raised\" leftButtonLabel=\"OKAY\" #alert (leftButtonSelect)=\"alert.close()\"></igx-dialog>\n       * ```\n       */\n\n      this.leftButtonType = 'flat';\n      /**\n       * An @Input property to set the left button color. The property accepts all valid CSS color property values.\n       * ```html\n       * <igx-dialog leftButtonColor=\"yellow\" leftButtonLabel=\"OKAY\" #alert (leftButtonSelect)=\"alert.close()\"></igx-dialog>\n       * ```\n       */\n\n      this.leftButtonColor = '';\n      /**\n       * An @Input property to set the left button `background-color`. The property accepts all valid CSS color property values.\n       * ```html\n       * <igx-dialog leftButtonBackgroundColor=\"black\" leftButtonLabel=\"OKAY\" #alert (leftButtonSelect)=\"alert.close()\"></igx-dialog>\n       * ```\n       */\n\n      this.leftButtonBackgroundColor = '';\n      /**\n       * An @Input property to set the left button `ripple`. The `ripple` animates a click/tap to a component as a series of fading waves.\n       * The property accepts all valid CSS color property values.\n       * ```html\n       * <igx-dialog leftButtonRipple=\"green\" leftButtonLabel=\"OKAY\" #alert (leftButtonSelect)=\"alert.close()\"></igx-dialog>\n       * ```\n       */\n\n      this.leftButtonRipple = '';\n      /**\n       * An @Input property to set the `label` of the right button of the dialog.\n       * ```html\n       * <igx-dialog rightButtonLabel=\"OKAY\" #alert title=\"Notification\"  (leftButtonSelect)=\"alert.close()\"></igx-dialog>\n       * ```\n       */\n\n      this.rightButtonLabel = '';\n      /**\n       * An @Input property to set the right button `type`. The types are `flat`, `raised` and `fab`.\n       * The `flat` type button is a rectangle and doesn't have a shadow. <br>\n       * The `raised` type button is also a rectangle but has a shadow. <br>\n       * The `fab` type button is a circle with a shadow. <br>\n       * The default value is `flat`.\n       * ```html\n       * <igx-dialog rightButtonType=\"fab\" rightButtonLabel=\"OKAY\" #alert (leftButtonSelect)=\"alert.close()\"></igx-dialog>\n       * ```\n       */\n\n      this.rightButtonType = 'flat';\n      /**\n       * An @Input property to set the right button `color`. The property accepts all valid CSS color property values.\n       * ```html\n       * <igx-dialog rightButtonColor=\"yellow\" rightButtonLabel=\"OKAY\" #alert (leftButtonSelect)=\"alert.close()\"></igx-dialog>\n       * ```\n       */\n\n      this.rightButtonColor = '';\n      /**\n       * An @Input property to set the right button `background-color`. The property accepts all valid CSS color property values.\n       * ```html\n       * <igx-dialog rightButtonBackgroundColor=\"black\" rightButtonLabel=\"OKAY\" #alert (leftButtonSelect)=\"alert.close()\"></igx-dialog>\n       * ```\n       */\n\n      this.rightButtonBackgroundColor = '';\n      /**\n       * An @Input property to set the right button `ripple`.\n       * ```html\n       * <igx-dialog rightButtonRipple=\"green\" rightButtonLabel=\"OKAY\" #alert (leftButtonSelect)=\"alert.close()\"></igx-dialog>\n       * ```\n       */\n\n      this.rightButtonRipple = '';\n      /**\n       * The default `tabindex` attribute for the component\n       *\n       * @hidden\n       */\n\n      this.tabindex = -1;\n      /**\n       * An event that is emitted before the dialog is opened.\n       * ```html\n       * <igx-dialog (opening)=\"onDialogOpenHandler($event)\" (leftButtonSelect)=\"dialog.close()\" rightButtonLabel=\"OK\">\n       * </igx-dialog>\n       * ```\n       */\n\n      this.opening = new EventEmitter();\n      /**\n       * An event that is emitted after the dialog is opened.\n       * ```html\n       * <igx-dialog (onOpened)=\"onDialogOpenedHandler($event)\" (leftButtonSelect)=\"dialog.close()\" rightButtonLabel=\"OK\">\n       * </igx-dialog>\n       * ```\n       */\n\n      this.opened = new EventEmitter();\n      /**\n       * An event that is emitted before the dialog is closed.\n       * ```html\n       * <igx-dialog (closing)=\"onDialogCloseHandler($event)\" title=\"Confirmation\" leftButtonLabel=\"Cancel\" rightButtonLabel=\"OK\">\n       * </igx-dialog>\n       * ```\n       */\n\n      this.closing = new EventEmitter();\n      /**\n       * An event that is emitted after the dialog is closed.\n       * ```html\n       * <igx-dialog (closed)=\"onDialogClosedHandler($event)\" title=\"Confirmation\" leftButtonLabel=\"Cancel\" rightButtonLabel=\"OK\">\n       * </igx-dialog>\n       * ```\n       */\n\n      this.closed = new EventEmitter();\n      /**\n       * An event that is emitted when the left button is clicked.\n       * ```html\n       * <igx-dialog (leftButtonSelect)=\"onDialogOKSelected($event)\" #dialog leftButtonLabel=\"OK\" rightButtonLabel=\"Cancel\">\n       * </igx-dialog>\n       * ```\n       */\n\n      this.leftButtonSelect = new EventEmitter();\n      /**\n       * An event that is emitted when the right button is clicked.\n       * ```html\n       * <igx-dialog (rightButtonSelect)=\"onDialogOKSelected($event)\"\n       * #dialog title=\"Confirmation\" (leftButtonSelect)=\"dialog.close()\" rightButtonLabel=\"OK\"\n       * rightButtonRipple=\"#4CAF50\" closeOnOutsideSelect=\"true\">\n       * </igx-dialog>\n       * ```\n       */\n\n      this.rightButtonSelect = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.isOpenChange = new EventEmitter();\n      this.destroy$ = new Subject();\n      this._positionSettings = {\n        openAnimation: fadeIn,\n        closeAnimation: fadeOut\n      };\n      this._closeOnOutsideSelect = false;\n      this._closeOnEscape = true;\n      this._isModal = true;\n      this._titleId = IgxDialogComponent.NEXT_ID++ + '_title';\n      this._overlayDefaultSettings = {\n        positionStrategy: new GlobalPositionStrategy(this._positionSettings),\n        scrollStrategy: new NoOpScrollStrategy(),\n        modal: this.isModal,\n        closeOnEscape: this._closeOnEscape,\n        closeOnOutsideClick: this.closeOnOutsideSelect\n      };\n    }\n    /**\n     * Controls whether the dialog should be shown as modal. Defaults to `true`\n     * ```html\n     * <igx-dialog [isModal]=\"false\" ></igx-dialog>\n     * ```\n     */\n\n\n    get isModal() {\n      return this._isModal;\n    }\n\n    set isModal(val) {\n      this._overlayDefaultSettings.modal = val;\n      this._isModal = val;\n    }\n    /**\n     * Controls whether the dialog should close when `Esc` key is pressed. Defaults to `true`\n     * ```html\n     * <igx-dialog [closeOnEscape]=\"false\" ></igx-dialog>\n     * ```\n     */\n\n\n    get closeOnEscape() {\n      return this._closeOnEscape;\n    }\n\n    set closeOnEscape(val) {\n      this._overlayDefaultSettings.closeOnEscape = val;\n      this._closeOnEscape = val;\n    }\n    /**\n     * An @Input property that allows you to enable the \"close on click outside the dialog\". By default it's disabled.\n     * ```html\n     * <igx-dialog closeOnOutsideSelect=\"true\" leftButtonLabel=\"Cancel\" (leftButtonSelect)=\"dialog.close()\"\n     * rightButtonLabel=\"OK\" rightButtonRipple=\"#4CAF50\" (rightButtonSelect)=\"onDialogOKSelected($event)\">\n     * </igx-dialog>\n     * ```\n     */\n\n\n    get closeOnOutsideSelect() {\n      return this._closeOnOutsideSelect;\n    }\n\n    set closeOnOutsideSelect(val) {\n      this._overlayDefaultSettings.closeOnOutsideClick = val;\n      this._closeOnOutsideSelect = val;\n    }\n    /**\n     * Get the position and animation settings used by the dialog.\n     * ```typescript\n     * @ViewChild('alert', { static: true }) public alert: IgxDialogComponent;\n     * let currentPosition: PositionSettings = this.alert.positionSettings\n     * ```\n     */\n\n\n    get positionSettings() {\n      return this._positionSettings;\n    }\n    /**\n     * Set the position and animation settings used by the dialog.\n     * ```typescript\n     * import { slideInLeft, slideOutRight } from 'igniteui-angular';\n     * ...\n     * @ViewChild('alert', { static: true }) public alert: IgxDialogComponent;\n     *  public newPositionSettings: PositionSettings = {\n     *      openAnimation: useAnimation(slideInTop, { params: { duration: '2000ms' } }),\n     *      closeAnimation: useAnimation(slideOutBottom, { params: { duration: '2000ms'} }),\n     *      horizontalDirection: HorizontalAlignment.Left,\n     *      verticalDirection: VerticalAlignment.Middle,\n     *      horizontalStartPoint: HorizontalAlignment.Left,\n     *      verticalStartPoint: VerticalAlignment.Middle,\n     *      minSize: { height: 100, width: 100 }\n     *  };\n     * this.alert.positionSettings = this.newPositionSettings;\n     * ```\n     */\n\n\n    set positionSettings(settings) {\n      this._positionSettings = settings;\n      this._overlayDefaultSettings.positionStrategy = new GlobalPositionStrategy(this._positionSettings);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get element() {\n      return this.elementRef.nativeElement;\n    }\n    /**\n     * Returns the value of state. Possible state values are \"open\" or \"close\".\n     * ```typescript\n     * @ViewChild(\"MyDialog\")\n     * public dialog: IgxDialogComponent;\n     * ngAfterViewInit() {\n     *     let dialogState = this.dialog.state;\n     * }\n     * ```\n     */\n\n\n    get state() {\n      return this.isOpen ? 'open' : 'close';\n    }\n    /**\n     * State of the dialog.\n     *\n     * ```typescript\n     * // get\n     * let dialogIsOpen = this.dialog.isOpen;\n     * ```\n     *\n     * ```html\n     * <!--set-->\n     * <igx-dialog [isOpen]='false'></igx-dialog>\n     * ```\n     *\n     * Two-way data binding.\n     * ```html\n     * <!--set-->\n     * <igx-dialog [(isOpen)]='model.isOpen'></igx-dialog>\n     * ```\n     */\n\n\n    get isOpen() {\n      return !this.toggleRef.collapsed;\n    }\n\n    set isOpen(value) {\n      if (value !== this.isOpen) {\n        this.isOpenChange.emit(value);\n\n        if (value) {\n          requestAnimationFrame(() => {\n            this.open();\n          });\n        } else {\n          this.close();\n        }\n      }\n    }\n\n    get isCollapsed() {\n      return this.toggleRef.collapsed;\n    }\n    /**\n     * Returns the value of the role of the dialog. The valid values are `dialog`, `alertdialog`, `alert`.\n     * ```typescript\n     * @ViewChild(\"MyDialog\")\n     * public dialog: IgxDialogComponent;\n     * ngAfterViewInit() {\n     *     let dialogRole = this.dialog.role;\n     * }\n     *  ```\n     */\n\n\n    get role() {\n      if (this.leftButtonLabel !== '' && this.rightButtonLabel !== '') {\n        return 'dialog';\n      } else if (this.leftButtonLabel !== '' || this.rightButtonLabel !== '') {\n        return 'alertdialog';\n      } else {\n        return 'alert';\n      }\n    }\n    /**\n     * Returns the value of the title id.\n     * ```typescript\n     *  @ViewChild(\"MyDialog\")\n     * public dialog: IgxDialogComponent;\n     * ngAfterViewInit() {\n     *     let dialogTitle = this.dialog.titleId;\n     * }\n     * ```\n     */\n\n\n    get titleId() {\n      return this._titleId;\n    }\n\n    ngAfterContentInit() {\n      this.toggleRef.closing.pipe(takeUntil(this.destroy$)).subscribe(eventArgs => this.emitCloseFromDialog(eventArgs));\n      this.toggleRef.closed.pipe(takeUntil(this.destroy$)).subscribe(eventArgs => this.emitClosedFromDialog(eventArgs));\n      this.toggleRef.opened.pipe(takeUntil(this.destroy$)).subscribe(eventArgs => this.emitOpenedFromDialog(eventArgs));\n    }\n    /**\n     * A method that opens the dialog.\n     *\n     * @memberOf {@link IgxDialogComponent}\n     * ```html\n     * <button (click)=\"dialog.open() igxButton=\"raised\" igxButtonColor=\"white\" igxRipple=\"white\">Trigger Dialog</button>\n     * <igx-dialog #dialog></igx-dialog>\n     * ```\n     */\n\n\n    open(overlaySettings = this._overlayDefaultSettings) {\n      const eventArgs = {\n        dialog: this,\n        event: null,\n        cancel: false\n      };\n      this.opening.emit(eventArgs);\n\n      if (!eventArgs.cancel) {\n        this.toggleRef.open(overlaySettings);\n        this.isOpenChange.emit(true);\n\n        if (!this.leftButtonLabel && !this.rightButtonLabel) {\n          this.toggleRef.element.focus();\n        }\n      }\n    }\n    /**\n     * A method that that closes the dialog.\n     *\n     *  @memberOf {@link IgxDialogComponent}\n     * ```html\n     * <button (click)=\"dialog.close() igxButton=\"raised\" igxButtonColor=\"white\" igxRipple=\"white\">Trigger Dialog</button>\n     * <igx-dialog #dialog></igx-dialog>\n     * ```\n     */\n\n\n    close() {\n      // `closing` will emit from `toggleRef.closing` subscription\n      this.toggleRef.close();\n    }\n    /**\n     * A method that opens/closes the dialog.\n     *\n     * @memberOf {@link IgxDialogComponent}\n     * ```html\n     * <button (click)=\"dialog.toggle() igxButton=\"raised\" igxButtonColor=\"white\" igxRipple=\"white\">Trigger Dialog</button>\n     * <igx-dialog #dialog></igx-dialog>\n     * ```\n     */\n\n\n    toggle() {\n      if (this.isOpen) {\n        this.close();\n      } else {\n        this.open();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onDialogSelected(event) {\n      event.stopPropagation();\n\n      if (this.isOpen && this.closeOnOutsideSelect && event.target.classList.contains(IgxDialogComponent.DIALOG_CLASS)) {\n        this.close();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onInternalLeftButtonSelect(event) {\n      this.leftButtonSelect.emit({\n        dialog: this,\n        event\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    onInternalRightButtonSelect(event) {\n      this.rightButtonSelect.emit({\n        dialog: this,\n        event\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      if (this.navService && this.id) {\n        this.navService.add(this.id, this);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      if (this.navService && this.id) {\n        this.navService.remove(this.id);\n      }\n    }\n\n    emitCloseFromDialog(eventArgs) {\n      const dialogEventsArgs = {\n        dialog: this,\n        event: eventArgs.event,\n        cancel: eventArgs.cancel\n      };\n      this.closing.emit(dialogEventsArgs);\n      eventArgs.cancel = dialogEventsArgs.cancel;\n\n      if (!eventArgs.cancel) {\n        this.isOpenChange.emit(false);\n      }\n    }\n\n    emitClosedFromDialog(eventArgs) {\n      this.closed.emit({\n        dialog: this,\n        event: eventArgs.event\n      });\n    }\n\n    emitOpenedFromDialog(eventArgs) {\n      this.opened.emit({\n        dialog: this,\n        event: eventArgs.event\n      });\n    }\n\n  }\n\n  IgxDialogComponent.NEXT_ID = 1;\n  IgxDialogComponent.DIALOG_CLASS = 'igx-dialog';\n\n  IgxDialogComponent.ɵfac = function IgxDialogComponent_Factory(t) {\n    return new (t || IgxDialogComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(IgxNavigationService, 8));\n  };\n\n  IgxDialogComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxDialogComponent,\n    selectors: [[\"igx-dialog\"]],\n    viewQuery: function IgxDialogComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxToggleDirective, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toggleRef = _t.first);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function IgxDialogComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id)(\"tabindex\", ctx.tabindex);\n        i0.ɵɵclassProp(\"igx-dialog--hidden\", ctx.isCollapsed);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      isModal: \"isModal\",\n      closeOnEscape: \"closeOnEscape\",\n      focusTrap: \"focusTrap\",\n      title: \"title\",\n      message: \"message\",\n      leftButtonLabel: \"leftButtonLabel\",\n      leftButtonType: \"leftButtonType\",\n      leftButtonColor: \"leftButtonColor\",\n      leftButtonBackgroundColor: \"leftButtonBackgroundColor\",\n      leftButtonRipple: \"leftButtonRipple\",\n      rightButtonLabel: \"rightButtonLabel\",\n      rightButtonType: \"rightButtonType\",\n      rightButtonColor: \"rightButtonColor\",\n      rightButtonBackgroundColor: \"rightButtonBackgroundColor\",\n      rightButtonRipple: \"rightButtonRipple\",\n      closeOnOutsideSelect: \"closeOnOutsideSelect\",\n      positionSettings: \"positionSettings\",\n      isOpen: \"isOpen\",\n      role: \"role\",\n      titleId: \"titleId\"\n    },\n    outputs: {\n      opening: \"opening\",\n      opened: \"opened\",\n      closing: \"closing\",\n      closed: \"closed\",\n      leftButtonSelect: \"leftButtonSelect\",\n      rightButtonSelect: \"rightButtonSelect\",\n      isOpenChange: \"isOpenChange\"\n    },\n    ngContentSelectors: _c77,\n    decls: 11,\n    vars: 9,\n    consts: [[\"tabindex\", \"0\", \"igxToggle\", \"\", 1, \"igx-dialog\", 3, \"igxFocusTrap\", \"click\"], [\"dialog\", \"\"], [1, \"igx-dialog__window\"], [\"dialogWindow\", \"\"], [\"class\", \"igx-dialog__window-title\", 4, \"ngIf\"], [4, \"ngIf\"], [1, \"igx-dialog__window-content\"], [\"class\", \"igx-dialog__window-message\", 4, \"ngIf\"], [\"class\", \"igx-dialog__window-actions\", 4, \"ngIf\"], [1, \"igx-dialog__window-title\"], [1, \"igx-dialog__window-message\"], [1, \"igx-dialog__window-actions\"], [\"type\", \"button\", 3, \"igxFocus\", \"igxButton\", \"igxButtonColor\", \"igxButtonBackground\", \"igxRipple\", \"click\", 4, \"ngIf\"], [\"type\", \"button\", 3, \"igxFocus\", \"igxButton\", \"igxButtonColor\", \"igxButtonBackground\", \"igxRipple\", \"click\"]],\n    template: function IgxDialogComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c76);\n        i0.ɵɵelementStart(0, \"div\", 0, 1);\n        i0.ɵɵlistener(\"click\", function IgxDialogComponent_Template_div_click_0_listener($event) {\n          return ctx.onDialogSelected($event);\n        });\n        i0.ɵɵelementStart(2, \"div\", 2, 3);\n        i0.ɵɵtemplate(4, IgxDialogComponent_div_4_Template, 2, 2, \"div\", 4);\n        i0.ɵɵtemplate(5, IgxDialogComponent_ng_content_5_Template, 1, 0, \"ng-content\", 5);\n        i0.ɵɵelementStart(6, \"div\", 6);\n        i0.ɵɵtemplate(7, IgxDialogComponent_span_7_Template, 2, 1, \"span\", 7);\n        i0.ɵɵtemplate(8, IgxDialogComponent_ng_content_8_Template, 1, 0, \"ng-content\", 5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(9, IgxDialogComponent_div_9_Template, 3, 2, \"div\", 8);\n        i0.ɵɵtemplate(10, IgxDialogComponent_ng_content_10_Template, 1, 0, \"ng-content\", 5);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"igxFocusTrap\", ctx.focusTrap);\n        i0.ɵɵadvance(2);\n        i0.ɵɵattribute(\"role\", ctx.role)(\"aria-labelledby\", ctx.titleId);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.title);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.title);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.message);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.message);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.leftButtonLabel || ctx.rightButtonLabel);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.leftButtonLabel && !ctx.rightButtonLabel);\n      }\n    },\n    directives: [IgxToggleDirective, IgxFocusTrapDirective, i4.NgIf, IgxFocusDirective, IgxButtonDirective, IgxRippleDirective],\n    encapsulation: 2\n  });\n  return IgxDialogComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxDialogModule = /*#__PURE__*/(() => {\n  class IgxDialogModule {}\n\n  IgxDialogModule.ɵfac = function IgxDialogModule_Factory(t) {\n    return new (t || IgxDialogModule)();\n  };\n\n  IgxDialogModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxDialogModule\n  });\n  IgxDialogModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, IgxToggleModule, IgxButtonModule, IgxRippleModule, IgxFocusModule, IgxFocusTrapModule]]\n  });\n  return IgxDialogModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst FilterMode = mkenum({\n  quickFilter: 'quickFilter',\n  excelStyleFilter: 'excelStyleFilter'\n});\nconst GridSummaryPosition = mkenum({\n  top: 'top',\n  bottom: 'bottom'\n});\nconst GridSummaryCalculationMode = mkenum({\n  rootLevelOnly: 'rootLevelOnly',\n  childLevelsOnly: 'childLevelsOnly',\n  rootAndChildLevels: 'rootAndChildLevels'\n});\nconst GridSelectionMode = mkenum({\n  none: 'none',\n  single: 'single',\n  multiple: 'multiple',\n  multipleCascade: 'multipleCascade'\n});\nconst ColumnDisplayOrder = mkenum({\n  Alphabetical: 'Alphabetical',\n  DisplayOrder: 'DisplayOrder'\n});\nvar ColumnPinningPosition = /*#__PURE__*/(() => {\n  (function (ColumnPinningPosition) {\n    ColumnPinningPosition[ColumnPinningPosition[\"Start\"] = 0] = \"Start\";\n    ColumnPinningPosition[ColumnPinningPosition[\"End\"] = 1] = \"End\";\n  })(ColumnPinningPosition || (ColumnPinningPosition = {}));\n\n  return ColumnPinningPosition;\n})();\nvar RowPinningPosition = /*#__PURE__*/(() => {\n  (function (RowPinningPosition) {\n    RowPinningPosition[RowPinningPosition[\"Top\"] = 0] = \"Top\";\n    RowPinningPosition[RowPinningPosition[\"Bottom\"] = 1] = \"Bottom\";\n  })(RowPinningPosition || (RowPinningPosition = {}));\n\n  return RowPinningPosition;\n})();\nvar GridPagingMode = /*#__PURE__*/(() => {\n  (function (GridPagingMode) {\n    GridPagingMode[GridPagingMode[\"Local\"] = 0] = \"Local\";\n    GridPagingMode[GridPagingMode[\"Remote\"] = 1] = \"Remote\";\n  })(GridPagingMode || (GridPagingMode = {}));\n\n  return GridPagingMode;\n})();\nvar GridInstanceType = /*#__PURE__*/(() => {\n  (function (GridInstanceType) {\n    GridInstanceType[GridInstanceType[\"Grid\"] = 0] = \"Grid\";\n    GridInstanceType[GridInstanceType[\"TreeGrid\"] = 1] = \"TreeGrid\";\n  })(GridInstanceType || (GridInstanceType = {}));\n\n  return GridInstanceType;\n})();\nlet BaseFilteringComponent = /*#__PURE__*/(() => {\n  class BaseFilteringComponent {\n    constructor(cdr, element, platform) {\n      this.cdr = cdr;\n      this.element = element;\n      this.platform = platform;\n    }\n\n  }\n\n  BaseFilteringComponent.ɵfac = function BaseFilteringComponent_Factory(t) {\n    return new (t || BaseFilteringComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  BaseFilteringComponent.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: BaseFilteringComponent\n  });\n  return BaseFilteringComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A component used for presenting Excel style clear filters UI.\n */\n\n\nlet IgxExcelStyleClearFiltersComponent = /*#__PURE__*/(() => {\n  class IgxExcelStyleClearFiltersComponent {\n    constructor(esf, platform) {\n      this.esf = esf;\n      this.platform = platform;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    clearFilterClass() {\n      if (this.esf.column.filteringExpressionsTree) {\n        return 'igx-excel-filter__actions-clear';\n      }\n\n      return 'igx-excel-filter__actions-clear--disabled';\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    clearFilter() {\n      this.esf.grid.filteringService.clearFilter(this.esf.column.field);\n      this.selectAllFilterItems();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onClearFilterKeyDown(eventArgs) {\n      if (eventArgs.key === this.platform.KEYMAP.ENTER) {\n        this.clearFilter();\n      }\n    }\n\n    selectAllFilterItems() {\n      this.esf.listData.forEach(filterListItem => {\n        filterListItem.isSelected = true;\n        filterListItem.indeterminate = false;\n      });\n      this.esf.detectChanges();\n    }\n\n  }\n\n  IgxExcelStyleClearFiltersComponent.ɵfac = function IgxExcelStyleClearFiltersComponent_Factory(t) {\n    return new (t || IgxExcelStyleClearFiltersComponent)(i0.ɵɵdirectiveInject(BaseFilteringComponent), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxExcelStyleClearFiltersComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxExcelStyleClearFiltersComponent,\n    selectors: [[\"igx-excel-style-clear-filters\"]],\n    decls: 1,\n    vars: 1,\n    consts: [[\"tabindex\", \"0\", \"role\", \"menuitem\", 3, \"ngClass\", \"keydown\", \"click\", 4, \"ngIf\"], [\"tabindex\", \"0\", \"role\", \"menuitem\", 3, \"ngClass\", \"keydown\", \"click\"]],\n    template: function IgxExcelStyleClearFiltersComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxExcelStyleClearFiltersComponent_div_0_Template, 5, 2, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.esf.column);\n      }\n    },\n    directives: [IgxIconComponent, i4.NgIf, i4.NgClass],\n    encapsulation: 2\n  });\n  return IgxExcelStyleClearFiltersComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxSelectItemComponent = /*#__PURE__*/(() => {\n  class IgxSelectItemComponent extends IgxDropDownItemComponent {\n    /**\n     * An @Input property that gets/sets the item's text to be displayed in the select component's input when the item is selected.\n     *\n     * ```typescript\n     *  //get\n     *  let mySelectedItem = this.dropDown.selectedItem;\n     *  let selectedItemText = mySelectedItem.text;\n     * ```\n     *\n     * ```html\n     * // set\n     * <igx-select-item [text]=\"'London'\"></igx-select-item>\n     * ```\n     */\n    get text() {\n      return this._text;\n    }\n\n    set text(text) {\n      this._text = text;\n    }\n    /** @hidden @internal */\n\n\n    get itemText() {\n      if (this._text !== undefined) {\n        return this._text;\n      } // If text @Input is undefined, try extract a meaningful item text out of the item template\n\n\n      return this.elementRef.nativeElement.textContent.trim();\n    }\n    /**\n     * Sets/Gets if the item is the currently selected one in the select\n     *\n     * ```typescript\n     *  let mySelectedItem = this.select.selectedItem;\n     *  let isMyItemSelected = mySelectedItem.selected; // true\n     * ```\n     */\n\n\n    get selected() {\n      return !this.isHeader && !this.disabled && this.selection.is_item_selected(this.dropDown.id, this);\n    }\n\n    set selected(value) {\n      if (value && !this.isHeader && !this.disabled) {\n        this.dropDown.selectItem(this);\n      }\n    }\n\n  }\n\n  IgxSelectItemComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxSelectItemComponent_BaseFactory;\n    return function IgxSelectItemComponent_Factory(t) {\n      return (ɵIgxSelectItemComponent_BaseFactory || (ɵIgxSelectItemComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxSelectItemComponent)))(t || IgxSelectItemComponent);\n    };\n  }();\n\n  IgxSelectItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxSelectItemComponent,\n    selectors: [[\"igx-select-item\"]],\n    inputs: {\n      text: \"text\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c8,\n    decls: 2,\n    vars: 0,\n    consts: [[1, \"igx-drop-down__inner\"]],\n    template: function IgxSelectItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"span\", 0);\n        i0.ɵɵprojection(1);\n        i0.ɵɵelementEnd();\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxSelectItemComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden @internal */\n\n\nlet SelectPositioningStrategy = /*#__PURE__*/(() => {\n  let SelectPositioningStrategy = class SelectPositioningStrategy extends BaseFitPositionStrategy {\n    constructor(select, settings, platform) {\n      super();\n      this.select = select;\n      this.platform = platform;\n      this._selectDefaultSettings = {\n        horizontalDirection: HorizontalAlignment.Right,\n        verticalDirection: VerticalAlignment.Bottom,\n        horizontalStartPoint: HorizontalAlignment.Left,\n        verticalStartPoint: VerticalAlignment.Top,\n        openAnimation: fadeIn,\n        closeAnimation: fadeOut\n      }; // Global variables required for cases of !initialCall (page scroll/overlay repositionAll)\n\n      this.global_yOffset = 0;\n      this.global_xOffset = 0;\n      this.global_styles = {};\n      this.settings = Object.assign({}, this._selectDefaultSettings, settings);\n    }\n    /** @inheritdoc */\n\n\n    position(contentElement, size, document, initialCall, target) {\n      const targetElement = target || this.settings.target;\n      const rects = super.calculateElementRectangles(contentElement, targetElement); // selectFit obj, to be used for both cases of initialCall and !initialCall(page scroll/overlay repositionAll)\n\n      const selectFit = {\n        verticalOffset: this.global_yOffset,\n        horizontalOffset: this.global_xOffset,\n        targetRect: rects.targetRect,\n        contentElementRect: rects.elementRect,\n        styles: this.global_styles,\n        scrollContainer: this.select.scrollContainer,\n        scrollContainerRect: this.select.scrollContainer.getBoundingClientRect()\n      };\n\n      if (initialCall) {\n        this.select.scrollContainer.scrollTop = 0; // Fill in the required selectFit object properties.\n\n        selectFit.viewPortRect = Util.getViewportRect(document);\n        selectFit.itemElement = this.getInteractionItemElement();\n        selectFit.itemRect = selectFit.itemElement.getBoundingClientRect(); // Calculate input and selected item elements style related variables\n\n        selectFit.styles = this.calculateStyles(selectFit, targetElement);\n        selectFit.scrollAmount = this.calculateScrollAmount(selectFit); // Calculate how much to offset the overlay container.\n\n        this.calculateYoffset(selectFit);\n        this.calculateXoffset(selectFit);\n        super.updateViewPortFit(selectFit); // container does not fit in viewPort and is out on Top or Bottom\n\n        if (selectFit.fitVertical.back < 0 || selectFit.fitVertical.forward < 0) {\n          this.fitInViewport(contentElement, selectFit);\n        } // Calculate scrollTop independently of the dropdown, as we cover all `igsSelect` specific positioning and\n        // scrolling to selected item scenarios here.\n\n\n        this.select.scrollContainer.scrollTop = selectFit.scrollAmount;\n      }\n\n      this.setStyles(contentElement, selectFit);\n    }\n    /**\n     * Obtain the selected item if there is such one or otherwise use the first one\n     */\n\n\n    getInteractionItemElement() {\n      let itemElement;\n\n      if (this.select.selectedItem) {\n        itemElement = this.select.selectedItem.element.nativeElement;\n      } else {\n        itemElement = this.select.getFirstItemElement();\n      }\n\n      return itemElement;\n    }\n    /**\n     * Position the items outer container so selected item text is positioned over input text and if header\n     * And/OR footer - both header/footer are visible\n     *\n     * @param selectFit selectFit to use for computation.\n     */\n\n\n    fitInViewport(contentElement, selectFit) {\n      const footer = selectFit.scrollContainerRect.bottom - selectFit.contentElementRect.bottom;\n      const header = selectFit.scrollContainerRect.top - selectFit.contentElementRect.top;\n      const lastItemFitSize = selectFit.targetRect.bottom + selectFit.styles.itemTextToInputTextDiff - footer;\n      const firstItemFitSize = selectFit.targetRect.top - selectFit.styles.itemTextToInputTextDiff - header; // out of viewPort on Top\n\n      if (selectFit.fitVertical.back < 0) {\n        const possibleScrollAmount = selectFit.scrollContainer.scrollHeight - selectFit.scrollContainerRect.height - selectFit.scrollAmount;\n\n        if (possibleScrollAmount + selectFit.fitVertical.back > 0 && firstItemFitSize > selectFit.viewPortRect.top) {\n          selectFit.scrollAmount -= selectFit.fitVertical.back;\n          selectFit.verticalOffset -= selectFit.fitVertical.back;\n          this.global_yOffset = selectFit.verticalOffset;\n        } else {\n          selectFit.verticalOffset = 0;\n          this.global_yOffset = 0;\n        } // out of viewPort on Bottom\n\n      } else if (selectFit.fitVertical.forward < 0) {\n        if (selectFit.scrollAmount + selectFit.fitVertical.forward > 0 && lastItemFitSize < selectFit.viewPortRect.bottom) {\n          selectFit.scrollAmount += selectFit.fitVertical.forward;\n          selectFit.verticalOffset += selectFit.fitVertical.forward;\n          this.global_yOffset = selectFit.verticalOffset;\n        } else {\n          selectFit.verticalOffset = -selectFit.contentElementRect.height + selectFit.targetRect.height;\n          this.global_yOffset = selectFit.verticalOffset;\n        }\n      }\n    }\n    /**\n     * Sets element's style which effectively positions the provided element\n     *\n     * @param element Element to position\n     * @param selectFit selectFit to use for computation.\n     * @param initialCall should be true if this is the initial call to the position method calling setStyles\n     */\n\n\n    setStyles(contentElement, selectFit) {\n      super.setStyle(contentElement, selectFit.targetRect, selectFit.contentElementRect, selectFit);\n      contentElement.style.width = `${selectFit.styles.contentElementNewWidth}px`; // manage container based on paddings?\n\n      this.global_styles.contentElementNewWidth = selectFit.styles.contentElementNewWidth;\n    }\n    /**\n     * Calculate selected item scroll position.\n     */\n\n\n    calculateScrollAmount(selectFit) {\n      const itemElementRect = selectFit.itemRect;\n      const scrollContainer = selectFit.scrollContainer;\n      const scrollContainerRect = selectFit.scrollContainerRect;\n      const scrollDelta = scrollContainerRect.top - itemElementRect.top;\n      let scrollPosition = scrollContainer.scrollTop - scrollDelta;\n      const dropDownHeight = scrollContainer.clientHeight;\n      scrollPosition -= dropDownHeight / 2;\n      scrollPosition += itemElementRect.height / 2;\n      return Math.round(Math.min(Math.max(0, scrollPosition), scrollContainer.scrollHeight - scrollContainerRect.height));\n    }\n    /**\n     * Calculate the necessary input and selected item styles to be used for positioning item text over input text.\n     * Calculate & Set default items container width.\n     *\n     * @param selectFit selectFit to use for computation.\n     */\n\n\n    calculateStyles(selectFit, target) {\n      const styles = {};\n      const inputElementStyles = window.getComputedStyle(target);\n      const itemElementStyles = window.getComputedStyle(selectFit.itemElement);\n      const numericInputFontSize = parseFloat(inputElementStyles.fontSize);\n      const numericItemFontSize = parseFloat(itemElementStyles.fontSize);\n      const inputTextToInputTop = (selectFit.targetRect.bottom - selectFit.targetRect.top - numericInputFontSize) / 2;\n      const itemTextToItemTop = (selectFit.itemRect.height - numericItemFontSize) / 2; // Adjust for input top padding\n\n      const negateInputPaddings = (parseFloat(inputElementStyles.paddingTop) - parseFloat(inputElementStyles.paddingBottom)) / 2;\n      styles.itemTextToInputTextDiff = Math.round(itemTextToItemTop - inputTextToInputTop + negateInputPaddings);\n      const numericLeftPadding = parseFloat(itemElementStyles.paddingLeft);\n      const numericTextIndent = parseFloat(itemElementStyles.textIndent);\n      styles.itemTextPadding = numericLeftPadding;\n      styles.itemTextIndent = numericTextIndent; // 24 is the input's toggle ddl icon width\n\n      styles.contentElementNewWidth = selectFit.targetRect.width + 24 + numericLeftPadding * 2;\n      return styles;\n    }\n    /**\n     * Calculate how much to offset the overlay container for Y-axis.\n     */\n\n\n    calculateYoffset(selectFit) {\n      selectFit.verticalOffset = -(selectFit.itemRect.top - selectFit.contentElementRect.top + selectFit.styles.itemTextToInputTextDiff - selectFit.scrollAmount);\n      this.global_yOffset = selectFit.verticalOffset;\n    }\n    /**\n     * Calculate how much to offset the overlay container for X-axis.\n     */\n\n\n    calculateXoffset(selectFit) {\n      selectFit.horizontalOffset = selectFit.styles.itemTextIndent - selectFit.styles.itemTextPadding;\n      this.global_xOffset = selectFit.horizontalOffset;\n    }\n\n  };\n  SelectPositioningStrategy = __decorate([__param(2, Optional())], SelectPositioningStrategy);\n  /** @hidden @internal */\n\n  return SelectPositioningStrategy;\n})();\nlet IgxSelectItemNavigationDirective = /*#__PURE__*/(() => {\n  class IgxSelectItemNavigationDirective extends IgxDropDownItemNavigationDirective {\n    constructor() {\n      super(null);\n      this._target = null;\n      /* eslint-disable @typescript-eslint/member-ordering */\n\n      this.inputStream = '';\n      this.clearStream$ = Subscription.EMPTY;\n    }\n\n    get target() {\n      return this._target;\n    }\n\n    set target(target) {\n      this._target = target ? target : this.dropdown;\n    }\n    /** Captures keydown events and calls the appropriate handlers on the target component */\n\n\n    handleKeyDown(event) {\n      if (!event) {\n        return;\n      }\n\n      const key = event.key.toLowerCase();\n\n      if (event.altKey && (key === 'arrowdown' || key === 'arrowup' || key === 'down' || key === 'up')) {\n        this.target.toggle();\n        return;\n      }\n\n      if (this.target.collapsed) {\n        switch (key) {\n          case 'space':\n          case 'spacebar':\n          case ' ':\n          case 'enter':\n            event.preventDefault();\n            this.target.open();\n            return;\n\n          case 'arrowdown':\n          case 'down':\n            this.target.navigateNext();\n            this.target.selectItem(this.target.focusedItem);\n            event.preventDefault();\n            return;\n\n          case 'arrowup':\n          case 'up':\n            this.target.navigatePrev();\n            this.target.selectItem(this.target.focusedItem);\n            event.preventDefault();\n            return;\n\n          default:\n            break;\n        }\n      } else if (key === 'tab' || event.shiftKey && key === 'tab') {\n        this.target.close();\n      }\n\n      super.handleKeyDown(event);\n      this.captureKey(event);\n    }\n\n    captureKey(event) {\n      // relying only on key, available on all major browsers:\n      // https://caniuse.com/#feat=keyboardevent-key (IE/Edge quirk doesn't affect letter typing)\n      if (!event || !event.key || event.key.length > 1 || event.key === ' ' || event.key === 'spacebar') {\n        // ignore longer keys ('Alt', 'ArrowDown', etc) AND spacebar (used of open/close)\n        return;\n      }\n\n      this.clearStream$.unsubscribe();\n      this.clearStream$ = timer(500).subscribe(() => {\n        this.inputStream = '';\n      });\n      this.inputStream += event.key;\n      const focusedItem = this.target.focusedItem; // select the item\n\n      if (focusedItem && this.inputStream.length > 1 && focusedItem.itemText.toLowerCase().startsWith(this.inputStream.toLowerCase())) {\n        return;\n      }\n\n      this.activateItemByText(this.inputStream);\n    }\n\n    activateItemByText(text) {\n      const items = this.target.items; // ^ this is focused OR selected if the dd is closed\n\n      let nextItem = this.findNextItem(items, text); // If there is no such an item starting with the current text input stream AND the last Char in the input stream\n      // is the same as the first one, find next item starting with the same first Char.\n      // Covers cases of holding down the same key Ex: \"pppppp\" that iterates trough list items starting with \"p\".\n\n      if (!nextItem && text.charAt(0) === text.charAt(text.length - 1)) {\n        text = text.slice(0, 1);\n        nextItem = this.findNextItem(items, text);\n      } // If there is no other item to be found, do not change the active item.\n\n\n      if (!nextItem) {\n        return;\n      }\n\n      if (this.target.collapsed) {\n        this.target.selectItem(nextItem);\n      }\n\n      this.target.navigateItem(items.indexOf(nextItem));\n    }\n\n    ngOnDestroy() {\n      this.clearStream$.unsubscribe();\n    }\n\n    findNextItem(items, text) {\n      const activeItemIndex = items.indexOf(this.target.focusedItem) || 0; // Match next item in ddl items and wrap around if needed\n\n      return items.slice(activeItemIndex + 1).find(x => !x.disabled && x.itemText.toLowerCase().startsWith(text.toLowerCase())) || items.slice(0, activeItemIndex).find(x => !x.disabled && x.itemText.toLowerCase().startsWith(text.toLowerCase()));\n    }\n\n  }\n\n  IgxSelectItemNavigationDirective.ɵfac = function IgxSelectItemNavigationDirective_Factory(t) {\n    return new (t || IgxSelectItemNavigationDirective)();\n  };\n\n  IgxSelectItemNavigationDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxSelectItemNavigationDirective,\n    selectors: [[\"\", \"igxSelectItemNavigation\", \"\"]],\n    inputs: {\n      target: [\"igxSelectItemNavigation\", \"target\"]\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return IgxSelectItemNavigationDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden @internal */\n\n\nlet IgxSelectToggleIconDirective = /*#__PURE__*/(() => {\n  class IgxSelectToggleIconDirective {}\n\n  IgxSelectToggleIconDirective.ɵfac = function IgxSelectToggleIconDirective_Factory(t) {\n    return new (t || IgxSelectToggleIconDirective)();\n  };\n\n  IgxSelectToggleIconDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxSelectToggleIconDirective,\n    selectors: [[\"\", \"igxSelectToggleIcon\", \"\"]]\n  });\n  return IgxSelectToggleIconDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden @internal */\n\n\nlet IgxSelectHeaderDirective = /*#__PURE__*/(() => {\n  class IgxSelectHeaderDirective {}\n\n  IgxSelectHeaderDirective.ɵfac = function IgxSelectHeaderDirective_Factory(t) {\n    return new (t || IgxSelectHeaderDirective)();\n  };\n\n  IgxSelectHeaderDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxSelectHeaderDirective,\n    selectors: [[\"\", \"igxSelectHeader\", \"\"]]\n  });\n  return IgxSelectHeaderDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden @internal */\n\n\nlet IgxSelectFooterDirective = /*#__PURE__*/(() => {\n  class IgxSelectFooterDirective {}\n\n  IgxSelectFooterDirective.ɵfac = function IgxSelectFooterDirective_Factory(t) {\n    return new (t || IgxSelectFooterDirective)();\n  };\n\n  IgxSelectFooterDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxSelectFooterDirective,\n    selectors: [[\"\", \"igxSelectFooter\", \"\"]]\n  });\n  return IgxSelectFooterDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * **Ignite UI for Angular Select** -\n * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/select)\n *\n * The `igxSelect` provides an input with dropdown list allowing selection of a single item.\n *\n * Example:\n * ```html\n * <igx-select #select1 [placeholder]=\"'Pick One'\">\n *   <label igxLabel>Select Label</label>\n *   <igx-select-item *ngFor=\"let item of items\" [value]=\"item.field\">\n *     {{ item.field }}\n *   </igx-select-item>\n * </igx-select>\n * ```\n */\n\n\nlet IgxSelectComponent = /*#__PURE__*/(() => {\n  class IgxSelectComponent extends IgxDropDownComponent {\n    constructor(elementRef, cdr, selection, overlayService, _displayDensityOptions, _inputGroupType, _injector) {\n      super(elementRef, cdr, selection, _displayDensityOptions);\n      this.elementRef = elementRef;\n      this.cdr = cdr;\n      this.selection = selection;\n      this.overlayService = overlayService;\n      this._displayDensityOptions = _displayDensityOptions;\n      this._inputGroupType = _inputGroupType;\n      this._injector = _injector;\n      /**\n       * An @Input property that disables the `IgxSelectComponent`.\n       * ```html\n       * <igx-select [disabled]=\"'true'\"></igx-select>\n       * ```\n       */\n\n      this.disabled = false;\n      /** @hidden @internal */\n\n      this.maxHeight = '256px';\n      /**\n       * Emitted before the dropdown is opened\n       *\n       * ```html\n       * <igx-select opening='handleOpening($event)'></igx-select>\n       * ```\n       */\n\n      this.opening = new EventEmitter();\n      /**\n       * Emitted after the dropdown is opened\n       *\n       * ```html\n       * <igx-select (opened)='handleOpened($event)'></igx-select>\n       * ```\n       */\n\n      this.opened = new EventEmitter();\n      /**\n       * Emitted before the dropdown is closed\n       *\n       * ```html\n       * <igx-select (closing)='handleClosing($event)'></igx-select>\n       * ```\n       */\n\n      this.closing = new EventEmitter();\n      /**\n       * Emitted after the dropdown is closed\n       *\n       * ```html\n       * <igx-select (closed)='handleClosed($event)'></igx-select>\n       * ```\n       */\n\n      this.closed = new EventEmitter();\n      /**\n       * The custom template, if any, that should be used when rendering the select TOGGLE(open/close) button\n       *\n       * ```typescript\n       * // Set in typescript\n       * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;\n       * myComponent.select.toggleIconTemplate = myCustomTemplate;\n       * ```\n       * ```html\n       * <!-- Set in markup -->\n       *  <igx-select #select>\n       *      ...\n       *      <ng-template igxSelectToggleIcon let-collapsed>\n       *          <igx-icon>{{ collapsed ? 'remove_circle' : 'remove_circle_outline'}}</igx-icon>\n       *      </ng-template>\n       *  </igx-select>\n       * ```\n       */\n\n      this.toggleIconTemplate = null;\n      /**\n       * The custom template, if any, that should be used when rendering the HEADER for the select items list\n       *\n       * ```typescript\n       * // Set in typescript\n       * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;\n       * myComponent.select.headerTemplate = myCustomTemplate;\n       * ```\n       * ```html\n       * <!-- Set in markup -->\n       *  <igx-select #select>\n       *      ...\n       *      <ng-template igxSelectHeader>\n       *          <div class=\"select__header\">\n       *              This is a custom header\n       *          </div>\n       *      </ng-template>\n       *  </igx-select>\n       * ```\n       */\n\n      this.headerTemplate = null;\n      /**\n       * The custom template, if any, that should be used when rendering the FOOTER for the select items list\n       *\n       * ```typescript\n       * // Set in typescript\n       * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;\n       * myComponent.select.footerTemplate = myCustomTemplate;\n       * ```\n       * ```html\n       * <!-- Set in markup -->\n       *  <igx-select #select>\n       *      ...\n       *      <ng-template igxSelectFooter>\n       *          <div class=\"select__footer\">\n       *              This is a custom footer\n       *          </div>\n       *      </ng-template>\n       *  </igx-select>\n       * ```\n       */\n\n      this.footerTemplate = null;\n      /** @hidden @internal do not use the drop-down container class */\n\n      this.cssClass = false;\n      /** @hidden @internal */\n\n      this.allowItemsFocus = false;\n      this.destroy$ = new Subject();\n      this.ngControl = null;\n      this._type = null;\n      this._onChangeCallback = noop;\n      this._onTouchedCallback = noop; //#region ControlValueAccessor\n\n      /** @hidden @internal */\n\n      this.writeValue = value => {\n        this.value = value;\n      };\n    }\n    /**\n     * An @Input property that gets/sets the component value.\n     *\n     * ```typescript\n     * // get\n     * let selectValue = this.select.value;\n     * ```\n     *\n     * ```typescript\n     * // set\n     * this.select.value = 'London';\n     * ```\n     * ```html\n     * <igx-select [value]=\"value\"></igx-select>\n     * ```\n     */\n\n\n    get value() {\n      return this._value;\n    }\n\n    set value(v) {\n      if (this._value === v) {\n        return;\n      }\n\n      this._value = v;\n      this.setSelection(this.items.find(x => x.value === this.value));\n    }\n    /**\n     * An @Input property that sets how the select will be styled.\n     * The allowed values are `line`, `box` and `border`. The input-group default is `line`.\n     * ```html\n     * <igx-select [type]=\"'box'\"></igx-select>\n     * ```\n     */\n\n\n    get type() {\n      return this._type || this._inputGroupType || 'line';\n    }\n\n    set type(val) {\n      this._type = val;\n    }\n    /** @hidden @internal */\n\n\n    get selectionValue() {\n      const selectedItem = this.selectedItem;\n      return selectedItem ? selectedItem.itemText : '';\n    }\n    /** @hidden @internal */\n\n\n    get selectedItem() {\n      return this.selection.first_item(this.id);\n    }\n    /** @hidden @internal */\n\n\n    registerOnChange(fn) {\n      this._onChangeCallback = fn;\n    }\n    /** @hidden @internal */\n\n\n    registerOnTouched(fn) {\n      this._onTouchedCallback = fn;\n    }\n    /** @hidden @internal */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    } //#endregion\n\n    /** @hidden @internal */\n\n\n    getEditElement() {\n      return this.input.nativeElement;\n    }\n    /** @hidden @internal */\n\n\n    selectItem(newSelection, event) {\n      const oldSelection = this.selectedItem;\n\n      if (newSelection === null || newSelection.disabled || newSelection.isHeader) {\n        return;\n      }\n\n      if (newSelection === oldSelection) {\n        this.toggleDirective.close();\n        return;\n      }\n\n      const args = {\n        oldSelection,\n        newSelection,\n        cancel: false\n      };\n      this.selectionChanging.emit(args);\n\n      if (args.cancel) {\n        return;\n      }\n\n      this.setSelection(newSelection);\n      this._value = newSelection.value;\n\n      if (event) {\n        this.toggleDirective.close();\n      }\n\n      this.cdr.detectChanges();\n\n      this._onChangeCallback(this.value);\n    }\n    /** @hidden @internal */\n\n\n    getFirstItemElement() {\n      return this.children.first.element.nativeElement;\n    }\n    /**\n     * Opens the select\n     *\n     * ```typescript\n     * this.select.open();\n     * ```\n     */\n\n\n    open(overlaySettings) {\n      if (this.disabled || this.items.length === 0) {\n        return;\n      }\n\n      if (!this.selectedItem) {\n        this.navigateFirst();\n      }\n\n      super.open(Object.assign({}, this._overlayDefaults, this.overlaySettings, overlaySettings));\n    }\n\n    inputGroupClick(event, overlaySettings) {\n      const targetElement = event.target;\n\n      if (this.hintElement && targetElement.contains(this.hintElement.nativeElement)) {\n        return;\n      }\n\n      this.toggle(Object.assign({}, this._overlayDefaults, this.overlaySettings, overlaySettings));\n    }\n    /** @hidden @internal */\n\n\n    ngAfterContentInit() {\n      this._overlayDefaults = {\n        target: this.getEditElement(),\n        modal: false,\n        positionStrategy: new SelectPositioningStrategy(this),\n        scrollStrategy: new AbsoluteScrollStrategy(),\n        excludeFromOutsideClick: [this.inputGroup.element.nativeElement]\n      };\n      const changes$ = this.children.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        this.setSelection(this.items.find(x => x.value === this.value));\n        this.cdr.detectChanges();\n      });\n      Promise.resolve().then(() => {\n        if (!changes$.closed) {\n          this.children.notifyOnChanges();\n        }\n      });\n    }\n    /**\n     * Event handlers\n     *\n     * @hidden @internal\n     */\n\n\n    handleOpening(e) {\n      const args = {\n        owner: this,\n        event: e.event,\n        cancel: e.cancel\n      };\n      this.opening.emit(args);\n      e.cancel = args.cancel;\n\n      if (args.cancel) {\n        return;\n      }\n    }\n    /** @hidden @internal */\n\n\n    onToggleContentAppended(event) {\n      var _a;\n\n      const info = this.overlayService.getOverlayById(event.id);\n\n      if (((_a = info === null || info === void 0 ? void 0 : info.settings) === null || _a === void 0 ? void 0 : _a.positionStrategy) instanceof SelectPositioningStrategy) {\n        return;\n      }\n\n      super.onToggleContentAppended(event);\n    }\n    /** @hidden @internal */\n\n\n    handleOpened() {\n      this.updateItemFocus();\n      this.opened.emit({\n        owner: this\n      });\n    }\n    /** @hidden @internal */\n\n\n    handleClosing(e) {\n      const args = {\n        owner: this,\n        event: e.event,\n        cancel: e.cancel\n      };\n      this.closing.emit(args);\n      e.cancel = args.cancel;\n    }\n    /** @hidden @internal */\n\n\n    handleClosed() {\n      this.focusItem(false);\n      this.closed.emit({\n        owner: this\n      });\n    }\n    /** @hidden @internal */\n\n\n    onBlur() {\n      this._onTouchedCallback();\n\n      if (this.ngControl && this.ngControl.invalid) {\n        this.input.valid = IgxInputState.INVALID;\n      } else {\n        this.input.valid = IgxInputState.INITIAL;\n      }\n    }\n    /** @hidden @internal */\n\n\n    onFocus() {\n      this._onTouchedCallback();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    ngOnInit() {\n      this.ngControl = this._injector.get(NgControl, null);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    ngAfterViewInit() {\n      if (this.ngControl) {\n        this.ngControl.statusChanges.pipe(takeUntil(this.destroy$)).subscribe(this.onStatusChanged.bind(this));\n        this.manageRequiredAsterisk();\n      }\n\n      this.cdr.detectChanges();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    ngOnDestroy() {\n      this.destroy$.next(true);\n      this.destroy$.complete();\n      this.selection.clear(this.id);\n    }\n    /**\n     * @hidden @internal\n     * Prevent input blur - closing the items container on Header/Footer Template click.\n     */\n\n\n    mousedownHandler(event) {\n      event.preventDefault();\n    }\n\n    onStatusChanged() {\n      if ((this.ngControl.control.touched || this.ngControl.control.dirty) && (this.ngControl.control.validator || this.ngControl.control.asyncValidator)) {\n        if (this.inputGroup.isFocused) {\n          this.input.valid = this.ngControl.invalid ? IgxInputState.INVALID : IgxInputState.VALID;\n        } else {\n          this.input.valid = this.ngControl.invalid ? IgxInputState.INVALID : IgxInputState.INITIAL;\n        }\n      } else {\n        // B.P. 18 May 2021: IgxDatePicker does not reset its state upon resetForm #9526\n        this.input.valid = IgxInputState.INITIAL;\n      }\n\n      this.manageRequiredAsterisk();\n    }\n\n    navigate(direction, currentIndex) {\n      if (this.collapsed && this.selectedItem) {\n        this.navigateItem(this.selectedItem.itemIndex);\n      }\n\n      super.navigate(direction, currentIndex);\n    }\n\n    manageRequiredAsterisk() {\n      const hasRequiredHTMLAttribute = this.elementRef.nativeElement.hasAttribute('required');\n\n      if (this.ngControl && this.ngControl.control.validator) {\n        // Run the validation with empty object to check if required is enabled.\n        const error = this.ngControl.control.validator({});\n        this.inputGroup.isRequired = error && error.required;\n        this.cdr.markForCheck(); // If validator is dynamically cleared and no required HTML attribute is set,\n        // reset label's required class(asterisk) and IgxInputState #6896\n      } else if (this.inputGroup.isRequired && this.ngControl && !this.ngControl.control.validator && !hasRequiredHTMLAttribute) {\n        this.input.valid = IgxInputState.INITIAL;\n        this.inputGroup.isRequired = false;\n        this.cdr.markForCheck();\n      }\n    }\n\n    setSelection(item) {\n      if (item && item.value !== undefined && item.value !== null) {\n        this.selection.set(this.id, new Set([item]));\n      } else {\n        this.selection.clear(this.id);\n      }\n    }\n\n  }\n\n  IgxSelectComponent.ɵfac = function IgxSelectComponent_Factory(t) {\n    return new (t || IgxSelectComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(IgxSelectionAPIService), i0.ɵɵdirectiveInject(IgxOverlayService), i0.ɵɵdirectiveInject(DisplayDensityToken, 8), i0.ɵɵdirectiveInject(IGX_INPUT_GROUP_TYPE, 8), i0.ɵɵdirectiveInject(i0.Injector));\n  };\n\n  IgxSelectComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxSelectComponent,\n    selectors: [[\"igx-select\"]],\n    contentQueries: function IgxSelectComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxLabelDirective, 7);\n        i0.ɵɵcontentQuery(dirIndex, IgxSelectToggleIconDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxSelectHeaderDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxSelectFooterDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxHintDirective, 5, ElementRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxSelectItemComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.label = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toggleIconTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.hintElement = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.children = _t);\n      }\n    },\n    viewQuery: function IgxSelectComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c62, 7, IgxInputGroupComponent);\n        i0.ɵɵviewQuery(_c78, 7, IgxInputDirective);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputGroup = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.input = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function IgxSelectComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"max-height\", ctx.maxHeight);\n      }\n    },\n    inputs: {\n      placeholder: \"placeholder\",\n      disabled: \"disabled\",\n      overlaySettings: \"overlaySettings\",\n      value: \"value\",\n      type: \"type\"\n    },\n    outputs: {\n      opening: \"opening\",\n      opened: \"opened\",\n      closing: \"closing\",\n      closed: \"closed\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: IgxSelectComponent,\n      multi: true\n    }, {\n      provide: IGX_DROPDOWN_BASE,\n      useExisting: IgxSelectComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c80,\n    decls: 21,\n    vars: 18,\n    consts: [[1, \"input-group\", 3, \"type\", \"displayDensity\", \"click\"], [\"inputGroup\", \"\"], [\"ngProjectAs\", \"[igxLabel]\", 5, [\"\", \"igxLabel\", \"\"]], [\"ngProjectAs\", \"igx-prefix\", 5, [\"igx-prefix\"]], [\"type\", \"text\", \"igxInput\", \"\", \"readonly\", \"true\", \"role\", \"combobox\", \"aria-haspopup\", \"listbox\", 1, \"input\", 3, \"igxSelectItemNavigation\", \"disabled\", \"value\", \"blur\", \"focus\"], [\"input\", \"\"], [\"ngProjectAs\", \"igx-suffix\", 5, [\"igx-suffix\"]], [4, \"ngIf\"], [\"ngProjectAs\", \"igx-hint, [igxHint]\", 5, [\"igx-hint\"]], [\"igxToggle\", \"\", 1, \"igx-drop-down__list\", 3, \"mousedown\", \"appended\", \"opening\", \"opened\", \"closing\", \"closed\"], [\"class\", \"igx-drop-down__select-header\", 4, \"ngIf\"], [\"unselectable\", \"on\", \"role\", \"listbox\", 1, \"igx-drop-down__list-scroll\"], [\"scrollContainer\", \"\"], [\"class\", \"igx-drop-down__select-footer\", 4, \"ngIf\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"igx-drop-down__select-header\"], [4, \"ngTemplateOutlet\"], [1, \"igx-drop-down__select-footer\"]],\n    template: function IgxSelectComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c79);\n        i0.ɵɵelementStart(0, \"igx-input-group\", 0, 1);\n        i0.ɵɵlistener(\"click\", function IgxSelectComponent_Template_igx_input_group_click_0_listener($event) {\n          return ctx.inputGroupClick($event);\n        });\n        i0.ɵɵelementContainerStart(2, 2);\n        i0.ɵɵprojection(3);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementContainerStart(4, 3);\n        i0.ɵɵprojection(5, 1);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementStart(6, \"input\", 4, 5);\n        i0.ɵɵlistener(\"blur\", function IgxSelectComponent_Template_input_blur_6_listener() {\n          return ctx.onBlur();\n        })(\"focus\", function IgxSelectComponent_Template_input_focus_6_listener() {\n          return ctx.onFocus();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementContainerStart(8, 6);\n        i0.ɵɵprojection(9, 2);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementStart(10, \"igx-suffix\");\n        i0.ɵɵtemplate(11, IgxSelectComponent_ng_container_11_Template, 2, 4, \"ng-container\", 7);\n        i0.ɵɵtemplate(12, IgxSelectComponent_igx_icon_12_Template, 2, 1, \"igx-icon\", 7);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementContainerStart(13, 8);\n        i0.ɵɵprojection(14, 3);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(15, \"div\", 9);\n        i0.ɵɵlistener(\"mousedown\", function IgxSelectComponent_Template_div_mousedown_15_listener($event) {\n          return ctx.mousedownHandler($event);\n        })(\"appended\", function IgxSelectComponent_Template_div_appended_15_listener($event) {\n          return ctx.onToggleContentAppended($event);\n        })(\"opening\", function IgxSelectComponent_Template_div_opening_15_listener($event) {\n          return ctx.handleOpening($event);\n        })(\"opened\", function IgxSelectComponent_Template_div_opened_15_listener() {\n          return ctx.handleOpened();\n        })(\"closing\", function IgxSelectComponent_Template_div_closing_15_listener($event) {\n          return ctx.handleClosing($event);\n        })(\"closed\", function IgxSelectComponent_Template_div_closed_15_listener() {\n          return ctx.handleClosed();\n        });\n        i0.ɵɵtemplate(16, IgxSelectComponent_div_16_Template, 2, 1, \"div\", 10);\n        i0.ɵɵelementStart(17, \"div\", 11, 12);\n        i0.ɵɵprojection(19, 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(20, IgxSelectComponent_div_20_Template, 2, 1, \"div\", 13);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"type\", ctx.type)(\"displayDensity\", ctx.displayDensity);\n        i0.ɵɵadvance(6);\n        i0.ɵɵproperty(\"igxSelectItemNavigation\", ctx)(\"disabled\", ctx.disabled)(\"value\", ctx.selectionValue);\n        i0.ɵɵattribute(\"placeholder\", ctx.placeholder)(\"aria-labelledby\", ctx.label == null ? null : ctx.label.id)(\"aria-expanded\", !ctx.collapsed)(\"aria-owns\", ctx.listId)(\"aria-activedescendant\", !ctx.collapsed ? ctx.focusedItem == null ? null : ctx.focusedItem.id : null);\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"ngIf\", ctx.toggleIconTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.toggleIconTemplate);\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"ngIf\", ctx.headerTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"max-height\", ctx.maxHeight);\n        i0.ɵɵattribute(\"id\", ctx.listId)(\"aria-labelledby\", ctx.label == null ? null : ctx.label.id);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.footerTemplate);\n      }\n    },\n    directives: [IgxInputGroupComponent, IgxIconComponent, IgxInputDirective, IgxSelectItemNavigationDirective, IgxSuffixDirective, i4.NgIf, i4.NgTemplateOutlet, IgxToggleDirective],\n    styles: [\"[_nghost-%COMP%]{display:block}\"]\n  });\n  return IgxSelectComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxExcelStyleDefaultExpressionComponent = /*#__PURE__*/(() => {\n  class IgxExcelStyleDefaultExpressionComponent {\n    constructor(cdr, platform) {\n      this.cdr = cdr;\n      this.platform = platform;\n      this.expressionRemoved = new EventEmitter();\n      this.logicOperatorChanged = new EventEmitter();\n      this.dropDownOverlaySettings = {\n        scrollStrategy: new AbsoluteScrollStrategy(),\n        modal: false,\n        closeOnOutsideClick: true\n      };\n    }\n\n    get isLast() {\n      return this.expressionsList[this.expressionsList.length - 1] === this.expressionUI;\n    }\n\n    get isSingle() {\n      return this.expressionsList.length === 1;\n    }\n\n    get conditionsPlaceholder() {\n      return this.grid.resourceStrings['igx_grid_filter_condition_placeholder'];\n    }\n\n    get inputValuePlaceholder() {\n      return this.grid.resourceStrings['igx_grid_filter_row_placeholder'];\n    }\n\n    get type() {\n      switch (this.column.dataType) {\n        case GridColumnDataType.Number:\n        case GridColumnDataType.Currency:\n        case GridColumnDataType.Percent:\n          return 'number';\n\n        default:\n          return 'text';\n      }\n    }\n\n    get conditions() {\n      return this.column.filters.conditionList();\n    }\n\n    get inputValuesElement() {\n      return this.inputValuesDirective.nativeElement;\n    }\n\n    ngAfterViewInit() {\n      this.dropDownOverlaySettings.outlet = this.overlayOutlet;\n      this.dropDownOverlaySettings.target = this.dropdownConditions.inputGroup.element.nativeElement;\n      this.dropDownOverlaySettings.excludeFromOutsideClick = [this.dropdownConditions.inputGroup.element.nativeElement];\n      this.dropDownOverlaySettings.positionStrategy = new ConnectedPositioningStrategy();\n    }\n\n    focus() {\n      // use requestAnimationFrame to focus the values input because when initializing the component\n      // datepicker's input group is not yet fully initialized\n      requestAnimationFrame(() => this.inputValuesElement.focus());\n    }\n\n    translateCondition(value) {\n      return this.grid.resourceStrings[`igx_grid_filter_${this.getCondition(value).name}`] || value;\n    }\n\n    getIconName() {\n      if (this.column.dataType === GridColumnDataType.Boolean && this.expressionUI.expression.condition === null) {\n        return this.getCondition(this.conditions[0]).iconName;\n      } else if (!this.expressionUI.expression.condition) {\n        return 'filter_list';\n      } else {\n        return this.expressionUI.expression.condition.iconName;\n      }\n    }\n\n    isConditionSelected(conditionName) {\n      return this.expressionUI.expression.condition && this.expressionUI.expression.condition.name === conditionName;\n    }\n\n    onConditionsChanged(eventArgs) {\n      const value = eventArgs.newSelection.value;\n      this.expressionUI.expression.condition = this.getCondition(value);\n      this.focus();\n    }\n\n    getCondition(value) {\n      return this.column.filters.condition(value);\n    }\n\n    getConditionFriendlyName(name) {\n      return this.grid.resourceStrings[`igx_grid_filter_${name}`] || name;\n    }\n\n    onValuesInput(eventArgs) {\n      this.expressionUI.expression.searchVal = DataUtil.parseValue(this.column.dataType, eventArgs.target.value);\n    }\n\n    onLogicOperatorButtonClicked(eventArgs, buttonIndex) {\n      if (this.logicOperatorButtonGroup.selectedButtons.length === 0) {\n        eventArgs.stopPropagation();\n        this.logicOperatorButtonGroup.selectButton(buttonIndex);\n      } else {\n        this.logicOperatorChanged.emit({\n          target: this.expressionUI,\n          newValue: buttonIndex\n        });\n      }\n    }\n\n    onLogicOperatorKeyDown(eventArgs, buttonIndex) {\n      if (eventArgs.key === this.platform.KEYMAP.ENTER) {\n        this.logicOperatorButtonGroup.selectButton(buttonIndex);\n        this.logicOperatorChanged.emit({\n          target: this.expressionUI,\n          newValue: buttonIndex\n        });\n      }\n    }\n\n    onRemoveButtonClick() {\n      this.expressionRemoved.emit(this.expressionUI);\n    }\n\n    onOutletPointerDown(event) {\n      event.preventDefault();\n    }\n\n  }\n\n  IgxExcelStyleDefaultExpressionComponent.ɵfac = function IgxExcelStyleDefaultExpressionComponent_Factory(t) {\n    return new (t || IgxExcelStyleDefaultExpressionComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxExcelStyleDefaultExpressionComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxExcelStyleDefaultExpressionComponent,\n    selectors: [[\"igx-excel-style-default-expression\"]],\n    viewQuery: function IgxExcelStyleDefaultExpressionComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c81, 7, IgxOverlayOutletDirective);\n        i0.ɵɵviewQuery(_c82, 7, IgxSelectComponent);\n        i0.ɵɵviewQuery(_c83, 5, IgxButtonGroupComponent);\n        i0.ɵɵviewQuery(_c84, 7, IgxInputDirective);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.overlayOutlet = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropdownConditions = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.logicOperatorButtonGroup = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputValuesDirective = _t.first);\n      }\n    },\n    inputs: {\n      column: \"column\",\n      expressionUI: \"expressionUI\",\n      expressionsList: \"expressionsList\",\n      grid: \"grid\",\n      displayDensity: \"displayDensity\"\n    },\n    outputs: {\n      expressionRemoved: \"expressionRemoved\",\n      logicOperatorChanged: \"logicOperatorChanged\"\n    },\n    decls: 14,\n    vars: 13,\n    consts: [[\"type\", \"box\", 3, \"displayDensity\", \"placeholder\", \"overlaySettings\", \"selectionChanging\"], [\"dropdownConditions\", \"\"], [\"family\", \"imx-icons\", 3, \"name\", 4, \"ngIf\"], [4, \"ngIf\"], [3, \"value\", \"text\", \"selected\", 4, \"ngFor\", \"ngForOf\"], [\"type\", \"box\", 3, \"displayDensity\"], [\"inputGroupValues\", \"\"], [\"igxInput\", \"\", \"tabindex\", \"0\", \"autocomplete\", \"off\", 3, \"type\", \"placeholder\", \"disabled\", \"value\", \"input\"], [\"inputValues\", \"\"], [\"igxButton\", \"icon\", 3, \"displayDensity\", \"click\", 4, \"ngIf\"], [3, \"multiSelection\", 4, \"ngIf\"], [\"igxOverlayOutlet\", \"\", 3, \"pointerdown\"], [\"overlayOutlet\", \"\"], [\"family\", \"imx-icons\", 3, \"name\"], [3, \"value\", \"text\", \"selected\"], [1, \"igx-grid__filtering-dropdown-items\"], [1, \"igx-grid__filtering-dropdown-text\"], [\"igxButton\", \"icon\", 3, \"displayDensity\", \"click\"], [3, \"multiSelection\"], [\"logicOperatorButtonGroup\", \"\"], [\"igxButton\", \"\", \"tabindex\", \"0\", \"type\", \"button\", 3, \"displayDensity\", \"selected\", \"keydown\", \"click\"], [\"andButton\", \"\"], [\"orButton\", \"\"]],\n    template: function IgxExcelStyleDefaultExpressionComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"igx-select\", 0, 1);\n        i0.ɵɵlistener(\"selectionChanging\", function IgxExcelStyleDefaultExpressionComponent_Template_igx_select_selectionChanging_0_listener($event) {\n          return ctx.onConditionsChanged($event);\n        });\n        i0.ɵɵelementStart(2, \"igx-prefix\");\n        i0.ɵɵtemplate(3, IgxExcelStyleDefaultExpressionComponent_igx_icon_3_Template, 1, 1, \"igx-icon\", 2);\n        i0.ɵɵtemplate(4, IgxExcelStyleDefaultExpressionComponent_igx_icon_4_Template, 2, 0, \"igx-icon\", 3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(5, IgxExcelStyleDefaultExpressionComponent_igx_select_item_5_Template, 5, 5, \"igx-select-item\", 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(6, \"igx-input-group\", 5, 6)(8, \"input\", 7, 8);\n        i0.ɵɵlistener(\"input\", function IgxExcelStyleDefaultExpressionComponent_Template_input_input_8_listener($event) {\n          return ctx.onValuesInput($event);\n        });\n        i0.ɵɵelementEnd()();\n        i0.ɵɵtemplate(10, IgxExcelStyleDefaultExpressionComponent_button_10_Template, 3, 1, \"button\", 9);\n        i0.ɵɵtemplate(11, IgxExcelStyleDefaultExpressionComponent_igx_buttongroup_11_Template, 8, 7, \"igx-buttongroup\", 10);\n        i0.ɵɵelementStart(12, \"div\", 11, 12);\n        i0.ɵɵlistener(\"pointerdown\", function IgxExcelStyleDefaultExpressionComponent_Template_div_pointerdown_12_listener($event) {\n          return ctx.onOutletPointerDown($event);\n        });\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"displayDensity\", ctx.displayDensity)(\"placeholder\", ctx.conditionsPlaceholder)(\"overlaySettings\", ctx.dropDownOverlaySettings);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.expressionUI.expression.condition);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.expressionUI.expression.condition);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.conditions);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"displayDensity\", ctx.displayDensity);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"type\", ctx.type)(\"placeholder\", ctx.inputValuePlaceholder)(\"disabled\", ctx.expressionUI.expression.condition && ctx.expressionUI.expression.condition.isUnary)(\"value\", ctx.expressionUI.expression.searchVal);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", !ctx.isSingle);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.isLast);\n      }\n    },\n    directives: [IgxSelectComponent, IgxIconComponent, IgxSelectItemComponent, IgxInputGroupComponent, IgxButtonGroupComponent, IgxPrefixDirective, i4.NgIf, i4.NgForOf, IgxInputDirective, IgxButtonDirective, IgxOverlayOutletDirective],\n    encapsulation: 2\n  });\n  return IgxExcelStyleDefaultExpressionComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst EVENT_SUFFIX = 'precise';\n/**\n * Touch gestures manager based on Hammer.js\n * Use with caution, this will track references for single manager per element. Very TBD. Much TODO.\n *\n * @hidden\n */\n\nlet HammerGesturesManager = /*#__PURE__*/(() => {\n  class HammerGesturesManager {\n    constructor(_zone, doc, platformUtil) {\n      this._zone = _zone;\n      this.doc = doc;\n      this.platformUtil = platformUtil;\n      /**\n       * Event option defaults for each recognizer, see http://hammerjs.github.io/api/ for API listing.\n       */\n\n      this.hammerOptions = {};\n      this._hammerManagers = [];\n      this.platformBrowser = this.platformUtil.isBrowser;\n\n      if (this.platformBrowser) {\n        this.hammerOptions = {\n          // D.P. #447 Force TouchInput due to PointerEventInput bug (https://github.com/hammerjs/hammer.js/issues/1065)\n          // see https://github.com/IgniteUI/igniteui-angular/issues/447#issuecomment-324601803\n          inputClass: Hammer.TouchInput,\n          recognizers: [[Hammer.Pan, {\n            threshold: 0\n          }], [Hammer.Swipe, {\n            direction: Hammer.DIRECTION_HORIZONTAL\n          }], [Hammer.Tap], [Hammer.Tap, {\n            event: 'doubletap',\n            taps: 2\n          }, ['tap']]]\n        };\n      }\n    }\n\n    supports(eventName) {\n      return eventName.toLowerCase().endsWith('.' + EVENT_SUFFIX);\n    }\n    /**\n     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.\n     * Modeling after other event plugins for easy future modifications.\n     */\n\n\n    addEventListener(element, eventName, eventHandler, options = null) {\n      if (!this.platformBrowser) {\n        return;\n      } // Creating the manager bind events, must be done outside of angular\n\n\n      return this._zone.runOutsideAngular(() => {\n        let mc = this.getManagerForElement(element);\n\n        if (mc === null) {\n          // new Hammer is a shortcut for Manager with defaults\n          mc = new Hammer(element, Object.assign(this.hammerOptions, options));\n          this.addManagerForElement(element, mc);\n        }\n\n        const handler = eventObj => this._zone.run(() => eventHandler(eventObj));\n\n        mc.on(eventName, handler);\n        return () => mc.off(eventName, handler);\n      });\n    }\n    /**\n     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.\n     * Modeling after other event plugins for easy future modifications.\n     *\n     * @param target Can be one of either window, body or document(fallback default).\n     */\n\n\n    addGlobalEventListener(target, eventName, eventHandler) {\n      if (!this.platformBrowser) {\n        return;\n      }\n\n      const element = this.getGlobalEventTarget(target); // Creating the manager bind events, must be done outside of angular\n\n      return this.addEventListener(element, eventName, eventHandler);\n    }\n    /**\n     * Exposes [Dom]Adapter.getGlobalEventTarget to get global event targets.\n     * Supported: window, document, body. Defaults to document for invalid args.\n     *\n     * @param target Target name\n     */\n\n\n    getGlobalEventTarget(target) {\n      return ɵgetDOM().getGlobalEventTarget(this.doc, target);\n    }\n    /**\n     * Set HammerManager options.\n     *\n     * @param element The DOM element used to create the manager on.\n     *\n     * ### Example\n     *\n     * ```ts\n     * manager.setManagerOption(myElem, \"pan\", { pointers: 1 });\n     * ```\n     */\n\n\n    setManagerOption(element, event, options) {\n      const manager = this.getManagerForElement(element);\n      manager.get(event).set(options);\n    }\n    /**\n     * Add an element and manager map to the internal collection.\n     *\n     * @param element The DOM element used to create the manager on.\n     */\n\n\n    addManagerForElement(element, manager) {\n      this._hammerManagers.push({\n        element,\n        manager\n      });\n    }\n    /**\n     * Get HammerManager for the element or null\n     *\n     * @param element The DOM element used to create the manager on.\n     */\n\n\n    getManagerForElement(element) {\n      const result = this._hammerManagers.filter((value, index, array) => value.element === element);\n\n      return result.length ? result[0].manager : null;\n    }\n    /**\n     * Destroys the HammerManager for the element, removing event listeners in the process.\n     *\n     * @param element The DOM element used to create the manager on.\n     */\n\n\n    removeManagerForElement(element) {\n      let index = null;\n\n      for (let i = 0; i < this._hammerManagers.length; i++) {\n        if (element === this._hammerManagers[i].element) {\n          index = i;\n          break;\n        }\n      }\n\n      if (index !== null) {\n        const item = this._hammerManagers.splice(index, 1)[0]; // destroy also\n\n\n        item.manager.destroy();\n      }\n    }\n    /** Destroys all internally tracked HammerManagers, removing event listeners in the process. */\n\n\n    destroy() {\n      for (const item of this._hammerManagers) {\n        item.manager.destroy();\n      }\n\n      this._hammerManagers = [];\n    }\n\n  }\n\n  HammerGesturesManager.ɵfac = function HammerGesturesManager_Factory(t) {\n    return new (t || HammerGesturesManager)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(PlatformUtil));\n  };\n\n  HammerGesturesManager.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: HammerGesturesManager,\n    factory: HammerGesturesManager.ɵfac\n  });\n  return HammerGesturesManager;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nconst IGX_TIME_PICKER_COMPONENT = 'IgxTimePickerComponentToken';\n/**\n * This file contains all the directives used by the @link IgxTimePickerComponent.\n * You should generally not use them directly.\n *\n * @preferred\n */\n\n/** @hidden */\n\nlet IgxItemListDirective = /*#__PURE__*/(() => {\n  class IgxItemListDirective {\n    constructor(timePicker, elementRef, touchManager) {\n      this.timePicker = timePicker;\n      this.elementRef = elementRef;\n      this.touchManager = touchManager;\n      this.tabindex = 0;\n\n      this.onPanMove = event => {\n        const delta = event.deltaY < 0 ? -1 : event.deltaY > 0 ? 1 : 0;\n\n        if (delta !== 0) {\n          this.nextItem(delta);\n        }\n      };\n    }\n\n    get defaultCSS() {\n      return true;\n    }\n\n    get hourCSS() {\n      return this.type === 'hourList';\n    }\n\n    get minuteCSS() {\n      return this.type === 'minuteList';\n    }\n\n    get secondsCSS() {\n      return this.type === 'secondsList';\n    }\n\n    get ampmCSS() {\n      return this.type === 'ampmList';\n    }\n\n    onFocus() {\n      this.isActive = true;\n    }\n\n    onBlur() {\n      this.isActive = false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onKeydownArrowDown(event) {\n      event.preventDefault();\n      this.nextItem(1);\n    }\n    /**\n     * @hidden\n     */\n\n\n    onKeydownArrowUp(event) {\n      event.preventDefault();\n      this.nextItem(-1);\n    }\n    /**\n     * @hidden\n     */\n\n\n    onKeydownArrowRight(event) {\n      event.preventDefault();\n      const listName = event.target.className;\n\n      if (listName.indexOf('hourList') !== -1 && this.timePicker.minuteList) {\n        this.timePicker.minuteList.nativeElement.focus();\n      } else if ((listName.indexOf('hourList') !== -1 || listName.indexOf('minuteList') !== -1) && this.timePicker.secondsList) {\n        this.timePicker.secondsList.nativeElement.focus();\n      } else if ((listName.indexOf('hourList') !== -1 || listName.indexOf('minuteList') !== -1 || listName.indexOf('secondsList') !== -1) && this.timePicker.ampmList) {\n        this.timePicker.ampmList.nativeElement.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onKeydownArrowLeft(event) {\n      event.preventDefault();\n      const listName = event.target.className;\n\n      if (listName.indexOf('ampmList') !== -1 && this.timePicker.secondsList) {\n        this.timePicker.secondsList.nativeElement.focus();\n      } else if (listName.indexOf('secondsList') !== -1 && this.timePicker.secondsList && listName.indexOf('minutesList') && this.timePicker.minuteList) {\n        this.timePicker.minuteList.nativeElement.focus();\n      } else if (listName.indexOf('ampmList') !== -1 && this.timePicker.minuteList) {\n        this.timePicker.minuteList.nativeElement.focus();\n      } else if ((listName.indexOf('ampmList') !== -1 || listName.indexOf('secondsList') !== -1 || listName.indexOf('minuteList') !== -1) && this.timePicker.hourList) {\n        this.timePicker.hourList.nativeElement.focus();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onKeydownEnter(event) {\n      event.preventDefault();\n      this.timePicker.okButtonClick();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onKeydownEscape(event) {\n      event.preventDefault();\n      this.timePicker.cancelButtonClick();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onHover() {\n      this.elementRef.nativeElement.focus();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onScroll(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      const delta = event.deltaY;\n\n      if (delta !== 0) {\n        this.nextItem(delta);\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    ngOnInit() {\n      const hammerOptions = {\n        recognizers: [[Hammer.Pan, {\n          direction: Hammer.DIRECTION_VERTICAL,\n          threshold: 10\n        }]]\n      };\n      this.touchManager.addEventListener(this.elementRef.nativeElement, 'pan', this.onPanMove, hammerOptions);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    ngOnDestroy() {\n      this.touchManager.destroy();\n    }\n\n    nextItem(delta) {\n      switch (this.type) {\n        case 'hourList':\n          {\n            this.timePicker.nextHour(delta);\n            break;\n          }\n\n        case 'minuteList':\n          {\n            this.timePicker.nextMinute(delta);\n            break;\n          }\n\n        case 'secondsList':\n          {\n            this.timePicker.nextSeconds(delta);\n            break;\n          }\n\n        case 'ampmList':\n          {\n            this.timePicker.nextAmPm(delta);\n            break;\n          }\n      }\n    }\n\n  }\n\n  IgxItemListDirective.ɵfac = function IgxItemListDirective_Factory(t) {\n    return new (t || IgxItemListDirective)(i0.ɵɵdirectiveInject(IGX_TIME_PICKER_COMPONENT), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(HammerGesturesManager));\n  };\n\n  IgxItemListDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxItemListDirective,\n    selectors: [[\"\", \"igxItemList\", \"\"]],\n    hostVars: 11,\n    hostBindings: function IgxItemListDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focus\", function IgxItemListDirective_focus_HostBindingHandler() {\n          return ctx.onFocus();\n        })(\"blur\", function IgxItemListDirective_blur_HostBindingHandler() {\n          return ctx.onBlur();\n        })(\"keydown.arrowdown\", function IgxItemListDirective_keydown_arrowdown_HostBindingHandler($event) {\n          return ctx.onKeydownArrowDown($event);\n        })(\"keydown.arrowup\", function IgxItemListDirective_keydown_arrowup_HostBindingHandler($event) {\n          return ctx.onKeydownArrowUp($event);\n        })(\"keydown.arrowright\", function IgxItemListDirective_keydown_arrowright_HostBindingHandler($event) {\n          return ctx.onKeydownArrowRight($event);\n        })(\"keydown.arrowleft\", function IgxItemListDirective_keydown_arrowleft_HostBindingHandler($event) {\n          return ctx.onKeydownArrowLeft($event);\n        })(\"keydown.enter\", function IgxItemListDirective_keydown_enter_HostBindingHandler($event) {\n          return ctx.onKeydownEnter($event);\n        })(\"keydown.escape\", function IgxItemListDirective_keydown_escape_HostBindingHandler($event) {\n          return ctx.onKeydownEscape($event);\n        })(\"mouseover\", function IgxItemListDirective_mouseover_HostBindingHandler() {\n          return ctx.onHover();\n        })(\"wheel\", function IgxItemListDirective_wheel_HostBindingHandler($event) {\n          return ctx.onScroll($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabindex\", ctx.tabindex);\n        i0.ɵɵclassProp(\"igx-time-picker__column\", ctx.defaultCSS)(\"igx-time-picker__hourList\", ctx.hourCSS)(\"igx-time-picker__minuteList\", ctx.minuteCSS)(\"igx-time-picker__secondsList\", ctx.secondsCSS)(\"igx-time-picker__ampmList\", ctx.ampmCSS);\n      }\n    },\n    inputs: {\n      type: [\"igxItemList\", \"type\"]\n    },\n    features: [i0.ɵɵProvidersFeature([HammerGesturesManager])]\n  });\n  return IgxItemListDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxTimeItemDirective = /*#__PURE__*/(() => {\n  class IgxTimeItemDirective {\n    constructor(timePicker, itemList) {\n      this.timePicker = timePicker;\n      this.itemList = itemList;\n    }\n\n    get defaultCSS() {\n      return true;\n    }\n\n    get selectedCSS() {\n      return this.isSelectedTime;\n    }\n\n    get activeCSS() {\n      return this.isSelectedTime && this.itemList.isActive;\n    }\n\n    get isSelectedTime() {\n      const currentValue = this.value.length < 2 ? `0${this.value}` : this.value;\n      const dateType = this.itemList.type;\n      const inputDateParts = DateTimeUtil.parseDateTimeFormat(this.timePicker.inputFormat);\n\n      switch (dateType) {\n        case 'hourList':\n          const hourPart = inputDateParts.find(element => element.type === 'hours');\n          return DateTimeUtil.getPartValue(this.timePicker.selectedDate, hourPart, hourPart.format.length) === currentValue;\n\n        case 'minuteList':\n          const minutePart = inputDateParts.find(element => element.type === 'minutes');\n          return DateTimeUtil.getPartValue(this.timePicker.selectedDate, minutePart, minutePart.format.length) === currentValue;\n\n        case 'secondsList':\n          const secondsPart = inputDateParts.find(element => element.type === 'seconds');\n          return DateTimeUtil.getPartValue(this.timePicker.selectedDate, secondsPart, secondsPart.format.length) === currentValue;\n\n        case 'ampmList':\n          const ampmPart = inputDateParts.find(element => element.format === 'tt');\n          return DateTimeUtil.getPartValue(this.timePicker.selectedDate, ampmPart, ampmPart.format.length) === this.value;\n      }\n    }\n\n    get minValue() {\n      const dateType = this.itemList.type;\n      const inputDateParts = DateTimeUtil.parseDateTimeFormat(this.timePicker.inputFormat);\n\n      switch (dateType) {\n        case 'hourList':\n          return this.getHourPart(this.timePicker.minDropdownValue);\n\n        case 'minuteList':\n          if (this.timePicker.selectedDate.getHours() === this.timePicker.minDropdownValue.getHours()) {\n            const minutePart = inputDateParts.find(element => element.type === 'minutes');\n            return DateTimeUtil.getPartValue(this.timePicker.minDropdownValue, minutePart, minutePart.format.length);\n          }\n\n          return '00';\n\n        case 'secondsList':\n          const date = new Date(this.timePicker.selectedDate);\n          const min = new Date(this.timePicker.minDropdownValue);\n          date.setSeconds(0);\n          min.setSeconds(0);\n\n          if (date.getTime() === min.getTime()) {\n            const secondsPart = inputDateParts.find(element => element.type === 'seconds');\n            return DateTimeUtil.getPartValue(this.timePicker.minDropdownValue, secondsPart, secondsPart.format.length);\n          }\n\n          return '00';\n\n        case 'ampmList':\n          const ampmPart = inputDateParts.find(element => element.format === 'tt');\n          return DateTimeUtil.getPartValue(this.timePicker.minDropdownValue, ampmPart, ampmPart.format.length);\n      }\n    }\n\n    get maxValue() {\n      const dateType = this.itemList.type;\n      const inputDateParts = DateTimeUtil.parseDateTimeFormat(this.timePicker.inputFormat);\n\n      switch (dateType) {\n        case 'hourList':\n          return this.getHourPart(this.timePicker.maxDropdownValue);\n\n        case 'minuteList':\n          if (this.timePicker.selectedDate.getHours() === this.timePicker.maxDropdownValue.getHours()) {\n            const minutePart = inputDateParts.find(element => element.type === 'minutes');\n            return DateTimeUtil.getPartValue(this.timePicker.maxDropdownValue, minutePart, minutePart.format.length);\n          } else {\n            const currentTime = new Date(this.timePicker.selectedDate);\n            const minDelta = this.timePicker.itemsDelta.minutes;\n            const remainder = 60 % minDelta;\n            const delta = remainder === 0 ? 60 - minDelta : 60 - remainder;\n            currentTime.setMinutes(delta);\n            const minutePart = inputDateParts.find(element => element.type === 'minutes');\n            return DateTimeUtil.getPartValue(currentTime, minutePart, minutePart.format.length);\n          }\n\n        case 'secondsList':\n          const date = new Date(this.timePicker.selectedDate);\n          const max = new Date(this.timePicker.maxDropdownValue);\n          date.setSeconds(0);\n          max.setSeconds(0);\n\n          if (date.getTime() === max.getTime()) {\n            const secondsPart = inputDateParts.find(element => element.type === 'seconds');\n            return DateTimeUtil.getPartValue(this.timePicker.maxDropdownValue, secondsPart, secondsPart.format.length);\n          } else {\n            const secDelta = this.timePicker.itemsDelta.seconds;\n            const remainder = 60 % secDelta;\n            const delta = remainder === 0 ? 60 - secDelta : 60 - remainder;\n            date.setSeconds(delta);\n            const secondsPart = inputDateParts.find(element => element.type === 'seconds');\n            return DateTimeUtil.getPartValue(date, secondsPart, secondsPart.format.length);\n          }\n\n        case 'ampmList':\n          const ampmPart = inputDateParts.find(element => element.format === 'tt');\n          return DateTimeUtil.getPartValue(this.timePicker.maxDropdownValue, ampmPart, ampmPart.format.length);\n      }\n    }\n\n    get hourValue() {\n      return this.getHourPart(this.timePicker.selectedDate);\n    }\n\n    onClick(item) {\n      if (item !== '') {\n        const dateType = this.itemList.type;\n        this.timePicker.onItemClick(item, dateType);\n      }\n    }\n\n    getHourPart(date) {\n      const inputDateParts = DateTimeUtil.parseDateTimeFormat(this.timePicker.inputFormat);\n      const hourPart = inputDateParts.find(element => element.type === 'hours');\n      const ampmPart = inputDateParts.find(element => element.format === 'tt');\n      const hour = DateTimeUtil.getPartValue(date, hourPart, hourPart.format.length);\n\n      if (ampmPart) {\n        const ampm = DateTimeUtil.getPartValue(date, ampmPart, ampmPart.format.length);\n        return `${hour} ${ampm}`;\n      }\n\n      return hour;\n    }\n\n  }\n\n  IgxTimeItemDirective.ɵfac = function IgxTimeItemDirective_Factory(t) {\n    return new (t || IgxTimeItemDirective)(i0.ɵɵdirectiveInject(IGX_TIME_PICKER_COMPONENT), i0.ɵɵdirectiveInject(IgxItemListDirective));\n  };\n\n  IgxTimeItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxTimeItemDirective,\n    selectors: [[\"\", \"igxTimeItem\", \"\"]],\n    hostVars: 6,\n    hostBindings: function IgxTimeItemDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function IgxTimeItemDirective_click_HostBindingHandler() {\n          return ctx.onClick(ctx.value);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-time-picker__item\", ctx.defaultCSS)(\"igx-time-picker__item--selected\", ctx.selectedCSS)(\"igx-time-picker__item--active\", ctx.activeCSS);\n      }\n    },\n    inputs: {\n      value: [\"igxTimeItem\", \"value\"]\n    },\n    exportAs: [\"timeItem\"]\n  });\n  return IgxTimeItemDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * This directive should be used to mark which ng-template will be used from IgxTimePicker when re-templating its input group.\n */\n\n\nlet IgxTimePickerTemplateDirective = /*#__PURE__*/(() => {\n  class IgxTimePickerTemplateDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxTimePickerTemplateDirective.ɵfac = function IgxTimePickerTemplateDirective_Factory(t) {\n    return new (t || IgxTimePickerTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxTimePickerTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxTimePickerTemplateDirective,\n    selectors: [[\"\", \"igxTimePickerTemplate\", \"\"]]\n  });\n  return IgxTimePickerTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * This directive can be used to add custom action buttons to the dropdown/dialog.\n */\n\n\nlet IgxTimePickerActionsDirective = /*#__PURE__*/(() => {\n  class IgxTimePickerActionsDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxTimePickerActionsDirective.ɵfac = function IgxTimePickerActionsDirective_Factory(t) {\n    return new (t || IgxTimePickerActionsDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxTimePickerActionsDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxTimePickerActionsDirective,\n    selectors: [[\"\", \"igxTimePickerActions\", \"\"]]\n  });\n  return IgxTimePickerActionsDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst ITEMS_COUNT = 7;\nlet TimeFormatPipe = /*#__PURE__*/(() => {\n  class TimeFormatPipe {\n    constructor(timePicker) {\n      this.timePicker = timePicker;\n    }\n\n    transform(value) {\n      const format = this.timePicker.inputFormat.replace('tt', 'aa');\n      const datePipe = new DatePipe(this.timePicker.locale);\n      return datePipe.transform(value, format);\n    }\n\n  }\n\n  TimeFormatPipe.ɵfac = function TimeFormatPipe_Factory(t) {\n    return new (t || TimeFormatPipe)(i0.ɵɵdirectiveInject(IGX_TIME_PICKER_COMPONENT, 16));\n  };\n\n  TimeFormatPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"timeFormatPipe\",\n    type: TimeFormatPipe,\n    pure: true\n  });\n  return TimeFormatPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TimeItemPipe = /*#__PURE__*/(() => {\n  class TimeItemPipe {\n    constructor(timePicker) {\n      this.timePicker = timePicker;\n    }\n\n    transform(_collection, timePart, selectedDate, min, max) {\n      let list;\n      let part;\n\n      switch (timePart) {\n        case 'hour':\n          list = this.generateHours(min, max);\n          const hours = this.timePicker.isTwelveHourFormat ? this.toTwelveHourFormat(selectedDate.getHours()) : selectedDate.getHours();\n          list = this.scrollListItem(hours, list);\n          part = DatePart.Hours;\n          break;\n\n        case 'minutes':\n          list = this.generateMinutes(selectedDate, min, max);\n          list = this.scrollListItem(selectedDate.getMinutes(), list);\n          part = DatePart.Minutes;\n          break;\n\n        case 'seconds':\n          list = this.generateSeconds(selectedDate, min, max);\n          list = this.scrollListItem(selectedDate.getSeconds(), list);\n          part = DatePart.Seconds;\n          break;\n\n        case 'ampm':\n          list = this.generateAmPm(min, max);\n          const selectedAmPm = this.timePicker.getPartValue(selectedDate, 'ampm');\n          list = this.scrollListItem(selectedAmPm, list);\n          part = DatePart.AmPm;\n          break;\n      }\n\n      return this.getListView(list, part);\n    }\n\n    getListView(view, dateType) {\n      for (let i = 0; i < view.length; i++) {\n        view[i] = this.getItemView(view[i], dateType);\n      }\n\n      return view;\n    }\n\n    getItemView(item, dateType) {\n      if (item === null) {\n        item = '';\n      } else if (dateType && typeof item !== 'string') {\n        const leadZeroHour = item < 10 && (this.timePicker.inputFormat.indexOf('hh') !== -1 || this.timePicker.inputFormat.indexOf('HH') !== -1);\n        const leadZeroMinute = item < 10 && this.timePicker.inputFormat.indexOf('mm') !== -1;\n        const leadZeroSeconds = item < 10 && this.timePicker.inputFormat.indexOf('ss') !== -1;\n        const leadZero = {\n          hours: leadZeroHour,\n          minutes: leadZeroMinute,\n          seconds: leadZeroSeconds\n        }[dateType];\n        item = leadZero ? '0' + item : `${item}`;\n      }\n\n      return item;\n    }\n\n    scrollListItem(item, items) {\n      const itemsCount = items.length;\n      let view;\n\n      if (items) {\n        const index = items.indexOf(item);\n\n        if (index < 3) {\n          view = items.slice(itemsCount - (3 - index), itemsCount);\n          view = view.concat(items.slice(0, index + 4));\n        } else if (index + 4 > itemsCount) {\n          view = items.slice(index - 3, itemsCount);\n          view = view.concat(items.slice(0, index + 4 - itemsCount));\n        } else {\n          view = items.slice(index - 3, index + 4);\n        }\n      }\n\n      return view;\n    }\n\n    generateHours(min, max) {\n      const hourItems = [];\n      let hoursCount = this.timePicker.isTwelveHourFormat ? 13 : 24;\n      hoursCount /= this.timePicker.itemsDelta.hours;\n      const minHours = min.getHours();\n      const maxHours = max.getHours();\n\n      if (hoursCount > 1) {\n        for (let hourIndex = 0; hourIndex < 24; hourIndex++) {\n          let hours = hourIndex * this.timePicker.itemsDelta.hours;\n\n          if (hours >= minHours && hours <= maxHours) {\n            hours = this.timePicker.isTwelveHourFormat ? this.toTwelveHourFormat(hours) : hours;\n\n            if (!hourItems.find(element => element === hours)) {\n              hourItems.push(hours);\n            }\n          }\n        }\n      } else {\n        hourItems.push(0);\n      }\n\n      if (hourItems.length < ITEMS_COUNT || hoursCount < ITEMS_COUNT || !this.timePicker.spinLoop) {\n        const index = !this.timePicker.spinLoop || hourItems.length < ITEMS_COUNT && hoursCount < ITEMS_COUNT ? 6 : 3;\n\n        for (let i = 0; i < index; i++) {\n          hourItems.push(null);\n        }\n      }\n\n      return hourItems;\n    }\n\n    generateMinutes(time, min, max) {\n      const minuteItems = [];\n      const minuteItemsCount = 60 / this.timePicker.itemsDelta.minutes;\n      time = new Date(time);\n\n      for (let i = 0; i < minuteItemsCount; i++) {\n        const minutes = i * this.timePicker.itemsDelta.minutes;\n        time.setMinutes(minutes);\n\n        if (time >= min && time <= max) {\n          minuteItems.push(i * this.timePicker.itemsDelta.minutes);\n        }\n      }\n\n      if (minuteItems.length < ITEMS_COUNT || minuteItemsCount < ITEMS_COUNT || !this.timePicker.spinLoop) {\n        const index = !this.timePicker.spinLoop || minuteItems.length < ITEMS_COUNT && minuteItemsCount < ITEMS_COUNT ? 6 : 3;\n\n        for (let i = 0; i < index; i++) {\n          minuteItems.push(null);\n        }\n      }\n\n      return minuteItems;\n    }\n\n    generateSeconds(time, min, max) {\n      const secondsItems = [];\n      const secondsItemsCount = 60 / this.timePicker.itemsDelta.seconds;\n      time = new Date(time);\n\n      for (let i = 0; i < secondsItemsCount; i++) {\n        const seconds = i * this.timePicker.itemsDelta.seconds;\n        time.setSeconds(seconds);\n\n        if (time.getTime() >= min.getTime() && time.getTime() <= max.getTime()) {\n          secondsItems.push(i * this.timePicker.itemsDelta.seconds);\n        }\n      }\n\n      if (secondsItems.length < ITEMS_COUNT || secondsItemsCount < ITEMS_COUNT || !this.timePicker.spinLoop) {\n        const index = !this.timePicker.spinLoop || secondsItems.length < ITEMS_COUNT && secondsItemsCount < ITEMS_COUNT ? 6 : 3;\n\n        for (let i = 0; i < index; i++) {\n          secondsItems.push(null);\n        }\n      }\n\n      return secondsItems;\n    }\n\n    generateAmPm(min, max) {\n      const ampmItems = [];\n      const minHour = min.getHours();\n      const maxHour = max.getHours();\n\n      if (minHour < 12) {\n        ampmItems.push('AM');\n      }\n\n      if (minHour >= 12 || maxHour >= 12) {\n        ampmItems.push('PM');\n      }\n\n      for (let i = 0; i < 5; i++) {\n        ampmItems.push(null);\n      }\n\n      return ampmItems;\n    }\n\n    toTwelveHourFormat(hour) {\n      if (hour > 12) {\n        hour -= 12;\n      } else if (hour === 0) {\n        hour = 12;\n      }\n\n      return hour;\n    }\n\n  }\n\n  TimeItemPipe.ɵfac = function TimeItemPipe_Factory(t) {\n    return new (t || TimeItemPipe)(i0.ɵɵdirectiveInject(IGX_TIME_PICKER_COMPONENT, 16));\n  };\n\n  TimeItemPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"timeItemPipe\",\n    type: TimeItemPipe,\n    pure: true\n  });\n  return TimeItemPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$c = 0;\nlet IgxTimePickerComponent = /*#__PURE__*/(() => {\n  class IgxTimePickerComponent extends PickerBaseDirective {\n    constructor(element, _localeId, _displayDensityOptions, _inputGroupType, _injector, platform, cdr) {\n      super(element, _localeId, _displayDensityOptions, _inputGroupType);\n      this.element = element;\n      this._localeId = _localeId;\n      this._displayDensityOptions = _displayDensityOptions;\n      this._inputGroupType = _inputGroupType;\n      this._injector = _injector;\n      this.platform = platform;\n      this.cdr = cdr;\n      /**\n       * An @Input property that sets the value of the `id` attribute.\n       * ```html\n       * <igx-time-picker [id]=\"'igx-time-picker-5'\" [displayFormat]=\"h:mm tt\" ></igx-time-picker>\n       * ```\n       */\n\n      this.id = `igx-time-picker-${NEXT_ID$c++}`;\n      /**\n       * The expected user input format and placeholder.\n       *\n       * @remarks\n       * Default is `hh:mm tt`\n       *\n       * @example\n       * ```html\n       * <igx-time-picker inputFormat=\"HH:mm\"></igx-time-picker>\n       * ```\n       */\n\n      this.inputFormat = DateTimeUtil.DEFAULT_TIME_INPUT_FORMAT;\n      /**\n       * Gets/Sets the interaction mode - dialog or drop down.\n       *\n       * @example\n       * ```html\n       * <igx-time-picker mode=\"dialog\"></igx-time-picker>\n       * ```\n       */\n\n      this.mode = PickerInteractionMode.DropDown;\n      /**\n       * An @Input property that determines the spin behavior. By default `spinLoop` is set to true.\n       * The seconds, minutes and hour spinning will wrap around by default.\n       * ```html\n       * <igx-time-picker [spinLoop]=\"false\"></igx-time-picker>\n       * ```\n       */\n\n      this.spinLoop = true;\n      /**\n       * Sets the orientation of the picker's header.\n       *\n       * @remarks\n       * Available in dialog mode only. Default value is `horizontal`.\n       *\n       * ```html\n       * <igx-time-picker [headerOrientation]=\"'vertical'\"></igx-time-picker>\n       * ```\n       */\n\n      this.headerOrientation = PickerHeaderOrientation.Horizontal;\n      /** @hidden @internal */\n\n      this.readOnly = false;\n      /**\n       * Emitted after a selection has been done.\n       *\n       * @example\n       * ```html\n       * <igx-time-picker (selected)=\"onSelection($event)\"></igx-time-picker>\n       * ```\n       */\n\n      this.selected = new EventEmitter();\n      /**\n       * Emitted when the picker's value changes.\n       *\n       * @remarks\n       * Used for `two-way` bindings.\n       *\n       * @example\n       * ```html\n       * <igx-time-picker [(value)]=\"date\"></igx-time-picker>\n       * ```\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * Emitted when the user types/spins invalid time in the time-picker editor.\n       *\n       *  @example\n       * ```html\n       * <igx-time-picker (validationFailed)=\"onValidationFailed($event)\"></igx-time-picker>\n       * ```\n       */\n\n      this.validationFailed = new EventEmitter();\n      /** @hidden */\n\n      this.cleared = false;\n      /** @hidden */\n\n      this.isNotEmpty = false;\n      /** @hidden @internal */\n\n      this.displayValue = {\n        transform: date => this.formatter(date)\n      };\n      /** @hidden @internal */\n\n      this.hourItems = [];\n      /** @hidden @internal */\n\n      this.minuteItems = [];\n      /** @hidden @internal */\n\n      this.secondsItems = [];\n      /** @hidden @internal */\n\n      this.ampmItems = [];\n      this._resourceStrings = CurrentResourceStrings.TimePickerResStrings;\n      this._okButtonLabel = null;\n      this._cancelButtonLabel = null;\n      this._itemsDelta = {\n        hours: 1,\n        minutes: 1,\n        seconds: 1\n      };\n      this._ngControl = null;\n      this._onChangeCallback = noop;\n      this._onTouchedCallback = noop;\n      this._onValidatorChange = noop;\n      this._defaultDialogOverlaySettings = {\n        closeOnOutsideClick: true,\n        modal: true,\n        closeOnEscape: true,\n        outlet: this.outlet\n      };\n      this._defaultDropDownOverlaySettings = {\n        target: this.element.nativeElement,\n        modal: false,\n        closeOnOutsideClick: true,\n        scrollStrategy: new AbsoluteScrollStrategy(),\n        positionStrategy: new AutoPositionStrategy(),\n        outlet: this.outlet\n      };\n    }\n    /**\n     * The minimum value the picker will accept.\n     *\n     * @remarks\n     * If a `string` value is passed in, it must be in ISO format.\n     *\n     * @example\n     * ```html\n     * <igx-time-picker [minValue]=\"18:00:00\"></igx-time-picker>\n     * ```\n     */\n\n\n    set minValue(value) {\n      this._minValue = value;\n      const date = this.parseToDate(value);\n\n      if (date) {\n        this._dateMinValue = new Date();\n\n        this._dateMinValue.setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n\n        this.minDropdownValue = this.setMinMaxDropdownValue('min', this._dateMinValue);\n      }\n\n      this.setSelectedValue(this._selectedDate);\n\n      this._onValidatorChange();\n    }\n\n    get minValue() {\n      return this._minValue;\n    }\n    /**\n     * Gets if the dropdown/dialog is collapsed\n     *\n     * ```typescript\n     * let isCollapsed = this.timePicker.collapsed;\n     * ```\n     */\n\n\n    get collapsed() {\n      var _a;\n\n      return (_a = this.toggleRef) === null || _a === void 0 ? void 0 : _a.collapsed;\n    }\n    /**\n     * The maximum value the picker will accept.\n     *\n     * @remarks\n     * If a `string` value is passed in, it must be in ISO format.\n     *\n     * @example\n     * ```html\n     * <igx-time-picker [maxValue]=\"20:30:00\"></igx-time-picker>\n     * ```\n     */\n\n\n    set maxValue(value) {\n      this._maxValue = value;\n      const date = this.parseToDate(value);\n\n      if (date) {\n        this._dateMaxValue = new Date();\n\n        this._dateMaxValue.setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n\n        this.maxDropdownValue = this.setMinMaxDropdownValue('max', this._dateMaxValue);\n      }\n\n      this.setSelectedValue(this._selectedDate);\n\n      this._onValidatorChange();\n    }\n\n    get maxValue() {\n      return this._maxValue;\n    }\n    /** @hidden */\n\n\n    get showClearButton() {\n      if (this.clearComponents.length) {\n        return false;\n      }\n\n      if (DateTimeUtil.isValidDate(this.value)) {\n        // TODO: Update w/ clear behavior\n        return this.value.getHours() !== 0 || this.value.getMinutes() !== 0 || this.value.getSeconds() !== 0;\n      }\n\n      return !!this.dateTimeEditor.value;\n    }\n    /** @hidden */\n\n\n    get showHoursList() {\n      return this.inputFormat.indexOf('h') !== -1 || this.inputFormat.indexOf('H') !== -1;\n    }\n    /** @hidden */\n\n\n    get showMinutesList() {\n      return this.inputFormat.indexOf('m') !== -1;\n    }\n    /** @hidden */\n\n\n    get showSecondsList() {\n      return this.inputFormat.indexOf('s') !== -1;\n    }\n    /** @hidden */\n\n\n    get showAmPmList() {\n      return this.inputFormat.indexOf('t') !== -1 || this.inputFormat.indexOf('a') !== -1;\n    }\n    /** @hidden */\n\n\n    get isTwelveHourFormat() {\n      return this.inputFormat.indexOf('h') !== -1;\n    }\n    /** @hidden @internal */\n\n\n    get isDropdown() {\n      return this.mode === PickerInteractionMode.DropDown;\n    }\n    /** @hidden @internal */\n\n\n    get isVertical() {\n      return this.headerOrientation === PickerHeaderOrientation.Vertical;\n    }\n    /** @hidden @internal */\n\n\n    get selectedDate() {\n      return this._selectedDate;\n    }\n    /** @hidden @internal */\n\n\n    get minDateValue() {\n      if (!this._dateMinValue) {\n        const minDate = new Date();\n        minDate.setHours(0, 0, 0, 0);\n        return minDate;\n      }\n\n      return this._dateMinValue;\n    }\n    /** @hidden @internal */\n\n\n    get maxDateValue() {\n      if (!this._dateMaxValue) {\n        const maxDate = new Date();\n        maxDate.setHours(23, 59, 59, 999);\n        return maxDate;\n      }\n\n      return this._dateMaxValue;\n    }\n\n    get required() {\n      if (this._ngControl && this._ngControl.control && this._ngControl.control.validator) {\n        // Run the validation with empty object to check if required is enabled.\n        const error = this._ngControl.control.validator({});\n\n        return !!(error && error.required);\n      }\n\n      return false;\n    }\n\n    get dialogOverlaySettings() {\n      return Object.assign({}, this._defaultDialogOverlaySettings, this.overlaySettings);\n    }\n\n    get dropDownOverlaySettings() {\n      return Object.assign({}, this._defaultDropDownOverlaySettings, this.overlaySettings);\n    }\n    /**\n     * The currently selected value / time from the drop-down/dialog\n     *\n     * @remarks\n     * The current value is of type `Date`\n     *\n     * @example\n     * ```typescript\n     * const newValue: Date = new Date(2000, 2, 2, 10, 15, 15);\n     * this.timePicker.value = newValue;\n     * ```\n     */\n\n\n    get value() {\n      return this._value;\n    }\n    /**\n     * An accessor that allows you to set a time using the `value` input.\n     * ```html\n     * public date: Date = new Date(Date.now());\n     *  //...\n     * <igx-time-picker [value]=\"date\" format=\"h:mm tt\"></igx-time-picker>\n     * ```\n     */\n\n\n    set value(value) {\n      const oldValue = this._value;\n      this._value = value;\n      const date = this.parseToDate(value);\n\n      if (date) {\n        this._dateValue = new Date();\n\n        this._dateValue.setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n\n        this.setSelectedValue(this._dateValue);\n      } else {\n        this._dateValue = null;\n        this.setSelectedValue(null);\n      }\n\n      if (this.dateTimeEditor) {\n        this.dateTimeEditor.value = date;\n      }\n\n      this.emitValueChange(oldValue, this._value);\n\n      this._onChangeCallback(this._value);\n    }\n    /**\n     * An accessor that sets the resource strings.\n     * By default it uses EN resources.\n     */\n\n\n    set resourceStrings(value) {\n      this._resourceStrings = Object.assign({}, this._resourceStrings, value);\n    }\n    /**\n     * An accessor that returns the resource strings.\n     */\n\n\n    get resourceStrings() {\n      return this._resourceStrings;\n    }\n    /**\n     * An @Input property that renders OK button with custom text. By default `okButtonLabel` is set to OK.\n     * ```html\n     * <igx-time-picker okButtonLabel='SET' [value]=\"date\" format=\"h:mm tt\"></igx-time-picker>\n     * ```\n     */\n\n\n    set okButtonLabel(value) {\n      this._okButtonLabel = value;\n    }\n    /**\n     * An accessor that returns the label of ok button.\n     */\n\n\n    get okButtonLabel() {\n      if (this._okButtonLabel === null) {\n        return this.resourceStrings.igx_time_picker_ok;\n      }\n\n      return this._okButtonLabel;\n    }\n    /**\n     * An @Input property that renders cancel button with custom text.\n     * By default `cancelButtonLabel` is set to Cancel.\n     * ```html\n     * <igx-time-picker cancelButtonLabel='Exit' [value]=\"date\" format=\"h:mm tt\"></igx-time-picker>\n     * ```\n     */\n\n\n    set cancelButtonLabel(value) {\n      this._cancelButtonLabel = value;\n    }\n    /**\n     * An accessor that returns the label of cancel button.\n     */\n\n\n    get cancelButtonLabel() {\n      if (this._cancelButtonLabel === null) {\n        return this.resourceStrings.igx_time_picker_cancel;\n      }\n\n      return this._cancelButtonLabel;\n    }\n    /**\n     * Delta values used to increment or decrement each editor date part on spin actions and\n     * to display time portions in the dropdown/dialog.\n     * By default `itemsDelta` is set to `{hour: 1, minute: 1, second: 1}`\n     * ```html\n     * <igx-time-picker [itemsDelta]=\"{hour:3, minute:5, second:10}\" id=\"time-picker\"></igx-time-picker>\n     * ```\n     */\n\n\n    set itemsDelta(value) {\n      Object.assign(this._itemsDelta, value);\n    }\n\n    get itemsDelta() {\n      return this._itemsDelta;\n    }\n    /** @hidden @internal */\n\n\n    onKeyDown(event) {\n      switch (event.key) {\n        case this.platform.KEYMAP.ARROW_UP:\n          if (event.altKey && this.isDropdown) {\n            this.close();\n          }\n\n          break;\n\n        case this.platform.KEYMAP.ARROW_DOWN:\n          if (event.altKey && this.isDropdown) {\n            this.open();\n          }\n\n          break;\n\n        case this.platform.KEYMAP.ESCAPE:\n          this.cancelButtonClick();\n          break;\n\n        case this.platform.KEYMAP.SPACE:\n          this.open();\n          event.preventDefault();\n          break;\n      }\n    }\n    /** @hidden @internal */\n\n\n    getPartValue(value, type) {\n      const inputDateParts = DateTimeUtil.parseDateTimeFormat(this.inputFormat);\n      const part = inputDateParts.find(element => element.type === type);\n      return DateTimeUtil.getPartValue(value, part, part.format.length);\n    }\n    /** @hidden @internal */\n\n\n    toISOString(value) {\n      return value.toLocaleTimeString('en-GB', {\n        hour: '2-digit',\n        minute: '2-digit',\n        second: '2-digit'\n      });\n    } // #region ControlValueAccessor\n\n    /** @hidden @internal */\n\n\n    writeValue(value) {\n      this._value = value;\n      const date = this.parseToDate(value);\n\n      if (date) {\n        this._dateValue = new Date();\n\n        this._dateValue.setHours(date.getHours(), date.getMinutes(), date.getSeconds());\n\n        this.setSelectedValue(this._dateValue);\n      } else {\n        this.setSelectedValue(null);\n      }\n\n      if (this.dateTimeEditor) {\n        this.dateTimeEditor.value = date;\n      }\n    }\n    /** @hidden @internal */\n\n\n    registerOnChange(fn) {\n      this._onChangeCallback = fn;\n    }\n    /** @hidden @internal */\n\n\n    registerOnTouched(fn) {\n      this._onTouchedCallback = fn;\n    }\n    /** @hidden @internal */\n\n\n    registerOnValidatorChange(fn) {\n      this._onValidatorChange = fn;\n    }\n    /** @hidden @internal */\n\n\n    validate(control) {\n      if (!control.value) {\n        return null;\n      } // InvalidDate handling\n\n\n      if (isDate(control.value) && !DateTimeUtil.isValidDate(control.value)) {\n        return {\n          value: true\n        };\n      }\n\n      const errors = {};\n      const value = DateTimeUtil.isValidDate(control.value) ? control.value : DateTimeUtil.parseIsoDate(control.value);\n      Object.assign(errors, DateTimeUtil.validateMinMax(value, this.minValue, this.maxValue, true, false));\n      return Object.keys(errors).length > 0 ? errors : null;\n    }\n    /** @hidden @internal */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    } //#endregion\n\n    /** @hidden */\n\n\n    ngOnInit() {\n      this._ngControl = this._injector.get(NgControl, null);\n      this.minDropdownValue = this.setMinMaxDropdownValue('min', this.minDateValue);\n      this.maxDropdownValue = this.setMinMaxDropdownValue('max', this.maxDateValue);\n      this.setSelectedValue(this._dateValue);\n    }\n    /** @hidden */\n\n\n    ngAfterViewInit() {\n      super.ngAfterViewInit();\n      this.subscribeToDateEditorEvents();\n      this.subscribeToToggleDirectiveEvents();\n      this._defaultDropDownOverlaySettings.excludeFromOutsideClick = [this._inputGroup.element.nativeElement];\n      fromEvent(this.inputDirective.nativeElement, 'blur').pipe(takeUntil(this._destroy$)).subscribe(() => {\n        if (this.collapsed) {\n          this.updateValidityOnBlur();\n        }\n      });\n      this.subToIconsClicked(this.clearComponents, () => this.clear());\n      this.clearComponents.changes.pipe(takeUntil(this._destroy$)).subscribe(() => this.subToIconsClicked(this.clearComponents, () => this.clear()));\n\n      if (this._ngControl) {\n        this._statusChanges$ = this._ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));\n        this._inputGroup.isRequired = this.required;\n        this.cdr.detectChanges();\n      }\n    }\n    /** @hidden */\n\n\n    ngOnDestroy() {\n      super.ngOnDestroy();\n\n      if (this._statusChanges$) {\n        this._statusChanges$.unsubscribe();\n      }\n    }\n    /** @hidden */\n\n\n    getEditElement() {\n      return this.dateTimeEditor.nativeElement;\n    }\n    /**\n     * Opens the picker's dialog UI.\n     *\n     * @param settings OverlaySettings - the overlay settings to use for positioning the drop down or dialog container according to\n     * ```html\n     * <igx-time-picker #picker [value]=\"date\"></igx-time-picker>\n     * <button (click)=\"picker.open()\">Open Dialog</button>\n     * ```\n     */\n\n\n    open(settings) {\n      if (this.disabled || !this.toggleRef.collapsed) {\n        return;\n      }\n\n      this.setSelectedValue(this._dateValue);\n      const overlaySettings = Object.assign({}, this.isDropdown ? this.dropDownOverlaySettings : this.dialogOverlaySettings, settings);\n      this.toggleRef.open(overlaySettings);\n    }\n    /**\n     * Closes the dropdown/dialog.\n     * ```html\n     * <igx-time-picker #timePicker></igx-time-picker>\n     * ```\n     * ```typescript\n     * @ViewChild('timePicker', { read: IgxTimePickerComponent }) picker: IgxTimePickerComponent;\n     * picker.close();\n     * ```\n     */\n\n\n    close() {\n      this.toggleRef.close();\n    }\n\n    toggle(settings) {\n      if (this.toggleRef.collapsed) {\n        this.open(settings);\n      } else {\n        this.close();\n      }\n    }\n    /**\n     * Clears the time picker value if it is a `string` or resets the time to `00:00:00` if the value is a Date object.\n     *\n     * @example\n     * ```typescript\n     * this.timePicker.clear();\n     * ```\n     */\n\n\n    clear() {\n      if (this.disabled) {\n        return;\n      }\n\n      if (!this.toggleRef.collapsed) {\n        this.close();\n      }\n\n      if (DateTimeUtil.isValidDate(this.value)) {\n        const oldValue = new Date(this.value);\n        this.value.setHours(0, 0, 0);\n\n        if (this.value.getTime() !== oldValue.getTime()) {\n          this.emitValueChange(oldValue, this.value);\n\n          this._dateValue.setHours(0, 0, 0);\n\n          this.dateTimeEditor.value = new Date(this.value);\n          this.setSelectedValue(this._dateValue);\n        }\n      } else {\n        this.value = null;\n      }\n    }\n    /**\n     * Selects time from the igxTimePicker.\n     *\n     * @example\n     * ```typescript\n     * this.timePicker.select(date);\n     *\n     * @param date Date object containing the time to be selected.\n     */\n\n\n    select(date) {\n      this.value = date;\n    }\n    /**\n     * Increment a specified `DatePart`.\n     *\n     * @param datePart The optional DatePart to increment. Defaults to Hour.\n     * @param delta The optional delta to increment by. Overrides `itemsDelta`.\n     * @example\n     * ```typescript\n     * this.timePicker.increment(DatePart.Hours);\n     * ```\n     */\n\n\n    increment(datePart, delta) {\n      this.dateTimeEditor.increment(datePart, delta);\n    }\n    /**\n     * Decrement a specified `DatePart`\n     *\n     * @param datePart The optional DatePart to decrement. Defaults to Hour.\n     * @param delta The optional delta to decrement by. Overrides `itemsDelta`.\n     * @example\n     * ```typescript\n     * this.timePicker.decrement(DatePart.Seconds);\n     * ```\n     */\n\n\n    decrement(datePart, delta) {\n      this.dateTimeEditor.decrement(datePart, delta);\n    }\n    /** @hidden @internal */\n\n\n    cancelButtonClick() {\n      this.setSelectedValue(this._dateValue);\n      this.dateTimeEditor.value = this.parseToDate(this.value);\n      this.close();\n    }\n    /** @hidden @internal */\n\n\n    okButtonClick() {\n      this.updateValue(this._selectedDate);\n      this.close();\n    }\n    /** @hidden @internal */\n\n\n    onItemClick(item, dateType) {\n      var _a, _b;\n\n      let date = new Date(this._selectedDate);\n\n      switch (dateType) {\n        case 'hourList':\n          let ampm;\n          const selectedHour = parseInt(item, 10);\n          let hours = selectedHour;\n\n          if (this.showAmPmList) {\n            ampm = this.getPartValue(date, 'ampm');\n            hours = this.toTwentyFourHourFormat(hours, ampm);\n            const minHours = ((_a = this.minDropdownValue) === null || _a === void 0 ? void 0 : _a.getHours()) || 0;\n            const maxHours = ((_b = this.maxDropdownValue) === null || _b === void 0 ? void 0 : _b.getHours()) || 24;\n\n            if (hours < minHours || hours > maxHours) {\n              hours = hours < 12 ? hours + 12 : hours - 12;\n            }\n          }\n\n          date.setHours(hours);\n          date = this.validateDropdownValue(date);\n\n          if (this.valueInRange(date, this.minDropdownValue, this.maxDropdownValue)) {\n            this.setSelectedValue(date);\n          }\n\n          break;\n\n        case 'minuteList':\n          {\n            const minutes = parseInt(item, 10);\n            date.setMinutes(minutes);\n            date = this.validateDropdownValue(date);\n            this.setSelectedValue(date);\n            break;\n          }\n\n        case 'secondsList':\n          {\n            const seconds = parseInt(item, 10);\n            date.setSeconds(seconds);\n\n            if (this.valueInRange(date, this.minDropdownValue, this.maxDropdownValue)) {\n              this.setSelectedValue(date);\n            }\n\n            break;\n          }\n\n        case 'ampmList':\n          {\n            let hour = this._selectedDate.getHours();\n\n            hour = item === 'AM' ? hour - 12 : hour + 12;\n            date.setHours(hour);\n            date = this.validateDropdownValue(date, true);\n            this.setSelectedValue(date);\n            break;\n          }\n      }\n\n      this.updateEditorValue();\n    }\n    /** @hidden @internal */\n\n\n    nextHour(delta) {\n      var _a, _b;\n\n      delta = delta > 0 ? 1 : -1;\n      const previousDate = new Date(this._selectedDate);\n      const minHours = (_a = this.minDropdownValue) === null || _a === void 0 ? void 0 : _a.getHours();\n      const maxHours = (_b = this.maxDropdownValue) === null || _b === void 0 ? void 0 : _b.getHours();\n      const previousHours = previousDate.getHours();\n      let hours = previousHours + delta * this.itemsDelta.hours;\n\n      if (previousHours === maxHours && delta > 0 || previousHours === minHours && delta < 0) {\n        hours = !this.spinLoop ? previousHours : delta > 0 ? minHours : maxHours;\n      }\n\n      this._selectedDate.setHours(hours);\n\n      this._selectedDate = this.validateDropdownValue(this._selectedDate);\n      this._selectedDate = new Date(this._selectedDate);\n      this.updateEditorValue();\n    }\n    /** @hidden @internal */\n\n\n    nextMinute(delta) {\n      delta = delta > 0 ? 1 : -1;\n      const minHours = this.minDropdownValue.getHours();\n      const maxHours = this.maxDropdownValue.getHours();\n\n      const hours = this._selectedDate.getHours();\n\n      let minutes = this._selectedDate.getMinutes();\n\n      const minMinutes = hours === minHours ? this.minDropdownValue.getMinutes() : 0;\n      const maxMinutes = hours === maxHours ? this.maxDropdownValue.getMinutes() : 60 % this.itemsDelta.minutes > 0 ? 60 - 60 % this.itemsDelta.minutes : 60 - this.itemsDelta.minutes;\n\n      if (delta < 0 && minutes === minMinutes || delta > 0 && minutes === maxMinutes) {\n        minutes = this.spinLoop && minutes === minMinutes ? maxMinutes : this.spinLoop && minutes === maxMinutes ? minMinutes : minutes;\n      } else {\n        minutes = minutes + delta * this.itemsDelta.minutes;\n      }\n\n      this._selectedDate.setMinutes(minutes);\n\n      this._selectedDate = this.validateDropdownValue(this._selectedDate);\n      this._selectedDate = new Date(this._selectedDate);\n      this.updateEditorValue();\n    }\n    /** @hidden @internal */\n\n\n    nextSeconds(delta) {\n      delta = delta > 0 ? 1 : -1;\n      const minHours = this.minDropdownValue.getHours();\n      const maxHours = this.maxDropdownValue.getHours();\n\n      const hours = this._selectedDate.getHours();\n\n      const minutes = this._selectedDate.getMinutes();\n\n      const minMinutes = this.minDropdownValue.getMinutes();\n      const maxMinutes = this.maxDropdownValue.getMinutes();\n\n      let seconds = this._selectedDate.getSeconds();\n\n      const minSeconds = hours === minHours && minutes === minMinutes ? this.minDropdownValue.getSeconds() : 0;\n      const maxSeconds = hours === maxHours && minutes === maxMinutes ? this.maxDropdownValue.getSeconds() : 60 % this.itemsDelta.seconds > 0 ? 60 - 60 % this.itemsDelta.seconds : 60 - this.itemsDelta.seconds;\n\n      if (delta < 0 && seconds === minSeconds || delta > 0 && seconds === maxSeconds) {\n        seconds = this.spinLoop && seconds === minSeconds ? maxSeconds : this.spinLoop && seconds === maxSeconds ? minSeconds : seconds;\n      } else {\n        seconds = seconds + delta * this.itemsDelta.seconds;\n      }\n\n      this._selectedDate.setSeconds(seconds);\n\n      this._selectedDate = this.validateDropdownValue(this._selectedDate);\n      this._selectedDate = new Date(this._selectedDate);\n      this.updateEditorValue();\n    }\n    /** @hidden @internal */\n\n\n    nextAmPm(delta) {\n      const ampm = this.getPartValue(this._selectedDate, 'ampm');\n\n      if (!delta || ampm === 'AM' && delta > 0 || ampm === 'PM' && delta < 0) {\n        let hours = this._selectedDate.getHours();\n\n        const sign = hours < 12 ? 1 : -1;\n        hours = hours + sign * 12;\n\n        this._selectedDate.setHours(hours);\n\n        this._selectedDate = this.validateDropdownValue(this._selectedDate, true);\n        this._selectedDate = new Date(this._selectedDate);\n        this.updateEditorValue();\n      }\n    }\n    /** @hidden @internal */\n\n\n    setSelectedValue(value) {\n      this._selectedDate = value ? new Date(value) : null;\n\n      if (!DateTimeUtil.isValidDate(this._selectedDate)) {\n        this._selectedDate = new Date(this.minDropdownValue);\n        return;\n      }\n\n      if (this.minValue && DateTimeUtil.lessThanMinValue(this._selectedDate, this.minDropdownValue, true, false)) {\n        this._selectedDate = new Date(this.minDropdownValue);\n        return;\n      }\n\n      if (this.maxValue && DateTimeUtil.greaterThanMaxValue(this._selectedDate, this.maxDropdownValue, true, false)) {\n        this._selectedDate = new Date(this.maxDropdownValue);\n        return;\n      }\n\n      if (this._selectedDate.getHours() % this.itemsDelta.hours > 0) {\n        this._selectedDate.setHours(this._selectedDate.getHours() + this.itemsDelta.hours - this._selectedDate.getHours() % this.itemsDelta.hours, 0, 0);\n      }\n\n      if (this._selectedDate.getMinutes() % this.itemsDelta.minutes > 0) {\n        this._selectedDate.setHours(this._selectedDate.getHours(), this._selectedDate.getMinutes() + this.itemsDelta.minutes - this._selectedDate.getMinutes() % this.itemsDelta.minutes, 0);\n      }\n\n      if (this._selectedDate.getSeconds() % this.itemsDelta.seconds > 0) {\n        this._selectedDate.setSeconds(this._selectedDate.getSeconds() + this.itemsDelta.seconds - this._selectedDate.getSeconds() % this.itemsDelta.seconds);\n      }\n    }\n\n    onStatusChanged() {\n      if ((this._ngControl.control.touched || this._ngControl.control.dirty) && (this._ngControl.control.validator || this._ngControl.control.asyncValidator)) {\n        if (this._inputGroup.isFocused) {\n          this.inputDirective.valid = this._ngControl.valid ? IgxInputState.VALID : IgxInputState.INVALID;\n        } else {\n          this.inputDirective.valid = this._ngControl.valid ? IgxInputState.INITIAL : IgxInputState.INVALID;\n        }\n      } else {\n        // B.P. 18 May 2021: IgxDatePicker does not reset its state upon resetForm #9526\n        this.inputDirective.valid = IgxInputState.INITIAL;\n      }\n\n      if (this._inputGroup && this._inputGroup.isRequired !== this.required) {\n        this._inputGroup.isRequired = this.required;\n      }\n    }\n\n    setMinMaxDropdownValue(type, time) {\n      let delta;\n      const sign = type === 'min' ? 1 : -1;\n      const hours = time.getHours();\n      let minutes = time.getMinutes();\n      let seconds = time.getSeconds();\n\n      if (this.showHoursList && hours % this.itemsDelta.hours > 0) {\n        delta = type === 'min' ? this.itemsDelta.hours - hours % this.itemsDelta.hours : hours % this.itemsDelta.hours;\n        minutes = type === 'min' ? 0 : 60 % this.itemsDelta.minutes > 0 ? 60 - 60 % this.itemsDelta.minutes : 60 - this.itemsDelta.minutes;\n        seconds = type === 'min' ? 0 : 60 % this.itemsDelta.seconds > 0 ? 60 - 60 % this.itemsDelta.seconds : 60 - this.itemsDelta.seconds;\n        time.setHours(hours + sign * delta, minutes, seconds);\n      } else if (this.showMinutesList && minutes % this.itemsDelta.minutes > 0) {\n        delta = type === 'min' ? this.itemsDelta.minutes - minutes % this.itemsDelta.minutes : minutes % this.itemsDelta.minutes;\n        seconds = type === 'min' ? 0 : 60 % this.itemsDelta.seconds > 0 ? 60 - 60 % this.itemsDelta.seconds : 60 - this.itemsDelta.seconds;\n        time.setHours(hours, minutes + sign * delta, seconds);\n      } else if (this.showSecondsList && seconds % this.itemsDelta.seconds > 0) {\n        delta = type === 'min' ? this.itemsDelta.seconds - seconds % this.itemsDelta.seconds : seconds % this.itemsDelta.seconds;\n        time.setHours(hours, minutes, seconds + sign * delta);\n      }\n\n      return time;\n    }\n\n    initializeContainer() {\n      requestAnimationFrame(() => {\n        if (this.hourList) {\n          this.hourList.nativeElement.focus();\n        } else if (this.minuteList) {\n          this.minuteList.nativeElement.focus();\n        } else if (this.secondsList) {\n          this.secondsList.nativeElement.focus();\n        }\n      });\n    }\n\n    validateDropdownValue(date, isAmPm = false) {\n      if (date > this.maxDropdownValue) {\n        if (isAmPm && date.getHours() !== this.maxDropdownValue.getHours()) {\n          date.setHours(12);\n        } else {\n          date = new Date(this.maxDropdownValue);\n        }\n      }\n\n      if (date < this.minDropdownValue) {\n        date = new Date(this.minDropdownValue);\n      }\n\n      return date;\n    }\n\n    emitValueChange(oldValue, newValue) {\n      if (!isEqual(oldValue, newValue)) {\n        this.valueChange.emit(newValue);\n      }\n    }\n\n    emitValidationFailedEvent(previousValue) {\n      const args = {\n        owner: this,\n        previousValue,\n        currentValue: this.value\n      };\n      this.validationFailed.emit(args);\n    }\n\n    updateValidityOnBlur() {\n      this._onTouchedCallback();\n\n      if (this._ngControl) {\n        if (!this._ngControl.valid) {\n          this.inputDirective.valid = IgxInputState.INVALID;\n        } else {\n          this.inputDirective.valid = IgxInputState.INITIAL;\n        }\n      }\n    }\n\n    valueInRange(value, minValue, maxValue) {\n      if (minValue && DateTimeUtil.lessThanMinValue(value, minValue, true, false)) {\n        return false;\n      }\n\n      if (maxValue && DateTimeUtil.greaterThanMaxValue(value, maxValue, true, false)) {\n        return false;\n      }\n\n      return true;\n    }\n\n    parseToDate(value) {\n      return DateTimeUtil.isValidDate(value) ? value : DateTimeUtil.parseIsoDate(value);\n    }\n\n    toTwentyFourHourFormat(hour, ampm) {\n      if (ampm === 'PM' && hour < 12) {\n        hour += 12;\n      } else if (ampm === 'AM' && hour === 12) {\n        hour = 0;\n      }\n\n      return hour;\n    }\n\n    updateValue(newValue) {\n      if (!this.value) {\n        this.value = newValue ? new Date(newValue) : newValue;\n      } else if (isDate(this.value)) {\n        const date = new Date(this.value);\n        date.setHours((newValue === null || newValue === void 0 ? void 0 : newValue.getHours()) || 0, (newValue === null || newValue === void 0 ? void 0 : newValue.getMinutes()) || 0, (newValue === null || newValue === void 0 ? void 0 : newValue.getSeconds()) || 0);\n        this.value = date;\n      } else {\n        this.value = newValue ? this.toISOString(newValue) : newValue;\n      }\n    }\n\n    updateEditorValue() {\n      const date = this.dateTimeEditor.value ? new Date(this.dateTimeEditor.value) : new Date();\n      date.setHours(this._selectedDate.getHours(), this._selectedDate.getMinutes(), this._selectedDate.getSeconds());\n      this.dateTimeEditor.value = date;\n    }\n\n    subscribeToDateEditorEvents() {\n      this.dateTimeEditor.valueChange.pipe( // internal date editor directive is only used w/ Date object values:\n      takeUntil(this._destroy$)).subscribe(date => {\n        this.updateValue(date);\n      });\n      this.dateTimeEditor.validationFailed.pipe(takeUntil(this._destroy$)).subscribe(event => {\n        this.emitValidationFailedEvent(event.oldValue);\n      });\n    }\n\n    subscribeToToggleDirectiveEvents() {\n      if (this.toggleRef) {\n        if (this._inputGroup) {\n          this.toggleRef.element.style.width = this._inputGroup.element.nativeElement.getBoundingClientRect().width + 'px';\n        }\n\n        this.toggleRef.opening.pipe(takeUntil(this._destroy$)).subscribe(e => {\n          const args = {\n            owner: this,\n            event: e.event,\n            cancel: false\n          };\n          this.opening.emit(args);\n          e.cancel = args.cancel;\n\n          if (args.cancel) {\n            return;\n          }\n\n          this.initializeContainer();\n        });\n        this.toggleRef.opened.pipe(takeUntil(this._destroy$)).subscribe(() => {\n          this.opened.emit({\n            owner: this\n          });\n        });\n        this.toggleRef.closed.pipe(takeUntil(this._destroy$)).subscribe(() => {\n          this.closed.emit({\n            owner: this\n          });\n        });\n        this.toggleRef.closing.pipe(takeUntil(this._destroy$)).subscribe(e => {\n          var _a;\n\n          const args = {\n            owner: this,\n            event: e.event,\n            cancel: false\n          };\n          this.closing.emit(args);\n          e.cancel = args.cancel;\n\n          if (args.cancel) {\n            return;\n          }\n\n          const value = this.parseToDate(this.value);\n\n          if (((_a = this.dateTimeEditor.value) === null || _a === void 0 ? void 0 : _a.getTime()) !== (value === null || value === void 0 ? void 0 : value.getTime())) {\n            this.updateValue(this._selectedDate);\n          } // Do not focus the input if clicking outside in dropdown mode\n\n\n          const input = this.getEditElement();\n\n          if (input && !(e.event && this.isDropdown)) {\n            input.focus();\n          } else {\n            this.updateValidityOnBlur();\n          }\n        });\n      }\n    }\n\n  }\n\n  IgxTimePickerComponent.ɵfac = function IgxTimePickerComponent_Factory(t) {\n    return new (t || IgxTimePickerComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(LOCALE_ID), i0.ɵɵdirectiveInject(DisplayDensityToken, 8), i0.ɵɵdirectiveInject(IGX_INPUT_GROUP_TYPE, 8), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(PlatformUtil), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  IgxTimePickerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxTimePickerComponent,\n    selectors: [[\"igx-time-picker\"]],\n    contentQueries: function IgxTimePickerComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxLabelDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, IgxTimePickerActionsDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, IgxPickerClearComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.label = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.timePickerActionsDirective = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.clearComponents = _t);\n      }\n    },\n    viewQuery: function IgxTimePickerComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c85, 5);\n        i0.ɵɵviewQuery(_c86, 5);\n        i0.ɵɵviewQuery(_c87, 5);\n        i0.ɵɵviewQuery(_c88, 5);\n        i0.ɵɵviewQuery(IgxInputDirective, 5, IgxInputDirective);\n        i0.ɵɵviewQuery(IgxInputGroupComponent, 5);\n        i0.ɵɵviewQuery(IgxDateTimeEditorDirective, 7);\n        i0.ɵɵviewQuery(IgxToggleDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.hourList = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.minuteList = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.secondsList = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.ampmList = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputDirective = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._inputGroup = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dateTimeEditor = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toggleRef = _t.first);\n      }\n    },\n    hostVars: 1,\n    hostBindings: function IgxTimePickerComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function IgxTimePickerComponent_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      displayFormat: \"displayFormat\",\n      inputFormat: \"inputFormat\",\n      mode: \"mode\",\n      minValue: \"minValue\",\n      maxValue: \"maxValue\",\n      spinLoop: \"spinLoop\",\n      formatter: \"formatter\",\n      headerOrientation: \"headerOrientation\",\n      readOnly: \"readOnly\",\n      value: \"value\",\n      resourceStrings: \"resourceStrings\",\n      okButtonLabel: \"okButtonLabel\",\n      cancelButtonLabel: \"cancelButtonLabel\",\n      itemsDelta: \"itemsDelta\"\n    },\n    outputs: {\n      selected: \"selected\",\n      valueChange: \"valueChange\",\n      validationFailed: \"validationFailed\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: IgxTimePickerComponent,\n      multi: true\n    }, {\n      provide: IGX_TIME_PICKER_COMPONENT,\n      useExisting: IgxTimePickerComponent\n    }, {\n      provide: NG_VALIDATORS,\n      useExisting: IgxTimePickerComponent,\n      multi: true\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c75,\n    decls: 24,\n    vars: 29,\n    consts: [[3, \"displayDensity\", \"type\", \"suppressInputAutofocus\"], [\"igxInput\", \"\", \"type\", \"text\", \"role\", \"combobox\", \"aria-haspopup\", \"dialog\", 3, \"displayValuePipe\", \"igxDateTimeEditor\", \"readonly\", \"minValue\", \"maxValue\", \"locale\", \"spinDelta\", \"spinLoop\", \"placeholder\", \"disabled\", \"displayFormat\", \"igxTextSelection\", \"click\"], [3, \"click\", 4, \"ngIf\"], [\"ngProjectAs\", \"[igxLabel]\", 5, [\"\", \"igxLabel\", \"\"]], [\"ngProjectAs\", \"igx-prefix\", 5, [\"igx-prefix\"]], [\"ngProjectAs\", \"igx-suffix\", 5, [\"igx-suffix\"]], [\"ngProjectAs\", \"igx-hint\", 5, [\"igx-hint\"]], [\"defaultTimePickerActions\", \"\"], [\"igxToggle\", \"\", \"role\", \"dialog\", 1, \"igx-time-picker\", 3, \"ngClass\"], [\"toggleDirective\", \"toggle\"], [\"class\", \"igx-time-picker__header\", 4, \"ngIf\"], [1, \"igx-time-picker__main\"], [1, \"igx-time-picker__body\"], [3, \"igxItemList\", 4, \"ngIf\"], [4, \"ngTemplateOutlet\"], [3, \"click\"], [3, \"title\"], [\"class\", \"igx-time-picker__buttons\", 4, \"ngIf\"], [1, \"igx-time-picker__buttons\"], [\"igxButton\", \"flat\", 3, \"click\", 4, \"ngIf\"], [\"igxButton\", \"flat\", 3, \"click\"], [1, \"igx-time-picker__header\"], [1, \"igx-time-picker__header-hour\"], [3, \"igxItemList\"], [\"hourList\", \"\"], [\"aria-label\", \"hour\", 3, \"igxTimeItem\", 4, \"ngFor\", \"ngForOf\"], [\"aria-label\", \"hour\", 3, \"igxTimeItem\"], [\"timeItem\", \"timeItem\"], [\"minuteList\", \"\"], [\"aria-label\", \"minutes\", 3, \"igxTimeItem\", 4, \"ngFor\", \"ngForOf\"], [\"aria-label\", \"minutes\", 3, \"igxTimeItem\"], [\"secondsList\", \"\"], [\"aria-label\", \"seconds\", 3, \"igxTimeItem\", 4, \"ngFor\", \"ngForOf\"], [\"aria-label\", \"seconds\", 3, \"igxTimeItem\"], [\"ampmList\", \"\"], [\"aria-label\", \"ampm\", 3, \"igxTimeItem\", 4, \"ngFor\", \"ngForOf\"], [\"aria-label\", \"ampm\", 3, \"igxTimeItem\"]],\n    template: function IgxTimePickerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c74);\n        i0.ɵɵelementStart(0, \"igx-input-group\", 0)(1, \"input\", 1);\n        i0.ɵɵlistener(\"click\", function IgxTimePickerComponent_Template_input_click_1_listener() {\n          return !ctx.isDropdown && ctx.toggle();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(2, IgxTimePickerComponent_igx_prefix_2_Template, 3, 1, \"igx-prefix\", 2);\n        i0.ɵɵelementContainerStart(3, 3);\n        i0.ɵɵprojection(4);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementContainerStart(5, 4);\n        i0.ɵɵprojection(6, 1);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵtemplate(7, IgxTimePickerComponent_igx_suffix_7_Template, 3, 0, \"igx-suffix\", 2);\n        i0.ɵɵelementContainerStart(8, 5);\n        i0.ɵɵprojection(9, 2);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementContainerStart(10, 6);\n        i0.ɵɵprojection(11, 3);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(12, IgxTimePickerComponent_ng_template_12_Template, 1, 1, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementStart(14, \"div\", 8, 9);\n        i0.ɵɵtemplate(16, IgxTimePickerComponent_div_16_Template, 5, 3, \"div\", 10);\n        i0.ɵɵelementStart(17, \"div\", 11)(18, \"div\", 12);\n        i0.ɵɵtemplate(19, IgxTimePickerComponent_div_19_Template, 4, 13, \"div\", 13);\n        i0.ɵɵtemplate(20, IgxTimePickerComponent_div_20_Template, 4, 13, \"div\", 13);\n        i0.ɵɵtemplate(21, IgxTimePickerComponent_div_21_Template, 4, 13, \"div\", 13);\n        i0.ɵɵtemplate(22, IgxTimePickerComponent_div_22_Template, 4, 13, \"div\", 13);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(23, IgxTimePickerComponent_ng_container_23_Template, 1, 0, \"ng-container\", 14);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        const _r2 = i0.ɵɵreference(13);\n\n        const _r4 = i0.ɵɵreference(15);\n\n        i0.ɵɵproperty(\"displayDensity\", ctx.displayDensity)(\"type\", ctx.type)(\"suppressInputAutofocus\", ctx.isDropdown);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"displayValuePipe\", ctx.formatter ? ctx.displayValue : null)(\"igxDateTimeEditor\", ctx.inputFormat)(\"readonly\", !ctx.isDropdown || ctx.readOnly)(\"minValue\", ctx.minValue)(\"maxValue\", ctx.maxValue)(\"locale\", ctx.locale)(\"spinDelta\", ctx.itemsDelta)(\"spinLoop\", ctx.spinLoop)(\"placeholder\", ctx.placeholder)(\"disabled\", ctx.disabled)(\"displayFormat\", ctx.displayFormat)(\"igxTextSelection\", ctx.isDropdown && !ctx.readOnly);\n        i0.ɵɵattribute(\"aria-expanded\", !_r4.collapsed)(\"aria-labelledby\", ctx.label == null ? null : ctx.label.id);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.toggleComponents.length);\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"ngIf\", ctx.showClearButton);\n        i0.ɵɵadvance(7);\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(26, _c93, ctx.isDropdown, ctx.isVertical && !ctx.isDropdown));\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", !ctx.isDropdown);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.showHoursList);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showMinutesList);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showSecondsList);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showAmPmList);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.timePickerActionsDirective ? ctx.timePickerActionsDirective.template : _r2);\n      }\n    },\n    directives: function () {\n      return [IgxInputGroupComponent, IgxIconComponent, IgxInputDirective, IgxDateTimeEditorDirective, IgxTextSelectionDirective, i4.NgIf, IgxPrefixDirective, IgxSuffixDirective, IgxButtonDirective, IgxToggleDirective, i4.NgClass, IgxItemListDirective, i4.NgForOf, IgxTimeItemDirective, i4.NgTemplateOutlet];\n    },\n    pipes: function () {\n      return [TimeFormatPipe, TimeItemPipe];\n    },\n    styles: [\"[_nghost-%COMP%]{display:block}\"]\n  });\n  return IgxTimePickerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxTimePickerModule = /*#__PURE__*/(() => {\n  class IgxTimePickerModule {}\n\n  IgxTimePickerModule.ɵfac = function IgxTimePickerModule_Factory(t) {\n    return new (t || IgxTimePickerModule)();\n  };\n\n  IgxTimePickerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxTimePickerModule\n  });\n  IgxTimePickerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [],\n    imports: [[CommonModule, IgxDateTimeEditorModule, IgxInputGroupModule, IgxIconModule, IgxButtonModule, IgxMaskModule, IgxToggleModule, IgxTextSelectionModule], IgxPickersCommonModule, IgxInputGroupModule]\n  });\n  return IgxTimePickerModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxExcelStyleDateExpressionComponent = /*#__PURE__*/(() => {\n  class IgxExcelStyleDateExpressionComponent extends IgxExcelStyleDefaultExpressionComponent {\n    get inputValuesElement() {\n      var _a, _b;\n\n      return ((_a = this.picker) === null || _a === void 0 ? void 0 : _a.getEditElement()) || ((_b = this.input) === null || _b === void 0 ? void 0 : _b.nativeElement);\n    }\n\n    get inputDatePlaceholder() {\n      return this.grid.resourceStrings['igx_grid_filter_row_date_placeholder'];\n    }\n\n    get inputTimePlaceholder() {\n      return this.grid.resourceStrings['igx_grid_filter_row_time_placeholder'];\n    }\n\n  }\n\n  IgxExcelStyleDateExpressionComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxExcelStyleDateExpressionComponent_BaseFactory;\n    return function IgxExcelStyleDateExpressionComponent_Factory(t) {\n      return (ɵIgxExcelStyleDateExpressionComponent_BaseFactory || (ɵIgxExcelStyleDateExpressionComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxExcelStyleDateExpressionComponent)))(t || IgxExcelStyleDateExpressionComponent);\n    };\n  }();\n\n  IgxExcelStyleDateExpressionComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxExcelStyleDateExpressionComponent,\n    selectors: [[\"igx-excel-style-date-expression\"]],\n    viewQuery: function IgxExcelStyleDateExpressionComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c78, 5, IgxInputDirective);\n        i0.ɵɵviewQuery(_c94, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.input = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.picker = _t.first);\n      }\n    },\n    inputs: {\n      displayDensity: \"displayDensity\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 13,\n    vars: 11,\n    consts: [[\"type\", \"box\", 3, \"displayDensity\", \"placeholder\", \"overlaySettings\", \"selectionChanging\"], [\"dropdownConditions\", \"\"], [\"family\", \"imx-icons\", 3, \"name\", 4, \"ngIf\"], [4, \"ngIf\"], [3, \"value\", \"text\", \"selected\", 4, \"ngFor\", \"ngForOf\"], [\"type\", \"box\", 3, \"value\", \"locale\", \"outlet\", \"displayDensity\", \"readOnly\", \"placeholder\", \"displayFormat\", \"formatter\", \"disabled\", \"valueChange\", \"click\", 4, \"ngIf\"], [\"type\", \"box\", 3, \"inputFormat\", \"value\", \"locale\", \"outlet\", \"displayDensity\", \"readOnly\", \"placeholder\", \"displayFormat\", \"formatter\", \"disabled\", \"valueChange\", \"click\", 4, \"ngIf\"], [\"type\", \"box\", 3, \"displayDensity\", 4, \"ngIf\"], [\"igxButton\", \"icon\", 3, \"displayDensity\", \"click\", 4, \"ngIf\"], [3, \"multiSelection\", 4, \"ngIf\"], [\"igxOverlayOutlet\", \"\", 3, \"pointerdown\"], [\"overlayOutlet\", \"\"], [\"family\", \"imx-icons\", 3, \"name\"], [3, \"value\", \"text\", \"selected\"], [\"type\", \"box\", 3, \"value\", \"locale\", \"outlet\", \"displayDensity\", \"readOnly\", \"placeholder\", \"displayFormat\", \"formatter\", \"disabled\", \"valueChange\", \"click\"], [\"picker\", \"\"], [\"type\", \"box\", 3, \"inputFormat\", \"value\", \"locale\", \"outlet\", \"displayDensity\", \"readOnly\", \"placeholder\", \"displayFormat\", \"formatter\", \"disabled\", \"valueChange\", \"click\"], [\"type\", \"box\", 3, \"displayDensity\"], [\"dropDownTarget\", \"\", \"inputGroup\", \"\"], [\"igxInput\", \"\", \"tabindex\", \"0\", 3, \"placeholder\", \"igxDateTimeEditor\", \"ngModel\", \"disabled\", \"ngModelChange\"], [\"input\", \"\"], [\"igxButton\", \"icon\", 3, \"displayDensity\", \"click\"], [3, \"multiSelection\"], [\"logicOperatorButtonGroup\", \"\"], [\"igxButton\", \"\", \"tabindex\", \"0\", \"type\", \"button\", 3, \"displayDensity\", \"selected\", \"keydown\", \"click\"], [\"andButton\", \"\"], [\"orButton\", \"\"]],\n    template: function IgxExcelStyleDateExpressionComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"igx-select\", 0, 1);\n        i0.ɵɵlistener(\"selectionChanging\", function IgxExcelStyleDateExpressionComponent_Template_igx_select_selectionChanging_0_listener($event) {\n          return ctx.onConditionsChanged($event);\n        });\n        i0.ɵɵelementStart(2, \"igx-prefix\");\n        i0.ɵɵtemplate(3, IgxExcelStyleDateExpressionComponent_igx_icon_3_Template, 1, 1, \"igx-icon\", 2);\n        i0.ɵɵtemplate(4, IgxExcelStyleDateExpressionComponent_igx_icon_4_Template, 2, 0, \"igx-icon\", 3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(5, IgxExcelStyleDateExpressionComponent_igx_select_item_5_Template, 4, 5, \"igx-select-item\", 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(6, IgxExcelStyleDateExpressionComponent_igx_date_picker_6_Template, 4, 9, \"igx-date-picker\", 5);\n        i0.ɵɵtemplate(7, IgxExcelStyleDateExpressionComponent_igx_time_picker_7_Template, 4, 10, \"igx-time-picker\", 6);\n        i0.ɵɵtemplate(8, IgxExcelStyleDateExpressionComponent_igx_input_group_8_Template, 5, 5, \"igx-input-group\", 7);\n        i0.ɵɵtemplate(9, IgxExcelStyleDateExpressionComponent_button_9_Template, 3, 1, \"button\", 8);\n        i0.ɵɵtemplate(10, IgxExcelStyleDateExpressionComponent_igx_buttongroup_10_Template, 8, 7, \"igx-buttongroup\", 9);\n        i0.ɵɵelementStart(11, \"div\", 10, 11);\n        i0.ɵɵlistener(\"pointerdown\", function IgxExcelStyleDateExpressionComponent_Template_div_pointerdown_11_listener($event) {\n          return ctx.onOutletPointerDown($event);\n        });\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"displayDensity\", ctx.displayDensity)(\"placeholder\", ctx.conditionsPlaceholder)(\"overlaySettings\", ctx.dropDownOverlaySettings);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.expressionUI.expression.condition);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.expressionUI.expression.condition);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.conditions);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.column.dataType === \"date\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.column.dataType === \"time\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.column.dataType === \"dateTime\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.isSingle);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.isLast);\n      }\n    },\n    directives: [IgxSelectComponent, IgxIconComponent, IgxSelectItemComponent, IgxDatePickerComponent, IgxPickerToggleComponent, IgxPickerClearComponent, IgxTimePickerComponent, IgxInputGroupComponent, IgxButtonGroupComponent, IgxPrefixDirective, i4.NgIf, i4.NgForOf, i12.DefaultValueAccessor, IgxInputDirective, IgxDateTimeEditorDirective, i12.NgControlStatus, i12.NgModel, IgxButtonDirective, IgxOverlayOutletDirective],\n    encapsulation: 2\n  });\n  return IgxExcelStyleDateExpressionComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden @internal\n */\n\n\nclass FilterListItem {\n  constructor() {\n    this.isSpecial = false;\n    this.isBlanks = false;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass ExpressionUI {\n  constructor() {\n    this.isSelected = false;\n    this.isVisible = true;\n  }\n\n}\n\nfunction generateExpressionsList(expressions, operator, expressionsUIs) {\n  generateExpressionsListRecursive(expressions, operator, expressionsUIs); // The beforeOperator of the first expression and the afterOperator of the last expression should be null\n\n  if (expressionsUIs.length) {\n    expressionsUIs[expressionsUIs.length - 1].afterOperator = null;\n  }\n}\n\nfunction generateExpressionsListRecursive(expressions, operator, expressionsUIs) {\n  if (!expressions) {\n    return;\n  }\n\n  if (expressions instanceof FilteringExpressionsTree) {\n    const expressionsTree = expressions;\n\n    for (const operand of expressionsTree.filteringOperands) {\n      generateExpressionsListRecursive(operand, expressionsTree.operator, expressionsUIs);\n    }\n\n    if (expressionsUIs.length) {\n      expressionsUIs[expressionsUIs.length - 1].afterOperator = operator;\n    }\n  } else {\n    const exprUI = new ExpressionUI();\n    exprUI.expression = expressions;\n    exprUI.afterOperator = operator;\n    const prevExprUI = expressionsUIs[expressionsUIs.length - 1];\n\n    if (prevExprUI) {\n      exprUI.beforeOperator = prevExprUI.afterOperator;\n    }\n\n    expressionsUIs.push(exprUI);\n  }\n}\n/**\n * @hidden\n */\n\n\nlet IgxExcelStyleCustomDialogComponent = /*#__PURE__*/(() => {\n  class IgxExcelStyleCustomDialogComponent {\n    constructor(overlayService, cdr, platform) {\n      this.overlayService = overlayService;\n      this.cdr = cdr;\n      this.platform = platform;\n      this.expressionsList = new Array();\n      this._customDialogPositionSettings = {\n        verticalDirection: VerticalAlignment.Middle,\n        horizontalDirection: HorizontalAlignment.Center,\n        horizontalStartPoint: HorizontalAlignment.Center,\n        verticalStartPoint: VerticalAlignment.Middle\n      };\n      this._customDialogOverlaySettings = {\n        closeOnOutsideClick: true,\n        modal: false,\n        positionStrategy: new AutoPositionStrategy(this._customDialogPositionSettings),\n        scrollStrategy: new AbsoluteScrollStrategy()\n      };\n    }\n\n    ngAfterViewInit() {\n      this._customDialogOverlaySettings.outlet = this.grid.outlet;\n    }\n\n    get template() {\n      if (this.column.dataType === GridColumnDataType.Date) {\n        return this.dateExpressionTemplate;\n      }\n\n      return this.defaultExpressionTemplate;\n    }\n\n    get grid() {\n      return this.filteringService.grid;\n    }\n\n    onCustomDialogOpening() {\n      if (this.selectedOperator) {\n        this.createInitialExpressionUIElement();\n      }\n    }\n\n    onCustomDialogOpened() {\n      if (this.expressionComponents.first) {\n        this.expressionComponents.first.focus();\n      }\n    }\n\n    open(esf) {\n      this._customDialogOverlaySettings.target = this.overlayComponentId ? this.grid.rootGrid ? this.grid.rootGrid.nativeElement : this.grid.nativeElement : esf;\n      this.toggle.open(this._customDialogOverlaySettings);\n      this.overlayComponentId = this.toggle.overlayId;\n    }\n\n    onClearButtonClick() {\n      this.filteringService.clearFilter(this.column.field);\n      this.createInitialExpressionUIElement();\n      this.cdr.detectChanges();\n    }\n\n    closeDialog() {\n      if (this.overlayComponentId) {\n        this.overlayService.hide(this.overlayComponentId);\n        this.overlayComponentId = null;\n      } else {\n        this.toggle.close();\n      }\n    }\n\n    onApplyButtonClick() {\n      this.expressionsList = this.expressionsList.filter(element => element.expression.condition && (element.expression.searchVal || element.expression.searchVal === 0 || element.expression.condition.isUnary));\n\n      if (this.expressionsList.length > 0) {\n        this.expressionsList[0].beforeOperator = null;\n        this.expressionsList[this.expressionsList.length - 1].afterOperator = null;\n      }\n\n      this.filteringService.filterInternal(this.column.field, this.expressionsList);\n      this.closeDialog();\n    }\n\n    onAddButtonClick() {\n      const exprUI = new ExpressionUI();\n      exprUI.expression = {\n        condition: null,\n        fieldName: this.column.field,\n        ignoreCase: this.column.filteringIgnoreCase,\n        searchVal: null\n      };\n      this.expressionsList[this.expressionsList.length - 1].afterOperator = FilteringLogic.And;\n      exprUI.beforeOperator = this.expressionsList[this.expressionsList.length - 1].afterOperator;\n      this.expressionsList.push(exprUI);\n      this.markChildrenForCheck();\n      this.scrollToBottom();\n    }\n\n    onExpressionRemoved(event) {\n      const indexToRemove = this.expressionsList.indexOf(event);\n\n      if (indexToRemove === 0 && this.expressionsList.length > 1) {\n        this.expressionsList[1].beforeOperator = null;\n      } else if (indexToRemove === this.expressionsList.length - 1) {\n        this.expressionsList[indexToRemove - 1].afterOperator = null;\n      } else {\n        this.expressionsList[indexToRemove - 1].afterOperator = this.expressionsList[indexToRemove + 1].beforeOperator;\n        this.expressionsList[0].beforeOperator = null;\n        this.expressionsList[this.expressionsList.length - 1].afterOperator = null;\n      }\n\n      this.expressionsList.splice(indexToRemove, 1);\n      this.cdr.detectChanges();\n      this.markChildrenForCheck();\n    }\n\n    onLogicOperatorChanged(event) {\n      const index = this.expressionsList.indexOf(event.target);\n      event.target.afterOperator = event.newValue;\n\n      if (index + 1 < this.expressionsList.length) {\n        this.expressionsList[index + 1].beforeOperator = event.newValue;\n      }\n    }\n\n    onKeyDown(eventArgs) {\n      eventArgs.stopPropagation();\n    }\n\n    onApplyButtonKeyDown(eventArgs) {\n      if (eventArgs.key === this.platform.KEYMAP.TAB && !eventArgs.shiftKey) {\n        eventArgs.stopPropagation();\n        eventArgs.preventDefault();\n      }\n    }\n\n    createCondition(conditionName) {\n      switch (this.column.dataType) {\n        case GridColumnDataType.Boolean:\n          return IgxBooleanFilteringOperand.instance().condition(conditionName);\n\n        case GridColumnDataType.Number:\n        case GridColumnDataType.Currency:\n        case GridColumnDataType.Percent:\n          return IgxNumberFilteringOperand.instance().condition(conditionName);\n\n        case GridColumnDataType.Date:\n          return IgxDateFilteringOperand.instance().condition(conditionName);\n\n        case GridColumnDataType.Time:\n          return IgxTimeFilteringOperand.instance().condition(conditionName);\n\n        case GridColumnDataType.DateTime:\n          return IgxDateTimeFilteringOperand.instance().condition(conditionName);\n\n        default:\n          return IgxStringFilteringOperand.instance().condition(conditionName);\n      }\n    }\n\n    markChildrenForCheck() {\n      this.expressionComponents.forEach(x => x.cdr.markForCheck());\n      this.expressionDateComponents.forEach(x => x.cdr.markForCheck());\n    }\n\n    createInitialExpressionUIElement() {\n      this.expressionsList = [];\n      const firstExprUI = new ExpressionUI();\n      firstExprUI.expression = {\n        condition: this.createCondition(this.selectedOperator),\n        fieldName: this.column.field,\n        ignoreCase: this.column.filteringIgnoreCase,\n        searchVal: null\n      };\n      firstExprUI.afterOperator = FilteringLogic.And;\n      this.expressionsList.push(firstExprUI);\n      const secondExprUI = new ExpressionUI();\n      secondExprUI.expression = {\n        condition: null,\n        fieldName: this.column.field,\n        ignoreCase: this.column.filteringIgnoreCase,\n        searchVal: null\n      };\n      secondExprUI.beforeOperator = FilteringLogic.And;\n      this.expressionsList.push(secondExprUI);\n    }\n\n    scrollToBottom() {\n      requestAnimationFrame(() => {\n        this.expressionsContainer.nativeElement.scrollTop = this.expressionsContainer.nativeElement.scrollHeight;\n      });\n    }\n\n  }\n\n  IgxExcelStyleCustomDialogComponent.ɵfac = function IgxExcelStyleCustomDialogComponent_Factory(t) {\n    return new (t || IgxExcelStyleCustomDialogComponent)(i0.ɵɵdirectiveInject(IgxOverlayService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxExcelStyleCustomDialogComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxExcelStyleCustomDialogComponent,\n    selectors: [[\"igx-excel-style-custom-dialog\"]],\n    viewQuery: function IgxExcelStyleCustomDialogComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c95, 7, IgxToggleDirective);\n        i0.ɵɵviewQuery(_c96, 5, TemplateRef);\n        i0.ɵɵviewQuery(_c97, 5, TemplateRef);\n        i0.ɵɵviewQuery(_c98, 7);\n        i0.ɵɵviewQuery(IgxExcelStyleDefaultExpressionComponent, 5);\n        i0.ɵɵviewQuery(IgxExcelStyleDateExpressionComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toggle = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultExpressionTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dateExpressionTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.expressionsContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.expressionComponents = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.expressionDateComponents = _t);\n      }\n    },\n    inputs: {\n      expressionsList: \"expressionsList\",\n      column: \"column\",\n      selectedOperator: \"selectedOperator\",\n      filteringService: \"filteringService\",\n      overlayComponentId: \"overlayComponentId\",\n      displayDensity: \"displayDensity\"\n    },\n    decls: 24,\n    vars: 16,\n    consts: [[\"igxToggle\", \"\", 1, \"igx-excel-filter__secondary\", 3, \"ngClass\", \"keydown\", \"opening\", \"opened\"], [\"toggle\", \"\"], [1, \"igx-excel-filter__secondary-header\"], [1, \"igx-typography__h6\"], [1, \"igx-excel-filter__secondary-main\"], [\"expressionsContainer\", \"\"], [4, \"ngIf\"], [\"igxButton\", \"\", 1, \"igx-excel-filter__add-filter\", 3, \"displayDensity\", \"click\"], [1, \"igx-excel-filter__secondary-footer\"], [1, \"igx-excel-filter__clear\"], [\"igxButton\", \"flat\", 3, \"displayDensity\", \"click\"], [1, \"igx-excel-filter__cancel\"], [1, \"igx-excel-filter__apply\"], [\"igxButton\", \"raised\", 3, \"displayDensity\", \"click\", \"keydown\"], [\"class\", \"igx-excel-filter__condition\", 3, \"expressionUI\", \"column\", \"grid\", \"displayDensity\", \"expressionsList\", \"expressionRemoved\", \"logicOperatorChanged\", 4, \"ngFor\", \"ngForOf\"], [1, \"igx-excel-filter__condition\", 3, \"expressionUI\", \"column\", \"grid\", \"displayDensity\", \"expressionsList\", \"expressionRemoved\", \"logicOperatorChanged\"]],\n    template: function IgxExcelStyleCustomDialogComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"article\", 0, 1);\n        i0.ɵɵlistener(\"keydown\", function IgxExcelStyleCustomDialogComponent_Template_article_keydown_0_listener($event) {\n          return ctx.onKeyDown($event);\n        })(\"opening\", function IgxExcelStyleCustomDialogComponent_Template_article_opening_0_listener() {\n          return ctx.onCustomDialogOpening();\n        })(\"opened\", function IgxExcelStyleCustomDialogComponent_Template_article_opened_0_listener() {\n          return ctx.onCustomDialogOpened();\n        });\n        i0.ɵɵelementStart(2, \"header\", 2)(3, \"h4\", 3);\n        i0.ɵɵtext(4);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(5, \"article\", 4, 5);\n        i0.ɵɵtemplate(7, IgxExcelStyleCustomDialogComponent_ng_container_7_Template, 2, 1, \"ng-container\", 6);\n        i0.ɵɵtemplate(8, IgxExcelStyleCustomDialogComponent_ng_container_8_Template, 2, 1, \"ng-container\", 6);\n        i0.ɵɵelementStart(9, \"button\", 7);\n        i0.ɵɵlistener(\"click\", function IgxExcelStyleCustomDialogComponent_Template_button_click_9_listener() {\n          return ctx.onAddButtonClick();\n        });\n        i0.ɵɵelementStart(10, \"igx-icon\");\n        i0.ɵɵtext(11, \"add\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(12, \"span\");\n        i0.ɵɵtext(13);\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵelementStart(14, \"footer\", 8)(15, \"div\", 9)(16, \"button\", 10);\n        i0.ɵɵlistener(\"click\", function IgxExcelStyleCustomDialogComponent_Template_button_click_16_listener() {\n          return ctx.onClearButtonClick();\n        });\n        i0.ɵɵtext(17);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(18, \"div\", 11)(19, \"button\", 10);\n        i0.ɵɵlistener(\"click\", function IgxExcelStyleCustomDialogComponent_Template_button_click_19_listener() {\n          return ctx.closeDialog();\n        });\n        i0.ɵɵtext(20);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(21, \"div\", 12)(22, \"button\", 13);\n        i0.ɵɵlistener(\"click\", function IgxExcelStyleCustomDialogComponent_Template_button_click_22_listener() {\n          return ctx.onApplyButtonClick();\n        })(\"keydown\", function IgxExcelStyleCustomDialogComponent_Template_button_keydown_22_listener($event) {\n          return ctx.onApplyButtonKeyDown($event);\n        });\n        i0.ɵɵtext(23);\n        i0.ɵɵelementEnd()()()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(13, _c99, ctx.grid.displayDensity === \"cosy\", ctx.grid.displayDensity === \"compact\"));\n        i0.ɵɵadvance(4);\n        i0.ɵɵtextInterpolate2(\" \", ctx.grid.resourceStrings.igx_grid_excel_custom_dialog_header, \"\", ctx.column.header || ctx.column.field, \" \");\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.column.dataType === \"date\" || ctx.column.dataType === \"dateTime\" || ctx.column.dataType === \"time\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.column.dataType !== \"date\" && ctx.column.dataType !== \"dateTime\" && ctx.column.dataType !== \"time\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"displayDensity\", ctx.displayDensity);\n        i0.ɵɵadvance(4);\n        i0.ɵɵtextInterpolate(ctx.grid.resourceStrings.igx_grid_excel_custom_dialog_add);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"displayDensity\", ctx.displayDensity);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate1(\" \", ctx.grid.resourceStrings.igx_grid_excel_custom_dialog_clear, \" \");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"displayDensity\", ctx.displayDensity);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate1(\" \", ctx.grid.resourceStrings.igx_grid_excel_cancel, \" \");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"displayDensity\", ctx.displayDensity);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate1(\" \", ctx.grid.resourceStrings.igx_grid_excel_apply, \" \");\n      }\n    },\n    directives: [IgxExcelStyleDateExpressionComponent, IgxExcelStyleDefaultExpressionComponent, IgxIconComponent, IgxToggleDirective, i4.NgClass, i4.NgIf, i4.NgForOf, IgxButtonDirective],\n    encapsulation: 2\n  });\n  return IgxExcelStyleCustomDialogComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A component used for presenting Excel style conditional filter UI.\n */\n\n\nlet IgxExcelStyleConditionalFilterComponent = /*#__PURE__*/(() => {\n  class IgxExcelStyleConditionalFilterComponent {\n    constructor(esf, platform) {\n      this.esf = esf;\n      this.platform = platform;\n      this.shouldOpenSubMenu = true;\n      this.destroy$ = new Subject();\n      this._subMenuPositionSettings = {\n        verticalStartPoint: VerticalAlignment.Top\n      };\n      this._subMenuOverlaySettings = {\n        closeOnOutsideClick: true,\n        modal: false,\n        positionStrategy: new AutoPositionStrategy(this._subMenuPositionSettings),\n        scrollStrategy: new AbsoluteScrollStrategy()\n      };\n      this.esf.columnChange.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        if (this.esf.grid) {\n          this.shouldOpenSubMenu = true;\n          this._subMenuOverlaySettings.outlet = this.esf.grid.outlet;\n        }\n      });\n\n      if (this.esf.grid) {\n        this._subMenuOverlaySettings.outlet = this.esf.grid.outlet;\n      }\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next(true);\n      this.destroy$.complete();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onTextFilterKeyDown(eventArgs) {\n      if (eventArgs.key === this.platform.KEYMAP.ENTER) {\n        this.onTextFilterClick(eventArgs);\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onTextFilterClick(eventArgs) {\n      if (this.shouldOpenSubMenu) {\n        this._subMenuOverlaySettings.target = eventArgs.currentTarget;\n        const gridRect = this.esf.grid.nativeElement.getBoundingClientRect();\n        const dropdownRect = this.esf.mainDropdown.nativeElement.getBoundingClientRect();\n        let x = dropdownRect.left + dropdownRect.width;\n        let x1 = gridRect.left + gridRect.width;\n        x += window.pageXOffset;\n        x1 += window.pageXOffset;\n\n        if (Math.abs(x - x1) < 200) {\n          this._subMenuOverlaySettings.positionStrategy.settings.horizontalDirection = HorizontalAlignment.Left;\n          this._subMenuOverlaySettings.positionStrategy.settings.horizontalStartPoint = HorizontalAlignment.Left;\n        } else {\n          this._subMenuOverlaySettings.positionStrategy.settings.horizontalDirection = HorizontalAlignment.Right;\n          this._subMenuOverlaySettings.positionStrategy.settings.horizontalStartPoint = HorizontalAlignment.Right;\n        }\n\n        this.subMenu.open(this._subMenuOverlaySettings);\n        this.shouldOpenSubMenu = false;\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    getCondition(value) {\n      return this.esf.column.filters.condition(value);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    translateCondition(value) {\n      return this.esf.grid.resourceStrings[`igx_grid_filter_${this.getCondition(value).name}`] || value;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onSubMenuSelection(eventArgs) {\n      if (this.esf.expressionsList && this.esf.expressionsList.length && this.esf.expressionsList[0].expression.condition.name !== 'in') {\n        this.customDialog.expressionsList = this.esf.expressionsList;\n      }\n\n      this.customDialog.selectedOperator = eventArgs.newSelection.value;\n      eventArgs.cancel = true;\n\n      if (this.esf.overlayComponentId) {\n        this.esf.hide();\n      }\n\n      this.subMenu.close();\n      this.customDialog.open(this.esf.mainDropdown.nativeElement);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onSubMenuClosed() {\n      requestAnimationFrame(() => {\n        this.shouldOpenSubMenu = true;\n      });\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    showCustomFilterItem() {\n      const exprTree = this.esf.column.filteringExpressionsTree;\n      return exprTree && exprTree.filteringOperands && exprTree.filteringOperands.length && !(exprTree.filteringOperands[0].condition && exprTree.filteringOperands[0].condition.name === 'in');\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get subMenuText() {\n      switch (this.esf.column.dataType) {\n        case GridColumnDataType.Boolean:\n          return this.esf.grid.resourceStrings.igx_grid_excel_boolean_filter;\n\n        case GridColumnDataType.Number:\n        case GridColumnDataType.Percent:\n          return this.esf.grid.resourceStrings.igx_grid_excel_number_filter;\n\n        case GridColumnDataType.Date:\n        case GridColumnDataType.DateTime:\n        case GridColumnDataType.Time:\n          return this.esf.grid.resourceStrings.igx_grid_excel_date_filter;\n\n        case GridColumnDataType.Currency:\n          return this.esf.grid.resourceStrings.igx_grid_excel_currency_filter;\n\n        default:\n          return this.esf.grid.resourceStrings.igx_grid_excel_text_filter;\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get conditions() {\n      return this.esf.column.filters.conditionList();\n    }\n\n  }\n\n  IgxExcelStyleConditionalFilterComponent.ɵfac = function IgxExcelStyleConditionalFilterComponent_Factory(t) {\n    return new (t || IgxExcelStyleConditionalFilterComponent)(i0.ɵɵdirectiveInject(BaseFilteringComponent), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxExcelStyleConditionalFilterComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxExcelStyleConditionalFilterComponent,\n    selectors: [[\"igx-excel-style-conditional-filter\"]],\n    viewQuery: function IgxExcelStyleConditionalFilterComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c100, 5, IgxExcelStyleCustomDialogComponent);\n        i0.ɵɵviewQuery(_c101, 5, IgxDropDownComponent);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.customDialog = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.subMenu = _t.first);\n      }\n    },\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngIf\"], [\"tabindex\", \"0\", \"role\", \"menuitem\", \"aria-haspopup\", \"true\", 1, \"igx-excel-filter__actions-filter\", 3, \"igxDropDownItemNavigation\", \"keydown\", \"click\"], [3, \"maxHeight\", \"displayDensity\", \"allowItemsFocus\", \"selectionChanging\", \"closed\"], [\"subMenu\", \"\"], [3, \"value\", 4, \"ngFor\", \"ngForOf\"], [3, \"column\", \"filteringService\", \"overlayComponentId\", \"displayDensity\"], [\"customDialog\", \"\"], [3, \"value\"], [1, \"igx-grid__filtering-dropdown-items\"], [\"family\", \"imx-icons\", 3, \"name\"], [1, \"igx-grid__filtering-dropdown-text\"]],\n    template: function IgxExcelStyleConditionalFilterComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxExcelStyleConditionalFilterComponent_ng_container_0_Template, 13, 11, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.esf.column);\n      }\n    },\n    directives: [IgxIconComponent, IgxDropDownComponent, IgxDropDownItemComponent, IgxExcelStyleCustomDialogComponent, i4.NgIf, IgxDropDownItemNavigationDirective, i4.NgForOf],\n    encapsulation: 2\n  });\n  return IgxExcelStyleConditionalFilterComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A component used for presenting Excel style header UI.\n */\n\n\nlet IgxExcelStyleHeaderComponent = /*#__PURE__*/(() => {\n  class IgxExcelStyleHeaderComponent {\n    constructor(esf) {\n      this.esf = esf;\n    }\n\n  }\n\n  IgxExcelStyleHeaderComponent.ɵfac = function IgxExcelStyleHeaderComponent_Factory(t) {\n    return new (t || IgxExcelStyleHeaderComponent)(i0.ɵɵdirectiveInject(BaseFilteringComponent));\n  };\n\n  IgxExcelStyleHeaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxExcelStyleHeaderComponent,\n    selectors: [[\"igx-excel-style-header\"]],\n    inputs: {\n      showPinning: \"showPinning\",\n      showSelecting: \"showSelecting\",\n      showHiding: \"showHiding\"\n    },\n    decls: 1,\n    vars: 1,\n    consts: [[\"class\", \"igx-excel-filter__menu-header\", 4, \"ngIf\"], [1, \"igx-excel-filter__menu-header\"], [1, \"igx-excel-filter__menu-header-actions\"], [\"igxButton\", \"icon\", 3, \"ngClass\", \"click\", 4, \"ngIf\"], [\"igxButton\", \"icon\", 3, \"click\", 4, \"ngIf\"], [\"igxButton\", \"icon\", 3, \"ngClass\", \"click\"], [\"igxButton\", \"icon\", 3, \"click\"], [\"family\", \"imx-icons\", 3, \"name\"]],\n    template: function IgxExcelStyleHeaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxExcelStyleHeaderComponent_header_0_Template, 7, 4, \"header\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.esf.column);\n      }\n    },\n    directives: [IgxIconComponent, i4.NgIf, IgxButtonDirective, i4.NgClass],\n    encapsulation: 2\n  });\n  return IgxExcelStyleHeaderComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A component used for presenting Excel style column hiding UI.\n */\n\n\nlet IgxExcelStyleHidingComponent = /*#__PURE__*/(() => {\n  class IgxExcelStyleHidingComponent {\n    constructor(esf) {\n      this.esf = esf;\n    }\n\n  }\n\n  IgxExcelStyleHidingComponent.ɵfac = function IgxExcelStyleHidingComponent_Factory(t) {\n    return new (t || IgxExcelStyleHidingComponent)(i0.ɵɵdirectiveInject(BaseFilteringComponent));\n  };\n\n  IgxExcelStyleHidingComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxExcelStyleHidingComponent,\n    selectors: [[\"igx-excel-style-hiding\"]],\n    decls: 1,\n    vars: 1,\n    consts: [[\"class\", \"igx-excel-filter__actions-hide\", \"tabindex\", \"0\", \"role\", \"menuitem\", 3, \"click\", 4, \"ngIf\"], [\"tabindex\", \"0\", \"role\", \"menuitem\", 1, \"igx-excel-filter__actions-hide\", 3, \"click\"]],\n    template: function IgxExcelStyleHidingComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxExcelStyleHidingComponent_div_0_Template, 5, 2, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.esf.column);\n      }\n    },\n    directives: [IgxIconComponent, i4.NgIf],\n    encapsulation: 2\n  });\n  return IgxExcelStyleHidingComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A component used for presenting Excel style column moving UI.\n */\n\n\nlet IgxExcelStyleMovingComponent = /*#__PURE__*/(() => {\n  class IgxExcelStyleMovingComponent {\n    constructor(esf) {\n      this.esf = esf;\n      /**\n       * @hidden @internal\n       */\n\n      this.defaultClass = true;\n    }\n\n    get visibleColumns() {\n      return this.esf.grid.visibleColumns.filter(col => !col.columnGroup);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get canNotMoveLeft() {\n      return this.esf.column.visibleIndex === 0 || this.esf.grid.unpinnedColumns.indexOf(this.esf.column) === 0 && this.esf.column.disablePinning || this.esf.column.level !== 0 && !this.findColumn(0, this.visibleColumns);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get canNotMoveRight() {\n      return this.esf.column.visibleIndex === this.visibleColumns.length - 1 || this.esf.column.level !== 0 && !this.findColumn(1, this.visibleColumns);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onMoveButtonClicked(moveDirection) {\n      let targetColumn;\n\n      if (this.esf.column.pinned) {\n        if (this.esf.column.isLastPinned && moveDirection === 1 && this.esf.grid.isPinningToStart) {\n          targetColumn = this.esf.grid.unpinnedColumns[0];\n          moveDirection = 0;\n        } else if (this.esf.column.isFirstPinned && moveDirection === 0 && !this.esf.grid.isPinningToStart) {\n          targetColumn = this.esf.grid.unpinnedColumns[this.esf.grid.unpinnedColumns.length - 1];\n          moveDirection = 1;\n        } else {\n          targetColumn = this.findColumn(moveDirection, this.esf.grid.pinnedColumns);\n        }\n      } else if (this.esf.grid.unpinnedColumns.indexOf(this.esf.column) === 0 && moveDirection === 0 && this.esf.grid.isPinningToStart) {\n        targetColumn = this.esf.grid.pinnedColumns[this.esf.grid.pinnedColumns.length - 1];\n\n        if (targetColumn.parent) {\n          targetColumn = targetColumn.topLevelParent;\n        }\n\n        moveDirection = 1;\n      } else if (this.esf.grid.unpinnedColumns.indexOf(this.esf.column) === this.esf.grid.unpinnedColumns.length - 1 && moveDirection === 1 && !this.esf.grid.isPinningToStart) {\n        targetColumn = this.esf.grid.pinnedColumns[0];\n        moveDirection = 0;\n      } else {\n        targetColumn = this.findColumn(moveDirection, this.esf.grid.unpinnedColumns);\n      }\n\n      this.esf.grid.moveColumn(this.esf.column, targetColumn, moveDirection);\n    }\n\n    findColumn(moveDirection, columns) {\n      let index = columns.indexOf(this.esf.column);\n\n      if (moveDirection === 0) {\n        while (index > 0) {\n          index--;\n\n          if (columns[index].level === this.esf.column.level && columns[index].parent === this.esf.column.parent) {\n            return columns[index];\n          }\n        }\n\n        return columns[0];\n      } else {\n        while (index < columns.length - 1) {\n          index++;\n\n          if (columns[index].level === this.esf.column.level && columns[index].parent === this.esf.column.parent) {\n            return columns[index];\n          }\n        }\n      }\n    }\n\n  }\n\n  IgxExcelStyleMovingComponent.ɵfac = function IgxExcelStyleMovingComponent_Factory(t) {\n    return new (t || IgxExcelStyleMovingComponent)(i0.ɵɵdirectiveInject(BaseFilteringComponent));\n  };\n\n  IgxExcelStyleMovingComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxExcelStyleMovingComponent,\n    selectors: [[\"igx-excel-style-moving\"]],\n    hostVars: 2,\n    hostBindings: function IgxExcelStyleMovingComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-excel-filter__move\", ctx.defaultClass);\n      }\n    },\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngIf\"], [3, \"multiSelection\"], [\"igxButton\", \"\", 3, \"displayDensity\", \"disabled\", \"click\"]],\n    template: function IgxExcelStyleMovingComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxExcelStyleMovingComponent_ng_container_0_Template, 14, 8, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.esf.column);\n      }\n    },\n    directives: [IgxButtonGroupComponent, IgxIconComponent, i4.NgIf, IgxButtonDirective],\n    encapsulation: 2\n  });\n  return IgxExcelStyleMovingComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A component used for presenting Excel style column pinning UI.\n */\n\n\nlet IgxExcelStylePinningComponent = /*#__PURE__*/(() => {\n  class IgxExcelStylePinningComponent {\n    constructor(esf) {\n      this.esf = esf;\n    }\n\n  }\n\n  IgxExcelStylePinningComponent.ɵfac = function IgxExcelStylePinningComponent_Factory(t) {\n    return new (t || IgxExcelStylePinningComponent)(i0.ɵɵdirectiveInject(BaseFilteringComponent));\n  };\n\n  IgxExcelStylePinningComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxExcelStylePinningComponent,\n    selectors: [[\"igx-excel-style-pinning\"]],\n    decls: 1,\n    vars: 1,\n    consts: [[\"tabindex\", \"0\", \"role\", \"menuitem\", 3, \"ngClass\", \"click\", 4, \"ngIf\"], [\"tabindex\", \"0\", \"role\", \"menuitem\", 3, \"ngClass\", \"click\"], [\"family\", \"imx-icons\", 3, \"name\"]],\n    template: function IgxExcelStylePinningComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxExcelStylePinningComponent_div_0_Template, 4, 3, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.esf.column);\n      }\n    },\n    directives: [IgxIconComponent, i4.NgIf, i4.NgClass],\n    encapsulation: 2\n  });\n  return IgxExcelStylePinningComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxListBaseDirective = /*#__PURE__*/(() => {\n  class IgxListBaseDirective extends DisplayDensityBase {\n    constructor(_displayDensityOptions) {\n      super(_displayDensityOptions);\n      this._displayDensityOptions = _displayDensityOptions;\n    }\n\n  }\n\n  IgxListBaseDirective.ɵfac = function IgxListBaseDirective_Factory(t) {\n    return new (t || IgxListBaseDirective)(i0.ɵɵdirectiveInject(DisplayDensityToken, 8));\n  };\n\n  IgxListBaseDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxListBaseDirective,\n    selectors: [[\"\", \"igxListBase\", \"\"]],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return IgxListBaseDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar IgxListPanState = /*#__PURE__*/(() => {\n  (function (IgxListPanState) {\n    IgxListPanState[IgxListPanState[\"NONE\"] = 0] = \"NONE\";\n    IgxListPanState[IgxListPanState[\"LEFT\"] = 1] = \"LEFT\";\n    IgxListPanState[IgxListPanState[\"RIGHT\"] = 2] = \"RIGHT\";\n  })(IgxListPanState || (IgxListPanState = {}));\n\n  return IgxListPanState;\n})();\nlet IgxEmptyListTemplateDirective = /*#__PURE__*/(() => {\n  class IgxEmptyListTemplateDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxEmptyListTemplateDirective.ɵfac = function IgxEmptyListTemplateDirective_Factory(t) {\n    return new (t || IgxEmptyListTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxEmptyListTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxEmptyListTemplateDirective,\n    selectors: [[\"\", \"igxEmptyList\", \"\"]]\n  });\n  return IgxEmptyListTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxDataLoadingTemplateDirective = /*#__PURE__*/(() => {\n  class IgxDataLoadingTemplateDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxDataLoadingTemplateDirective.ɵfac = function IgxDataLoadingTemplateDirective_Factory(t) {\n    return new (t || IgxDataLoadingTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxDataLoadingTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxDataLoadingTemplateDirective,\n    selectors: [[\"\", \"igxDataLoading\", \"\"]]\n  });\n  return IgxDataLoadingTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxListItemLeftPanningTemplateDirective = /*#__PURE__*/(() => {\n  class IgxListItemLeftPanningTemplateDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxListItemLeftPanningTemplateDirective.ɵfac = function IgxListItemLeftPanningTemplateDirective_Factory(t) {\n    return new (t || IgxListItemLeftPanningTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxListItemLeftPanningTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxListItemLeftPanningTemplateDirective,\n    selectors: [[\"\", \"igxListItemLeftPanning\", \"\"]]\n  });\n  return IgxListItemLeftPanningTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxListItemRightPanningTemplateDirective = /*#__PURE__*/(() => {\n  class IgxListItemRightPanningTemplateDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxListItemRightPanningTemplateDirective.ɵfac = function IgxListItemRightPanningTemplateDirective_Factory(t) {\n    return new (t || IgxListItemRightPanningTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxListItemRightPanningTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxListItemRightPanningTemplateDirective,\n    selectors: [[\"\", \"igxListItemRightPanning\", \"\"]]\n  });\n  return IgxListItemRightPanningTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The Ignite UI List Item component is a container intended for row items in the Ignite UI for Angular List component.\n *\n * Example:\n * ```html\n * <igx-list>\n *   <igx-list-item isHeader=\"true\">Contacts</igx-list-item>\n *   <igx-list-item *ngFor=\"let contact of contacts\">\n *     <span class=\"name\">{{ contact.name }}</span>\n *     <span class=\"phone\">{{ contact.phone }}</span>\n *   </igx-list-item>\n * </igx-list>\n * ```\n */\n\n\nlet IgxListItemComponent = /*#__PURE__*/(() => {\n  class IgxListItemComponent {\n    constructor(list, elementRef, _renderer) {\n      this.list = list;\n      this.elementRef = elementRef;\n      this._renderer = _renderer;\n      /**\n       * Sets/gets whether the `list item` is hidden.\n       * By default the `hidden` value is `false`.\n       * ```html\n       * <igx-list-item [hidden] = \"true\">Hidden Item</igx-list-item>\n       * ```\n       * ```typescript\n       * let isHidden =  this.listItem.hidden;\n       * ```\n       *\n       * @memberof IgxListItemComponent\n       */\n\n      this.hidden = false;\n      /**\n       * Gets the `touch-action` style of the `list item`.\n       * ```typescript\n       * let touchAction = this.listItem.touchAction;\n       * ```\n       */\n\n      this.touchAction = 'pan-y';\n      /**\n       * @hidden\n       */\n\n      this._panState = IgxListPanState.NONE;\n      /**\n       * @hidden\n       */\n\n      this.panOffset = 0;\n      /**\n       * @hidden\n       */\n\n      this._index = null;\n      /**\n       * @hidden\n       */\n\n      this.lastPanDir = IgxListPanState.NONE;\n    }\n    /**\n     * Gets the `panState` of a `list item`.\n     * ```typescript\n     * let itemPanState =  this.listItem.panState;\n     * ```\n     *\n     * @memberof IgxListItemComponent\n     */\n\n\n    get panState() {\n      return this._panState;\n    }\n    /**\n     * Gets the `index` of a `list item`.\n     * ```typescript\n     * let itemIndex =  this.listItem.index;\n     * ```\n     *\n     * @memberof IgxListItemComponent\n     */\n\n\n    get index() {\n      return this._index !== null ? this._index : this.list.children.toArray().indexOf(this);\n    }\n    /**\n     * Sets the `index` of the `list item`.\n     * ```typescript\n     * this.listItem.index = index;\n     * ```\n     *\n     * @memberof IgxListItemComponent\n     */\n\n\n    set index(value) {\n      this._index = value;\n    }\n    /**\n     * Returns an element reference to the list item.\n     * ```typescript\n     * let listItemElement =  this.listItem.element.\n     * ```\n     *\n     * @memberof IgxListItemComponent\n     */\n\n\n    get element() {\n      return this.elementRef.nativeElement;\n    }\n    /**\n     * Returns a reference container which contains the list item's content.\n     * ```typescript\n     * let listItemContainer =  this.listItem.contentElement.\n     * ```\n     *\n     * @memberof IgxListItemComponent\n     */\n\n\n    get contentElement() {\n      const candidates = this.element.getElementsByClassName('igx-list__item-content');\n      return candidates && candidates.length > 0 ? candidates[0] : null;\n    }\n    /**\n     * Returns the `context` object which represents the `template context` binding into the `list item container`\n     * by providing the `$implicit` declaration which is the `IgxListItemComponent` itself.\n     * ```typescript\n     * let listItemComponent = this.listItem.context;\n     * ```\n     */\n\n\n    get context() {\n      return {\n        $implicit: this\n      };\n    }\n    /**\n     * Gets the width of a `list item`.\n     * ```typescript\n     * let itemWidth = this.listItem.width;\n     * ```\n     *\n     * @memberof IgxListItemComponent\n     */\n\n\n    get width() {\n      if (this.element) {\n        return this.element.offsetWidth;\n      }\n    }\n    /**\n     * Gets the maximum left position of the `list item`.\n     * ```typescript\n     * let maxLeft = this.listItem.maxLeft;\n     * ```\n     *\n     * @memberof IgxListItemComponent\n     */\n\n\n    get maxLeft() {\n      return -this.width;\n    }\n    /**\n     * Gets the maximum right position of the `list item`.\n     * ```typescript\n     * let maxRight = this.listItem.maxRight;\n     * ```\n     *\n     * @memberof IgxListItemComponent\n     */\n\n\n    get maxRight() {\n      return this.width;\n    }\n    /**\n     * Gets the `role` attribute of the `list item`.\n     * ```typescript\n     * let itemRole =  this.listItem.role;\n     * ```\n     *\n     * @memberof IgxListItemComponent\n     */\n\n\n    get role() {\n      return this.isHeader ? 'separator' : 'listitem';\n    }\n    /**\n     * Indicates whether `list item` should have header style.\n     * ```typescript\n     * let headerStyle =  this.listItem.headerStyle;\n     * ```\n     *\n     * @memberof IgxListItemComponent\n     */\n\n\n    get headerStyle() {\n      return this.isHeader;\n    }\n    /**\n     * Applies the inner style of the `list item` if the item is not counted as header.\n     * ```typescript\n     * let innerStyle =  this.listItem.innerStyle;\n     * ```\n     *\n     * @memberof IgxListItemComponent\n     */\n\n\n    get innerStyle() {\n      return !this.isHeader;\n    }\n    /**\n     * Returns string value which describes the display mode of the `list item`.\n     * ```typescript\n     * let isHidden = this.listItem.display;\n     * ```\n     *\n     * @memberof IgxListItemComponent\n     */\n\n\n    get display() {\n      return this.hidden ? 'none' : '';\n    }\n    /**\n     * @hidden\n     */\n\n\n    clicked(evt) {\n      this.list.itemClicked.emit({\n        item: this,\n        event: evt,\n        direction: this.lastPanDir\n      });\n      this.lastPanDir = IgxListPanState.NONE;\n    }\n    /**\n     * @hidden\n     */\n\n\n    panStart() {\n      if (this.isTrue(this.isHeader)) {\n        return;\n      }\n\n      if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {\n        return;\n      }\n\n      this.list.startPan.emit({\n        item: this,\n        direction: this.lastPanDir,\n        keepitem: false\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    panCancel() {\n      this.resetPanPosition();\n      this.list.endPan.emit({\n        item: this,\n        direction: this.lastPanDir,\n        keepItem: false\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    panMove(ev) {\n      if (this.isTrue(this.isHeader)) {\n        return;\n      }\n\n      if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {\n        return;\n      }\n\n      const isPanningToLeft = ev.deltaX < 0;\n\n      if (isPanningToLeft && this.isTrue(this.list.allowLeftPanning)) {\n        this.showLeftPanTemplate();\n        this.setContentElementLeft(Math.max(this.maxLeft, ev.deltaX));\n      } else if (!isPanningToLeft && this.isTrue(this.list.allowRightPanning)) {\n        this.showRightPanTemplate();\n        this.setContentElementLeft(Math.min(this.maxRight, ev.deltaX));\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    panEnd() {\n      if (this.isTrue(this.isHeader)) {\n        return;\n      }\n\n      if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {\n        return;\n      } // the translation offset of the current list item content\n\n\n      const relativeOffset = this.panOffset;\n      const widthTriggeringGrip = this.width * this.list.panEndTriggeringThreshold;\n\n      if (relativeOffset === 0) {\n        return; // no panning has occured\n      }\n\n      const dir = relativeOffset > 0 ? IgxListPanState.RIGHT : IgxListPanState.LEFT;\n      this.lastPanDir = dir;\n      const args = {\n        item: this,\n        direction: dir,\n        keepItem: false\n      };\n      this.list.endPan.emit(args);\n      const oldPanState = this._panState;\n\n      if (Math.abs(relativeOffset) < widthTriggeringGrip) {\n        this.resetPanPosition();\n        this.list.resetPan.emit(this);\n        return;\n      }\n\n      if (dir === IgxListPanState.LEFT) {\n        this.list.leftPan.emit(args);\n      } else {\n        this.list.rightPan.emit(args);\n      }\n\n      if (args.keepItem === true) {\n        this.setContentElementLeft(0);\n        this._panState = IgxListPanState.NONE;\n      } else {\n        if (dir === IgxListPanState.LEFT) {\n          this.setContentElementLeft(this.maxLeft);\n          this._panState = IgxListPanState.LEFT;\n        } else {\n          this.setContentElementLeft(this.maxRight);\n          this._panState = IgxListPanState.RIGHT;\n        }\n      }\n\n      if (oldPanState !== this._panState) {\n        const args2 = {\n          oldState: oldPanState,\n          newState: this._panState,\n          item: this\n        };\n        this.list.panStateChange.emit(args2);\n      }\n\n      this.hideLeftAndRightPanTemplates();\n    }\n    /**\n     * @hidden\n     */\n\n\n    showLeftPanTemplate() {\n      this.setLeftAndRightTemplatesVisibility('visible', 'hidden');\n    }\n    /**\n     * @hidden\n     */\n\n\n    showRightPanTemplate() {\n      this.setLeftAndRightTemplatesVisibility('hidden', 'visible');\n    }\n    /**\n     * @hidden\n     */\n\n\n    hideLeftAndRightPanTemplates() {\n      setTimeout(() => {\n        this.setLeftAndRightTemplatesVisibility('hidden', 'hidden');\n      }, 500);\n    }\n    /**\n     * @hidden\n     */\n\n\n    setLeftAndRightTemplatesVisibility(leftVisibility, rightVisibility) {\n      if (this.leftPanningTemplateElement && this.leftPanningTemplateElement.nativeElement) {\n        this.leftPanningTemplateElement.nativeElement.style.visibility = leftVisibility;\n      }\n\n      if (this.rightPanningTemplateElement && this.rightPanningTemplateElement.nativeElement) {\n        this.rightPanningTemplateElement.nativeElement.style.visibility = rightVisibility;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    setContentElementLeft(value) {\n      this.panOffset = value;\n      this.contentElement.style.transform = 'translateX(' + value + 'px)';\n    }\n    /**\n     * @hidden\n     */\n\n\n    isTrue(value) {\n      if (typeof value === 'boolean') {\n        return value;\n      } else {\n        return value === 'true';\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    resetPanPosition() {\n      this.setContentElementLeft(0);\n      this._panState = IgxListPanState.NONE;\n      this.hideLeftAndRightPanTemplates();\n    }\n\n  }\n\n  IgxListItemComponent.ɵfac = function IgxListItemComponent_Factory(t) {\n    return new (t || IgxListItemComponent)(i0.ɵɵdirectiveInject(IgxListBaseDirective), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  IgxListItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxListItemComponent,\n    selectors: [[\"igx-list-item\"]],\n    viewQuery: function IgxListItemComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c102, 5);\n        i0.ɵɵviewQuery(_c103, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.leftPanningTemplateElement = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.rightPanningTemplateElement = _t.first);\n      }\n    },\n    hostVars: 10,\n    hostBindings: function IgxListItemComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function IgxListItemComponent_click_HostBindingHandler($event) {\n          return ctx.clicked($event);\n        })(\"panstart\", function IgxListItemComponent_panstart_HostBindingHandler() {\n          return ctx.panStart();\n        })(\"pancancel\", function IgxListItemComponent_pancancel_HostBindingHandler() {\n          return ctx.panCancel();\n        })(\"panmove\", function IgxListItemComponent_panmove_HostBindingHandler($event) {\n          return ctx.panMove($event);\n        })(\"panend\", function IgxListItemComponent_panend_HostBindingHandler() {\n          return ctx.panEnd();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-label\", ctx.ariaLabel)(\"role\", ctx.role);\n        i0.ɵɵstyleProp(\"touch-action\", ctx.touchAction)(\"display\", ctx.display);\n        i0.ɵɵclassProp(\"igx-list__header\", ctx.headerStyle)(\"igx-list__item-base\", ctx.innerStyle);\n      }\n    },\n    inputs: {\n      isHeader: \"isHeader\",\n      hidden: \"hidden\",\n      index: \"index\"\n    },\n    features: [i0.ɵɵProvidersFeature([HammerGesturesManager])],\n    ngContentSelectors: _c105,\n    decls: 12,\n    vars: 4,\n    consts: [[\"class\", \"igx-list__item-right\", 3, \"width\", \"height\", 4, \"ngIf\"], [\"class\", \"igx-list__item-left\", 3, \"width\", \"height\", 4, \"ngIf\"], [\"itemsContent\", \"\"], [\"itemThumbnails\", \"\"], [\"itemLines\", \"\"], [\"itemActions\", \"\"], [4, \"ngIf\"], [1, \"igx-list__item-right\"], [\"leftPanningTmpl\", \"\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"igx-list__item-left\"], [\"rightPanningTmpl\", \"\"], [1, \"igx-list__item-thumbnail\"], [1, \"igx-list__item-lines\"], [1, \"igx-list__item-actions\"], [4, \"ngTemplateOutlet\"], [1, \"igx-list__item-content\"]],\n    template: function IgxListItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c104);\n        i0.ɵɵtemplate(0, IgxListItemComponent_div_0_Template, 3, 6, \"div\", 0);\n        i0.ɵɵtemplate(1, IgxListItemComponent_div_1_Template, 3, 6, \"div\", 1);\n        i0.ɵɵtemplate(2, IgxListItemComponent_ng_template_2_Template, 1, 0, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(4, IgxListItemComponent_ng_template_4_Template, 2, 0, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(6, IgxListItemComponent_ng_template_6_Template, 2, 0, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(8, IgxListItemComponent_ng_template_8_Template, 2, 0, \"ng-template\", null, 5, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(10, IgxListItemComponent_ng_container_10_Template, 2, 1, \"ng-container\", 6);\n        i0.ɵɵtemplate(11, IgxListItemComponent_ng_container_11_Template, 6, 4, \"ng-container\", 6);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.isHeader && ctx.list.listItemLeftPanningTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.isHeader && ctx.list.listItemRightPanningTemplate);\n        i0.ɵɵadvance(9);\n        i0.ɵɵproperty(\"ngIf\", ctx.isHeader);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.isHeader);\n      }\n    },\n    directives: [i4.NgIf, i4.NgTemplateOutlet],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxListItemComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$b = 0;\n/**\n * igxListThumbnail is container for the List media\n * Use it to wrap anything you want to be used as a thumbnail.\n */\n\nlet IgxListThumbnailDirective = /*#__PURE__*/(() => {\n  class IgxListThumbnailDirective {}\n\n  IgxListThumbnailDirective.ɵfac = function IgxListThumbnailDirective_Factory(t) {\n    return new (t || IgxListThumbnailDirective)();\n  };\n\n  IgxListThumbnailDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxListThumbnailDirective,\n    selectors: [[\"\", \"igxListThumbnail\", \"\"]]\n  });\n  return IgxListThumbnailDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * igxListAction is container for the List action\n * Use it to wrap anything you want to be used as a list action: icon, checkbox...\n */\n\n\nlet IgxListActionDirective = /*#__PURE__*/(() => {\n  class IgxListActionDirective {}\n\n  IgxListActionDirective.ɵfac = function IgxListActionDirective_Factory(t) {\n    return new (t || IgxListActionDirective)();\n  };\n\n  IgxListActionDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxListActionDirective,\n    selectors: [[\"\", \"igxListAction\", \"\"]]\n  });\n  return IgxListActionDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * igxListLine is container for the List text content\n * Use it to wrap anything you want to be used as a plane text.\n */\n\n\nlet IgxListLineDirective = /*#__PURE__*/(() => {\n  class IgxListLineDirective {}\n\n  IgxListLineDirective.ɵfac = function IgxListLineDirective_Factory(t) {\n    return new (t || IgxListLineDirective)();\n  };\n\n  IgxListLineDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxListLineDirective,\n    selectors: [[\"\", \"igxListLine\", \"\"]]\n  });\n  return IgxListLineDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * igxListLineTitle is a directive that add class to the target element\n * Use it to make anything to look like list Title.\n */\n\n\nlet IgxListLineTitleDirective = /*#__PURE__*/(() => {\n  class IgxListLineTitleDirective {\n    constructor() {\n      this.cssClass = 'igx-list__item-line-title';\n    }\n\n  }\n\n  IgxListLineTitleDirective.ɵfac = function IgxListLineTitleDirective_Factory(t) {\n    return new (t || IgxListLineTitleDirective)();\n  };\n\n  IgxListLineTitleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxListLineTitleDirective,\n    selectors: [[\"\", \"igxListLineTitle\", \"\"]],\n    hostVars: 2,\n    hostBindings: function IgxListLineTitleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-list__item-line-title\", ctx.cssClass);\n      }\n    }\n  });\n  return IgxListLineTitleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * igxListLineSubTitle is a directive that add class to the target element\n * Use it to make anything to look like list Subtitle.\n */\n\n\nlet IgxListLineSubTitleDirective = /*#__PURE__*/(() => {\n  class IgxListLineSubTitleDirective {\n    constructor() {\n      this.cssClass = 'igx-list__item-line-subtitle';\n    }\n\n  }\n\n  IgxListLineSubTitleDirective.ɵfac = function IgxListLineSubTitleDirective_Factory(t) {\n    return new (t || IgxListLineSubTitleDirective)();\n  };\n\n  IgxListLineSubTitleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxListLineSubTitleDirective,\n    selectors: [[\"\", \"igxListLineSubTitle\", \"\"]],\n    hostVars: 2,\n    hostBindings: function IgxListLineSubTitleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-list__item-line-subtitle\", ctx.cssClass);\n      }\n    }\n  });\n  return IgxListLineSubTitleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Displays a collection of data items in a templatable list format\n *\n * @igxModule IgxListModule\n *\n * @igxTheme igx-list-theme\n *\n * @igxKeywords list, data\n *\n * @igxGroup Grids & Lists\n *\n * @remarks\n * The Ignite UI List displays rows of items and supports one or more header items as well as search and filtering\n * of list items. Each list item is completely templatable and will support any valid HTML or Angular component.\n *\n * @example\n * ```html\n * <igx-list>\n *   <igx-list-item isHeader=\"true\">Contacts</igx-list-item>\n *   <igx-list-item *ngFor=\"let contact of contacts\">\n *     <span class=\"name\">{{ contact.name }}</span>\n *     <span class=\"phone\">{{ contact.phone }}</span>\n *   </igx-list-item>\n * </igx-list>\n * ```\n */\n\n\nlet IgxListComponent = /*#__PURE__*/(() => {\n  class IgxListComponent extends IgxListBaseDirective {\n    constructor(element, _displayDensityOptions) {\n      super(_displayDensityOptions);\n      this.element = element;\n      this._displayDensityOptions = _displayDensityOptions;\n      /**\n       * Provides a threshold after which the item's panning will be completed automatically.\n       *\n       * @remarks\n       * By default this property is set to 0.5 which is 50% of the list item's width.\n       *\n       * @example\n       * ```html\n       * <igx-list [panEndTriggeringThreshold]=\"0.8\"></igx-list>\n       * ```\n       */\n\n      this.panEndTriggeringThreshold = 0.5;\n      /**\n       * Sets/gets the `id` of the list.\n       *\n       * @remarks\n       * If not set, the `id` of the first list component will be `\"igx-list-0\"`.\n       *\n       * @example\n       * ```html\n       * <igx-list id=\"my-first-list\"></igx-list>\n       * ```\n       * ```typescript\n       * let listId = this.list.id;\n       * ```\n       */\n\n      this.id = `igx-list-${NEXT_ID$b++}`;\n      /**\n       * Sets/gets whether the left panning of an item is allowed.\n       *\n       * @remarks\n       * Default value is `false`.\n       *\n       * @example\n       * ```html\n       * <igx-list [allowLeftPanning]=\"true\"></igx-list>\n       * ```\n       * ```typescript\n       * let isLeftPanningAllowed = this.list.allowLeftPanning;\n       * ```\n       */\n\n      this.allowLeftPanning = false;\n      /**\n       * Sets/gets whether the right panning of an item is allowed.\n       *\n       * @remarks\n       * Default value is `false`.\n       *\n       * @example\n       * ```html\n       * <igx-list [allowRightPanning]=\"true\"></igx-list>\n       * ```\n       * ```typescript\n       * let isRightPanningAllowed = this.list.allowRightPanning;\n       * ```\n       */\n\n      this.allowRightPanning = false;\n      /**\n       * Sets/gets whether the list is currently loading data.\n       *\n       * @remarks\n       * Set it to display the dataLoadingTemplate while data is being retrieved.\n       * Default value is `false`.\n       *\n       * @example\n       * ```html\n       *  <igx-list [isLoading]=\"true\"></igx-list>\n       * ```\n       * ```typescript\n       * let isLoading = this.list.isLoading;\n       * ```\n       */\n\n      this.isLoading = false;\n      /**\n       * Event emitted when a left pan gesture is executed on a list item.\n       *\n       * @remarks\n       * Provides a reference to an object of type `IListItemPanningEventArgs` as an event argument.\n       *\n       * @example\n       * ```html\n       * <igx-list [allowLeftPanning]=\"true\" (leftPan)=\"leftPan($event)\"></igx-list>\n       * ```\n       */\n\n      this.leftPan = new EventEmitter();\n      /**\n       * Event emitted when a right pan gesture is executed on a list item.\n       *\n       * @remarks\n       * Provides a reference to an object of type `IListItemPanningEventArgs` as an event argument.\n       *\n       * @example\n       * ```html\n       * <igx-list [allowRightPanning]=\"true\" (rightPan)=\"rightPan($event)\"></igx-list>\n       * ```\n       */\n\n      this.rightPan = new EventEmitter();\n      /**\n       * Event emitted when a pan gesture is started.\n       *\n       * @remarks\n       * Provides a reference to an object of type `IListItemPanningEventArgs` as an event argument.\n       *\n       * @example\n       * ```html\n       * <igx-list (startPan)=\"startPan($event)\"></igx-list>\n       * ```\n       */\n\n      this.startPan = new EventEmitter();\n      /**\n       * Event emitted when a pan gesture is completed or canceled.\n       *\n       * @remarks\n       * Provides a reference to an object of type `IListItemPanningEventArgs` as an event argument.\n       *\n       * @example\n       * ```html\n       * <igx-list (endPan)=\"endPan($event)\"></igx-list>\n       * ```\n       */\n\n      this.endPan = new EventEmitter();\n      /**\n       * Event emitted when a pan item is returned to its original position.\n       *\n       * @remarks\n       * Provides a reference to an object of type `IgxListComponent` as an event argument.\n       *\n       * @example\n       * ```html\n       * <igx-list (resetPan)=\"resetPan($event)\"></igx-list>\n       * ```\n       */\n\n      this.resetPan = new EventEmitter();\n      /**\n       *\n       * Event emitted when a pan gesture is executed on a list item.\n       *\n       * @remarks\n       * Provides references to the `IgxListItemComponent` and `IgxListPanState` as event arguments.\n       *\n       * @example\n       * ```html\n       * <igx-list (panStateChange)=\"panStateChange($event)\"></igx-list>\n       * ```\n       */\n\n      this.panStateChange = new EventEmitter();\n      /**\n       * Event emitted when a list item is clicked.\n       *\n       * @remarks\n       * Provides references to the `IgxListItemComponent` and `Event` as event arguments.\n       *\n       * @example\n       * ```html\n       * <igx-list (itemClicked)=\"onItemClicked($event)\"></igx-list>\n       * ```\n       */\n\n      this.itemClicked = new EventEmitter();\n      this._resourceStrings = CurrentResourceStrings.ListResStrings;\n    }\n    /**\n     * Sets the resource strings.\n     * By default it uses EN resources.\n     */\n\n\n    set resourceStrings(value) {\n      this._resourceStrings = Object.assign({}, this._resourceStrings, value);\n    }\n    /**\n     * Returns the resource strings.\n     */\n\n\n    get resourceStrings() {\n      return this._resourceStrings;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get sortedChildren() {\n      if (this.children !== undefined) {\n        return this.children.toArray().sort((a, b) => a.index - b.index);\n      }\n\n      return null;\n    }\n    /**\n     * Gets the `role` attribute value.\n     *\n     * @example\n     * ```typescript\n     * let listRole =  this.list.role;\n     * ```\n     */\n\n\n    get role() {\n      return 'list';\n    }\n    /**\n     * Gets a boolean indicating if the list is empty.\n     *\n     * @example\n     * ```typescript\n     * let isEmpty =  this.list.isListEmpty;\n     * ```\n     */\n\n\n    get isListEmpty() {\n      return !this.children || this.children.length === 0;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get cssClass() {\n      return !this.isListEmpty && this.displayDensity === DisplayDensity.comfortable;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get cssClassCompact() {\n      return !this.isListEmpty && this.displayDensity === DisplayDensity.compact;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get cssClassCosy() {\n      return !this.isListEmpty && this.displayDensity === DisplayDensity.cosy;\n    }\n    /**\n     * Gets the list `items` excluding the header ones.\n     *\n     * @example\n     * ```typescript\n     * let listItems: IgxListItemComponent[] = this.list.items;\n     * ```\n     */\n\n\n    get items() {\n      const items = [];\n\n      if (this.children !== undefined) {\n        for (const child of this.sortedChildren) {\n          if (!child.isHeader) {\n            items.push(child);\n          }\n        }\n      }\n\n      return items;\n    }\n    /**\n     * Gets the header list `items`.\n     *\n     * @example\n     * ```typescript\n     * let listHeaders: IgxListItemComponent[] =  this.list.headers;\n     * ```\n     */\n\n\n    get headers() {\n      const headers = [];\n\n      if (this.children !== undefined) {\n        for (const child of this.children.toArray()) {\n          if (child.isHeader) {\n            headers.push(child);\n          }\n        }\n      }\n\n      return headers;\n    }\n    /**\n     * Gets the `context` object of the template binding.\n     *\n     * @remark\n     * Gets the `context` object which represents the `template context` binding into the `list container`\n     * by providing the `$implicit` declaration which is the `IgxListComponent` itself.\n     *\n     * @example\n     * ```typescript\n     * let listComponent =  this.list.context;\n     * ```\n     */\n\n\n    get context() {\n      return {\n        $implicit: this\n      };\n    }\n    /**\n     * Gets a `TemplateRef` to the currently used template.\n     *\n     * @example\n     * ```typescript\n     * let listTemplate = this.list.template;\n     * ```\n     */\n\n\n    get template() {\n      if (this.isLoading) {\n        return this.dataLoadingTemplate ? this.dataLoadingTemplate.template : this.defaultDataLoadingTemplate;\n      } else {\n        return this.emptyListTemplate ? this.emptyListTemplate.template : this.defaultEmptyListTemplate;\n      }\n    }\n\n  }\n\n  IgxListComponent.ɵfac = function IgxListComponent_Factory(t) {\n    return new (t || IgxListComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DisplayDensityToken, 8));\n  };\n\n  IgxListComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxListComponent,\n    selectors: [[\"igx-list\"]],\n    contentQueries: function IgxListComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxEmptyListTemplateDirective, 5, IgxEmptyListTemplateDirective);\n        i0.ɵɵcontentQuery(dirIndex, IgxDataLoadingTemplateDirective, 5, IgxDataLoadingTemplateDirective);\n        i0.ɵɵcontentQuery(dirIndex, IgxListItemLeftPanningTemplateDirective, 5, IgxListItemLeftPanningTemplateDirective);\n        i0.ɵɵcontentQuery(dirIndex, IgxListItemRightPanningTemplateDirective, 5, IgxListItemRightPanningTemplateDirective);\n        i0.ɵɵcontentQuery(dirIndex, IgxListItemComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.emptyListTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dataLoadingTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.listItemLeftPanningTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.listItemRightPanningTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.children = _t);\n      }\n    },\n    viewQuery: function IgxListComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c106, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c107, 7, TemplateRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultEmptyListTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultDataLoadingTemplate = _t.first);\n      }\n    },\n    hostVars: 10,\n    hostBindings: function IgxListComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id)(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"igx-list--empty\", ctx.isListEmpty)(\"igx-list\", ctx.cssClass)(\"igx-list--compact\", ctx.cssClassCompact)(\"igx-list--cosy\", ctx.cssClassCosy);\n      }\n    },\n    inputs: {\n      panEndTriggeringThreshold: \"panEndTriggeringThreshold\",\n      id: \"id\",\n      allowLeftPanning: \"allowLeftPanning\",\n      allowRightPanning: \"allowRightPanning\",\n      isLoading: \"isLoading\",\n      resourceStrings: \"resourceStrings\"\n    },\n    outputs: {\n      leftPan: \"leftPan\",\n      rightPan: \"rightPan\",\n      startPan: \"startPan\",\n      endPan: \"endPan\",\n      resetPan: \"resetPan\",\n      panStateChange: \"panStateChange\",\n      itemClicked: \"itemClicked\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxListBaseDirective,\n      useExisting: IgxListComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c8,\n    decls: 6,\n    vars: 1,\n    consts: [[\"defaultEmptyList\", \"\"], [\"defaultDataLoading\", \"\"], [4, \"ngIf\"], [1, \"igx-list__message\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function IgxListComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n        i0.ɵɵtemplate(1, IgxListComponent_ng_template_1_Template, 2, 1, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(3, IgxListComponent_ng_template_3_Template, 2, 1, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(5, IgxListComponent_ng_container_5_Template, 2, 2, \"ng-container\", 2);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"ngIf\", !ctx.children || ctx.children.length === 0 || ctx.isLoading);\n      }\n    },\n    directives: [i4.NgIf, i4.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return IgxListComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxListModule = /*#__PURE__*/(() => {\n  class IgxListModule {}\n\n  IgxListModule.ɵfac = function IgxListModule_Factory(t) {\n    return new (t || IgxListModule)();\n  };\n\n  IgxListModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxListModule\n  });\n  IgxListModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, IgxRippleModule]]\n  });\n  return IgxListModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxProcessBarTextTemplateDirective = /*#__PURE__*/(() => {\n  class IgxProcessBarTextTemplateDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxProcessBarTextTemplateDirective.ɵfac = function IgxProcessBarTextTemplateDirective_Factory(t) {\n    return new (t || IgxProcessBarTextTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxProcessBarTextTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxProcessBarTextTemplateDirective,\n    selectors: [[\"\", \"igxProcessBarText\", \"\"]]\n  });\n  return IgxProcessBarTextTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxProgressBarGradientDirective = /*#__PURE__*/(() => {\n  class IgxProgressBarGradientDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxProgressBarGradientDirective.ɵfac = function IgxProgressBarGradientDirective_Factory(t) {\n    return new (t || IgxProgressBarGradientDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxProgressBarGradientDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxProgressBarGradientDirective,\n    selectors: [[\"\", \"igxProgressBarGradient\", \"\"]]\n  });\n  return IgxProgressBarGradientDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nfunction DIR_DOCUMENT_FACTORY() {\n  return inject(DOCUMENT);\n}\n/**\n * Injection token is used to inject the document into Directionality\n * which factory could be faked for testing purposes.\n *\n * We can't provide and mock the DOCUMENT token from platform-browser because configureTestingModule\n * allows override of the default providers, directive, pipes, modules of the test injector\n * which causes errors.\n *\n * @hidden\n */\n\n\nconst DIR_DOCUMENT = new InjectionToken('dir-doc', {\n  providedIn: 'root',\n  factory: DIR_DOCUMENT_FACTORY\n});\n/**\n * @hidden\n *\n * Bidirectional service that extracts the value of the direction attribute on the body or html elements.\n *\n * The dir attribute over the body element takes precedence.\n */\n\nlet IgxDirectionality = /*#__PURE__*/(() => {\n  class IgxDirectionality {\n    constructor(document) {\n      this._document = document;\n      const bodyDir = this._document.body ? this._document.body.dir : null;\n      const htmlDir = this._document.documentElement ? this._document.documentElement.dir : null;\n      const extractedDir = bodyDir || htmlDir;\n      this._dir = extractedDir === 'ltr' || extractedDir === 'rtl' ? extractedDir : 'ltr';\n    }\n\n    get value() {\n      return this._dir;\n    }\n\n    get document() {\n      return this._document;\n    }\n\n    get rtl() {\n      return this._dir === 'rtl';\n    }\n\n  }\n\n  IgxDirectionality.ɵfac = function IgxDirectionality_Factory(t) {\n    return new (t || IgxDirectionality)(i0.ɵɵinject(DIR_DOCUMENT));\n  };\n\n  IgxDirectionality.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxDirectionality,\n    factory: IgxDirectionality.ɵfac,\n    providedIn: 'root'\n  });\n  return IgxDirectionality;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst ONE_PERCENT = 0.01;\nconst MIN_VALUE = 0;\nconst IgxTextAlign = mkenum({\n  START: 'start',\n  CENTER: 'center',\n  END: 'end'\n});\nconst IgxProgressType = mkenum({\n  ERROR: 'error',\n  INFO: 'info',\n  WARNING: 'warning',\n  SUCCESS: 'success'\n});\n/**\n * @hidden\n */\n\nlet BaseProgressDirective = /*#__PURE__*/(() => {\n  class BaseProgressDirective {\n    constructor() {\n      /**\n       * An event, which is triggered after a progress is changed.\n       * ```typescript\n       * public progressChange(event) {\n       *     alert(\"Progress made!\");\n       * }\n       *  //...\n       * ```\n       * ```html\n       * <igx-circular-bar [value]=\"currentValue\" (progressChanged)=\"progressChange($event)\"></igx-circular-bar>\n       * <igx-linear-bar [value]=\"currentValue\" (progressChanged)=\"progressChange($event)\"></igx-linear-bar>\n       * ```\n       */\n      this.progressChanged = new EventEmitter();\n      /**\n       * Sets/Gets progressbar in indeterminate. By default it is set to false.\n       * ```html\n       * <igx-linear-bar [indeterminate]=\"true\"></igx-linear-bar>\n       * <igx-circular-bar [indeterminate]=\"true\"></igx-circular-bar>\n       * ```\n       */\n\n      this.indeterminate = false;\n      /**\n       * Sets/Gets progressbar animation duration. By default it is 2000ms.\n       * ```html\n       * <igx-linear-bar [indeterminate]=\"true\"></igx-linear-bar>\n       * ```\n       */\n\n      this.animationDuration = 2000;\n      this._initValue = 0;\n      this._contentInit = false;\n      this._max = 100;\n      this._value = MIN_VALUE;\n      this._newVal = MIN_VALUE;\n      this._animate = true;\n      this._internalState = {\n        oldVal: 0,\n        newVal: 0\n      };\n    }\n    /**\n     * Returns the value which update the progress indicator of the `progress bar`.\n     * ```typescript\n     * @ViewChild(\"MyProgressBar\")\n     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;\n     * public stepValue(event) {\n     *     let step = this.progressBar.step;\n     *     alert(step);\n     * }\n     * ```\n     */\n\n\n    get step() {\n      if (this._step) {\n        return this._step;\n      }\n\n      return this._max * ONE_PERCENT;\n    }\n    /**\n     * Sets the value by which progress indicator is updated. By default it is 1.\n     * ```html\n     * <igx-linear-bar [max]=\"200\" [value]=\"0\" [step]=\"1\"></igx-linear-bar>\n     * <igx-circular-bar [max]=\"200\" [value]=\"0\" [step]=\"1\"></igx-circular-bar>\n     * ```\n     */\n\n\n    set step(val) {\n      const step = Number(val);\n\n      if (step > this.max) {\n        return;\n      }\n\n      this._step = step;\n    }\n    /**\n     * Animating the progress. By default it is set to true.\n     * ```html\n     * <igx-linear-bar [animate]=\"false\" [max]=\"200\" [value]=\"50\"></igx-linear-bar>\n     * <igx-circular-bar [animate]=\"false\" [max]=\"200\" [value]=\"50\"></igx-circular-bar>\n     * ```\n     */\n\n\n    set animate(animate) {\n      this._animate = animate;\n\n      if (animate) {\n        this.animationDuration = 2000;\n      } else {\n        this.animationDuration = 0;\n      }\n    }\n    /**\n     * Returns whether the `progress bar` has animation true/false.\n     * ```typescript\n     * @ViewChild(\"MyProgressBar\")\n     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;\n     * public animationStatus(event) {\n     *     let animationStatus = this.progressBar.animate;\n     *     alert(animationStatus);\n     * }\n     * ```\n     */\n\n\n    get animate() {\n      return this._animate;\n    }\n    /**\n     * Set maximum value that can be passed. By default it is set to 100.\n     * ```html\n     * <igx-linear-bar [max]=\"200\" [value]=\"0\"></igx-linear-bar>\n     * <igx-circular-bar [max]=\"200\" [value]=\"0\"></igx-circular-bar>\n     * ```\n     */\n\n\n    set max(maxNum) {\n      if (maxNum < MIN_VALUE || this._max === maxNum || this._animation && this._animation.playState !== 'finished') {\n        return;\n      }\n\n      this._internalState.newVal = Math.round(toValue(toPercent(this.value, maxNum), maxNum));\n      this._value = this._internalState.oldVal = Math.round(toValue(this.valueInPercent, maxNum));\n      this._max = maxNum;\n      this.triggerProgressTransition(this._internalState.oldVal, this._internalState.newVal, true);\n    }\n    /**\n     * Returns the the maximum progress value of the `progress bar`.\n     * ```typescript\n     * @ViewChild(\"MyProgressBar\")\n     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;\n     * public maxValue(event) {\n     *     let max = this.progressBar.max;\n     *     alert(max);\n     * }\n     * ```\n     */\n\n\n    get max() {\n      return this._max;\n    }\n    /**\n     * Returns the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.\n     * ```typescript\n     * @ViewChild(\"MyProgressBar\")\n     * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent\n     * public valuePercent(event){\n     *     let percentValue = this.progressBar.valueInPercent;\n     *     alert(percentValue);\n     * }\n     * ```\n     */\n\n\n    get valueInPercent() {\n      const val = toPercent(this._value, this._max);\n      return val;\n    }\n    /**\n     * Returns value that indicates the current `IgxLinearProgressBarComponent` position.\n     * ```typescript\n     * @ViewChild(\"MyProgressBar\")\n     * public progressBar: IgxLinearProgressBarComponent;\n     * public getValue(event) {\n     *     let value = this.progressBar.value;\n     *     alert(value);\n     * }\n     * ```\n     */\n\n\n    get value() {\n      return this._value;\n    }\n    /**\n     * Set value that indicates the current `IgxLinearProgressBarComponent` position.\n     * ```html\n     * <igx-linear-bar [striped]=\"false\" [max]=\"200\" [value]=\"50\"></igx-linear-bar>\n     * ```\n     */\n\n\n    set value(val) {\n      if (this._animation && this._animation.playState !== 'finished' || val < 0) {\n        return;\n      }\n\n      const valInRange = valueInRange(val, this.max);\n\n      if (isNaN(valInRange) || this._value === val || this.indeterminate) {\n        return;\n      }\n\n      if (this._contentInit) {\n        this.triggerProgressTransition(this._value, valInRange);\n      } else {\n        this._initValue = valInRange;\n      }\n    }\n\n    triggerProgressTransition(oldVal, newVal, maxUpdate = false) {\n      if (oldVal === newVal) {\n        return;\n      }\n\n      const changedValues = {\n        currentValue: newVal,\n        previousValue: oldVal\n      };\n      const stepDirection = this.directionFlow(oldVal, newVal);\n\n      if (this._animate) {\n        const newToPercent = toPercent(newVal, this.max);\n        const oldToPercent = toPercent(oldVal, this.max);\n        const duration = this.animationDuration / Math.abs(newToPercent - oldToPercent) / (this._step ? this._step : 1);\n        this.runAnimation(newVal);\n        this._interval = setInterval(() => this.increase(newVal, stepDirection), duration);\n      } else {\n        this.updateProgress(newVal);\n      }\n\n      if (maxUpdate) {\n        return;\n      }\n\n      this.progressChanged.emit(changedValues);\n    }\n    /**\n     * @hidden\n     */\n\n\n    increase(newValue, step) {\n      const targetValue = toPercent(newValue, this._max);\n      this._value = valueInRange(this._value, this._max) + step;\n\n      if (step > 0 && this.valueInPercent >= targetValue || step < 0 && this.valueInPercent <= targetValue) {\n        if (this._value !== newValue) {\n          this._value = newValue;\n        }\n\n        return clearInterval(this._interval);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    directionFlow(currentValue, prevValue) {\n      return currentValue < prevValue ? this.step : -this.step;\n    }\n    /**\n     * @hidden\n     * @param step\n     */\n\n\n    updateProgress(val) {\n      this._value = valueInRange(val, this._max); // this.valueInPercent = toPercent(val, this._max);\n\n      this.runAnimation(val);\n    }\n\n  }\n\n  BaseProgressDirective.ɵfac = function BaseProgressDirective_Factory(t) {\n    return new (t || BaseProgressDirective)();\n  };\n\n  BaseProgressDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: BaseProgressDirective,\n    hostVars: 2,\n    hostBindings: function BaseProgressDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-valuemax\", ctx.max)(\"aria-valuenow\", ctx.value);\n      }\n    },\n    inputs: {\n      indeterminate: \"indeterminate\",\n      animationDuration: \"animationDuration\",\n      step: \"step\",\n      animate: \"animate\",\n      max: \"max\",\n      value: \"value\"\n    },\n    outputs: {\n      progressChanged: \"progressChanged\"\n    }\n  });\n  return BaseProgressDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_LINEAR_ID = 0;\nlet NEXT_CIRCULAR_ID = 0;\nlet NEXT_GRADIENT_ID = 0;\nlet IgxLinearProgressBarComponent = /*#__PURE__*/(() => {\n  class IgxLinearProgressBarComponent extends BaseProgressDirective {\n    constructor() {\n      super(...arguments);\n      this.valueMin = 0;\n      this.cssClass = 'igx-linear-bar';\n      /**\n       * Set `IgxLinearProgressBarComponent` to have striped style. By default it is set to false.\n       * ```html\n       * <igx-linear-bar [striped]=\"true\" [max]=\"200\" [value]=\"50\"></igx-linear-bar>\n       * ```\n       */\n\n      this.striped = false;\n      /**\n       * An @Input property that sets the value of the `role` attribute. If not provided it will be automatically set to `progressbar`.\n       * ```html\n       * <igx-linear-bar role=\"progressbar\"></igx-linear-bar>\n       * ```\n       */\n\n      this.role = 'progressbar';\n      /**\n       * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.\n       * ```html\n       * <igx-linear-bar [id]=\"'igx-linear-bar-55'\" [striped]=\"true\" [max]=\"200\" [value]=\"50\"></igx-linear-bar>\n       * ```\n       */\n\n      this.id = `igx-linear-bar-${NEXT_LINEAR_ID++}`;\n      /**\n       * Set the position that defines where the text is aligned.\n       * Possible options - `IgxTextAlign.START` (default), `IgxTextAlign.CENTER`, `IgxTextAlign.END`.\n       * ```typescript\n       * public positionCenter: IgxTextAlign;\n       * public ngOnInit() {\n       *     this.positionCenter = IgxTextAlign.CENTER;\n       * }\n       *  //...\n       * ```\n       *  ```html\n       * <igx-linear-bar type=\"warning\" [text]=\"'Custom text'\" [textAlign]=\"positionCenter\" [striped]=\"true\"></igx-linear-bar>\n       * ```\n       */\n\n      this.textAlign = IgxTextAlign.START;\n      /**\n       * Set the text to be visible. By default it is set to true.\n       * ```html\n       *  <igx-linear-bar type=\"default\" [textVisibility]=\"false\"></igx-linear-bar>\n       * ```\n       */\n\n      this.textVisibility = true;\n      /**\n       * Set the position that defines if the text should be aligned above the progress line. By default is set to false.\n       * ```html\n       *  <igx-linear-bar type=\"error\" [textTop]=\"true\"></igx-linear-bar>\n       * ```\n       */\n\n      this.textTop = false;\n      /**\n       * Set type of the `IgxLinearProgressBarComponent`. Possible options - `default`, `success`, `info`, `warning`, and `error`.\n       * ```html\n       * <igx-linear-bar [striped]=\"false\" [max]=\"100\" [value]=\"0\" type=\"error\"></igx-linear-bar>\n       * ```\n       */\n\n      this.type = 'default';\n      this.animationState = {\n        width: '0%'\n      };\n    }\n    /**\n     * @hidden\n     * ```\n     */\n\n\n    get isIndeterminate() {\n      return this.indeterminate;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get error() {\n      return this.type === IgxProgressType.ERROR;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get info() {\n      return this.type === IgxProgressType.INFO;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get warning() {\n      return this.type === IgxProgressType.WARNING;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get success() {\n      return this.type === IgxProgressType.SUCCESS;\n    }\n\n    ngAfterContentInit() {\n      this.triggerProgressTransition(MIN_VALUE, this._initValue);\n      this._contentInit = true;\n    }\n\n    runAnimation(value) {\n      if (this._animation && this._animation.playState !== 'finished') {\n        return;\n      }\n\n      const valueInPercent = this.max <= 0 ? 0 : toPercent(value, this.max);\n      const FRAMES = [];\n      FRAMES[0] = Object.assign({}, this.animationState);\n      this.animationState.width = valueInPercent + '%';\n      FRAMES[1] = Object.assign({}, this.animationState);\n      this._animation = this._progressIndicator.nativeElement.animate(FRAMES, {\n        easing: 'ease-out',\n        fill: 'forwards',\n        duration: this.animationDuration\n      });\n    }\n\n  }\n\n  IgxLinearProgressBarComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxLinearProgressBarComponent_BaseFactory;\n    return function IgxLinearProgressBarComponent_Factory(t) {\n      return (ɵIgxLinearProgressBarComponent_BaseFactory || (ɵIgxLinearProgressBarComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxLinearProgressBarComponent)))(t || IgxLinearProgressBarComponent);\n    };\n  }();\n\n  IgxLinearProgressBarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxLinearProgressBarComponent,\n    selectors: [[\"igx-linear-bar\"]],\n    viewQuery: function IgxLinearProgressBarComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c108, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._progressIndicator = _t.first);\n      }\n    },\n    hostVars: 17,\n    hostBindings: function IgxLinearProgressBarComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-valuemin\", ctx.valueMin)(\"role\", ctx.role)(\"id\", ctx.id);\n        i0.ɵɵclassProp(\"igx-linear-bar\", ctx.cssClass)(\"igx-linear-bar--striped\", ctx.striped)(\"igx-linear-bar--indeterminate\", ctx.isIndeterminate)(\"igx-linear-bar--danger\", ctx.error)(\"igx-linear-bar--info\", ctx.info)(\"igx-linear-bar--warning\", ctx.warning)(\"igx-linear-bar--success\", ctx.success);\n      }\n    },\n    inputs: {\n      striped: \"striped\",\n      role: \"role\",\n      id: \"id\",\n      textAlign: \"textAlign\",\n      textVisibility: \"textVisibility\",\n      textTop: \"textTop\",\n      text: \"text\",\n      type: \"type\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 5,\n    vars: 10,\n    consts: [[1, \"igx-linear-bar__base\"], [1, \"igx-linear-bar__indicator\"], [\"indicator\", \"\"], [1, \"igx-linear-bar__value\", 3, \"ngClass\"]],\n    template: function IgxLinearProgressBarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵelement(1, \"div\", 1, 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"span\", 3);\n        i0.ɵɵtext(4);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", 0);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction5(4, _c109, ctx.textAlign === \"start\", ctx.textAlign === \"center\", ctx.textAlign === \"end\", ctx.textTop, !ctx.textVisibility));\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate1(\" \", ctx.text ? ctx.text : ctx.valueInPercent + \"%\", \"\\n\");\n      }\n    },\n    directives: [i4.NgClass],\n    encapsulation: 2\n  });\n  return IgxLinearProgressBarComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxCircularProgressBarComponent = /*#__PURE__*/(() => {\n  class IgxCircularProgressBarComponent extends BaseProgressDirective {\n    constructor(renderer, _directionality) {\n      super();\n      this.renderer = renderer;\n      this._directionality = _directionality;\n      /** @hidden */\n\n      this.cssClass = 'igx-circular-bar';\n      /**\n       * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.\n       * ```html\n       * <igx-circular-bar [id]=\"'igx-circular-bar-55'\" [value]=\"50\"></igx-circular-bar>\n       * ```\n       */\n\n      this.id = `igx-circular-bar-${NEXT_CIRCULAR_ID++}`;\n      /**\n       * Sets the text visibility. By default it is set to true.\n       * ```html\n       * <igx-circular-bar [textVisibility]=\"false\"></igx-circular-bar>\n       * ```\n       */\n\n      this.textVisibility = true;\n      /**\n       * @hidden\n       */\n\n      this.gradientId = `igx-circular-gradient-${NEXT_GRADIENT_ID++}`;\n      this._circleRadius = 46;\n      this._circumference = 2 * Math.PI * this._circleRadius;\n      this.STROKE_OPACITY_DVIDER = 100;\n      this.STROKE_OPACITY_ADDITION = .2;\n      this.animationState = {\n        strokeDashoffset: 289,\n        strokeOpacity: 1\n      };\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isIndeterminate() {\n      return this.indeterminate;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get context() {\n      return {\n        $implicit: {\n          value: this.value,\n          valueInPercent: this.valueInPercent,\n          max: this.max\n        }\n      };\n    }\n\n    ngAfterContentInit() {\n      this.triggerProgressTransition(MIN_VALUE, this._initValue);\n      this._contentInit = true;\n    }\n\n    ngAfterViewInit() {\n      this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke', `url(#${this.gradientId})`);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get textContent() {\n      return this.text;\n    }\n\n    runAnimation(value) {\n      if (this._animation && this._animation.playState !== 'finished') {\n        return;\n      }\n\n      const valueInPercent = this.max <= 0 ? 0 : toPercent(value, this.max);\n      const FRAMES = [];\n      FRAMES[0] = Object.assign({}, this.animationState);\n      this.animationState.strokeDashoffset = this.getProgress(valueInPercent);\n      this.animationState.strokeOpacity = toPercent(value, this.max) / this.STROKE_OPACITY_DVIDER + this.STROKE_OPACITY_ADDITION;\n      FRAMES[1] = Object.assign({}, this.animationState);\n      this._animation = this._svgCircle.nativeElement.animate(FRAMES, {\n        easing: 'ease-out',\n        fill: 'forwards',\n        duration: this.animationDuration\n      });\n    }\n\n    getProgress(percentage) {\n      return this._directionality.rtl ? this._circumference + percentage * this._circumference / 100 : this._circumference - percentage * this._circumference / 100;\n    }\n\n  }\n\n  IgxCircularProgressBarComponent.ɵfac = function IgxCircularProgressBarComponent_Factory(t) {\n    return new (t || IgxCircularProgressBarComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(IgxDirectionality));\n  };\n\n  IgxCircularProgressBarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxCircularProgressBarComponent,\n    selectors: [[\"igx-circular-bar\"]],\n    contentQueries: function IgxCircularProgressBarComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxProcessBarTextTemplateDirective, 5, IgxProcessBarTextTemplateDirective);\n        i0.ɵɵcontentQuery(dirIndex, IgxProgressBarGradientDirective, 5, IgxProgressBarGradientDirective);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.textTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.gradientTemplate = _t.first);\n      }\n    },\n    viewQuery: function IgxCircularProgressBarComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c110, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._svgCircle = _t.first);\n      }\n    },\n    hostVars: 5,\n    hostBindings: function IgxCircularProgressBarComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id);\n        i0.ɵɵclassProp(\"igx-circular-bar\", ctx.cssClass)(\"igx-circular-bar--indeterminate\", ctx.isIndeterminate);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      isIndeterminate: \"isIndeterminate\",\n      textVisibility: \"textVisibility\",\n      text: \"text\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 12,\n    vars: 7,\n    consts: [[\"xmlns\", \"http://www.w3.org/2000/svg\", 0, \"xmlns\", \"xlink\", \"http://www.w3.org/1999/xlink\", \"version\", \"1.1\", \"viewBox\", \"0 0 100 100\", \"preserveAspectRatio\", \"xMidYMid meet\", \"role\", \"progressbar\", \"aria-valuemin\", \"0\"], [\"svg\", \"\"], [\"cx\", \"50\", \"cy\", \"50\", \"r\", \"46\", 1, \"igx-circular-bar__inner\"], [\"cx\", \"50\", \"cy\", \"50\", \"r\", \"46\", 1, \"igx-circular-bar__outer\"], [\"circle\", \"\"], [\"text-anchor\", \"middle\", \"x\", \"50\", \"y\", \"60\", 4, \"ngIf\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"defaultTextTemplate\", \"\"], [\"defaultGradientTemplate\", \"\"], [\"text-anchor\", \"middle\", \"x\", \"50\", \"y\", \"60\"], [1, \"igx-circular-bar__text\"], [\"gradientTransform\", \"rotate(90)\", 3, \"id\"], [\"offset\", \"0%\", 1, \"igx-circular-bar__gradient-start\"], [\"offset\", \"100%\", 1, \"igx-circular-bar__gradient-end\"]],\n    template: function IgxCircularProgressBarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵnamespaceSVG();\n        i0.ɵɵelementStart(0, \"svg\", 0, 1);\n        i0.ɵɵelement(2, \"circle\", 2)(3, \"circle\", 3, 4);\n        i0.ɵɵtemplate(5, IgxCircularProgressBarComponent__svg_text_5_Template, 2, 2, \"text\", 5);\n        i0.ɵɵelementStart(6, \"defs\");\n        i0.ɵɵtemplate(7, IgxCircularProgressBarComponent__svg_ng_container_7_Template, 1, 0, \"ng-container\", 6);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(8, IgxCircularProgressBarComponent__svg_ng_template_8_Template, 2, 1, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(10, IgxCircularProgressBarComponent__svg_ng_template_10_Template, 3, 1, \"ng-template\", null, 8, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        const _r6 = i0.ɵɵreference(11);\n\n        i0.ɵɵattribute(\"aria-valuemax\", ctx.max)(\"aria-valuenow\", ctx.value);\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"ngIf\", ctx.textVisibility);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.gradientTemplate ? ctx.gradientTemplate.template : _r6)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(5, _c24, ctx.gradientId));\n      }\n    },\n    directives: [i4.NgIf, i4.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return IgxCircularProgressBarComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst valueInRange = (value, max, min = 0) => Math.max(Math.min(value, max), min);\n\nconst toPercent = (value, max) => !max ? 0 : Math.floor(100 * value / max);\n\nconst toValue = (value, max) => max * value / 100;\n/**\n * @hidden\n */\n\n\nlet IgxProgressBarModule = /*#__PURE__*/(() => {\n  class IgxProgressBarModule {}\n\n  IgxProgressBarModule.ɵfac = function IgxProgressBarModule_Factory(t) {\n    return new (t || IgxProgressBarModule)();\n  };\n\n  IgxProgressBarModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxProgressBarModule\n  });\n  IgxProgressBarModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return IgxProgressBarModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // Enums\n\n\nconst IgxTreeSelectionType = mkenum({\n  None: 'None',\n  BiState: 'BiState',\n  Cascading: 'Cascading'\n}); // Token\n\nconst IGX_TREE_COMPONENT = new InjectionToken('IgxTreeToken');\nconst IGX_TREE_NODE_COMPONENT = new InjectionToken('IgxTreeNodeToken');\n/** @hidden @internal */\n\nlet IgxTreeService = /*#__PURE__*/(() => {\n  class IgxTreeService {\n    constructor() {\n      this.expandedNodes = new Set();\n      this.collapsingNodes = new Set();\n\n      this.siblingComparer = (data, node) => node !== data && node.level === data.level;\n    }\n    /**\n     * Adds the node to the `expandedNodes` set and fires the nodes change event\n     *\n     * @param node target node\n     * @param uiTrigger is the event triggered by a ui interraction (so we know if we should animate)\n     * @returns void\n     */\n\n\n    expand(node, uiTrigger) {\n      var _a;\n\n      this.collapsingNodes.delete(node);\n\n      if (!this.expandedNodes.has(node)) {\n        node.expandedChange.emit(true);\n      } else {\n        return;\n      }\n\n      this.expandedNodes.add(node);\n\n      if (this.tree.singleBranchExpand) {\n        (_a = this.tree.findNodes(node, this.siblingComparer)) === null || _a === void 0 ? void 0 : _a.forEach(e => {\n          if (uiTrigger) {\n            e.collapse();\n          } else {\n            e.expanded = false;\n          }\n        });\n      }\n    }\n    /**\n     * Adds a node to the `collapsing` collection\n     *\n     * @param node target node\n     */\n\n\n    collapsing(node) {\n      this.collapsingNodes.add(node);\n    }\n    /**\n     * Removes the node from the 'expandedNodes' set and emits the node's change event\n     *\n     * @param node target node\n     * @returns void\n     */\n\n\n    collapse(node) {\n      if (this.expandedNodes.has(node)) {\n        node.expandedChange.emit(false);\n      }\n\n      this.collapsingNodes.delete(node);\n      this.expandedNodes.delete(node);\n    }\n\n    isExpanded(node) {\n      return this.expandedNodes.has(node);\n    }\n\n    register(tree) {\n      this.tree = tree;\n    }\n\n  }\n\n  IgxTreeService.ɵfac = function IgxTreeService_Factory(t) {\n    return new (t || IgxTreeService)();\n  };\n\n  IgxTreeService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxTreeService,\n    factory: IgxTreeService.ɵfac\n  });\n  return IgxTreeService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n;\n/** @hidden @internal */\n\nlet IgxTreeSelectionService = /*#__PURE__*/(() => {\n  class IgxTreeSelectionService {\n    constructor() {\n      this.nodeSelection = new Set();\n      this.indeterminateNodes = new Set();\n    }\n\n    register(tree) {\n      this.tree = tree;\n    }\n    /** Select range from last selected node to the current specified node. */\n\n\n    selectMultipleNodes(node, event) {\n      if (!this.nodeSelection.size) {\n        this.selectNode(node);\n        return;\n      }\n\n      const lastSelectedNodeIndex = this.tree.nodes.toArray().indexOf(this.getSelectedNodes()[this.nodeSelection.size - 1]);\n      const currentNodeIndex = this.tree.nodes.toArray().indexOf(node);\n      const nodes = this.tree.nodes.toArray().slice(Math.min(currentNodeIndex, lastSelectedNodeIndex), Math.max(currentNodeIndex, lastSelectedNodeIndex) + 1);\n      const added = nodes.filter(_node => !this.isNodeSelected(_node));\n      const newSelection = this.getSelectedNodes().concat(added);\n      this.emitNodeSelectionEvent(newSelection, added, [], event);\n    }\n    /** Select the specified node and emit event. */\n\n\n    selectNode(node, event) {\n      if (this.tree.selection === IgxTreeSelectionType.None) {\n        return;\n      }\n\n      this.emitNodeSelectionEvent([...this.getSelectedNodes(), node], [node], [], event);\n    }\n    /** Deselect the specified node and emit event. */\n\n\n    deselectNode(node, event) {\n      const newSelection = this.getSelectedNodes().filter(r => r !== node);\n      this.emitNodeSelectionEvent(newSelection, [], [node], event);\n    }\n    /** Clears node selection */\n\n\n    clearNodesSelection() {\n      this.nodeSelection.clear();\n      this.indeterminateNodes.clear();\n    }\n\n    isNodeSelected(node) {\n      return this.nodeSelection.has(node);\n    }\n\n    isNodeIndeterminate(node) {\n      return this.indeterminateNodes.has(node);\n    }\n    /** Select specified nodes. No event is emitted. */\n\n\n    selectNodesWithNoEvent(nodes, clearPrevSelection = false, shouldEmit = true) {\n      if (this.tree && this.tree.selection === IgxTreeSelectionType.Cascading) {\n        this.cascadeSelectNodesWithNoEvent(nodes, clearPrevSelection);\n        return;\n      }\n\n      const oldSelection = this.getSelectedNodes();\n\n      if (clearPrevSelection) {\n        this.nodeSelection.clear();\n      }\n\n      nodes.forEach(node => this.nodeSelection.add(node));\n\n      if (shouldEmit) {\n        this.emitSelectedChangeEvent(oldSelection);\n      }\n    }\n    /** Deselect specified nodes. No event is emitted. */\n\n\n    deselectNodesWithNoEvent(nodes, shouldEmit = true) {\n      const oldSelection = this.getSelectedNodes();\n\n      if (!nodes) {\n        this.nodeSelection.clear();\n      } else if (this.tree && this.tree.selection === IgxTreeSelectionType.Cascading) {\n        this.cascadeDeselectNodesWithNoEvent(nodes);\n      } else {\n        nodes.forEach(node => this.nodeSelection.delete(node));\n      }\n\n      if (shouldEmit) {\n        this.emitSelectedChangeEvent(oldSelection);\n      }\n    }\n    /** Called on `node.ngOnDestroy` to ensure state is correct after node is removed */\n\n\n    ensureStateOnNodeDelete(node) {\n      var _a;\n\n      if (((_a = this.tree) === null || _a === void 0 ? void 0 : _a.selection) !== IgxTreeSelectionType.Cascading) {\n        return;\n      }\n\n      requestAnimationFrame(() => {\n        var _a;\n\n        if (this.isNodeSelected(node)) {\n          // node is destroyed, do not emit event\n          this.deselectNodesWithNoEvent([node], false);\n        } else {\n          if (!node.parentNode) {\n            return;\n          }\n\n          const assitantLeafNode = (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.allChildren.find(e => {\n            var _a;\n\n            return !((_a = e._children) === null || _a === void 0 ? void 0 : _a.length);\n          });\n\n          if (!assitantLeafNode) {\n            return;\n          }\n\n          this.retriggerNodeState(assitantLeafNode);\n        }\n      });\n    }\n    /** Retriggers a node's selection state */\n\n\n    retriggerNodeState(node) {\n      if (node.selected) {\n        this.nodeSelection.delete(node);\n        this.selectNodesWithNoEvent([node], false, false);\n      } else {\n        this.nodeSelection.add(node);\n        this.deselectNodesWithNoEvent([node], false);\n      }\n    }\n    /** Returns array of the selected nodes. */\n\n\n    getSelectedNodes() {\n      return this.nodeSelection.size ? Array.from(this.nodeSelection) : [];\n    }\n    /** Returns array of the nodes in indeterminate state. */\n\n\n    getIndeterminateNodes() {\n      return this.indeterminateNodes.size ? Array.from(this.indeterminateNodes) : [];\n    }\n\n    emitNodeSelectionEvent(newSelection, added, removed, event) {\n      if (this.tree.selection === IgxTreeSelectionType.Cascading) {\n        this.emitCascadeNodeSelectionEvent(newSelection, added, removed, event);\n        return;\n      }\n\n      const currSelection = this.getSelectedNodes();\n\n      if (this.areEqualCollections(currSelection, newSelection)) {\n        return;\n      }\n\n      const args = {\n        oldSelection: currSelection,\n        newSelection,\n        added,\n        removed,\n        event,\n        cancel: false,\n        owner: this.tree\n      };\n      this.tree.nodeSelection.emit(args);\n\n      if (args.cancel) {\n        return;\n      }\n\n      this.selectNodesWithNoEvent(args.newSelection, true);\n    }\n\n    areEqualCollections(first, second) {\n      return first.length === second.length && new Set(first.concat(second)).size === first.length;\n    }\n\n    cascadeSelectNodesWithNoEvent(nodes, clearPrevSelection = false) {\n      const oldSelection = this.getSelectedNodes();\n\n      if (clearPrevSelection) {\n        this.indeterminateNodes.clear();\n        this.nodeSelection.clear();\n        this.calculateNodesNewSelectionState({\n          added: nodes,\n          removed: []\n        });\n      } else {\n        const newSelection = [...oldSelection, ...nodes];\n        const args = {\n          oldSelection,\n          newSelection\n        }; // retrieve only the rows without their parents/children which has to be added to the selection\n\n        this.populateAddRemoveArgs(args);\n        this.calculateNodesNewSelectionState(args);\n      }\n\n      this.nodeSelection = new Set(this.nodesToBeSelected);\n      this.indeterminateNodes = new Set(this.nodesToBeIndeterminate);\n      this.emitSelectedChangeEvent(oldSelection);\n    }\n\n    cascadeDeselectNodesWithNoEvent(nodes) {\n      const args = {\n        added: [],\n        removed: nodes\n      };\n      this.calculateNodesNewSelectionState(args);\n      this.nodeSelection = new Set(this.nodesToBeSelected);\n      this.indeterminateNodes = new Set(this.nodesToBeIndeterminate);\n    }\n    /**\n     * populates the nodesToBeSelected and nodesToBeIndeterminate sets\n     * with the nodes which will be eventually in selected/indeterminate state\n     */\n\n\n    calculateNodesNewSelectionState(args) {\n      this.nodesToBeSelected = new Set(args.oldSelection ? args.oldSelection : this.getSelectedNodes());\n      this.nodesToBeIndeterminate = new Set(this.getIndeterminateNodes());\n      this.cascadeSelectionState(args.removed, false);\n      this.cascadeSelectionState(args.added, true);\n    }\n    /** Ensures proper selection state for all predescessors and descendants during a selection event */\n\n\n    cascadeSelectionState(nodes, selected) {\n      if (!nodes || nodes.length === 0) {\n        return;\n      }\n\n      if (nodes && nodes.length > 0) {\n        const nodeCollection = this.getCascadingNodeCollection(nodes);\n        nodeCollection.nodes.forEach(node => {\n          if (selected) {\n            this.nodesToBeSelected.add(node);\n          } else {\n            this.nodesToBeSelected.delete(node);\n          }\n\n          this.nodesToBeIndeterminate.delete(node);\n        });\n        Array.from(nodeCollection.parents).forEach(parent => {\n          this.handleParentSelectionState(parent);\n        });\n      }\n    }\n\n    emitCascadeNodeSelectionEvent(newSelection, added, removed, event) {\n      const currSelection = this.getSelectedNodes();\n\n      if (this.areEqualCollections(currSelection, newSelection)) {\n        return;\n      }\n\n      const args = {\n        oldSelection: currSelection,\n        newSelection,\n        added,\n        removed,\n        event,\n        cancel: false,\n        owner: this.tree\n      };\n      this.calculateNodesNewSelectionState(args);\n      args.newSelection = Array.from(this.nodesToBeSelected); // retrieve nodes/parents/children which has been added/removed from the selection\n\n      this.populateAddRemoveArgs(args);\n      this.tree.nodeSelection.emit(args);\n\n      if (args.cancel) {\n        return;\n      } // if args.newSelection hasn't been modified\n\n\n      if (this.areEqualCollections(Array.from(this.nodesToBeSelected), args.newSelection)) {\n        this.nodeSelection = new Set(this.nodesToBeSelected);\n        this.indeterminateNodes = new Set(this.nodesToBeIndeterminate);\n        this.emitSelectedChangeEvent(currSelection);\n      } else {\n        // select the nodes within the modified args.newSelection with no event\n        this.cascadeSelectNodesWithNoEvent(args.newSelection, true);\n      }\n    }\n    /**\n     * recursively handle the selection state of the direct and indirect parents\n     */\n\n\n    handleParentSelectionState(node) {\n      if (!node) {\n        return;\n      }\n\n      this.handleNodeSelectionState(node);\n\n      if (node.parentNode) {\n        this.handleParentSelectionState(node.parentNode);\n      }\n    }\n    /**\n     * Handle the selection state of a given node based the selection states of its direct children\n     */\n\n\n    handleNodeSelectionState(node) {\n      const nodesArray = node && node._children ? node._children.toArray() : [];\n\n      if (nodesArray.length) {\n        if (nodesArray.every(n => this.nodesToBeSelected.has(n))) {\n          this.nodesToBeSelected.add(node);\n          this.nodesToBeIndeterminate.delete(node);\n        } else if (nodesArray.some(n => this.nodesToBeSelected.has(n) || this.nodesToBeIndeterminate.has(n))) {\n          this.nodesToBeIndeterminate.add(node);\n          this.nodesToBeSelected.delete(node);\n        } else {\n          this.nodesToBeIndeterminate.delete(node);\n          this.nodesToBeSelected.delete(node);\n        }\n      } else {\n        // if the children of the node has been deleted and the node was selected do not change its state\n        if (this.isNodeSelected(node)) {\n          this.nodesToBeSelected.add(node);\n        } else {\n          this.nodesToBeSelected.delete(node);\n        }\n\n        this.nodesToBeIndeterminate.delete(node);\n      }\n    }\n    /**\n     * Get a collection of all nodes affected by the change event\n     *\n     * @param nodesToBeProcessed set of the nodes to be selected/deselected\n     * @returns a collection of all affected nodes and all their parents\n     */\n\n\n    getCascadingNodeCollection(nodes) {\n      const collection = {\n        parents: new Set(),\n        nodes: new Set(nodes)\n      };\n      Array.from(collection.nodes).forEach(node => {\n        var _a;\n\n        const nodeAndAllChildren = ((_a = node.allChildren) === null || _a === void 0 ? void 0 : _a.toArray()) || [];\n        nodeAndAllChildren.forEach(n => {\n          collection.nodes.add(n);\n        });\n\n        if (node && node.parentNode) {\n          collection.parents.add(node.parentNode);\n        }\n      });\n      return collection;\n    }\n    /**\n     * retrieve the nodes which should be added/removed to/from the old selection\n     */\n\n\n    populateAddRemoveArgs(args) {\n      args.removed = args.oldSelection.filter(x => args.newSelection.indexOf(x) < 0);\n      args.added = args.newSelection.filter(x => args.oldSelection.indexOf(x) < 0);\n    }\n    /** Emits the `selectedChange` event for each node affected by the selection */\n\n\n    emitSelectedChangeEvent(oldSelection) {\n      this.getSelectedNodes().forEach(n => {\n        if (oldSelection.indexOf(n) < 0) {\n          n.selectedChange.emit(true);\n        }\n      });\n      oldSelection.forEach(n => {\n        if (!this.nodeSelection.has(n)) {\n          n.selectedChange.emit(false);\n        }\n      });\n    }\n\n  }\n\n  IgxTreeSelectionService.ɵfac = function IgxTreeSelectionService_Factory(t) {\n    return new (t || IgxTreeSelectionService)();\n  };\n\n  IgxTreeSelectionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxTreeSelectionService,\n    factory: IgxTreeSelectionService.ɵfac\n  });\n  return IgxTreeSelectionService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden @internal */\n\n\nlet IgxTreeNavigationService = /*#__PURE__*/(() => {\n  class IgxTreeNavigationService {\n    constructor(treeService, selectionService) {\n      this.treeService = treeService;\n      this.selectionService = selectionService;\n      this._focusedNode = null;\n      this._lastFocusedNode = null;\n      this._activeNode = null;\n      this._visibleChildren = [];\n      this._invisibleChildren = new Set();\n      this._disabledChildren = new Set();\n      this._cacheChange = new Subject();\n\n      this._cacheChange.subscribe(() => {\n        var _a;\n\n        this._visibleChildren = ((_a = this.tree) === null || _a === void 0 ? void 0 : _a.nodes) ? this.tree.nodes.filter(e => !(this._invisibleChildren.has(e) || this._disabledChildren.has(e))) : [];\n      });\n    }\n\n    register(tree) {\n      this.tree = tree;\n    }\n\n    get focusedNode() {\n      return this._focusedNode;\n    }\n\n    set focusedNode(value) {\n      if (this._focusedNode === value) {\n        return;\n      }\n\n      this._lastFocusedNode = this._focusedNode;\n\n      if (this._lastFocusedNode) {\n        this._lastFocusedNode.tabIndex = -1;\n      }\n\n      this._focusedNode = value;\n\n      if (this._focusedNode !== null) {\n        this._focusedNode.tabIndex = 0;\n\n        this._focusedNode.header.nativeElement.focus();\n      }\n    }\n\n    get activeNode() {\n      return this._activeNode;\n    }\n\n    set activeNode(value) {\n      if (this._activeNode === value) {\n        return;\n      }\n\n      this._activeNode = value;\n      this.tree.activeNodeChanged.emit(this._activeNode);\n    }\n\n    get visibleChildren() {\n      return this._visibleChildren;\n    }\n\n    update_disabled_cache(node) {\n      if (node.disabled) {\n        this._disabledChildren.add(node);\n      } else {\n        this._disabledChildren.delete(node);\n      }\n\n      this._cacheChange.next();\n    }\n\n    init_invisible_cache() {\n      this.tree.nodes.filter(e => e.level === 0).forEach(node => {\n        this.update_visible_cache(node, node.expanded, false);\n      });\n\n      this._cacheChange.next();\n    }\n\n    update_visible_cache(node, expanded, shouldEmit = true) {\n      if (expanded) {\n        node._children.forEach(child => {\n          this._invisibleChildren.delete(child);\n\n          this.update_visible_cache(child, child.expanded, false);\n        });\n      } else {\n        node.allChildren.forEach(c => this._invisibleChildren.add(c));\n      }\n\n      if (shouldEmit) {\n        this._cacheChange.next();\n      }\n    }\n    /**\n     * Sets the node as focused (and active)\n     *\n     * @param node target node\n     * @param isActive if true, sets the node as active\n     */\n\n\n    setFocusedAndActiveNode(node, isActive = true) {\n      if (isActive) {\n        this.activeNode = node;\n      }\n\n      this.focusedNode = node;\n    }\n    /** Handler for keydown events. Used in tree.component.ts */\n\n\n    handleKeydown(event) {\n      const key = event.key.toLowerCase();\n\n      if (!this.focusedNode) {\n        return;\n      }\n\n      if (!(NAVIGATION_KEYS.has(key) || key === '*')) {\n        if (key === 'enter') {\n          this.activeNode = this.focusedNode;\n        }\n\n        return;\n      }\n\n      event.preventDefault();\n\n      if (event.repeat) {\n        setTimeout(() => this.handleNavigation(event), 1);\n      } else {\n        this.handleNavigation(event);\n      }\n    }\n\n    ngOnDestroy() {\n      this._cacheChange.next();\n\n      this._cacheChange.complete();\n    }\n\n    handleNavigation(event) {\n      switch (event.key.toLowerCase()) {\n        case 'home':\n          this.setFocusedAndActiveNode(this.visibleChildren[0]);\n          break;\n\n        case 'end':\n          this.setFocusedAndActiveNode(this.visibleChildren[this.visibleChildren.length - 1]);\n          break;\n\n        case 'arrowleft':\n        case 'left':\n          this.handleArrowLeft();\n          break;\n\n        case 'arrowright':\n        case 'right':\n          this.handleArrowRight();\n          break;\n\n        case 'arrowup':\n        case 'up':\n          this.handleUpDownArrow(true, event);\n          break;\n\n        case 'arrowdown':\n        case 'down':\n          this.handleUpDownArrow(false, event);\n          break;\n\n        case '*':\n          this.handleAsterisk();\n          break;\n\n        case ' ':\n        case 'spacebar':\n        case 'space':\n          this.handleSpace(event.shiftKey);\n          break;\n\n        default:\n          return;\n      }\n    }\n\n    handleArrowLeft() {\n      var _a;\n\n      if (this.focusedNode.expanded && !this.treeService.collapsingNodes.has(this.focusedNode) && ((_a = this.focusedNode._children) === null || _a === void 0 ? void 0 : _a.length)) {\n        this.activeNode = this.focusedNode;\n        this.focusedNode.collapse();\n      } else {\n        const parentNode = this.focusedNode.parentNode;\n\n        if (parentNode && !parentNode.disabled) {\n          this.setFocusedAndActiveNode(parentNode);\n        }\n      }\n    }\n\n    handleArrowRight() {\n      if (this.focusedNode._children.length > 0) {\n        if (!this.focusedNode.expanded) {\n          this.activeNode = this.focusedNode;\n          this.focusedNode.expand();\n        } else {\n          if (this.treeService.collapsingNodes.has(this.focusedNode)) {\n            this.focusedNode.expand();\n            return;\n          }\n\n          const firstChild = this.focusedNode._children.find(node => !node.disabled);\n\n          if (firstChild) {\n            this.setFocusedAndActiveNode(firstChild);\n          }\n        }\n      }\n    }\n\n    handleUpDownArrow(isUp, event) {\n      const next = this.getVisibleNode(this.focusedNode, isUp ? -1 : 1);\n\n      if (next === this.focusedNode) {\n        return;\n      }\n\n      if (event.ctrlKey) {\n        this.setFocusedAndActiveNode(next, false);\n      } else {\n        this.setFocusedAndActiveNode(next);\n      }\n    }\n\n    handleAsterisk() {\n      const nodes = this.focusedNode.parentNode ? this.focusedNode.parentNode._children : this.tree.rootNodes;\n      nodes === null || nodes === void 0 ? void 0 : nodes.forEach(node => {\n        if (!node.disabled && (!node.expanded || this.treeService.collapsingNodes.has(node))) {\n          node.expand();\n        }\n      });\n    }\n\n    handleSpace(shiftKey = false) {\n      if (this.tree.selection === IgxTreeSelectionType.None) {\n        return;\n      }\n\n      this.activeNode = this.focusedNode;\n\n      if (shiftKey) {\n        this.selectionService.selectMultipleNodes(this.focusedNode);\n        return;\n      }\n\n      if (this.focusedNode.selected) {\n        this.selectionService.deselectNode(this.focusedNode);\n      } else {\n        this.selectionService.selectNode(this.focusedNode);\n      }\n    }\n    /** Gets the next visible node in the given direction - 1 -> next, -1 -> previous */\n\n\n    getVisibleNode(node, dir = 1) {\n      const nodeIndex = this.visibleChildren.indexOf(node);\n      return this.visibleChildren[nodeIndex + dir] || node;\n    }\n\n  }\n\n  IgxTreeNavigationService.ɵfac = function IgxTreeNavigationService_Factory(t) {\n    return new (t || IgxTreeNavigationService)(i0.ɵɵinject(IgxTreeService), i0.ɵɵinject(IgxTreeSelectionService));\n  };\n\n  IgxTreeNavigationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxTreeNavigationService,\n    factory: IgxTreeNavigationService.ɵfac\n  });\n  return IgxTreeNavigationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // TODO: Implement aria functionality\n\n/**\n * @hidden @internal\n * Used for links (`a` tags) in the body of an `igx-tree-node`. Handles aria and event dispatch.\n */\n\n\nlet IgxTreeNodeLinkDirective = /*#__PURE__*/(() => {\n  class IgxTreeNodeLinkDirective {\n    constructor(node, navService, elementRef) {\n      this.node = node;\n      this.navService = navService;\n      this.elementRef = elementRef;\n      this.role = 'treeitem';\n      this._parentNode = null;\n    }\n    /**\n     * The node's parent. Should be used only when the link is defined\n     * in `<ng-template>` tag outside of its parent, as Angular DI will not properly provide a reference\n     *\n     * ```html\n     * <igx-tree>\n     *     <igx-tree-node #myNode *ngFor=\"let node of data\" [data]=\"node\">\n     *         <ng-template *ngTemplateOutlet=\"nodeTemplate; context: { $implicit: data, parentNode: myNode }\">\n     *         </ng-template>\n     *     </igx-tree-node>\n     *     ...\n     *     <!-- node template is defined under tree to access related services -->\n     *     <ng-template #nodeTemplate let-data let-node=\"parentNode\">\n     *         <a [igxTreeNodeLink]=\"node\">{{ data.label }}</a>\n     *     </ng-template>\n     * </igx-tree>\n     * ```\n     */\n\n\n    set parentNode(val) {\n      if (val) {\n        this._parentNode = val;\n\n        this._parentNode.addLinkChild(this);\n      }\n    }\n\n    get parentNode() {\n      return this._parentNode;\n    }\n    /** A pointer to the parent node */\n\n\n    get target() {\n      return this.node || this.parentNode;\n    }\n    /** @hidden @internal */\n\n\n    get tabIndex() {\n      var _a;\n\n      return this.navService.focusedNode === this.target ? ((_a = this.target) === null || _a === void 0 ? void 0 : _a.disabled) ? -1 : 0 : -1;\n    }\n    /**\n     * @hidden @internal\n     * Clear the node's focused state\n     */\n\n\n    handleBlur() {\n      this.target.isFocused = false;\n    }\n    /**\n     * @hidden @internal\n     * Set the node as focused\n     */\n\n\n    handleFocus() {\n      if (this.target && !this.target.disabled) {\n        if (this.navService.focusedNode !== this.target) {\n          this.navService.focusedNode = this.target;\n        }\n\n        this.target.isFocused = true;\n      }\n    }\n\n    ngOnDestroy() {\n      this.target.removeLinkChild(this);\n    }\n\n  }\n\n  IgxTreeNodeLinkDirective.ɵfac = function IgxTreeNodeLinkDirective_Factory(t) {\n    return new (t || IgxTreeNodeLinkDirective)(i0.ɵɵdirectiveInject(IGX_TREE_NODE_COMPONENT, 8), i0.ɵɵdirectiveInject(IgxTreeNavigationService), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxTreeNodeLinkDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxTreeNodeLinkDirective,\n    selectors: [[\"\", \"igxTreeNodeLink\", \"\"]],\n    hostVars: 2,\n    hostBindings: function IgxTreeNodeLinkDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"blur\", function IgxTreeNodeLinkDirective_blur_HostBindingHandler() {\n          return ctx.handleBlur();\n        })(\"focus\", function IgxTreeNodeLinkDirective_focus_HostBindingHandler() {\n          return ctx.handleFocus();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"tabindex\", ctx.tabIndex);\n      }\n    },\n    inputs: {\n      parentNode: [\"igxTreeNodeLink\", \"parentNode\"]\n    }\n  });\n  return IgxTreeNodeLinkDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n *\n * The tree node component represents a child node of the tree component or another tree node.\n * Usage:\n *\n * ```html\n *  <igx-tree>\n *  ...\n *    <igx-tree-node [data]=\"data\" [selected]=\"service.isNodeSelected(data.Key)\" [expanded]=\"service.isNodeExpanded(data.Key)\">\n *      {{ data.FirstName }} {{ data.LastName }}\n *    </igx-tree-node>\n *  ...\n *  </igx-tree>\n * ```\n */\n\n\nlet IgxTreeNodeComponent = /*#__PURE__*/(() => {\n  class IgxTreeNodeComponent extends ToggleAnimationPlayer {\n    constructor(tree, selectionService, treeService, navService, cdr, builder, element, parentNode) {\n      super(builder);\n      this.tree = tree;\n      this.selectionService = selectionService;\n      this.treeService = treeService;\n      this.navService = navService;\n      this.cdr = cdr;\n      this.builder = builder;\n      this.element = element;\n      this.parentNode = parentNode;\n      /**\n       * To be used for load-on-demand scenarios in order to specify whether the node is loading data.\n       *\n       * @remarks\n       * Loading nodes do not render children.\n       */\n\n      this.loading = false;\n      /**\n       * Emitted when the node's `selected` property changes.\n       *\n       * ```html\n       * <igx-tree>\n       *      <igx-tree-node *ngFor=\"let node of data\" [data]=\"node\" [(selected)]=\"node.selected\">\n       *      </igx-tree-node>\n       * </igx-tree>\n       * ```\n       *\n       * ```typescript\n       * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];\n       * node.selectedChange.pipe(takeUntil(this.destroy$)).subscribe((e: boolean) => console.log(\"Node selection changed to \", e))\n       * ```\n       */\n\n      this.selectedChange = new EventEmitter();\n      /**\n       * Emitted when the node's `expanded` property changes.\n       *\n       * ```html\n       * <igx-tree>\n       *      <igx-tree-node *ngFor=\"let node of data\" [data]=\"node\" [(expanded)]=\"node.expanded\">\n       *      </igx-tree-node>\n       * </igx-tree>\n       * ```\n       *\n       * ```typescript\n       * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];\n       * node.expandedChange.pipe(takeUntil(this.destroy$)).subscribe((e: boolean) => console.log(\"Node expansion state changed to \", e))\n       * ```\n       */\n\n      this.expandedChange = new EventEmitter();\n      /** @hidden @internal */\n\n      this.cssClass = 'igx-tree-node';\n      /** @hidden @internal */\n\n      this.registeredChildren = [];\n      /** @hidden @internal */\n\n      this._resourceStrings = CurrentResourceStrings.TreeResStrings;\n      this._tabIndex = null;\n      this._disabled = false;\n    } // TO DO: return different tab index depending on anchor child\n\n    /** @hidden @internal */\n\n\n    set tabIndex(val) {\n      this._tabIndex = val;\n    }\n    /** @hidden @internal */\n\n\n    get tabIndex() {\n      if (this.disabled) {\n        return -1;\n      }\n\n      if (this._tabIndex === null) {\n        if (this.navService.focusedNode === null) {\n          return this.hasLinkChildren ? -1 : 0;\n        }\n\n        return -1;\n      }\n\n      return this.hasLinkChildren ? -1 : this._tabIndex;\n    }\n    /** @hidden @internal */\n\n\n    get animationSettings() {\n      return this.tree.animationSettings;\n    }\n    /**\n     * Gets/Sets the resource strings.\n     *\n     * @remarks\n     * Uses EN resources by default.\n     */\n\n\n    set resourceStrings(value) {\n      this._resourceStrings = Object.assign({}, this._resourceStrings, value);\n    }\n    /**\n     * An accessor that returns the resource strings.\n     */\n\n\n    get resourceStrings() {\n      if (!this._resourceStrings) {\n        this._resourceStrings = CurrentResourceStrings.TreeResStrings;\n      }\n\n      return this._resourceStrings;\n    }\n    /**\n     * Gets/Sets the active state of the node\n     *\n     * @param value: boolean\n     */\n\n\n    set active(value) {\n      if (value) {\n        this.navService.activeNode = this;\n        this.tree.activeNodeBindingChange.emit(this);\n      }\n    }\n\n    get active() {\n      return this.navService.activeNode === this;\n    }\n    /** @hidden @internal */\n\n\n    get focused() {\n      return this.isFocused && this.navService.focusedNode === this;\n    }\n    /**\n     * Retrieves the full path to the node incuding itself\n     *\n     * ```typescript\n     * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];\n     * const path: IgxTreeNode<any>[] = node.path;\n     * ```\n     */\n\n\n    get path() {\n      var _a;\n\n      return ((_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.path) ? [...this.parentNode.path, this] : [this];\n    } // TODO: bind to disabled state when node is dragged\n\n    /**\n     * Gets/Sets the disabled state of the node\n     *\n     * @param value: boolean\n     */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n\n    set disabled(value) {\n      if (value !== this._disabled) {\n        this._disabled = value;\n        this.tree.disabledChange.emit(this);\n      }\n    }\n    /** @hidden @internal */\n\n\n    get role() {\n      return this.hasLinkChildren ? 'none' : 'treeitem';\n    }\n\n    /**\n     * Return the child nodes of the node (if any)\n     *\n     * @remark\n     * Returns `null` if node does not have children\n     *\n     * @example\n     * ```typescript\n     * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];\n     * const children: IgxTreeNode<any>[] = node.children;\n     * ```\n     */\n    get children() {\n      var _a;\n\n      return ((_a = this._children) === null || _a === void 0 ? void 0 : _a.length) ? this._children.toArray() : null;\n    }\n\n    get hasLinkChildren() {\n      var _a, _b;\n\n      return ((_a = this.linkChildren) === null || _a === void 0 ? void 0 : _a.length) > 0 || ((_b = this.registeredChildren) === null || _b === void 0 ? void 0 : _b.length) > 0;\n    }\n    /** @hidden @internal */\n\n\n    get isCompact() {\n      var _a;\n\n      return ((_a = this.tree) === null || _a === void 0 ? void 0 : _a.displayDensity) === DisplayDensity.compact;\n    }\n    /** @hidden @internal */\n\n\n    get isCosy() {\n      var _a;\n\n      return ((_a = this.tree) === null || _a === void 0 ? void 0 : _a.displayDensity) === DisplayDensity.cosy;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get showSelectors() {\n      return this.tree.selection !== IgxTreeSelectionType.None;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get indeterminate() {\n      return this.selectionService.isNodeIndeterminate(this);\n    }\n    /** The depth of the node, relative to the root\n     *\n     * ```html\n     * <igx-tree>\n     *  ...\n     *  <igx-tree-node #node>\n     *      My level is {{ node.level }}\n     *  </igx-tree-node>\n     * </igx-tree>\n     * ```\n     *\n     * ```typescript\n     * const node: IgxTreeNode<any> = this.tree.findNodes(data[12])[0];\n     * const level: number = node.level;\n     * ```\n     */\n\n\n    get level() {\n      return this.parentNode ? this.parentNode.level + 1 : 0;\n    }\n    /** Get/set whether the node is selected. Supporst two-way binding.\n     *\n     * ```html\n     * <igx-tree>\n     *  ...\n     *  <igx-tree-node *ngFor=\"let node of data\" [(selected)]=\"node.selected\">\n     *      {{ node.label }}\n     *  </igx-tree-node>\n     * </igx-tree>\n     * ```\n     *\n     * ```typescript\n     * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];\n     * const selected = node.selected;\n     * node.selected = true;\n     * ```\n     */\n\n\n    get selected() {\n      return this.selectionService.isNodeSelected(this);\n    }\n\n    set selected(val) {\n      var _a;\n\n      if (!(((_a = this.tree) === null || _a === void 0 ? void 0 : _a.nodes) && this.tree.nodes.find(e => e === this)) && val) {\n        this.tree.forceSelect.push(this);\n        return;\n      }\n\n      if (val && !this.selectionService.isNodeSelected(this)) {\n        this.selectionService.selectNodesWithNoEvent([this]);\n      }\n\n      if (!val && this.selectionService.isNodeSelected(this)) {\n        this.selectionService.deselectNodesWithNoEvent([this]);\n      }\n    }\n    /** Get/set whether the node is expanded\n     *\n     * ```html\n     * <igx-tree>\n     *  ...\n     *  <igx-tree-node *ngFor=\"let node of data\" [expanded]=\"node.name === this.expandedNode\">\n     *      {{ node.label }}\n     *  </igx-tree-node>\n     * </igx-tree>\n     * ```\n     *\n     * ```typescript\n     * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];\n     * const expanded = node.expanded;\n     * node.expanded = true;\n     * ```\n     */\n\n\n    get expanded() {\n      return this.treeService.isExpanded(this);\n    }\n\n    set expanded(val) {\n      if (val) {\n        this.treeService.expand(this, false);\n      } else {\n        this.treeService.collapse(this);\n      }\n    }\n    /** @hidden @internal */\n\n\n    get expandIndicatorTemplate() {\n      var _a;\n\n      return ((_a = this.tree) === null || _a === void 0 ? void 0 : _a.expandIndicator) ? this.tree.expandIndicator : this._defaultExpandIndicatorTemplate;\n    }\n    /**\n     * The native DOM element representing the node. Could be null in certain environments.\n     *\n     * ```typescript\n     * // get the nativeElement of the second node\n     * const node: IgxTreeNode = this.tree.nodes.first();\n     * const nodeElement: HTMLElement = node.nativeElement;\n     * ```\n     */\n\n    /** @hidden @internal */\n\n\n    get nativeElement() {\n      return this.element.nativeElement;\n    }\n    /** @hidden @internal */\n\n\n    ngOnInit() {\n      this.openAnimationDone.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        this.tree.nodeExpanded.emit({\n          owner: this.tree,\n          node: this\n        });\n      });\n      this.closeAnimationDone.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        this.tree.nodeCollapsed.emit({\n          owner: this.tree,\n          node: this\n        });\n        this.treeService.collapse(this);\n        this.cdr.markForCheck();\n      });\n    }\n    /**\n     * @hidden @internal\n     * Sets the focus to the node's <a> child, if present\n     * Sets the node as the tree service's focusedNode\n     * Marks the node as the current active element\n     */\n\n\n    handleFocus() {\n      var _a;\n\n      if (this.disabled) {\n        return;\n      }\n\n      if (this.navService.focusedNode !== this) {\n        this.navService.focusedNode = this;\n      }\n\n      this.isFocused = true;\n\n      if ((_a = this.linkChildren) === null || _a === void 0 ? void 0 : _a.length) {\n        this.linkChildren.first.nativeElement.focus();\n        return;\n      }\n\n      if (this.registeredChildren.length) {\n        this.registeredChildren[0].elementRef.nativeElement.focus();\n        return;\n      }\n    }\n    /**\n     * @hidden @internal\n     * Clear the node's focused status\n     */\n\n\n    clearFocus() {\n      this.isFocused = false;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onSelectorClick(event) {\n      // event.stopPropagation();\n      event.preventDefault(); // this.navService.handleFocusedAndActiveNode(this);\n\n      if (event.shiftKey) {\n        this.selectionService.selectMultipleNodes(this, event);\n        return;\n      }\n\n      if (this.selected) {\n        this.selectionService.deselectNode(this, event);\n      } else {\n        this.selectionService.selectNode(this, event);\n      }\n    }\n    /**\n     * Toggles the node expansion state, triggering animation\n     *\n     * ```html\n     * <igx-tree>\n     *      <igx-tree-node #node>My Node</igx-tree-node>\n     * </igx-tree>\n     * <button igxButton (click)=\"node.toggle()\">Toggle Node</button>\n     * ```\n     *\n     * ```typescript\n     * const myNode: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];\n     * myNode.toggle();\n     * ```\n     */\n\n\n    toggle() {\n      if (this.expanded) {\n        this.collapse();\n      } else {\n        this.expand();\n      }\n    }\n    /** @hidden @internal */\n\n\n    indicatorClick() {\n      this.toggle();\n      this.navService.setFocusedAndActiveNode(this);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onPointerDown(event) {\n      event.stopPropagation();\n      this.navService.setFocusedAndActiveNode(this);\n    }\n\n    ngOnDestroy() {\n      super.ngOnDestroy();\n      this.selectionService.ensureStateOnNodeDelete(this);\n    }\n    /**\n     * Expands the node, triggering animation\n     *\n     * ```html\n     * <igx-tree>\n     *      <igx-tree-node #node>My Node</igx-tree-node>\n     * </igx-tree>\n     * <button igxButton (click)=\"node.expand()\">Expand Node</button>\n     * ```\n     *\n     * ```typescript\n     * const myNode: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];\n     * myNode.expand();\n     * ```\n     */\n\n\n    expand() {\n      const args = {\n        owner: this.tree,\n        node: this,\n        cancel: false\n      };\n      this.tree.nodeExpanding.emit(args);\n\n      if (!args.cancel) {\n        this.treeService.expand(this, true);\n        this.cdr.detectChanges();\n        this.playOpenAnimation(this.childrenContainer);\n      }\n    }\n    /**\n     * Collapses the node, triggering animation\n     *\n     * ```html\n     * <igx-tree>\n     *      <igx-tree-node #node>My Node</igx-tree-node>\n     * </igx-tree>\n     * <button igxButton (click)=\"node.collapse()\">Collapse Node</button>\n     * ```\n     *\n     * ```typescript\n     * const myNode: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];\n     * myNode.collapse();\n     * ```\n     */\n\n\n    collapse() {\n      const args = {\n        owner: this.tree,\n        node: this,\n        cancel: false\n      };\n      this.tree.nodeCollapsing.emit(args);\n\n      if (!args.cancel) {\n        this.treeService.collapsing(this);\n        this.playCloseAnimation(this.childrenContainer);\n      }\n    }\n    /** @hidden @internal */\n\n\n    addLinkChild(link) {\n      this._tabIndex = -1;\n      this.registeredChildren.push(link);\n    }\n\n    /** @hidden @internal */\n    removeLinkChild(link) {\n      const index = this.registeredChildren.indexOf(link);\n\n      if (index !== -1) {\n        this.registeredChildren.splice(index, 1);\n      }\n    }\n\n  }\n\n  IgxTreeNodeComponent.ɵfac = function IgxTreeNodeComponent_Factory(t) {\n    return new (t || IgxTreeNodeComponent)(i0.ɵɵdirectiveInject(IGX_TREE_COMPONENT), i0.ɵɵdirectiveInject(IgxTreeSelectionService), i0.ɵɵdirectiveInject(IgxTreeService), i0.ɵɵdirectiveInject(IgxTreeNavigationService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.AnimationBuilder), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(IGX_TREE_NODE_COMPONENT, 12));\n  };\n\n  IgxTreeNodeComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxTreeNodeComponent,\n    selectors: [[\"igx-tree-node\"]],\n    contentQueries: function IgxTreeNodeComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxTreeNodeLinkDirective, 4, ElementRef);\n        i0.ɵɵcontentQuery(dirIndex, IGX_TREE_NODE_COMPONENT, 4, IGX_TREE_NODE_COMPONENT);\n        i0.ɵɵcontentQuery(dirIndex, IGX_TREE_NODE_COMPONENT, 5, IGX_TREE_NODE_COMPONENT);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.linkChildren = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._children = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.allChildren = _t);\n      }\n    },\n    viewQuery: function IgxTreeNodeComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c111, 5, ElementRef);\n        i0.ɵɵviewQuery(_c52, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c112, 5, ElementRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.header = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._defaultExpandIndicatorTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.childrenContainer = _t.first);\n      }\n    },\n    hostVars: 5,\n    hostBindings: function IgxTreeNodeComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"igx-tree-node--disabled\", ctx.disabled)(\"igx-tree-node\", ctx.cssClass);\n      }\n    },\n    inputs: {\n      data: \"data\",\n      loading: \"loading\",\n      resourceStrings: \"resourceStrings\",\n      active: \"active\",\n      disabled: \"disabled\",\n      selected: \"selected\",\n      expanded: \"expanded\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\",\n      expandedChange: \"expandedChange\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IGX_TREE_NODE_COMPONENT,\n      useExisting: IgxTreeNodeComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c117,\n    decls: 12,\n    vars: 2,\n    consts: [[\"noDragTemplate\", \"\"], [4, \"ngTemplateOutlet\"], [\"class\", \"igx-tree-node__group\", \"role\", \"group\", 4, \"ngIf\"], [\"defaultIndicator\", \"\"], [\"selectMarkerTemplate\", \"\"], [\"headerTemplate\", \"\"], [\"dragTemplate\", \"\"], [\"role\", \"group\", 1, \"igx-tree-node__group\"], [\"childrenContainer\", \"\"], [3, \"checked\", \"readonly\", \"indeterminate\", \"tabindex\"], [1, \"igx-tree-node__wrapper\", 3, \"tabIndex\", \"ngClass\", \"pointerdown\", \"focus\", \"blur\"], [\"ghostTemplate\", \"\"], [\"aria-hidden\", \"true\"], [\"aria-hidden\", \"true\", \"class\", \"igx-tree-node__spacer\", 4, \"ngFor\", \"ngForOf\"], [\"class\", \"igx-tree-node__toggle-button\", 3, \"ngClass\", \"click\", 4, \"ngIf\"], [\"class\", \"igx-tree-node__toggle-button\", 4, \"ngIf\"], [\"class\", \"igx-tree-node__select\", 3, \"pointerdown\", \"click\", 4, \"ngIf\"], [1, \"igx-tree-node__content\"], [1, \"igx-tree-node__drop-indicator\"], [\"aria-hidden\", \"true\", 1, \"igx-tree-node__spacer\"], [1, \"igx-tree-node__toggle-button\", 3, \"ngClass\", \"click\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"igx-tree-node__toggle-button\"], [3, \"animate\", \"indeterminate\", \"textVisibility\"], [1, \"igx-tree-node__select\", 3, \"pointerdown\", \"click\"], [1, \"igx-tree-node__drag-wrapper\"]],\n    template: function IgxTreeNodeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c116);\n        i0.ɵɵtemplate(0, IgxTreeNodeComponent_ng_template_0_Template, 1, 1, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, IgxTreeNodeComponent_2_Template, 1, 0, null, 1);\n        i0.ɵɵtemplate(3, IgxTreeNodeComponent_div_3_Template, 3, 0, \"div\", 2);\n        i0.ɵɵtemplate(4, IgxTreeNodeComponent_ng_template_4_Template, 2, 2, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(6, IgxTreeNodeComponent_ng_template_6_Template, 1, 4, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(8, IgxTreeNodeComponent_ng_template_8_Template, 12, 17, \"ng-template\", null, 5, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(10, IgxTreeNodeComponent_ng_template_10_Template, 2, 1, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        const _r0 = i0.ɵɵreference(1);\n\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", _r0);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.expanded && !ctx.loading);\n      }\n    },\n    directives: [IgxIconComponent, IgxCheckboxComponent, IgxCircularProgressBarComponent, i4.NgTemplateOutlet, i4.NgIf, i4.NgClass, i4.NgForOf],\n    encapsulation: 2\n  });\n  return IgxTreeNodeComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden @internal\n * Used for templating the select marker of the tree\n */\n\n\nlet IgxTreeSelectMarkerDirective = /*#__PURE__*/(() => {\n  class IgxTreeSelectMarkerDirective {}\n\n  IgxTreeSelectMarkerDirective.ɵfac = function IgxTreeSelectMarkerDirective_Factory(t) {\n    return new (t || IgxTreeSelectMarkerDirective)();\n  };\n\n  IgxTreeSelectMarkerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxTreeSelectMarkerDirective,\n    selectors: [[\"\", \"igxTreeSelectMarker\", \"\"]]\n  });\n  return IgxTreeSelectMarkerDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden @internal\n * Used for templating the expand indicator of the tree\n */\n\n\nlet IgxTreeExpandIndicatorDirective = /*#__PURE__*/(() => {\n  class IgxTreeExpandIndicatorDirective {}\n\n  IgxTreeExpandIndicatorDirective.ɵfac = function IgxTreeExpandIndicatorDirective_Factory(t) {\n    return new (t || IgxTreeExpandIndicatorDirective)();\n  };\n\n  IgxTreeExpandIndicatorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxTreeExpandIndicatorDirective,\n    selectors: [[\"\", \"igxTreeExpandIndicator\", \"\"]]\n  });\n  return IgxTreeExpandIndicatorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxTreeComponent = /*#__PURE__*/(() => {\n  class IgxTreeComponent extends DisplayDensityBase {\n    constructor(navService, selectionService, treeService, element, _displayDensityOptions) {\n      super(_displayDensityOptions);\n      this.navService = navService;\n      this.selectionService = selectionService;\n      this.treeService = treeService;\n      this.element = element;\n      this._displayDensityOptions = _displayDensityOptions;\n      this.cssClass = 'igx-tree';\n      /** Get/Set how the tree should handle branch expansion.\n       * If set to `true`, only a single branch can be expanded at a time, collapsing all others\n       *\n       * ```html\n       * <igx-tree [singleBranchExpand]=\"true\">\n       * ...\n       * </igx-tree>\n       * ```\n       *\n       * ```typescript\n       * const tree: IgxTree = this.tree;\n       * this.tree.singleBranchExpand = false;\n       * ```\n       */\n\n      this.singleBranchExpand = false;\n      /** Get/Set the animation settings that branches should use when expanding/collpasing.\n       *\n       * ```html\n       * <igx-tree [animationSettings]=\"customAnimationSettings\">\n       * </igx-tree>\n       * ```\n       *\n       * ```typescript\n       * const animationSettings: ToggleAnimationSettings = {\n       *      openAnimation: growVerIn,\n       *      closeAnimation: growVerOut\n       * };\n       *\n       * this.tree.animationSettings = animationSettings;\n       * ```\n       */\n\n      this.animationSettings = {\n        openAnimation: growVerIn,\n        closeAnimation: growVerOut\n      };\n      /** Emitted when the node selection is changed through interaction\n       *\n       * ```html\n       * <igx-tree (nodeSelection)=\"handleNodeSelection($event)\">\n       * </igx-tree>\n       * ```\n       *\n       *```typescript\n       * public handleNodeSelection(event: ITreeNodeSelectionEvent) {\n       *  const newSelection: IgxTreeNode<any>[] = event.newSelection;\n       *  const added: IgxTreeNode<any>[] = event.added;\n       *  console.log(\"New selection will be: \", newSelection);\n       *  console.log(\"Added nodes: \", event.added);\n       * }\n       *```\n       */\n\n      this.nodeSelection = new EventEmitter();\n      /** Emitted when a node is expanding, before it finishes\n       *\n       * ```html\n       * <igx-tree (nodeExpanding)=\"handleNodeExpanding($event)\">\n       * </igx-tree>\n       * ```\n       *\n       *```typescript\n       * public handleNodeExpanding(event: ITreeNodeTogglingEventArgs) {\n       *  const expandedNode: IgxTreeNode<any> = event.node;\n       *  if (expandedNode.disabled) {\n       *      event.cancel = true;\n       *  }\n       * }\n       *```\n       */\n\n      this.nodeExpanding = new EventEmitter();\n      /** Emitted when a node is expanded, after it finishes\n       *\n       * ```html\n       * <igx-tree (nodeExpanded)=\"handleNodeExpanded($event)\">\n       * </igx-tree>\n       * ```\n       *\n       *```typescript\n       * public handleNodeExpanded(event: ITreeNodeToggledEventArgs) {\n       *  const expandedNode: IgxTreeNode<any> = event.node;\n       *  console.log(\"Node is expanded: \", expandedNode.data);\n       * }\n       *```\n       */\n\n      this.nodeExpanded = new EventEmitter();\n      /** Emitted when a node is collapsing, before it finishes\n       *\n       * ```html\n       * <igx-tree (nodeCollapsing)=\"handleNodeCollapsing($event)\">\n       * </igx-tree>\n       * ```\n       *\n       *```typescript\n       * public handleNodeCollapsing(event: ITreeNodeTogglingEventArgs) {\n       *  const collapsedNode: IgxTreeNode<any> = event.node;\n       *  if (collapsedNode.alwaysOpen) {\n       *      event.cancel = true;\n       *  }\n       * }\n       *```\n       */\n\n      this.nodeCollapsing = new EventEmitter();\n      /** Emitted when a node is collapsed, after it finishes\n       *\n       * @example\n       * ```html\n       * <igx-tree (nodeCollapsed)=\"handleNodeCollapsed($event)\">\n       * </igx-tree>\n       * ```\n       * ```typescript\n       * public handleNodeCollapsed(event: ITreeNodeToggledEventArgs) {\n       *  const collapsedNode: IgxTreeNode<any> = event.node;\n       *  console.log(\"Node is collapsed: \", collapsedNode.data);\n       * }\n       * ```\n       */\n\n      this.nodeCollapsed = new EventEmitter();\n      /**\n       * Emitted when the active node is changed.\n       *\n       * @example\n       * ```\n       * <igx-tree (activeNodeChanged)=\"activeNodeChanged($event)\"></igx-tree>\n       * ```\n       */\n\n      this.activeNodeChanged = new EventEmitter();\n      /** @hidden @internal */\n\n      this.disabledChange = new EventEmitter();\n      /**\n       * Emitted when the active node is set through API\n       *\n       * @hidden @internal\n       */\n\n      this.activeNodeBindingChange = new EventEmitter();\n      /** @hidden @internal */\n\n      this.forceSelect = [];\n      this._selection = IgxTreeSelectionType.None;\n      this.destroy$ = new Subject();\n      this.unsubChildren$ = new Subject();\n\n      this._comparer = (data, node) => node.data === data;\n\n      this.selectionService.register(this);\n      this.treeService.register(this);\n      this.navService.register(this);\n    }\n    /**\n     * Gets/Sets tree selection mode\n     *\n     * @remarks\n     * By default the tree selection mode is 'None'\n     * @param selectionMode: IgxTreeSelectionType\n     */\n\n\n    get selection() {\n      return this._selection;\n    }\n\n    set selection(selectionMode) {\n      this._selection = selectionMode;\n      this.selectionService.clearNodesSelection();\n    }\n    /**\n     * Returns all **root level** nodes\n     *\n     * ```typescript\n     * const tree: IgxTree = this.tree;\n     * const rootNodes: IgxTreeNodeComponent<any>[] = tree.rootNodes;\n     * ```\n     */\n\n\n    get rootNodes() {\n      var _a;\n\n      return (_a = this.nodes) === null || _a === void 0 ? void 0 : _a.filter(node => node.level === 0);\n    }\n    /** @hidden @internal */\n\n\n    get nativeElement() {\n      return this.element.nativeElement;\n    }\n    /**\n     * Expands all of the passed nodes.\n     * If no nodes are passed, expands ALL nodes\n     *\n     * @param nodes nodes to be expanded\n     *\n     * ```typescript\n     * const targetNodes: IgxTreeNode<any> = this.tree.findNodes(true, (_data: any, node: IgxTreeNode<any>) => node.data.expandable);\n     * tree.expandAll(nodes);\n     * ```\n     */\n\n\n    expandAll(nodes) {\n      nodes = nodes || this.nodes.toArray();\n      nodes.forEach(e => e.expanded = true);\n    }\n    /**\n     * Collapses all of the passed nodes.\n     * If no nodes are passed, collapses ALL nodes\n     *\n     * @param nodes nodes to be collapsed\n     *\n     * ```typescript\n     * const targetNodes: IgxTreeNode<any> = this.tree.findNodes(true, (_data: any, node: IgxTreeNode<any>) => node.data.collapsible);\n     * tree.collapseAll(nodes);\n     * ```\n     */\n\n\n    collapseAll(nodes) {\n      nodes = nodes || this.nodes.toArray();\n      nodes.forEach(e => e.expanded = false);\n    }\n    /**\n     * Deselect all nodes if the nodes collection is empty. Otherwise, deselect the nodes in the nodes collection.\n     *\n     * @example\n     * ```typescript\n     *  const arr = [\n     *      this.tree.nodes.toArray()[0],\n     *      this.tree.nodes.toArray()[1]\n     *  ];\n     *  this.tree.deselectAll(arr);\n     * ```\n     * @param nodes: IgxTreeNodeComponent<any>[]\n     */\n\n\n    deselectAll(nodes) {\n      this.selectionService.deselectNodesWithNoEvent(nodes);\n    }\n    /**\n     * Returns all of the nodes that match the passed searchTerm.\n     * Accepts a custom comparer function for evaluating the search term against the nodes.\n     *\n     * @remark\n     * Default search compares the passed `searchTerm` against the node's `data` Input.\n     * When using `findNodes` w/o a `comparer`, make sure all nodes have `data` passed.\n     *\n     * @param searchTerm The data of the searched node\n     * @param comparer A custom comparer function that evaluates the passed `searchTerm` against all nodes.\n     * @returns Array of nodes that match the search. `null` if no nodes are found.\n     *\n     * ```html\n     * <igx-tree>\n     *     <igx-tree-node *ngFor=\"let node of data\" [data]=\"node\">\n     *          {{ node.label }}\n     *     </igx-tree-node>\n     * </igx-tree>\n     * ```\n     *\n     * ```typescript\n     * public data: DataEntry[] = FETCHED_DATA;\n     * ...\n     * const matchedNodes: IgxTreeNode<DataEntry>[] = this.tree.findNodes<DataEntry>(searchTerm: data[5]);\n     * ```\n     *\n     * Using a custom comparer\n     * ```typescript\n     * public data: DataEntry[] = FETCHED_DATA;\n     * ...\n     * const comparer: IgxTreeSearchResolver = (data: any, node: IgxTreeNode<DataEntry>) {\n     *      return node.data.index % 2 === 0;\n     * }\n     * const evenIndexNodes: IgxTreeNode<DataEntry>[] = this.tree.findNodes<DataEntry>(null, comparer);\n     * ```\n     */\n\n\n    findNodes(searchTerm, comparer) {\n      const compareFunc = comparer || this._comparer;\n      const results = this.nodes.filter(node => compareFunc(searchTerm, node));\n      return (results === null || results === void 0 ? void 0 : results.length) === 0 ? null : results;\n    }\n    /** @hidden @internal */\n\n\n    handleKeydown(event) {\n      this.navService.handleKeydown(event);\n    }\n    /** @hidden @internal */\n\n\n    ngOnInit() {\n      super.ngOnInit();\n      this.disabledChange.pipe(takeUntil(this.destroy$)).subscribe(e => {\n        this.navService.update_disabled_cache(e);\n      });\n      this.activeNodeBindingChange.pipe(takeUntil(this.destroy$)).subscribe(node => {\n        var _a;\n\n        this.expandToNode(this.navService.activeNode);\n        this.scrollNodeIntoView((_a = node === null || node === void 0 ? void 0 : node.header) === null || _a === void 0 ? void 0 : _a.nativeElement);\n      });\n      this.onDensityChanged.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        requestAnimationFrame(() => {\n          var _a;\n\n          this.scrollNodeIntoView((_a = this.navService.activeNode) === null || _a === void 0 ? void 0 : _a.header.nativeElement);\n        });\n      });\n      this.subToCollapsing();\n    }\n    /** @hidden @internal */\n\n\n    ngAfterViewInit() {\n      var _a, _b;\n\n      this.nodes.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        this.subToChanges();\n      });\n      this.scrollNodeIntoView((_b = (_a = this.navService.activeNode) === null || _a === void 0 ? void 0 : _a.header) === null || _b === void 0 ? void 0 : _b.nativeElement);\n      this.subToChanges();\n    }\n    /** @hidden @internal */\n\n\n    ngOnDestroy() {\n      this.unsubChildren$.next();\n      this.unsubChildren$.complete();\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n\n    expandToNode(node) {\n      if (node && node.parentNode) {\n        node.path.forEach(n => {\n          if (n !== node && !n.expanded) {\n            n.expanded = true;\n          }\n        });\n      }\n    }\n\n    subToCollapsing() {\n      this.nodeCollapsing.pipe(takeUntil(this.destroy$)).subscribe(event => {\n        if (event.cancel) {\n          return;\n        }\n\n        this.navService.update_visible_cache(event.node, false);\n      });\n      this.nodeExpanding.pipe(takeUntil(this.destroy$)).subscribe(event => {\n        if (event.cancel) {\n          return;\n        }\n\n        this.navService.update_visible_cache(event.node, true);\n      });\n    }\n\n    subToChanges() {\n      this.unsubChildren$.next();\n      const toBeSelected = [...this.forceSelect];\n      requestAnimationFrame(() => {\n        this.selectionService.selectNodesWithNoEvent(toBeSelected);\n      });\n      this.forceSelect = [];\n      this.nodes.forEach(node => {\n        node.expandedChange.pipe(takeUntil(this.unsubChildren$)).subscribe(nodeState => {\n          this.navService.update_visible_cache(node, nodeState);\n        });\n        node.closeAnimationDone.pipe(takeUntil(this.unsubChildren$)).subscribe(() => {\n          var _a;\n\n          const targetElement = (_a = this.navService.focusedNode) === null || _a === void 0 ? void 0 : _a.header.nativeElement;\n          this.scrollNodeIntoView(targetElement);\n        });\n        node.openAnimationDone.pipe(takeUntil(this.unsubChildren$)).subscribe(() => {\n          var _a;\n\n          const targetElement = (_a = this.navService.focusedNode) === null || _a === void 0 ? void 0 : _a.header.nativeElement;\n          this.scrollNodeIntoView(targetElement);\n        });\n      });\n      this.navService.init_invisible_cache();\n    }\n\n    scrollNodeIntoView(el) {\n      if (!el) {\n        return;\n      }\n\n      const nodeRect = el.getBoundingClientRect();\n      const treeRect = this.nativeElement.getBoundingClientRect();\n      const topOffset = treeRect.top > nodeRect.top ? nodeRect.top - treeRect.top : 0;\n      const bottomOffset = treeRect.bottom < nodeRect.bottom ? nodeRect.bottom - treeRect.bottom : 0;\n      const shouldScroll = !!topOffset || !!bottomOffset;\n\n      if (shouldScroll && this.nativeElement.scrollHeight > this.nativeElement.clientHeight) {\n        // this.nativeElement.scrollTop = nodeRect.y - treeRect.y - nodeRect.height;\n        this.nativeElement.scrollTop = this.nativeElement.scrollTop + bottomOffset + topOffset + (topOffset ? -1 : +1) * nodeRect.height;\n      }\n    }\n\n  }\n\n  IgxTreeComponent.ɵfac = function IgxTreeComponent_Factory(t) {\n    return new (t || IgxTreeComponent)(i0.ɵɵdirectiveInject(IgxTreeNavigationService), i0.ɵɵdirectiveInject(IgxTreeSelectionService), i0.ɵɵdirectiveInject(IgxTreeService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DisplayDensityToken, 8));\n  };\n\n  IgxTreeComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxTreeComponent,\n    selectors: [[\"igx-tree\"]],\n    contentQueries: function IgxTreeComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxTreeExpandIndicatorDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxTreeNodeComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.expandIndicator = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nodes = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function IgxTreeComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-tree\", ctx.cssClass);\n      }\n    },\n    inputs: {\n      selection: \"selection\",\n      singleBranchExpand: \"singleBranchExpand\",\n      animationSettings: \"animationSettings\"\n    },\n    outputs: {\n      nodeSelection: \"nodeSelection\",\n      nodeExpanding: \"nodeExpanding\",\n      nodeExpanded: \"nodeExpanded\",\n      nodeCollapsing: \"nodeCollapsing\",\n      nodeCollapsed: \"nodeCollapsed\",\n      activeNodeChanged: \"activeNodeChanged\"\n    },\n    features: [i0.ɵɵProvidersFeature([IgxTreeService, IgxTreeSelectionService, IgxTreeNavigationService, {\n      provide: IGX_TREE_COMPONENT,\n      useExisting: IgxTreeComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c119,\n    decls: 2,\n    vars: 0,\n    consts: [[\"role\", \"tree\", 1, \"igx-tree__root\", 3, \"keydown\"]],\n    template: function IgxTreeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c118);\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵlistener(\"keydown\", function IgxTreeComponent_Template_div_keydown_0_listener($event) {\n          return ctx.handleKeydown($event);\n        });\n        i0.ɵɵprojection(1);\n        i0.ɵɵelementEnd();\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxTreeComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n *\n * NgModule defining the components and directives needed for `igx-tree`\n */\n\n\nlet IgxTreeModule = /*#__PURE__*/(() => {\n  class IgxTreeModule {}\n\n  IgxTreeModule.ɵfac = function IgxTreeModule_Factory(t) {\n    return new (t || IgxTreeModule)();\n  };\n\n  IgxTreeModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxTreeModule\n  });\n  IgxTreeModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, FormsModule, IgxIconModule, IgxInputGroupModule, IgxCheckboxModule, IgxProgressBarModule], IgxIconModule, IgxInputGroupModule, IgxCheckboxModule, IgxExpansionPanelModule]\n  });\n  return IgxTreeModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxExcelStyleLoadingValuesTemplateDirective = /*#__PURE__*/(() => {\n  class IgxExcelStyleLoadingValuesTemplateDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxExcelStyleLoadingValuesTemplateDirective.ɵfac = function IgxExcelStyleLoadingValuesTemplateDirective_Factory(t) {\n    return new (t || IgxExcelStyleLoadingValuesTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxExcelStyleLoadingValuesTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxExcelStyleLoadingValuesTemplateDirective,\n    selectors: [[\"\", \"igxExcelStyleLoading\", \"\"]]\n  });\n  return IgxExcelStyleLoadingValuesTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A component used for presenting Excel style search UI.\n */\n\n\nlet IgxExcelStyleSearchComponent = /*#__PURE__*/(() => {\n  class IgxExcelStyleSearchComponent {\n    constructor(cdr, esf, platform) {\n      this.cdr = cdr;\n      this.esf = esf;\n      this.platform = platform;\n      /**\n       * @hidden @internal\n       */\n\n      this.defaultClass = true;\n      /**\n       * @hidden @internal\n       */\n\n      this.displayedListData = [];\n      this.destroy$ = new Subject();\n      /**\n       * @hidden @internal\n       */\n\n      this.refreshSize = () => {\n        if (this.virtDir) {\n          this.virtDir.igxForContainerSize = this.containerSize;\n          this.virtDir.igxForItemSize = this.itemSize;\n          this.virtDir.recalcUpdateSizes();\n          this.cdr.detectChanges();\n        }\n      };\n\n      esf.loadingStart.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        this.displayedListData = [];\n        this.isLoading = true;\n      });\n      esf.loadingEnd.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        this.refreshSize();\n        this.isLoading = false;\n      });\n      esf.initialized.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        requestAnimationFrame(() => {\n          this.refreshSize();\n          this.searchInput.nativeElement.focus();\n        });\n      });\n      esf.columnChange.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        var _a;\n\n        (_a = this.virtDir) === null || _a === void 0 ? void 0 : _a.resetScrollPosition();\n      });\n      esf.listDataLoaded.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        this._selectAllItem = this.esf.listData[0];\n\n        if (this.isHierarchical() && this.esf.listData[0].isSpecial) {\n          this.esf.listData.splice(0, 1);\n        }\n\n        if (this.searchValue) {\n          this.clearInput();\n        } else {\n          this.filterListData();\n        }\n\n        this.cdr.detectChanges();\n        requestAnimationFrame(() => {\n          this.refreshSize();\n          this.searchInput.nativeElement.focus();\n        });\n      });\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get selectAllItem() {\n      if (!this._selectAllItem) {\n        const selectAllItem = {\n          isSelected: false,\n          isFiltered: false,\n          indeterminate: false,\n          isSpecial: true,\n          isBlanks: false,\n          value: this.esf.grid.resourceStrings.igx_grid_excel_select_all,\n          label: this.esf.grid.resourceStrings.igx_grid_excel_select_all\n        };\n        this._selectAllItem = selectAllItem;\n      }\n\n      return this._selectAllItem;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get addToCurrentFilterItem() {\n      if (!this._addToCurrentFilterItem) {\n        const addToCurrentFilterItem = {\n          isSelected: false,\n          isFiltered: false,\n          indeterminate: false,\n          isSpecial: true,\n          isBlanks: false,\n          value: this.esf.grid.resourceStrings.igx_grid_excel_add_to_filter,\n          label: this.esf.grid.resourceStrings.igx_grid_excel_add_to_filter\n        };\n        this._addToCurrentFilterItem = addToCurrentFilterItem;\n      }\n\n      return this._addToCurrentFilterItem;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get isLoading() {\n      return this._isLoading;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    set isLoading(value) {\n      this._isLoading = value;\n\n      if (!this.cdr.destroyed) {\n        this.cdr.detectChanges();\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get valuesLoadingTemplate() {\n      var _a;\n\n      if ((_a = this.esf.grid) === null || _a === void 0 ? void 0 : _a.excelStyleLoadingValuesTemplateDirective) {\n        return this.esf.grid.excelStyleLoadingValuesTemplateDirective.template;\n      } else {\n        return this.defaultExcelStyleLoadingValuesTemplate;\n      }\n    }\n\n    ngAfterViewInit() {\n      requestAnimationFrame(this.refreshSize);\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next(true);\n      this.destroy$.complete();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    clearInput() {\n      this.searchValue = null;\n      this.filterListData();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onCheckboxChange(eventArgs) {\n      const selectedIndex = this.displayedListData.indexOf(eventArgs.checkbox.value);\n      const selectAllBtn = this.displayedListData[0];\n\n      if (selectedIndex === 0) {\n        this.displayedListData.forEach(element => {\n          if (element === this.addToCurrentFilterItem) {\n            return;\n          }\n\n          element.isSelected = eventArgs.checked;\n        });\n        selectAllBtn.indeterminate = false;\n      } else {\n        eventArgs.checkbox.value.isSelected = eventArgs.checked;\n        const indexToStartSlicing = this.displayedListData.indexOf(this.addToCurrentFilterItem) > -1 ? 2 : 1;\n        const slicedArray = this.displayedListData.slice(indexToStartSlicing, this.displayedListData.length);\n\n        if (!slicedArray.find(el => el.isSelected === false)) {\n          selectAllBtn.indeterminate = false;\n          selectAllBtn.isSelected = true;\n        } else if (!slicedArray.find(el => el.isSelected === true)) {\n          selectAllBtn.indeterminate = false;\n          selectAllBtn.isSelected = false;\n        } else {\n          selectAllBtn.indeterminate = true;\n        }\n      }\n\n      eventArgs.checkbox.nativeCheckbox.nativeElement.blur();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onSelectAllCheckboxChange(eventArgs) {\n      this._selectAllItem.isSelected = eventArgs.checked;\n      this._selectAllItem.indeterminate = false;\n      const treeNodes = this.tree.nodes;\n      treeNodes.forEach(node => node.data.isSelected = eventArgs.checked);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onNodeSelectionChange(eventArgs) {\n      eventArgs.added.forEach(node => {\n        node.data.isSelected = true;\n      });\n      eventArgs.removed.forEach(node => {\n        node.data.isSelected = false;\n      });\n      this._hierarchicalSelectedItems = eventArgs.newSelection.map(item => item.data);\n      const selectAllBtn = this.selectAllItem;\n\n      if (this._hierarchicalSelectedItems.length === 0) {\n        selectAllBtn.indeterminate = false;\n        selectAllBtn.isSelected = false;\n      } else if (this._hierarchicalSelectedItems.length === this.tree.nodes.length) {\n        selectAllBtn.indeterminate = false;\n        selectAllBtn.isSelected = true;\n      } else {\n        selectAllBtn.indeterminate = true;\n        selectAllBtn.isSelected = false;\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get itemSize() {\n      let itemSize = '40px';\n\n      switch (this.esf.displayDensity) {\n        case DisplayDensity.cosy:\n          itemSize = '32px';\n          break;\n\n        case DisplayDensity.compact:\n          itemSize = '24px';\n          break;\n\n        default:\n          break;\n      }\n\n      return itemSize;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get containerSize() {\n      var _a;\n\n      if (this.esf.listData.length) {\n        return (_a = this.list) === null || _a === void 0 ? void 0 : _a.element.nativeElement.offsetHeight;\n      } // GE Nov 1st, 2021 #10355 Return a numeric value, so the chunk size is calculated properly.\n      // If we skip this branch, on applying the filter the _calculateChunkSize() method off the ForOfDirective receives\n      // an igxForContainerSize = undefined, thus assigns the chunkSize to the igxForOf.length which leads to performance issues.\n\n\n      return 0;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get applyButtonDisabled() {\n      return this._selectAllItem && !this._selectAllItem.isSelected && !this._selectAllItem.indeterminate || this.displayedListData && this.displayedListData.length === 0;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onInputKeyDown(event) {\n      switch (event.key) {\n        case this.platform.KEYMAP.ENTER:\n          event.preventDefault();\n          this.applyFilter();\n          return;\n\n        case this.platform.KEYMAP.ESCAPE:\n          if (this.searchValue) {\n            event.stopPropagation();\n            this.clearInput();\n          }\n\n          return;\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    filterListData() {\n      var _a, _b, _c;\n\n      if (((_a = this.esf.column) === null || _a === void 0 ? void 0 : _a.dataType) === GridColumnDataType.Number || ((_b = this.esf.column) === null || _b === void 0 ? void 0 : _b.dataType) === GridColumnDataType.Currency || ((_c = this.esf.column) === null || _c === void 0 ? void 0 : _c.dataType) === GridColumnDataType.Percent) {\n        this.rejectNonNumericalEntries();\n      }\n\n      if (!this.esf.listData || !this.esf.listData.length) {\n        this.displayedListData = [];\n        return;\n      }\n\n      let selectAllBtn;\n\n      if (this._selectAllItem) {\n        selectAllBtn = this._selectAllItem;\n      } else {\n        selectAllBtn = this.esf.listData[0];\n      }\n\n      if (!this.searchValue) {\n        let anyFiltered = this.esf.listData.some(i => i.isFiltered);\n        let anyUnfiltered = this.esf.listData.some(i => !i.isFiltered);\n        selectAllBtn.indeterminate = anyFiltered && anyUnfiltered;\n\n        if (this.isHierarchical() && this.tree) {\n          this._hierarchicalSelectedItems = this.tree.nodes.map(n => n.data).filter(item => item.isFiltered);\n        }\n\n        this.esf.listData.forEach(i => i.isSelected = i.isFiltered);\n\n        if (this.displayedListData !== this.esf.listData) {\n          this.displayedListData = this.esf.listData;\n\n          if (this.isHierarchical()) {\n            this.cdr.detectChanges();\n            this.tree.nodes.forEach(n => {\n              const item = n.data;\n              n.selected = item.isSelected || item.isFiltered;\n              anyFiltered = anyFiltered || n.selected;\n              anyUnfiltered = anyUnfiltered || !n.selected;\n            });\n            selectAllBtn.indeterminate = anyFiltered && anyUnfiltered;\n          }\n        }\n\n        selectAllBtn.label = this.esf.grid.resourceStrings.igx_grid_excel_select_all;\n        this.cdr.detectChanges();\n        return;\n      }\n\n      const searchVal = this.searchValue.toLowerCase();\n\n      if (this.isHierarchical()) {\n        this._hierarchicalSelectedItems = [];\n        this.esf.listData.forEach(i => i.isSelected = false);\n        const matchedData = cloneHierarchicalArray(this.esf.listData, 'children');\n        this.displayedListData = this.hierarchicalSelectMatches(matchedData, searchVal);\n        this.cdr.detectChanges();\n        this.tree.nodes.forEach(n => {\n          n.selected = true;\n\n          if (n.data.label.toString().toLowerCase().indexOf(searchVal) > -1) {\n            this.expandAllParentNodes(n);\n          }\n        });\n      } else {\n        this.displayedListData = this.esf.listData.filter((it, i) => i === 0 && it.isSpecial || it.label !== null && it.label !== undefined && !it.isBlanks && it.label.toString().toLowerCase().indexOf(searchVal) > -1);\n        this.esf.listData.forEach(i => i.isSelected = false);\n        this.displayedListData.forEach(i => i.isSelected = true);\n        this.displayedListData.splice(1, 0, this.addToCurrentFilterItem);\n\n        if (this.displayedListData.length === 2) {\n          this.displayedListData = [];\n        }\n      }\n\n      selectAllBtn.indeterminate = false;\n      selectAllBtn.isSelected = true;\n      selectAllBtn.label = this.esf.grid.resourceStrings.igx_grid_excel_select_all_search_results;\n      this.cdr.detectChanges();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    applyFilter() {\n      const filterTree = new FilteringExpressionsTree(FilteringLogic.Or, this.esf.column.field);\n      let selectedItems = [];\n\n      if (this.isHierarchical()) {\n        if (this.addToCurrentFilterCheckbox && this.addToCurrentFilterCheckbox.checked) {\n          this.addFilteredToSelectedItems(this.esf.listData);\n        }\n\n        selectedItems = this._hierarchicalSelectedItems;\n      } else {\n        const item = this.displayedListData[1];\n        const addToCurrentFilterOptionVisible = item === this.addToCurrentFilterItem;\n        selectedItems = addToCurrentFilterOptionVisible && item.isSelected ? this.esf.listData.slice(1, this.esf.listData.length).filter(el => el.isSelected || el.isFiltered) : this.esf.listData.slice(1, this.esf.listData.length).filter(el => el.isSelected);\n      }\n\n      let unselectedItem;\n\n      if (this.isHierarchical()) {\n        unselectedItem = this.esf.listData.find(el => el.isSelected === false);\n      } else {\n        unselectedItem = this.esf.listData.slice(1, this.esf.listData.length).find(el => el.isSelected === false);\n      }\n\n      if (unselectedItem) {\n        if (selectedItems.length <= IgxExcelStyleSearchComponent.filterOptimizationThreshold) {\n          selectedItems.forEach(element => {\n            let condition = null;\n\n            if (element.value !== null && element.value !== undefined) {\n              if (this.esf.column.dataType === GridColumnDataType.Boolean) {\n                condition = this.createCondition(element.value.toString());\n              } else {\n                const filterCondition = this.esf.column.dataType === GridColumnDataType.Time ? 'at' : 'equals';\n                condition = this.createCondition(filterCondition);\n              }\n            } else {\n              condition = this.createCondition('empty');\n            }\n\n            filterTree.filteringOperands.push({\n              condition,\n              fieldName: this.esf.column.field,\n              ignoreCase: this.esf.column.filteringIgnoreCase,\n              searchVal: element.value\n            });\n          });\n        } else {\n          const blanksItemIndex = selectedItems.findIndex(e => e.value === null || e.value === undefined);\n          let blanksItem;\n\n          if (blanksItemIndex >= 0) {\n            blanksItem = selectedItems[blanksItemIndex];\n            selectedItems.splice(blanksItemIndex, 1);\n          }\n\n          filterTree.filteringOperands.push({\n            condition: this.createCondition('in'),\n            fieldName: this.esf.column.field,\n            ignoreCase: this.esf.column.filteringIgnoreCase,\n            searchVal: new Set(this.esf.column.dataType === GridColumnDataType.Date || this.esf.column.dataType === GridColumnDataType.DateTime ? selectedItems.map(d => d.value.toISOString()) : this.esf.column.dataType === GridColumnDataType.Time ? selectedItems.map(e => e.value.toLocaleTimeString()) : selectedItems.map(e => e.value))\n          });\n\n          if (blanksItem) {\n            filterTree.filteringOperands.push({\n              condition: this.createCondition('empty'),\n              fieldName: this.esf.column.field,\n              ignoreCase: this.esf.column.filteringIgnoreCase,\n              searchVal: blanksItem.value\n            });\n          }\n        }\n\n        const grid = this.esf.grid;\n        const col = this.esf.column;\n        grid.filteringService.filterInternal(col.field, filterTree);\n        this.esf.expressionsList = new Array();\n        grid.filteringService.generateExpressionsList(col.filteringExpressionsTree, grid.filteringLogic, this.esf.expressionsList);\n      } else {\n        this.esf.grid.filteringService.clearFilter(this.esf.column.field);\n      }\n\n      this.esf.closeDropdown();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    isHierarchical() {\n      return this.esf.isHierarchical;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    isTreeEmpty() {\n      return this.esf.isHierarchical && this.displayedListData.length === 0;\n    }\n\n    hierarchicalSelectMatches(data, searchVal) {\n      data.forEach(element => {\n        element.indeterminate = false;\n        element.isSelected = false;\n        const node = this.tree.nodes.filter(n => n.data.label === element.label)[0];\n\n        if (node) {\n          node.expanded = false;\n        }\n\n        if (element.label.toString().toLowerCase().indexOf(searchVal) > -1) {\n          element.isSelected = true;\n          this.hierarchicalSelectAllChildren(element);\n\n          this._hierarchicalSelectedItems.push(element);\n        } else if (element.children.length > 0) {\n          element.children = this.hierarchicalSelectMatches(element.children, searchVal);\n\n          if (element.children.length > 0) {\n            element.isSelected = true;\n\n            if (node) {\n              node.expanded = true;\n            }\n          }\n        }\n      });\n      return data.filter(element => element.isSelected === true);\n    }\n\n    hierarchicalSelectAllChildren(element) {\n      element.children.forEach(child => {\n        child.indeterminate = false;\n        child.isSelected = true;\n\n        this._hierarchicalSelectedItems.push(child);\n\n        if (child.children) {\n          this.hierarchicalSelectAllChildren(child);\n        }\n      });\n    }\n\n    expandAllParentNodes(node) {\n      if (node.parentNode) {\n        node.parentNode.expanded = true;\n        this.expandAllParentNodes(node.parentNode);\n      }\n    }\n\n    addFilteredToSelectedItems(records) {\n      records.forEach(record => {\n        if (record.children) {\n          this.addFilteredToSelectedItems(record.children);\n        }\n\n        if (record.isFiltered && this._hierarchicalSelectedItems.indexOf(record) < 0) {\n          this._hierarchicalSelectedItems.push(record);\n        }\n      });\n    }\n\n    createCondition(conditionName) {\n      switch (this.esf.column.dataType) {\n        case GridColumnDataType.Boolean:\n          return IgxBooleanFilteringOperand.instance().condition(conditionName);\n\n        case GridColumnDataType.Number:\n        case GridColumnDataType.Currency:\n        case GridColumnDataType.Percent:\n          return IgxNumberFilteringOperand.instance().condition(conditionName);\n\n        case GridColumnDataType.Date:\n          return IgxDateFilteringOperand.instance().condition(conditionName);\n\n        case GridColumnDataType.Time:\n          return IgxTimeFilteringOperand.instance().condition(conditionName);\n\n        case GridColumnDataType.DateTime:\n          return IgxDateTimeFilteringOperand.instance().condition(conditionName);\n\n        default:\n          return IgxStringFilteringOperand.instance().condition(conditionName);\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    rejectNonNumericalEntries() {\n      const regExp = /[^0-9\\.,eE\\-]/g;\n\n      if (this.searchValue && regExp.test(this.searchValue)) {\n        this.searchInput.value = this.searchValue.replace(regExp, '');\n        this.searchValue = this.searchInput.value;\n      }\n    }\n\n  }\n\n  IgxExcelStyleSearchComponent.filterOptimizationThreshold = 2;\n\n  IgxExcelStyleSearchComponent.ɵfac = function IgxExcelStyleSearchComponent_Factory(t) {\n    return new (t || IgxExcelStyleSearchComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(BaseFilteringComponent), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxExcelStyleSearchComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxExcelStyleSearchComponent,\n    selectors: [[\"igx-excel-style-search\"]],\n    viewQuery: function IgxExcelStyleSearchComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c78, 7, IgxInputDirective);\n        i0.ɵɵviewQuery(_c120, 5, IgxListComponent);\n        i0.ɵɵviewQuery(_c121, 5, IgxCheckboxComponent);\n        i0.ɵɵviewQuery(_c122, 5, IgxCheckboxComponent);\n        i0.ɵɵviewQuery(_c123, 5, IgxTreeComponent);\n        i0.ɵɵviewQuery(IgxForOfDirective, 7);\n        i0.ɵɵviewQuery(_c124, 5, TemplateRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.searchInput = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.list = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.selectAllCheckbox = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.addToCurrentFilterCheckbox = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tree = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.virtDir = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultExcelStyleLoadingValuesTemplate = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function IgxExcelStyleSearchComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-excel-filter__menu-main\", ctx.defaultClass);\n      }\n    },\n    decls: 19,\n    vars: 11,\n    consts: [[\"type\", \"box\", 3, \"displayDensity\"], [\"igxPrefix\", \"\"], [\"igxInput\", \"\", \"tabindex\", \"0\", \"autocomplete\", \"off\", 3, \"ngModel\", \"placeholder\", \"ngModelChange\", \"keydown\"], [\"input\", \"\"], [\"igxSuffix\", \"\", \"tabindex\", \"0\", 3, \"click\", 4, \"ngIf\"], [3, \"displayDensity\", \"isLoading\", 4, \"ngIf\"], [\"class\", \"igx-excel-filter__tree\", 4, \"ngIf\"], [\"emptySearch\", \"\"], [\"defaultExcelStyleLoadingValuesTemplate\", \"\"], [1, \"igx-excel-filter__menu-footer\"], [1, \"igx-excel-filter__cancel\"], [\"igxButton\", \"flat\", 3, \"displayDensity\", \"click\"], [1, \"igx-excel-filter__apply\"], [\"igxButton\", \"raised\", 3, \"displayDensity\", \"disabled\", \"click\"], [\"igxSuffix\", \"\", \"tabindex\", \"0\", 3, \"click\"], [3, \"displayDensity\", \"isLoading\"], [\"list\", \"\"], [2, \"overflow\", \"hidden\", \"position\", \"relative\"], [4, \"igxFor\", \"igxForOf\", \"igxForScrollOrientation\", \"igxForContainerSize\", \"igxForItemSize\"], [\"igxDataLoading\", \"\"], [\"igxEmptyList\", \"\"], [3, \"value\", \"tabindex\", \"checked\", \"disableRipple\", \"indeterminate\", \"disableTransitions\", \"change\"], [1, \"igx-excel-filter__loading\"], [4, \"ngTemplateOutlet\"], [1, \"igx-excel-filter__tree\"], [\"class\", \"igx-excel-filter__tree-alike\", 4, \"ngIf\"], [\"selection\", \"Cascading\", 3, \"displayDensity\", \"nodeSelection\"], [\"tree\", \"\"], [3, \"data\", \"selected\", 4, \"ngFor\", \"ngForOf\"], [3, \"ngIf\"], [1, \"igx-excel-filter__tree-alike\"], [1, \"igx-excel-filter__tree-alike-item\"], [3, \"value\", \"checked\", \"disableRipple\", \"indeterminate\", \"disableTransitions\", \"change\"], [\"selectAllCheckbox\", \"\"], [\"class\", \"igx-excel-filter__tree-alike-item\", 4, \"ngIf\"], [3, \"value\", \"checked\", \"disableRipple\", \"disableTransitions\"], [\"addToCurrentFilterCheckbox\", \"\"], [3, \"data\", \"selected\"], [1, \"igx-excel-filter__empty\"], [3, \"indeterminate\"]],\n    template: function IgxExcelStyleSearchComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"igx-input-group\", 0)(1, \"igx-icon\", 1);\n        i0.ɵɵtext(2, \"search\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"input\", 2, 3);\n        i0.ɵɵlistener(\"ngModelChange\", function IgxExcelStyleSearchComponent_Template_input_ngModelChange_3_listener($event) {\n          return ctx.searchValue = $event;\n        })(\"ngModelChange\", function IgxExcelStyleSearchComponent_Template_input_ngModelChange_3_listener() {\n          return ctx.filterListData();\n        })(\"keydown\", function IgxExcelStyleSearchComponent_Template_input_keydown_3_listener($event) {\n          return ctx.onInputKeyDown($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(5, IgxExcelStyleSearchComponent_igx_icon_5_Template, 2, 0, \"igx-icon\", 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(6, IgxExcelStyleSearchComponent_igx_list_6_Template, 6, 6, \"igx-list\", 5);\n        i0.ɵɵtemplate(7, IgxExcelStyleSearchComponent_div_7_Template, 7, 4, \"div\", 6);\n        i0.ɵɵtemplate(8, IgxExcelStyleSearchComponent_ng_template_8_Template, 2, 1, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(10, IgxExcelStyleSearchComponent_ng_template_10_Template, 1, 1, \"ng-template\", null, 8, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementStart(12, \"footer\", 9)(13, \"div\", 10)(14, \"button\", 11);\n        i0.ɵɵlistener(\"click\", function IgxExcelStyleSearchComponent_Template_button_click_14_listener() {\n          return ctx.esf.cancel();\n        });\n        i0.ɵɵtext(15);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(16, \"div\", 12)(17, \"button\", 13);\n        i0.ɵɵlistener(\"click\", function IgxExcelStyleSearchComponent_Template_button_click_17_listener() {\n          return ctx.applyFilter();\n        });\n        i0.ɵɵtext(18);\n        i0.ɵɵelementEnd()()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"displayDensity\", ctx.esf.displayDensity);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngModel\", ctx.searchValue)(\"placeholder\", ctx.esf.column == null ? null : ctx.esf.column.grid.resourceStrings.igx_grid_excel_search_placeholder);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.searchValue || ctx.searchValue === 0);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.isHierarchical());\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isHierarchical());\n        i0.ɵɵadvance(7);\n        i0.ɵɵproperty(\"displayDensity\", ctx.esf.displayDensity);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate1(\" \", ctx.esf.grid == null ? null : ctx.esf.grid.resourceStrings.igx_grid_excel_cancel, \" \");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"displayDensity\", ctx.esf.displayDensity)(\"disabled\", ctx.applyButtonDisabled);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate1(\" \", ctx.esf.grid == null ? null : ctx.esf.grid.resourceStrings.igx_grid_excel_apply, \" \");\n      }\n    },\n    directives: [IgxInputGroupComponent, IgxIconComponent, IgxListComponent, IgxListItemComponent, IgxCheckboxComponent, IgxTreeComponent, IgxTreeNodeComponent, IgxCircularProgressBarComponent, IgxPrefixDirective, i12.DefaultValueAccessor, IgxInputDirective, i12.NgControlStatus, i12.NgModel, i4.NgIf, IgxSuffixDirective, IgxForOfDirective, IgxDataLoadingTemplateDirective, i4.NgTemplateOutlet, IgxEmptyListTemplateDirective, i4.NgForOf, IgxButtonDirective],\n    encapsulation: 2\n  });\n  return IgxExcelStyleSearchComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A component used for presenting Excel style conditional filter UI.\n */\n\n\nlet IgxExcelStyleSelectingComponent = /*#__PURE__*/(() => {\n  class IgxExcelStyleSelectingComponent {\n    constructor(esf) {\n      this.esf = esf;\n    }\n\n  }\n\n  IgxExcelStyleSelectingComponent.ɵfac = function IgxExcelStyleSelectingComponent_Factory(t) {\n    return new (t || IgxExcelStyleSelectingComponent)(i0.ɵɵdirectiveInject(BaseFilteringComponent));\n  };\n\n  IgxExcelStyleSelectingComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxExcelStyleSelectingComponent,\n    selectors: [[\"igx-excel-style-selecting\"]],\n    decls: 1,\n    vars: 1,\n    consts: [[\"tabindex\", \"0\", \"role\", \"button\", 3, \"ngClass\", \"click\", 4, \"ngIf\"], [\"tabindex\", \"0\", \"role\", \"button\", 3, \"ngClass\", \"click\"]],\n    template: function IgxExcelStyleSelectingComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxExcelStyleSelectingComponent_div_0_Template, 5, 3, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.esf.column);\n      }\n    },\n    directives: [IgxIconComponent, i4.NgIf, i4.NgClass],\n    encapsulation: 2\n  });\n  return IgxExcelStyleSelectingComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A component used for presenting Excel style column sorting UI.\n */\n\n\nlet IgxExcelStyleSortingComponent = /*#__PURE__*/(() => {\n  class IgxExcelStyleSortingComponent {\n    constructor(esf, cdr) {\n      this.esf = esf;\n      this.cdr = cdr;\n      /**\n       * @hidden @internal\n       */\n\n      this.defaultClass = true;\n      this.destroy$ = new Subject();\n      this.esf.sortingChanged.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        this.updateSelectedButtons(this.esf.column.field);\n      });\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next(true);\n      this.destroy$.complete();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onSortButtonClicked(sortDirection) {\n      if (this.sortButtonGroup.selectedIndexes.length === 0) {\n        if (this.esf.grid.isColumnGrouped(this.esf.column.field)) {\n          this.sortButtonGroup.selectButton(sortDirection - 1);\n        } else {\n          this.esf.grid.clearSort(this.esf.column.field);\n        }\n      } else {\n        this.esf.grid.sort({\n          fieldName: this.esf.column.field,\n          dir: sortDirection,\n          ignoreCase: true\n        });\n      }\n    }\n\n    updateSelectedButtons(fieldName) {\n      const sortIndex = this.esf.grid.sortingExpressions.findIndex(s => s.fieldName === fieldName);\n      this.cdr.detectChanges();\n      this.sortButtonGroup.buttons.forEach((b, i) => {\n        this.sortButtonGroup.deselectButton(i);\n      });\n\n      if (sortIndex !== -1) {\n        const sortDirection = this.esf.grid.sortingExpressions[sortIndex].dir;\n        this.sortButtonGroup.selectButton(sortDirection - 1);\n      }\n    }\n\n  }\n\n  IgxExcelStyleSortingComponent.ɵfac = function IgxExcelStyleSortingComponent_Factory(t) {\n    return new (t || IgxExcelStyleSortingComponent)(i0.ɵɵdirectiveInject(BaseFilteringComponent), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  IgxExcelStyleSortingComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxExcelStyleSortingComponent,\n    selectors: [[\"igx-excel-style-sorting\"]],\n    viewQuery: function IgxExcelStyleSortingComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c125, 5, IgxButtonGroupComponent);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.sortButtonGroup = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function IgxExcelStyleSortingComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-excel-filter__sort\", ctx.defaultClass);\n      }\n    },\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngIf\"], [3, \"multiSelection\"], [\"sortButtonGroup\", \"\"], [\"igxButton\", \"\", 3, \"displayDensity\", \"click\"]],\n    template: function IgxExcelStyleSortingComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxExcelStyleSortingComponent_ng_container_0_Template, 15, 8, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.esf.column);\n      }\n    },\n    directives: [IgxButtonGroupComponent, IgxIconComponent, i4.NgIf, IgxButtonDirective],\n    encapsulation: 2\n  });\n  return IgxExcelStyleSortingComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxExcelStyleColumnOperationsTemplateDirective = /*#__PURE__*/(() => {\n  class IgxExcelStyleColumnOperationsTemplateDirective {}\n\n  IgxExcelStyleColumnOperationsTemplateDirective.ɵfac = function IgxExcelStyleColumnOperationsTemplateDirective_Factory(t) {\n    return new (t || IgxExcelStyleColumnOperationsTemplateDirective)();\n  };\n\n  IgxExcelStyleColumnOperationsTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxExcelStyleColumnOperationsTemplateDirective,\n    selectors: [[\"igx-excel-style-column-operations\"], [\"\", \"igxExcelStyleColumnOperations\", \"\"]]\n  });\n  return IgxExcelStyleColumnOperationsTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxExcelStyleFilterOperationsTemplateDirective = /*#__PURE__*/(() => {\n  class IgxExcelStyleFilterOperationsTemplateDirective {}\n\n  IgxExcelStyleFilterOperationsTemplateDirective.ɵfac = function IgxExcelStyleFilterOperationsTemplateDirective_Factory(t) {\n    return new (t || IgxExcelStyleFilterOperationsTemplateDirective)();\n  };\n\n  IgxExcelStyleFilterOperationsTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxExcelStyleFilterOperationsTemplateDirective,\n    selectors: [[\"igx-excel-style-filter-operations\"], [\"\", \"igxExcelStyleFilterOperations\", \"\"]]\n  });\n  return IgxExcelStyleFilterOperationsTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A component used for presenting Excel style filtering UI for a specific column.\n * It is used internally in the Grid, but could also be hosted in a container outside of it.\n *\n * Example:\n * ```html\n * <igx-grid-excel-style-filtering\n *     [column]=\"grid1.columns[0]\">\n * </igx-grid-excel-style-filtering>\n * ```\n */\n\n\nlet IgxGridExcelStyleFilteringComponent = /*#__PURE__*/(() => {\n  class IgxGridExcelStyleFilteringComponent extends BaseFilteringComponent {\n    constructor(cdr, element, platform, gridAPI) {\n      super(cdr, element, platform);\n      this.cdr = cdr;\n      this.element = element;\n      this.platform = platform;\n      this.gridAPI = gridAPI;\n      /**\n       * @hidden @internal\n       */\n\n      this.defaultClass = true;\n      /**\n       * @hidden @internal\n       */\n\n      this.inline = true;\n      /**\n       * @hidden @internal\n       */\n\n      this.loadingStart = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.loadingEnd = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.initialized = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.sortingChanged = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.columnChange = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.listDataLoaded = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.expressionsList = new Array();\n      /**\n       * @hidden @internal\n       */\n\n      this.listData = new Array();\n      /**\n       * @hidden @internal\n       */\n\n      this.uniqueValues = [];\n      /**\n       * @hidden @internal\n       */\n\n      this.isHierarchical = false;\n      this.containsNullOrEmpty = false;\n      this.selectAllSelected = true;\n      this.selectAllIndeterminate = false;\n      this.filterValues = new Set();\n    }\n    /**\n     * An @Input property that sets the column.\n     */\n\n\n    set column(value) {\n      var _a;\n\n      this._column = value;\n      this.listData = new Array();\n      this.columnChange.emit(this._column);\n      (_a = this.subscriptions) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n\n      if (this._column) {\n        this.grid.filteringService.registerSVGIcons();\n        this.init();\n        this.sortingChanged.emit();\n        this.subscriptions = this.grid.columnPin.subscribe(() => {\n          requestAnimationFrame(() => {\n            if (!this.cdr.destroyed) {\n              this.cdr.detectChanges();\n            }\n          });\n        });\n        this.subscriptions.add(this.grid.columnVisibilityChanged.subscribe(() => this.detectChanges()));\n        this.subscriptions.add(this.grid.sortingExpressionsChange.subscribe(() => this.sortingChanged.emit()));\n        this.subscriptions.add(this.grid.filteringExpressionsTreeChange.subscribe(() => this.init()));\n        this.subscriptions.add(this.grid.onDensityChanged.subscribe(() => this.detectChanges()));\n        this.subscriptions.add(this.grid.columnMovingEnd.subscribe(() => this.cdr.markForCheck()));\n      }\n    }\n    /**\n     * Returns the current column.\n     */\n\n\n    get column() {\n      return this._column;\n    }\n    /**\n     * Gets the minimum height.\n     */\n\n\n    get minHeight() {\n      if (this._minHeight || this._minHeight === 0) {\n        return this._minHeight;\n      }\n\n      if (!this.inline) {\n        let minHeight = 645;\n\n        switch (this.displayDensity) {\n          case DisplayDensity.cosy:\n            minHeight = 465;\n            break;\n\n          case DisplayDensity.compact:\n            minHeight = 330;\n            break;\n\n          default:\n            break;\n        }\n\n        return `${minHeight}px`;\n      }\n    }\n    /**\n     * Sets the minimum height.\n     */\n\n\n    set minHeight(value) {\n      this._minHeight = value;\n    }\n    /**\n     * Gets the maximum height.\n     */\n\n\n    get maxHeight() {\n      if (this._maxHeight) {\n        return this._maxHeight;\n      }\n\n      if (!this.inline) {\n        let maxHeight = 775;\n\n        switch (this.displayDensity) {\n          case DisplayDensity.cosy:\n            maxHeight = 565;\n            break;\n\n          case DisplayDensity.compact:\n            maxHeight = 405;\n            break;\n\n          default:\n            break;\n        }\n\n        return `${maxHeight}px`;\n      }\n    }\n    /**\n     * Sets the maximum height.\n     */\n\n\n    set maxHeight(value) {\n      this._maxHeight = value;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get grid() {\n      var _a, _b;\n\n      return (_b = (_a = this.column) === null || _a === void 0 ? void 0 : _a.grid) !== null && _b !== void 0 ? _b : this.gridAPI;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get displayDensity() {\n      var _a;\n\n      return (_a = this.grid) === null || _a === void 0 ? void 0 : _a.displayDensity;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    ngOnDestroy() {\n      var _a;\n\n      (_a = this.subscriptions) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n      delete this.overlayComponentId;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    initialize(column, overlayService) {\n      this.inline = false;\n      this.column = column;\n      this.overlayService = overlayService;\n\n      if (this._originalDisplay) {\n        this.element.nativeElement.style.display = this._originalDisplay;\n      }\n\n      this.initialized.emit();\n      this.subscriptions.add(this.grid.columnMoving.subscribe(() => this.closeDropdown()));\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onPin() {\n      this.closeDropdown();\n      this.column.pinned = !this.column.pinned;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onSelect() {\n      if (!this.column.selected) {\n        this.grid.selectionService.selectColumn(this.column.field, this.grid.columnSelection === GridSelectionMode.single);\n      } else {\n        this.grid.selectionService.deselectColumn(this.column.field);\n      }\n\n      this.grid.notifyChanges();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    columnSelectable() {\n      var _a, _b;\n\n      return ((_a = this.grid) === null || _a === void 0 ? void 0 : _a.columnSelection) !== GridSelectionMode.none && ((_b = this.column) === null || _b === void 0 ? void 0 : _b.selectable);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onHideToggle() {\n      this.column.toggleVisibility();\n      this.closeDropdown();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    cancel() {\n      if (!this.overlayComponentId) {\n        this.init();\n      }\n\n      this.closeDropdown();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    closeDropdown() {\n      if (this.overlayComponentId) {\n        this.overlayService.hide(this.overlayComponentId);\n        this.overlayComponentId = null;\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onKeyDown(eventArgs) {\n      if (this.platform.isFilteringKeyCombo(eventArgs)) {\n        eventArgs.preventDefault();\n        this.closeDropdown();\n      }\n\n      eventArgs.stopPropagation();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    hide() {\n      this._originalDisplay = document.defaultView.getComputedStyle(this.element.nativeElement).display;\n      this.element.nativeElement.style.display = 'none';\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    detectChanges() {\n      this.cdr.detectChanges();\n    }\n\n    init() {\n      this.expressionsList = new Array();\n      generateExpressionsList(this.column.filteringExpressionsTree, this.grid.filteringLogic, this.expressionsList);\n      this.populateColumnData();\n    }\n\n    areExpressionsSelectable() {\n      if (this.expressionsList.length === 1 && (this.expressionsList[0].expression.condition.name === 'equals' || this.expressionsList[0].expression.condition.name === 'at' || this.expressionsList[0].expression.condition.name === 'true' || this.expressionsList[0].expression.condition.name === 'false' || this.expressionsList[0].expression.condition.name === 'empty' || this.expressionsList[0].expression.condition.name === 'in')) {\n        return true;\n      }\n\n      const selectableExpressionsCount = this.expressionsList.filter(exp => (exp.beforeOperator === 1 || exp.afterOperator === 1) && (exp.expression.condition.name === 'equals' || exp.expression.condition.name === 'at' || exp.expression.condition.name === 'true' || exp.expression.condition.name === 'false' || exp.expression.condition.name === 'empty' || exp.expression.condition.name === 'in')).length;\n      return selectableExpressionsCount === this.expressionsList.length;\n    }\n\n    populateColumnData() {\n      this.cdr.detectChanges();\n\n      if (this.grid.uniqueColumnValuesStrategy) {\n        this.renderColumnValuesRemotely();\n      } else {\n        this.renderColumnValuesFromData();\n      }\n    }\n\n    renderColumnValuesRemotely() {\n      this.loadingStart.emit();\n      const expressionsTree = this.getColumnFilterExpressionsTree();\n      const prevColumn = this.column;\n      this.grid.uniqueColumnValuesStrategy(this.column, expressionsTree, values => {\n        if (!this.column || this.column !== prevColumn) {\n          return;\n        }\n\n        const items = values.map(v => ({\n          value: v\n        }));\n        this.uniqueValues = this.column.sortStrategy.sort(items, 'value', SortingDirection.Asc, this.column.sortingIgnoreCase, (obj, key) => {\n          let resolvedValue = obj[key];\n\n          if (this.column.dataType === GridColumnDataType.Time) {\n            resolvedValue = new Date().setHours(resolvedValue.getHours(), resolvedValue.getMinutes(), resolvedValue.getSeconds(), resolvedValue.getMilliseconds());\n          }\n\n          return resolvedValue;\n        });\n        this.renderValues();\n        this.loadingEnd.emit();\n      });\n    }\n\n    renderColumnValuesFromData() {\n      this.loadingStart.emit();\n      const expressionsTree = this.getColumnFilterExpressionsTree();\n      const promise = this.grid.filterStrategy.getFilterItems(this.column, expressionsTree);\n      promise.then(items => {\n        this.isHierarchical = items.length > 0 && items.some(i => i.children && i.children.length > 0);\n        this.uniqueValues = items;\n        this.renderValues();\n        this.loadingEnd.emit();\n        this.sortingChanged.emit();\n      });\n    }\n\n    renderValues() {\n      this.filterValues = this.generateFilterValues(this.column.dataType === GridColumnDataType.Date || this.column.dataType === GridColumnDataType.DateTime);\n      this.generateListData();\n    }\n\n    generateFilterValues(isDateColumn = false) {\n      let filterValues;\n\n      if (isDateColumn) {\n        filterValues = new Set(this.expressionsList.reduce((arr, e) => {\n          if (e.expression.condition.name === 'in') {\n            return [...arr, ...Array.from(e.expression.searchVal.values()).map(v => new Date(v).toISOString())];\n          }\n\n          return [...arr, ...[e.expression.searchVal ? e.expression.searchVal.toISOString() : e.expression.searchVal]];\n        }, []));\n      } else if (this.column.dataType === GridColumnDataType.Time) {\n        filterValues = new Set(this.expressionsList.reduce((arr, e) => {\n          if (e.expression.condition.name === 'in') {\n            return [...arr, ...Array.from(e.expression.searchVal.values()).map(v => typeof v === 'string' ? v : new Date(v).toLocaleTimeString())];\n          }\n\n          return [...arr, ...[e.expression.searchVal ? e.expression.searchVal.toLocaleTimeString() : e.expression.searchVal]];\n        }, []));\n      } else {\n        filterValues = new Set(this.expressionsList.reduce((arr, e) => {\n          if (e.expression.condition.name === 'in') {\n            return [...arr, ...Array.from(e.expression.searchVal.values())];\n          }\n\n          return [...arr, ...[e.expression.searchVal]];\n        }, []));\n      }\n\n      return filterValues;\n    }\n\n    generateListData() {\n      this.listData = new Array();\n      const shouldUpdateSelection = this.areExpressionsSelectable();\n\n      if (this.column.dataType === GridColumnDataType.Boolean) {\n        this.addBooleanItems();\n      } else {\n        this.addItems(shouldUpdateSelection);\n      }\n\n      if (!this.isHierarchical && this.containsNullOrEmpty) {\n        const blanksItem = this.generateBlanksItem(shouldUpdateSelection);\n        this.listData.unshift(blanksItem);\n      }\n\n      if (this.listData.length > 0) {\n        this.addSelectAllItem();\n      }\n\n      if (!this.cdr.destroyed) {\n        this.cdr.detectChanges();\n      }\n\n      this.listDataLoaded.emit();\n    }\n\n    getColumnFilterExpressionsTree() {\n      const gridExpressionsTree = this.grid.filteringExpressionsTree;\n      const expressionsTree = new FilteringExpressionsTree(gridExpressionsTree.operator, gridExpressionsTree.fieldName);\n\n      for (const operand of gridExpressionsTree.filteringOperands) {\n        if (operand instanceof FilteringExpressionsTree) {\n          const columnExprTree = operand;\n\n          if (columnExprTree.fieldName === this.column.field) {\n            continue;\n          }\n        }\n\n        expressionsTree.filteringOperands.push(operand);\n      }\n\n      return expressionsTree;\n    }\n\n    addBooleanItems() {\n      this.selectAllSelected = true;\n      this.selectAllIndeterminate = false;\n      this.uniqueValues.forEach(element => {\n        const value = element.value;\n        const filterListItem = new FilterListItem();\n\n        if (value !== undefined && value !== null && value !== '') {\n          if (this.column.filteringExpressionsTree) {\n            if (value === true && this.expressionsList.find(exp => exp.expression.condition.name === 'true')) {\n              filterListItem.isSelected = true;\n              filterListItem.isFiltered = true;\n              this.selectAllIndeterminate = true;\n            } else if (value === false && this.expressionsList.find(exp => exp.expression.condition.name === 'false')) {\n              filterListItem.isSelected = true;\n              filterListItem.isFiltered = true;\n              this.selectAllIndeterminate = true;\n            } else {\n              filterListItem.isSelected = false;\n              filterListItem.isFiltered = false;\n            }\n          } else {\n            filterListItem.isSelected = true;\n            filterListItem.isFiltered = true;\n          }\n\n          filterListItem.value = value;\n          filterListItem.label = value ? this.grid.resourceStrings.igx_grid_filter_true : this.grid.resourceStrings.igx_grid_filter_false;\n          filterListItem.indeterminate = false;\n          this.listData.push(filterListItem);\n        } else {\n          this.containsNullOrEmpty = true;\n        }\n      });\n    }\n\n    addItems(shouldUpdateSelection) {\n      this.selectAllSelected = true;\n      this.selectAllIndeterminate = false;\n      this.containsNullOrEmpty = false;\n      this.listData = this.generateFilterListItems(this.uniqueValues, shouldUpdateSelection);\n      this.containsNullOrEmpty = this.uniqueValues.length > this.listData.length;\n    }\n\n    generateFilterListItems(values, shouldUpdateSelection, parent) {\n      let filterListItems = [];\n      values === null || values === void 0 ? void 0 : values.forEach(element => {\n        var _a, _b;\n\n        const value = element.value;\n        const hasValue = value !== undefined && value !== null && value !== '';\n\n        if (hasValue) {\n          const filterListItem = new FilterListItem();\n          filterListItem.parent = parent;\n          filterListItem.value = value;\n          filterListItem.label = element.label !== undefined ? element.label : this.getFilterItemLabel(value);\n          filterListItem.indeterminate = false;\n          filterListItem.isSelected = true;\n          filterListItem.isFiltered = true;\n\n          if (this.column.filteringExpressionsTree) {\n            filterListItem.isSelected = false;\n            filterListItem.isFiltered = false;\n\n            if (shouldUpdateSelection) {\n              const exprValue = this.getExpressionValue(value);\n\n              if (this.filterValues.has(exprValue)) {\n                filterListItem.isSelected = true;\n                filterListItem.isFiltered = true;\n              }\n\n              this.selectAllIndeterminate = true;\n            } else {\n              this.selectAllSelected = false;\n            }\n          }\n\n          filterListItem.children = this.generateFilterListItems((_a = element.children) !== null && _a !== void 0 ? _a : (_b = element.value) === null || _b === void 0 ? void 0 : _b.children, shouldUpdateSelection, filterListItem);\n          filterListItems.push(filterListItem);\n        }\n      });\n      return filterListItems;\n    }\n\n    addSelectAllItem() {\n      const selectAll = new FilterListItem();\n      selectAll.isSelected = this.selectAllSelected;\n      selectAll.value = this.grid.resourceStrings.igx_grid_excel_select_all;\n      selectAll.label = this.grid.resourceStrings.igx_grid_excel_select_all;\n      selectAll.indeterminate = this.selectAllIndeterminate;\n      selectAll.isSpecial = true;\n      selectAll.isFiltered = this.selectAllSelected;\n      this.listData.unshift(selectAll);\n    }\n\n    generateBlanksItem(shouldUpdateSelection) {\n      const blanks = new FilterListItem();\n\n      if (this.column.filteringExpressionsTree) {\n        if (shouldUpdateSelection) {\n          if (this.filterValues.has(null)) {\n            blanks.isSelected = true;\n            blanks.isFiltered = true;\n          } else {\n            blanks.isSelected = false;\n            blanks.isFiltered = false;\n          }\n        }\n      } else {\n        blanks.isSelected = true;\n        blanks.isFiltered = true;\n      }\n\n      blanks.value = null;\n      blanks.label = this.grid.resourceStrings.igx_grid_excel_blanks;\n      blanks.indeterminate = false;\n      blanks.isSpecial = true;\n      blanks.isBlanks = true;\n      return blanks;\n    }\n\n    getFilterItemLabel(value, applyFormatter = true, data) {\n      if (this.column.formatter) {\n        if (applyFormatter) {\n          return this.column.formatter(value, data);\n        }\n\n        return value;\n      }\n\n      const {\n        display,\n        format,\n        digitsInfo,\n        currencyCode,\n        timezone\n      } = this.column.pipeArgs;\n      const locale = this.grid.locale;\n\n      switch (this.column.dataType) {\n        case GridColumnDataType.Date:\n        case GridColumnDataType.DateTime:\n        case GridColumnDataType.Time:\n          return formatDate(value, format, locale, timezone);\n\n        case GridColumnDataType.Currency:\n          return formatCurrency(value, currencyCode || getLocaleCurrencyCode(locale), display, digitsInfo, locale);\n\n        case GridColumnDataType.Number:\n          return formatNumber(value, locale, digitsInfo);\n\n        case GridColumnDataType.Percent:\n          return formatPercent(value, locale, digitsInfo);\n\n        default:\n          return value;\n      }\n    }\n\n    getExpressionValue(value) {\n      if (this.column.dataType === GridColumnDataType.Date) {\n        value = value ? new Date(value).toISOString() : value;\n      } else if (this.column.dataType === GridColumnDataType.DateTime) {\n        value = value ? new Date(value).toISOString() : value;\n      } else if (this.column.dataType === GridColumnDataType.Time) {\n        value = value ? new Date(value).toLocaleTimeString() : value;\n      }\n\n      return value;\n    }\n\n  }\n\n  IgxGridExcelStyleFilteringComponent.ɵfac = function IgxGridExcelStyleFilteringComponent_Factory(t) {\n    return new (t || IgxGridExcelStyleFilteringComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(PlatformUtil), i0.ɵɵdirectiveInject(IGX_GRID_BASE, 9));\n  };\n\n  IgxGridExcelStyleFilteringComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxGridExcelStyleFilteringComponent,\n    selectors: [[\"igx-grid-excel-style-filtering\"]],\n    contentQueries: function IgxGridExcelStyleFilteringComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxExcelStyleColumnOperationsTemplateDirective, 5, IgxExcelStyleColumnOperationsTemplateDirective);\n        i0.ɵɵcontentQuery(dirIndex, IgxExcelStyleFilterOperationsTemplateDirective, 5, IgxExcelStyleFilterOperationsTemplateDirective);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.excelColumnOperationsDirective = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.excelFilterOperationsDirective = _t.first);\n      }\n    },\n    viewQuery: function IgxGridExcelStyleFilteringComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c126, 5, ElementRef);\n        i0.ɵɵviewQuery(_c127, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c128, 7, TemplateRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.mainDropdown = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultExcelColumnOperations = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultExcelFilterOperations = _t.first);\n      }\n    },\n    hostVars: 6,\n    hostBindings: function IgxGridExcelStyleFilteringComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"max-height\", ctx.maxHeight);\n        i0.ɵɵclassProp(\"igx-excel-filter\", ctx.defaultClass)(\"igx-excel-filter--inline\", ctx.inline);\n      }\n    },\n    inputs: {\n      column: \"column\",\n      minHeight: \"minHeight\",\n      maxHeight: \"maxHeight\"\n    },\n    outputs: {\n      loadingStart: \"loadingStart\",\n      loadingEnd: \"loadingEnd\",\n      initialized: \"initialized\",\n      sortingChanged: \"sortingChanged\",\n      columnChange: \"columnChange\",\n      listDataLoaded: \"listDataLoaded\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: BaseFilteringComponent,\n      useExisting: forwardRef(() => IgxGridExcelStyleFilteringComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c131,\n    decls: 8,\n    vars: 13,\n    consts: [[\"defaultExcelColumnOperations\", \"\"], [\"defaultExcelFilterOperations\", \"\"], [\"role\", \"menu\", 1, \"igx-excel-filter__menu\", 3, \"ngClass\", \"id\", \"keydown\"], [\"mainDropdown\", \"\"], [4, \"ngIf\", \"ngIfElse\"], [3, \"showHiding\", \"showPinning\", \"showSelecting\"], [4, \"ngIf\"]],\n    template: function IgxGridExcelStyleFilteringComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c129);\n        i0.ɵɵtemplate(0, IgxGridExcelStyleFilteringComponent_ng_template_0_Template, 6, 8, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, IgxGridExcelStyleFilteringComponent_ng_template_2_Template, 3, 0, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementStart(4, \"article\", 2, 3);\n        i0.ɵɵlistener(\"keydown\", function IgxGridExcelStyleFilteringComponent_Template_article_keydown_4_listener($event) {\n          return ctx.onKeyDown($event);\n        });\n        i0.ɵɵtemplate(6, IgxGridExcelStyleFilteringComponent_ng_container_6_Template, 2, 0, \"ng-container\", 4);\n        i0.ɵɵtemplate(7, IgxGridExcelStyleFilteringComponent_ng_container_7_Template, 2, 0, \"ng-container\", 4);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        const _r0 = i0.ɵɵreference(1);\n\n        const _r2 = i0.ɵɵreference(3);\n\n        i0.ɵɵadvance(4);\n        i0.ɵɵstyleProp(\"min-height\", ctx.minHeight)(\"max-height\", ctx.maxHeight);\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(10, _c130, ctx.displayDensity === \"cosy\", ctx.displayDensity === \"compact\"))(\"id\", ctx.overlayComponentId);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.excelColumnOperationsDirective)(\"ngIfElse\", _r0);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.excelFilterOperationsDirective)(\"ngIfElse\", _r2);\n      }\n    },\n    directives: [IgxExcelStyleHeaderComponent, IgxExcelStyleSortingComponent, IgxExcelStyleMovingComponent, IgxExcelStylePinningComponent, IgxExcelStyleHidingComponent, IgxExcelStyleSelectingComponent, IgxExcelStyleClearFiltersComponent, IgxExcelStyleConditionalFilterComponent, IgxExcelStyleSearchComponent, i4.NgIf, i4.NgClass],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxGridExcelStyleFilteringComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * This enumeration is used to configure whether the drop position is set before or after\n * the target.\n */\n\n\nvar DropPosition = /*#__PURE__*/(() => {\n  (function (DropPosition) {\n    DropPosition[DropPosition[\"BeforeDropTarget\"] = 0] = \"BeforeDropTarget\";\n    DropPosition[DropPosition[\"AfterDropTarget\"] = 1] = \"AfterDropTarget\";\n  })(DropPosition || (DropPosition = {}));\n\n  return DropPosition;\n})();\n\n/**\n * @hidden\n * @internal\n */\nlet IgxColumnMovingService = /*#__PURE__*/(() => {\n  class IgxColumnMovingService {}\n\n  IgxColumnMovingService.ɵfac = function IgxColumnMovingService_Factory(t) {\n    return new (t || IgxColumnMovingService)();\n  };\n\n  IgxColumnMovingService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxColumnMovingService,\n    factory: IgxColumnMovingService.ɵfac,\n    providedIn: 'root'\n  });\n  return IgxColumnMovingService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet GridBaseAPIService = /*#__PURE__*/(() => {\n  class GridBaseAPIService {\n    constructor(crudService, cms) {\n      this.crudService = crudService;\n      this.cms = cms;\n      this.destroyMap = new Map();\n    }\n\n    get_column_by_name(name) {\n      return this.grid.columnList.find(col => col.field === name);\n    }\n\n    get_summary_data() {\n      const grid = this.grid;\n      let data = grid.filteredData;\n\n      if (data && grid.hasPinnedRecords) {\n        data = grid._filteredUnpinnedData;\n      }\n\n      if (!data) {\n        if (grid.transactions.enabled) {\n          data = DataUtil.mergeTransactions(cloneArray(grid.data), grid.transactions.getAggregatedChanges(true), grid.primaryKey, grid.dataCloneStrategy);\n          const deletedRows = grid.transactions.getTransactionLog().filter(t => t.type === TransactionType.DELETE).map(t => t.id);\n          deletedRows.forEach(rowID => {\n            const tempData = grid.primaryKey ? data.map(rec => rec[grid.primaryKey]) : data;\n            const index = tempData.indexOf(rowID);\n\n            if (index !== -1) {\n              data.splice(index, 1);\n            }\n          });\n        } else {\n          data = grid.data;\n        }\n      }\n\n      return data;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    getRowData(rowID) {\n      const data = this.get_all_data(this.grid.transactions.enabled);\n      const index = this.get_row_index_in_data(rowID, data);\n      return data[index];\n    }\n\n    get_row_index_in_data(rowID, dataCollection) {\n      const grid = this.grid;\n\n      if (!grid) {\n        return -1;\n      }\n\n      const data = dataCollection !== null && dataCollection !== void 0 ? dataCollection : this.get_all_data(grid.transactions.enabled);\n      return grid.primaryKey ? data.findIndex(record => record.recordRef ? record.recordRef[grid.primaryKey] === rowID : record[grid.primaryKey] === rowID) : data.indexOf(rowID);\n    }\n\n    get_row_by_key(rowSelector) {\n      if (!this.grid) {\n        return null;\n      }\n\n      const primaryKey = this.grid.primaryKey;\n\n      if (primaryKey !== undefined && primaryKey !== null) {\n        return this.grid.dataRowList.find(row => row.data[primaryKey] === rowSelector);\n      } else {\n        return this.grid.dataRowList.find(row => row.data === rowSelector);\n      }\n    }\n\n    get_row_by_index(rowIndex) {\n      return this.grid.rowList.find(row => row.index === rowIndex);\n    }\n    /**\n     * Gets the rowID of the record at the specified data view index\n     *\n     * @param index\n     * @param dataCollection\n     */\n\n\n    get_rec_id_by_index(index, dataCollection) {\n      dataCollection = dataCollection || this.grid.data;\n\n      if (index >= 0 && index < dataCollection.length) {\n        const rec = dataCollection[index];\n        return this.grid.primaryKey ? rec[this.grid.primaryKey] : rec;\n      }\n\n      return null;\n    }\n\n    get_cell_by_key(rowSelector, field) {\n      const row = this.get_row_by_key(rowSelector);\n\n      if (row && row.cells) {\n        return row.cells.find(cell => cell.column.field === field);\n      }\n    }\n\n    get_cell_by_index(rowIndex, columnID) {\n      const row = this.get_row_by_index(rowIndex);\n      const hasCells = row && row.cells;\n\n      if (hasCells && typeof columnID === 'number') {\n        return row.cells.find(cell => cell.column.index === columnID);\n      }\n\n      if (hasCells && typeof columnID === 'string') {\n        return row.cells.find(cell => cell.column.field === columnID);\n      }\n    }\n\n    get_cell_by_visible_index(rowIndex, columnIndex) {\n      const row = this.get_row_by_index(rowIndex);\n\n      if (row && row.cells) {\n        return row.cells.find(cell => cell.visibleColumnIndex === columnIndex);\n      }\n    }\n\n    update_cell(cell) {\n      if (!cell) {\n        return;\n      }\n\n      const args = cell.createEditEventArgs(true);\n      this.grid.summaryService.clearSummaryCache(args);\n      const data = this.getRowData(cell.id.rowID);\n      this.updateData(this.grid, cell.id.rowID, data, cell.rowData, reverseMapper(cell.column.field, args.newValue));\n\n      if (this.grid.primaryKey === cell.column.field) {\n        if (this.grid.selectionService.isRowSelected(cell.id.rowID)) {\n          this.grid.selectionService.deselectRow(cell.id.rowID);\n          this.grid.selectionService.selectRowById(args.newValue);\n        }\n\n        if (this.grid.hasSummarizedColumns) {\n          this.grid.summaryService.removeSummaries(cell.id.rowID);\n        }\n      }\n\n      if (!this.grid.rowEditable || !this.crudService.row || this.crudService.row.id !== cell.id.rowID || !this.grid.transactions.enabled) {\n        this.grid.summaryService.clearSummaryCache(args);\n        this.grid.pipeTrigger++;\n      }\n\n      return args;\n    } // TODO: CRUD refactor to not emit editing evts.\n\n\n    update_row(row, value, event) {\n      const grid = this.grid;\n      const selected = grid.selectionService.isRowSelected(row.id);\n      const rowInEditMode = this.crudService.row;\n      const data = this.get_all_data(grid.transactions.enabled);\n      const index = this.get_row_index_in_data(row.id, data);\n      const hasSummarized = grid.hasSummarizedColumns;\n      this.crudService.updateRowEditData(row, value);\n      const args = row.createEditEventArgs(true, event); // If no valid row is found\n\n      if (index === -1) {\n        return args;\n      }\n\n      if (rowInEditMode) {\n        const hasChanges = grid.transactions.getState(args.rowID, true);\n        grid.transactions.endPending(false);\n\n        if (!hasChanges) {\n          return args;\n        }\n      }\n\n      if (!args.newValue) {\n        return args;\n      }\n\n      if (hasSummarized) {\n        grid.summaryService.removeSummaries(args.rowID);\n      }\n\n      this.updateData(grid, row.id, data[index], args.oldValue, args.newValue);\n      const newId = grid.primaryKey ? args.newValue[grid.primaryKey] : args.newValue;\n\n      if (selected) {\n        grid.selectionService.deselectRow(row.id);\n        grid.selectionService.selectRowById(newId);\n      } // make sure selection is handled prior to updating the row.id\n\n\n      row.id = newId;\n\n      if (hasSummarized) {\n        grid.summaryService.removeSummaries(newId);\n      }\n\n      grid.pipeTrigger++;\n      return args;\n    }\n\n    sort(expression) {\n      if (expression.dir === SortingDirection.None) {\n        this.remove_grouping_expression(expression.fieldName);\n      }\n\n      const sortingState = cloneArray(this.grid.sortingExpressions);\n      this.prepare_sorting_expression([sortingState], expression);\n      this.grid.sortingExpressions = sortingState;\n    }\n\n    sort_multiple(expressions) {\n      const sortingState = cloneArray(this.grid.sortingExpressions);\n\n      for (const each of expressions) {\n        if (each.dir === SortingDirection.None) {\n          this.remove_grouping_expression(each.fieldName);\n        }\n\n        this.prepare_sorting_expression([sortingState], each);\n      }\n\n      this.grid.sortingExpressions = sortingState;\n    }\n\n    clear_sort(fieldName) {\n      const sortingState = this.grid.sortingExpressions;\n      const index = sortingState.findIndex(expr => expr.fieldName === fieldName);\n\n      if (index > -1) {\n        sortingState.splice(index, 1);\n        this.grid.sortingExpressions = sortingState;\n      }\n    }\n\n    clear_groupby(_name) {}\n\n    should_apply_number_style(column) {\n      return column.dataType === GridColumnDataType.Number;\n    }\n\n    get_data() {\n      const grid = this.grid;\n      const data = grid.data ? grid.data : [];\n      return data;\n    }\n\n    get_all_data(includeTransactions = false) {\n      const grid = this.grid;\n      let data = grid && grid.data ? grid.data : [];\n      data = includeTransactions ? grid.dataWithAddedInTransactionRows : data;\n      return data;\n    }\n\n    get_filtered_data() {\n      return this.grid.filteredData;\n    }\n\n    addRowToData(rowData, _parentID) {\n      // Add row goes to transactions and if rowEditable is properly implemented, added rows will go to pending transactions\n      // If there is a row in edit - > commit and close\n      const grid = this.grid;\n\n      if (grid.transactions.enabled) {\n        const transactionId = grid.primaryKey ? rowData[grid.primaryKey] : rowData;\n        const transaction = {\n          id: transactionId,\n          type: TransactionType.ADD,\n          newValue: rowData\n        };\n        grid.transactions.add(transaction);\n      } else {\n        grid.data.push(rowData);\n      }\n    }\n\n    deleteRowFromData(rowID, index) {\n      //  if there is a row (index !== 0) delete it\n      //  if there is a row in ADD or UPDATE state change it's state to DELETE\n      const grid = this.grid;\n\n      if (index !== -1) {\n        if (grid.transactions.enabled) {\n          const transaction = {\n            id: rowID,\n            type: TransactionType.DELETE,\n            newValue: null\n          };\n          grid.transactions.add(transaction, grid.data[index]);\n        } else {\n          grid.data.splice(index, 1);\n        }\n      } else {\n        const state = grid.transactions.getState(rowID);\n        grid.transactions.add({\n          id: rowID,\n          type: TransactionType.DELETE,\n          newValue: null\n        }, state && state.recordRef);\n      }\n    }\n\n    deleteRowById(rowId) {\n      let index;\n      const grid = this.grid;\n      const data = this.get_all_data();\n\n      if (grid.primaryKey) {\n        // eslint-disable-next-line @typescript-eslint/no-shadow\n        index = data.map(record => record[grid.primaryKey]).indexOf(rowId);\n      } else {\n        index = data.indexOf(rowId);\n      }\n\n      const state = grid.transactions.getState(rowId);\n      const hasRowInNonDeletedState = state && state.type !== TransactionType.DELETE; //  if there is a row (index !== -1) and the we have cell in edit mode on same row exit edit mode\n      //  if there is no row (index === -1), but there is a row in ADD or UPDATE state do as above\n      //  Otherwise just exit - there is nothing to delete\n\n      if (index !== -1 || hasRowInNonDeletedState) {\n        // Always exit edit when row is deleted\n        this.crudService.endEdit(true);\n      } else {\n        return;\n      }\n\n      const record = data[index]; // //  TODO: should we emit this when cascadeOnDelete is true for each row?!?!\n\n      grid.rowDeletedNotifier.next({\n        data: data[index]\n      });\n      this.deleteRowFromData(rowId, index);\n\n      if (grid.selectionService.isRowSelected(rowId)) {\n        grid.selectionService.deselectRow(rowId);\n      } else {\n        grid.selectionService.clearHeaderCBState();\n      }\n\n      grid.pipeTrigger++;\n      grid.notifyChanges(); // Data needs to be recalculated if transactions are in place\n      // If no transactions, `data` will be a reference to the grid getter, otherwise it will be stale\n\n      const dataAfterDelete = grid.transactions.enabled ? grid.dataWithAddedInTransactionRows : data;\n      grid.refreshSearch();\n\n      if (dataAfterDelete.length % grid.perPage === 0 && dataAfterDelete.length / grid.perPage - 1 < grid.page && grid.page !== 0) {\n        grid.page--;\n      }\n\n      return record;\n    }\n\n    get_row_id(rowData) {\n      return this.grid.primaryKey ? rowData[this.grid.primaryKey] : rowData;\n    }\n\n    row_deleted_transaction(rowID) {\n      const grid = this.grid;\n\n      if (!grid) {\n        return false;\n      }\n\n      if (!grid.transactions.enabled) {\n        return false;\n      }\n\n      const state = grid.transactions.getState(rowID);\n\n      if (state) {\n        return state.type === TransactionType.DELETE;\n      }\n\n      return false;\n    }\n\n    get_row_expansion_state(record) {\n      const grid = this.grid;\n      const states = grid.expansionStates;\n      const rowID = grid.primaryKey ? record[grid.primaryKey] : record;\n      const expanded = states.get(rowID);\n\n      if (expanded !== undefined) {\n        return expanded;\n      } else {\n        return grid.getDefaultExpandState(record);\n      }\n    }\n\n    set_row_expansion_state(rowID, expanded, event) {\n      const grid = this.grid;\n      const expandedStates = grid.expansionStates;\n\n      if (!this.allow_expansion_state_change(rowID, expanded)) {\n        return;\n      }\n\n      const args = {\n        rowID,\n        expanded,\n        event,\n        cancel: false\n      };\n      grid.rowToggle.emit(args);\n\n      if (args.cancel) {\n        return;\n      }\n\n      expandedStates.set(rowID, expanded);\n      grid.expansionStates = expandedStates; // K.D. 28 Feb, 2022 #10634 Don't trigger endEdit/commit upon row expansion state change\n      // this.crudService.endEdit(false);\n    }\n\n    get_rec_by_id(rowID) {\n      return this.grid.primaryKey ? this.getRowData(rowID) : rowID;\n    }\n    /**\n     * Returns the index of the record in the data view by pk or -1 if not found or primaryKey is not set.\n     *\n     * @param pk\n     * @param dataCollection\n     */\n\n\n    get_rec_index_by_id(pk, dataCollection) {\n      dataCollection = dataCollection || this.grid.data;\n      return this.grid.primaryKey ? dataCollection.findIndex(rec => rec[this.grid.primaryKey] === pk) : -1;\n    }\n\n    allow_expansion_state_change(rowID, expanded) {\n      return this.grid.expansionStates.get(rowID) !== expanded;\n    }\n\n    prepare_sorting_expression(stateCollections, expression) {\n      if (expression.dir === SortingDirection.None) {\n        stateCollections.forEach(state => {\n          state.splice(state.findIndex(expr => expr.fieldName === expression.fieldName), 1);\n        });\n        return;\n      }\n      /**\n       * We need to make sure the states in each collection with same fields point to the same object reference.\n       * If the different state collections provided have different sizes we need to get the largest one.\n       * That way we can get the state reference from the largest one that has the same fieldName as the expression to prepare.\n       */\n\n\n      let maxCollection = stateCollections[0];\n\n      for (let i = 1; i < stateCollections.length; i++) {\n        if (maxCollection.length < stateCollections[i].length) {\n          maxCollection = stateCollections[i];\n        }\n      }\n\n      const maxExpr = maxCollection.find(expr => expr.fieldName === expression.fieldName);\n      stateCollections.forEach(collection => {\n        const myExpr = collection.find(expr => expr.fieldName === expression.fieldName);\n\n        if (!myExpr && !maxExpr) {\n          // Expression with this fieldName is missing from the current and the max collection.\n          collection.push(expression);\n        } else if (!myExpr && maxExpr) {\n          // Expression with this fieldName is missing from the current and but the max collection has.\n          collection.push(maxExpr);\n          Object.assign(maxExpr, expression);\n        } else {\n          // The current collection has the expression so just update it.\n          Object.assign(myExpr, expression);\n        }\n      });\n    }\n\n    remove_grouping_expression(_fieldName) {}\n\n    filterDataByExpressions(expressionsTree) {\n      let data = this.get_all_data();\n\n      if (expressionsTree.filteringOperands.length) {\n        const state = {\n          expressionsTree,\n          strategy: this.grid.filterStrategy\n        };\n        data = FilterUtil.filter(cloneArray(data), state, this.grid);\n      }\n\n      return data;\n    }\n\n    sortDataByExpressions(data, expressions) {\n      return DataUtil.sort(cloneArray(data), expressions, this.grid.sortStrategy, this.grid);\n    }\n    /**\n     * Updates related row of provided grid's data source with provided new row value\n     *\n     * @param grid Grid to update data for\n     * @param rowID ID of the row to update\n     * @param rowValueInDataSource Initial value of the row as it is in data source\n     * @param rowCurrentValue Current value of the row as it is with applied previous transactions\n     * @param rowNewValue New value of the row\n     */\n\n\n    updateData(grid, rowID, rowValueInDataSource, rowCurrentValue, rowNewValue) {\n      if (grid.transactions.enabled) {\n        const transaction = {\n          id: rowID,\n          type: TransactionType.UPDATE,\n          newValue: rowNewValue\n        };\n        grid.transactions.add(transaction, rowCurrentValue);\n      } else {\n        mergeObjects(rowValueInDataSource, rowNewValue);\n      }\n    }\n\n    update_row_in_array(value, rowID, index) {\n      const grid = this.grid;\n      grid.data[index] = value;\n    }\n\n    getSortStrategyPerColumn(fieldName) {\n      return this.get_column_by_name(fieldName) ? this.get_column_by_name(fieldName).sortStrategy : undefined;\n    }\n\n  }\n\n  GridBaseAPIService.ɵfac = function GridBaseAPIService_Factory(t) {\n    return new (t || GridBaseAPIService)(i0.ɵɵinject(IgxGridCRUDService), i0.ɵɵinject(IgxColumnMovingService));\n  };\n\n  GridBaseAPIService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: GridBaseAPIService,\n    factory: GridBaseAPIService.ɵfac\n  });\n  return GridBaseAPIService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nfunction WatchChanges() {\n  return (target, key, propDesc) => {\n    const privateKey = '_' + key.toString();\n    propDesc = propDesc || {\n      configurable: true,\n      enumerable: true\n    };\n\n    propDesc.get = propDesc.get || function () {\n      return this[privateKey];\n    };\n\n    const originalSetter = propDesc.set || function (val) {\n      this[privateKey] = val;\n    };\n\n    propDesc.set = function (val) {\n      const init = this._init;\n      const oldValue = this[key];\n\n      if (val !== oldValue || typeof val === 'object' && val === oldValue) {\n        originalSetter.call(this, val);\n\n        if (this.ngOnChanges && !init) {\n          // in case wacthed prop changes trigger ngOnChanges manually\n          const changes = {\n            [key]: new SimpleChange(oldValue, val, false)\n          };\n          this.ngOnChanges(changes);\n        }\n      }\n    };\n\n    return propDesc;\n  };\n}\n\nfunction WatchColumnChanges() {\n  return (target, key, propDesc) => {\n    const privateKey = '_' + key.toString();\n    propDesc = propDesc || {\n      configurable: true,\n      enumerable: true\n    };\n\n    propDesc.get = propDesc.get || function () {\n      return this[privateKey];\n    };\n\n    const originalSetter = propDesc.set || function (val) {\n      this[privateKey] = val;\n    };\n\n    propDesc.set = function (val) {\n      const oldValue = this[key];\n      originalSetter.call(this, val);\n\n      if (val !== oldValue || typeof val === 'object' && val === oldValue) {\n        if (this.columnChange) {\n          this.columnChange.emit();\n        }\n      }\n    };\n\n    return propDesc;\n  };\n}\n\nfunction notifyChanges(repaint = false) {\n  return (_, key, propDesc) => {\n    const privateKey = `__${key}`;\n    propDesc = propDesc || {\n      enumerable: true,\n      configurable: true\n    };\n    const originalSetter = propDesc ? propDesc.set : null;\n\n    propDesc.get = propDesc.get || function () {\n      return this[privateKey];\n    };\n\n    propDesc.set = function (newValue) {\n      if (originalSetter) {\n        originalSetter.call(this, newValue);\n\n        if (this.grid) {\n          this.grid.notifyChanges(repaint && !this.grid.isPivot);\n        }\n      } else {\n        if (newValue === this[key]) {\n          return;\n        }\n\n        this[privateKey] = newValue;\n\n        if (this.grid) {\n          this.grid.notifyChanges(repaint && !this.grid.isPivot);\n        }\n      }\n    };\n\n    return propDesc;\n  };\n}\n\nlet IgxFilterCellTemplateDirective = /*#__PURE__*/(() => {\n  class IgxFilterCellTemplateDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxFilterCellTemplateDirective.ɵfac = function IgxFilterCellTemplateDirective_Factory(t) {\n    return new (t || IgxFilterCellTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxFilterCellTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxFilterCellTemplateDirective,\n    selectors: [[\"\", \"igxFilterCellTemplate\", \"\"]]\n  });\n  return IgxFilterCellTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxCellTemplateDirective = /*#__PURE__*/(() => {\n  class IgxCellTemplateDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxCellTemplateDirective.ɵfac = function IgxCellTemplateDirective_Factory(t) {\n    return new (t || IgxCellTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxCellTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxCellTemplateDirective,\n    selectors: [[\"\", \"igxCell\", \"\"]]\n  });\n  return IgxCellTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxCellHeaderTemplateDirective = /*#__PURE__*/(() => {\n  class IgxCellHeaderTemplateDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxCellHeaderTemplateDirective.ɵfac = function IgxCellHeaderTemplateDirective_Factory(t) {\n    return new (t || IgxCellHeaderTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxCellHeaderTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxCellHeaderTemplateDirective,\n    selectors: [[\"\", \"igxHeader\", \"\"]]\n  });\n  return IgxCellHeaderTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxCellFooterTemplateDirective = /*#__PURE__*/(() => {\n  class IgxCellFooterTemplateDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxCellFooterTemplateDirective.ɵfac = function IgxCellFooterTemplateDirective_Factory(t) {\n    return new (t || IgxCellFooterTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxCellFooterTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxCellFooterTemplateDirective,\n    selectors: [[\"\", \"igxFooter\", \"\"]]\n  });\n  return IgxCellFooterTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxCellEditorTemplateDirective = /*#__PURE__*/(() => {\n  class IgxCellEditorTemplateDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxCellEditorTemplateDirective.ɵfac = function IgxCellEditorTemplateDirective_Factory(t) {\n    return new (t || IgxCellEditorTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxCellEditorTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxCellEditorTemplateDirective,\n    selectors: [[\"\", \"igxCellEditor\", \"\"]]\n  });\n  return IgxCellEditorTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxCollapsibleIndicatorTemplateDirective = /*#__PURE__*/(() => {\n  class IgxCollapsibleIndicatorTemplateDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxCollapsibleIndicatorTemplateDirective.ɵfac = function IgxCollapsibleIndicatorTemplateDirective_Factory(t) {\n    return new (t || IgxCollapsibleIndicatorTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxCollapsibleIndicatorTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxCollapsibleIndicatorTemplateDirective,\n    selectors: [[\"\", \"igxCollapsibleIndicator\", \"\"]]\n  });\n  return IgxCollapsibleIndicatorTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxSummaryTemplateDirective = /*#__PURE__*/(() => {\n  class IgxSummaryTemplateDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxSummaryTemplateDirective.ɵfac = function IgxSummaryTemplateDirective_Factory(t) {\n    return new (t || IgxSummaryTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxSummaryTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxSummaryTemplateDirective,\n    selectors: [[\"\", \"igxSummary\", \"\"]]\n  });\n  return IgxSummaryTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass IgxGridCell {\n  /**\n   * @hidden\n   */\n  constructor(grid, row, column) {\n    this.grid = grid;\n\n    if (typeof row === 'number') {\n      this._rowIndex = row;\n    } else {\n      this._row = row;\n      this._rowIndex = row.index;\n    }\n\n    if (typeof column === 'string') {\n      this._columnField = column;\n    } else {\n      this._column = column;\n    }\n  }\n  /**\n   * Returns the row containing the cell.\n   * ```typescript\n   * let row = this.cell.row;\n   * ```\n   *\n   * @memberof IgxGridCell\n   */\n\n\n  get row() {\n    return this._row || this.grid.createRow(this._rowIndex);\n  }\n  /**\n   * Returns the column of the cell.\n   * ```typescript\n   * let column = this.cell.column;\n   * ```\n   *\n   * @memberof IgxGridCell\n   */\n\n\n  get column() {\n    return this._column || this.grid.getColumnByName(this._columnField);\n  }\n  /**\n   * Gets the current edit value while a cell is in edit mode.\n   * ```typescript\n   * let editValue = this.cell.editValue;\n   * ```\n   *\n   * @memberof IgxGridCell\n   */\n\n\n  get editValue() {\n    if (this.isCellInEditMode()) {\n      return this.grid.crudService.cell.editValue;\n    }\n  }\n  /**\n   * Sets the current edit value while a cell is in edit mode.\n   * Only for cell editing mode.\n   * ```typescript\n   * this.cell.editValue = value;\n   * ```\n   *\n   * @memberof IgxGridCell\n   */\n\n\n  set editValue(value) {\n    if (this.isCellInEditMode()) {\n      this.grid.crudService.cell.editValue = value;\n    }\n  }\n  /**\n   * Returns whether the cell is editable..\n   *\n   * @memberof IgxGridCell\n   */\n\n\n  get editable() {\n    var _a;\n\n    return this.column.editable && !((_a = this.row) === null || _a === void 0 ? void 0 : _a.disabled);\n  }\n  /**\n   * Gets the width of the cell.\n   * ```typescript\n   * let cellWidth = this.cell.width;\n   * ```\n   *\n   * @memberof IgxGridCell\n   */\n\n\n  get width() {\n    return this.column.width;\n  }\n  /**\n   * Returns the cell value.\n   *\n   * @memberof IgxGridCell\n   */\n\n\n  get value() {\n    var _a, _b; // will return undefined for a column layout, because getCellByColumnVisibleIndex may return the column layout at that index.\n    // getCellByColumnVisibleIndex is deprecated and will be removed in future version\n\n\n    return this.column.field ? this.column.hasNestedPath ? resolveNestedPath((_a = this.row) === null || _a === void 0 ? void 0 : _a.data, this.column.field) : (_b = this.row) === null || _b === void 0 ? void 0 : _b.data[this.column.field] : undefined;\n  }\n  /**\n   * Updates the cell value.\n   *\n   * @memberof IgxGridCell\n   */\n\n\n  set value(val) {\n    this.update(val);\n  }\n  /**\n   * Gets the cell id.\n   * A cell in the grid is identified by:\n   * - rowID - primaryKey data value or the whole rowData, if the primaryKey is omitted.\n   * - rowIndex - the row index\n   * - columnID - column index\n   *\n   * ```typescript\n   * let cellID = cell.id;\n   * ```\n   *\n   * @memberof IgxGridCell\n   */\n\n\n  get id() {\n    var _a, _b, _c;\n\n    const primaryKey = this.grid.primaryKey;\n    const rowID = primaryKey ? (_a = this.row) === null || _a === void 0 ? void 0 : _a.data[primaryKey] : (_b = this.row) === null || _b === void 0 ? void 0 : _b.data;\n    return {\n      rowID,\n      columnID: this.column.index,\n      rowIndex: this._rowIndex || ((_c = this.row) === null || _c === void 0 ? void 0 : _c.index)\n    };\n  }\n  /**\n   * Returns if the row is currently in edit mode.\n   *\n   * @memberof IgxGridCell\n   */\n\n\n  get editMode() {\n    return this.isCellInEditMode();\n  }\n  /**\n   * Starts/ends edit mode for the cell.\n   *\n   * ```typescript\n   * cell.editMode  = !cell.editMode;\n   * ```\n   *\n   * @memberof IgxGridCell\n   */\n\n\n  set editMode(value) {\n    var _a;\n\n    const isInEditMode = this.isCellInEditMode();\n\n    if (!this.row || ((_a = this.row) === null || _a === void 0 ? void 0 : _a.deleted) || isInEditMode === value) {\n      return;\n    }\n\n    if (this.editable && value) {\n      this.endEdit(); // TODO possibly define similar method in gridAPI, which does not emit event\n\n      this.grid.crudService.enterEditMode(this);\n    } else {\n      this.grid.crudService.endCellEdit();\n    }\n\n    this.grid.notifyChanges();\n  }\n  /**\n   * Gets whether the cell is selected.\n   * ```typescript\n   * let isSelected = this.cell.selected;\n   * ```\n   *\n   *\n   * @memberof IgxGridCell\n   */\n\n\n  get selected() {\n    return this.grid.selectionService.selected(this.selectionNode);\n  }\n  /**\n   * Selects/deselects the cell.\n   * ```typescript\n   * this.cell.selected = true.\n   * ```\n   *\n   *\n   * @memberof IgxGridCell\n   */\n\n\n  set selected(val) {\n    const node = this.selectionNode;\n\n    if (val) {\n      this.grid.selectionService.add(node);\n    } else {\n      this.grid.selectionService.remove(node);\n    }\n\n    this.grid.notifyChanges();\n  }\n\n  get active() {\n    var _a;\n\n    const node = this.grid.navigation.activeNode;\n    return node ? node.row === ((_a = this.row) === null || _a === void 0 ? void 0 : _a.index) && node.column === this.column.visibleIndex : false;\n  }\n  /**\n   * Updates the cell value.\n   *\n   * ```typescript\n   * cell.update(newValue);\n   * ```\n   *\n   * @memberof IgxGridCell\n   */\n\n\n  update(val) {\n    var _a;\n\n    if ((_a = this.row) === null || _a === void 0 ? void 0 : _a.deleted) {\n      return;\n    }\n\n    this.endEdit();\n    const cell = this.isCellInEditMode() ? this.grid.crudService.cell : this.grid.crudService.createCell(this);\n    cell.editValue = val;\n    this.grid.gridAPI.update_cell(cell);\n    this.grid.crudService.endCellEdit();\n    this.grid.notifyChanges();\n  }\n\n  get selectionNode() {\n    var _a;\n\n    return {\n      row: (_a = this.row) === null || _a === void 0 ? void 0 : _a.index,\n      column: this.column.columnLayoutChild ? this.column.parent.visibleIndex : this.column.visibleIndex,\n      layout: this.column.columnLayoutChild ? {\n        rowStart: this.column.rowStart,\n        colStart: this.column.colStart,\n        rowEnd: this.column.rowEnd,\n        colEnd: this.column.colEnd,\n        columnVisibleIndex: this.column.visibleIndex\n      } : null\n    };\n  }\n\n  isCellInEditMode() {\n    if (this.grid.crudService.cellInEditMode) {\n      const cellInEditMode = this.grid.crudService.cell.id;\n      const isCurrentCell = cellInEditMode.rowID === this.id.rowID && cellInEditMode.rowIndex === this.id.rowIndex && cellInEditMode.columnID === this.id.columnID;\n      return isCurrentCell;\n    }\n\n    return false;\n  }\n\n  endEdit() {\n    if (!this.isCellInEditMode()) {\n      this.grid.gridAPI.update_cell(this.grid.crudService.cell);\n      this.grid.crudService.endCellEdit();\n    }\n  }\n\n}\n\nconst DEFAULT_DATE_FORMAT = 'mediumDate';\nconst DEFAULT_TIME_FORMAT = 'mediumTime';\nconst DEFAULT_DATE_TIME_FORMAT = 'medium';\nconst DEFAULT_DIGITS_INFO = '1.0-3';\n/**\n * **Ignite UI for Angular Column** -\n * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid/grid#columns-configuration)\n *\n * The Ignite UI Column is used within an `igx-grid` element to define what data the column will show. Features such as sorting,\n * filtering & editing are enabled at the column level.  You can also provide a template containing custom content inside\n * the column using `ng-template` which will be used for all cells within the column.\n */\n\nlet IgxColumnComponent = /*#__PURE__*/(() => {\n  class IgxColumnComponent {\n    constructor(grid, cdr, platform) {\n      this.grid = grid;\n      this.cdr = cdr;\n      this.platform = platform;\n      /**\n       * Sets/gets the `header` value.\n       * ```typescript\n       * let columnHeader = this.column.header;\n       * ```\n       * ```html\n       * <igx-column [header] = \"'ID'\"></igx-column>\n       * ```\n       *\n       * @memberof IgxColumnComponent\n       */\n\n      this.header = '';\n      /**\n       * Sets/gets the `title` value.\n       * ```typescript\n       * let title = this.column.title;\n       * ```\n       * ```html\n       * <igx-column [title] = \"'Some column tooltip'\"></igx-column>\n       * ```\n       *\n       * @memberof IgxColumnComponent\n       */\n\n      this.title = '';\n      /**\n       * Sets/gets whether the column is sortable.\n       * Default value is `false`.\n       * ```typescript\n       * let isSortable = this.column.sortable;\n       * ```\n       * ```html\n       * <igx-column [sortable] = \"true\"></igx-column>\n       * ```\n       *\n       * @memberof IgxColumnComponent\n       */\n\n      this.sortable = false;\n      /**\n       * Sets/gets whether the column is groupable.\n       * Default value is `false`.\n       * ```typescript\n       * let isGroupable = this.column.groupable;\n       * ```\n       * ```html\n       * <igx-column [groupable] = \"true\"></igx-column>\n       * ```\n       *\n       * @memberof IgxColumnComponent\n       */\n\n      this.groupable = false;\n      /**\n       * Sets/gets whether the column is filterable.\n       * Default value is `true`.\n       * ```typescript\n       * let isFilterable = this.column.filterable;\n       * ```\n       * ```html\n       * <igx-column [filterable] = \"false\"></igx-column>\n       * ```\n       *\n       * @memberof IgxColumnComponent\n       */\n\n      this.filterable = true;\n      /**\n       * Sets/gets whether the column is resizable.\n       * Default value is `false`.\n       * ```typescript\n       * let isResizable = this.column.resizable;\n       * ```\n       * ```html\n       * <igx-column [resizable] = \"true\"></igx-column>\n       * ```\n       *\n       * @memberof IgxColumnComponent\n       */\n\n      this.resizable = false;\n      /**\n       * Sets/gets whether the column header is included in autosize logic.\n       * Useful when template for a column header is sized based on parent, for example a default `div`.\n       * Default value is `false`.\n       * ```typescript\n       * let isResizable = this.column.resizable;\n       * ```\n       * ```html\n       * <igx-column [resizable] = \"true\"></igx-column>\n       * ```\n       *\n       * @memberof IgxColumnComponent\n       */\n\n      this.autosizeHeader = true;\n      /**\n       * @hidden\n       */\n\n      this.hiddenChange = new EventEmitter();\n      /** @hidden */\n\n      this.expandedChange = new EventEmitter();\n      /** @hidden */\n\n      this.collapsibleChange = new EventEmitter();\n      /** @hidden */\n\n      this.visibleWhenCollapsedChange = new EventEmitter();\n      /** @hidden */\n\n      this.columnChange = new EventEmitter();\n      /**\n       * Gets whether the hiding is disabled.\n       * ```typescript\n       * let isHidingDisabled =  this.column.disableHiding;\n       * ```\n       *\n       * @memberof IgxColumnComponent\n       */\n\n      this.disableHiding = false;\n      /**\n       * Gets whether the pinning is disabled.\n       * ```typescript\n       * let isPinningDisabled =  this.column.disablePinning;\n       * ```\n       *\n       * @memberof IgxColumnComponent\n       */\n\n      this.disablePinning = false;\n      /**\n       * @deprecated in version 13.1.0. Use `IgxGridComponent.moving` instead.\n       *\n       * Sets/gets whether the column is movable.\n       * Default value is `false`.\n       *\n       * ```typescript\n       * let isMovable = this.column.movable;\n       * ```\n       * ```html\n       * <igx-column [movable] = \"true\"></igx-column>\n       * ```\n       *\n       * @memberof IgxColumnComponent\n       */\n\n      this.movable = false;\n      /**\n       * Sets/gets the class selector of the column header.\n       * ```typescript\n       * let columnHeaderClass = this.column.headerClasses;\n       * ```\n       * ```html\n       * <igx-column [headerClasses] = \"'column-header'\"></igx-column>\n       * ```\n       *\n       * @memberof IgxColumnComponent\n       */\n\n      this.headerClasses = '';\n      /**\n       * Sets conditional style properties on the column header.\n       * Similar to `ngStyle` it accepts an object literal where the keys are\n       * the style properties and the value is the expression to be evaluated.\n       * ```typescript\n       * styles = {\n       *  background: 'royalblue',\n       *  color: (column) => column.pinned ? 'red': 'inherit'\n       * }\n       * ```\n       * ```html\n       * <igx-column [headerStyles]=\"styles\"></igx-column>\n       * ```\n       *\n       * @memberof IgxColumnComponent\n       */\n\n      this.headerStyles = null;\n      /**\n       * Sets/gets the class selector of the column group header.\n       * ```typescript\n       * let columnHeaderClass = this.column.headerGroupClasses;\n       * ```\n       * ```html\n       * <igx-column [headerGroupClasses] = \"'column-group-header'\"></igx-column>\n       * ```\n       *\n       * @memberof IgxColumnComponent\n       */\n\n      this.headerGroupClasses = '';\n      /**\n       * Sets conditional style properties on the column header group wrapper.\n       * Similar to `ngStyle` it accepts an object literal where the keys are\n       * the style properties and the value is the expression to be evaluated.\n       * ```typescript\n       * styles = {\n       *  background: 'royalblue',\n       *  color: (column) => column.pinned ? 'red': 'inherit'\n       * }\n       * ```\n       * ```html\n       * <igx-column [headerGroupStyles]=\"styles\"></igx-column>\n       * ```\n       *\n       * @memberof IgxColumnComponent\n       */\n\n      this.headerGroupStyles = null;\n      /**\n       * Sets conditional style properties on the column cells.\n       * Similar to `ngStyle` it accepts an object literal where the keys are\n       * the style properties and the value is the expression to be evaluated.\n       * As with `cellClasses` it accepts a callback function.\n       * ```typescript\n       * styles = {\n       *  background: 'royalblue',\n       *  color: (rowData, columnKey, cellValue, rowIndex) => value.startsWith('Important') ? 'red': 'inherit'\n       * }\n       * ```\n       * ```html\n       * <igx-column [cellStyles]=\"styles\"></igx-column>\n       * ```\n       *\n       * @memberof IgxColumnComponent\n       */\n\n      this.cellStyles = null;\n      /**\n       * Sets/gets whether the column filtering should be case sensitive.\n       * Default value is `true`.\n       * ```typescript\n       * let filteringIgnoreCase = this.column.filteringIgnoreCase;\n       * ```\n       * ```html\n       * <igx-column [filteringIgnoreCase] = \"false\"></igx-column>\n       * ```\n       *\n       * @memberof IgxColumnComponent\n       */\n\n      this.filteringIgnoreCase = true;\n      /**\n       * Sets/gets whether the column sorting should be case sensitive.\n       * Default value is `true`.\n       * ```typescript\n       * let sortingIgnoreCase = this.column.sortingIgnoreCase;\n       * ```\n       * ```html\n       * <igx-column [sortingIgnoreCase] = \"false\"></igx-column>\n       * ```\n       *\n       * @memberof IgxColumnComponent\n       */\n\n      this.sortingIgnoreCase = true;\n      /**\n       * Sets/gets whether the column is `searchable`.\n       * Default value is `true`.\n       * ```typescript\n       * let isSearchable =  this.column.searchable';\n       * ```\n       * ```html\n       *  <igx-column [searchable] = \"false\"></igx-column>\n       * ```\n       *\n       * @memberof IgxColumnComponent\n       */\n\n      this.searchable = true;\n      /**\n       * Sets/gets the data type of the column values.\n       * Default value is `string`.\n       * ```typescript\n       * let columnDataType = this.column.dataType;\n       * ```\n       * ```html\n       * <igx-column [dataType] = \"'number'\"></igx-column>\n       * ```\n       *\n       * @memberof IgxColumnComponent\n       */\n\n      this.dataType = GridColumnDataType.String;\n      /**\n       * @hidden\n       */\n\n      this.widthChange = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.pinnedChange = new EventEmitter();\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this.defaultTimeFormat = 'hh:mm:ss tt';\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this.defaultDateTimeFormat = 'dd/MM/yyyy HH:mm:ss tt';\n      /**\n       * Sets/gets the parent column.\n       * ```typescript\n       * let parentColumn = this.column.parent;\n       * ```\n       * ```typescript\n       * this.column.parent = higherLevelColumn;\n       * ```\n       *\n       * @memberof IgxColumnComponent\n       */\n\n      this.parent = null;\n      /**\n       * @hidden\n       */\n\n      this.destroy$ = new Subject();\n      /**\n       * @hidden\n       */\n\n      this._applySelectableClass = false;\n      this._vIndex = NaN;\n      /**\n       * @hidden\n       */\n\n      this._pinned = false;\n      /**\n       * @hidden\n       */\n\n      this._summaries = null;\n      /**\n       * @hidden\n       */\n\n      this._filters = null;\n      /**\n       * @hidden\n       */\n\n      this._sortStrategy = DefaultSortingStrategy.instance();\n      /**\n       * @hidden\n       */\n\n      this._hidden = false;\n      /**\n       * @hidden\n       */\n\n      this._disablePinning = false;\n      /**\n       * @hidden\n       */\n\n      this._defaultMinWidth = '';\n      /**\n       * @hidden\n       */\n\n      this._hasSummary = false;\n      /**\n       * @hidden\n       */\n\n      this._collapsible = false;\n      /**\n       * @hidden\n       */\n\n      this._expanded = true;\n      /**\n       * @hidden\n       */\n\n      this._selectable = true;\n      this._calcWidth = null;\n      this._columnPipeArgs = {\n        digitsInfo: DEFAULT_DIGITS_INFO\n      };\n    }\n    /**\n     * Sets/gets the `field` value.\n     * ```typescript\n     * let columnField = this.column.field;\n     * ```\n     * ```html\n     * <igx-column [field] = \"'ID'\"></igx-column>\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    set field(value) {\n      this._field = value;\n      this.hasNestedPath = value === null || value === void 0 ? void 0 : value.includes('.');\n    }\n\n    get field() {\n      return this._field;\n    }\n    /**\n     * Returns if the column is selectable.\n     * ```typescript\n     * let columnSelectable = this.column.selectable;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get selectable() {\n      return this._selectable;\n    }\n    /**\n     * Sets if the column is selectable.\n     * Default value is `true`.\n     * ```html\n     * <igx-column [selectable] = \"false\"></igx-column>\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    set selectable(value) {\n      this._selectable = value;\n    }\n    /**\n     * Gets whether the column is editable.\n     * Default value is `false`.\n     * ```typescript\n     * let isEditable = this.column.editable;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get editable() {\n      // Updating the primary key when grid has transactions (incl. row edit)\n      // should not be allowed, as that can corrupt transaction state.\n      const rowEditable = this.grid && this.grid.rowEditable;\n      const hasTransactions = this.grid && this.grid.transactions.enabled;\n\n      if (this.isPrimaryColumn && (rowEditable || hasTransactions)) {\n        return false;\n      }\n\n      if (this._editable !== undefined) {\n        return this._editable;\n      } else {\n        return rowEditable;\n      }\n    }\n    /**\n     * Sets whether the column is editable.\n     * ```typescript\n     * this.column.editable = true;\n     * ```\n     * ```html\n     * <igx-column [editable] = \"true\"></igx-column>\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    set editable(editable) {\n      this._editable = editable;\n    }\n    /**\n     * Gets a value indicating whether the summary for the column is enabled.\n     * ```typescript\n     * let hasSummary = this.column.hasSummary;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get hasSummary() {\n      return this._hasSummary;\n    }\n    /**\n     * Sets a value indicating whether the summary for the column is enabled.\n     * Default value is `false`.\n     * ```html\n     * <igx-column [hasSummary] = \"true\"></igx-column>\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    set hasSummary(value) {\n      this._hasSummary = value;\n\n      if (this.grid) {\n        this.grid.summaryService.resetSummaryHeight();\n      }\n    }\n    /**\n     * Gets whether the column is hidden.\n     * ```typescript\n     * let isHidden = this.column.hidden;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get hidden() {\n      return this._hidden;\n    }\n    /**\n     * Sets the column hidden property.\n     * Default value is `false`.\n     * ```html\n     * <igx-column [hidden] = \"true\"></igx-column>\n     * ```\n     *\n     * Two-way data binding.\n     * ```html\n     * <igx-column [(hidden)] = \"model.isHidden\"></igx-column>\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    set hidden(value) {\n      if (this._hidden !== value) {\n        this._hidden = value;\n        this.hiddenChange.emit(this._hidden);\n\n        if (this.columnLayoutChild && this.parent.hidden !== value) {\n          this.parent.hidden = value;\n          return;\n        }\n\n        if (this.grid) {\n          this.grid.crudService.endEdit(false);\n          this.grid.summaryService.resetSummaryHeight();\n          this.grid.filteringService.refreshExpressions();\n          this.grid.filteringService.hideFilteringRowOnColumnVisibilityChange(this);\n          this.grid.notifyChanges();\n        }\n      }\n    }\n    /**\n     * Returns if the column is selected.\n     * ```typescript\n     * let isSelected = this.column.selected;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get selected() {\n      return this.grid.selectionService.isColumnSelected(this.field);\n    }\n    /**\n     * Select/deselect a column.\n     * Default value is `false`.\n     * ```typescript\n     * this.column.selected = true;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    set selected(value) {\n      if (this.selectable && value !== this.selected) {\n        if (value) {\n          this.grid.selectionService.selectColumnsWithNoEvent([this.field]);\n        } else {\n          this.grid.selectionService.deselectColumnsWithNoEvent([this.field]);\n        }\n\n        this.grid.notifyChanges();\n      }\n    }\n    /**\n     * Gets the `width` of the column.\n     * ```typescript\n     * let columnWidth = this.column.width;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get width() {\n      return this.widthSetByUser ? this._width : this.defaultWidth;\n    }\n    /**\n     * Sets the `width` of the column.\n     * ```html\n     * <igx-column [width] = \"'25%'\"></igx-column>\n     * ```\n     *\n     * Two-way data binding.\n     * ```html\n     * <igx-column [(width)]=\"model.columns[0].width\"></igx-column>\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    set width(value) {\n      if (value) {\n        this._calcWidth = null;\n        this.calcPixelWidth = NaN;\n        this.widthSetByUser = true; // width could be passed as number from the template\n        // host bindings are not px affixed so we need to ensure we affix simple number strings\n\n        if (typeof value === 'number' || value.match(/^[0-9]*$/)) {\n          value = value + 'px';\n        }\n\n        this._width = value;\n\n        if (this.grid) {\n          this.cacheCalcWidth();\n        }\n\n        this.widthChange.emit(this._width);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get calcWidth() {\n      return this.getCalcWidth();\n    }\n    /**\n     * @hidden\n     */\n\n\n    get maxWidthPx() {\n      const gridAvailableSize = this.grid.calcWidth;\n      const isPercentageWidth = this.maxWidth && typeof this.maxWidth === 'string' && this.maxWidth.indexOf('%') !== -1;\n      return isPercentageWidth ? parseFloat(this.maxWidth) / 100 * gridAvailableSize : parseFloat(this.maxWidth);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get maxWidthPercent() {\n      const gridAvailableSize = this.grid.calcWidth;\n      const isPercentageWidth = this.maxWidth && typeof this.maxWidth === 'string' && this.maxWidth.indexOf('%') !== -1;\n      return isPercentageWidth ? parseFloat(this.maxWidth) : parseFloat(this.maxWidth) / gridAvailableSize * 100;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get minWidthPx() {\n      const gridAvailableSize = this.grid.calcWidth;\n      const isPercentageWidth = this.minWidth && typeof this.minWidth === 'string' && this.minWidth.indexOf('%') !== -1;\n      return isPercentageWidth ? parseFloat(this.minWidth) / 100 * gridAvailableSize : parseFloat(this.minWidth);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get minWidthPercent() {\n      const gridAvailableSize = this.grid.calcWidth;\n      const isPercentageWidth = this.minWidth && typeof this.minWidth === 'string' && this.minWidth.indexOf('%') !== -1;\n      return isPercentageWidth ? parseFloat(this.minWidth) : parseFloat(this.minWidth) / gridAvailableSize * 100;\n    }\n    /**\n     * Sets/gets the minimum `width` of the column.\n     * Default value is `88`;\n     * ```typescript\n     * let columnMinWidth = this.column.minWidth;\n     * ```\n     * ```html\n     * <igx-column [minWidth] = \"'100px'\"></igx-column>\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    set minWidth(value) {\n      const minVal = parseFloat(value);\n\n      if (Number.isNaN(minVal)) {\n        return;\n      }\n\n      this._defaultMinWidth = value;\n    }\n\n    get minWidth() {\n      return !this._defaultMinWidth ? this.defaultMinWidth : this._defaultMinWidth;\n    }\n    /**\n     * Gets the column index.\n     * ```typescript\n     * let columnIndex = this.column.index;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get index() {\n      return this.grid._columns.indexOf(this);\n    }\n    /**\n     * Gets whether the column is `pinned`.\n     * ```typescript\n     * let isPinned = this.column.pinned;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get pinned() {\n      return this._pinned;\n    }\n    /**\n     * Sets whether the column is pinned.\n     * Default value is `false`.\n     * ```html\n     * <igx-column [pinned] = \"true\"></igx-column>\n     * ```\n     *\n     * Two-way data binding.\n     * ```html\n     * <igx-column [(pinned)] = \"model.columns[0].isPinned\"></igx-column>\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    set pinned(value) {\n      if (this._pinned !== value) {\n        if (this.grid && this.width && !isNaN(parseInt(this.width, 10))) {\n          if (value) {\n            this.pin();\n          } else {\n            this.unpin();\n          }\n\n          return;\n        }\n        /* No grid/width available at initialization. `initPinning` in the grid\n           will re-init the group (if present)\n        */\n\n\n        this._pinned = value;\n        this.pinnedChange.emit(this._pinned);\n      }\n    }\n    /**\n     * Gets the column `summaries`.\n     * ```typescript\n     * let columnSummaries = this.column.summaries;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get summaries() {\n      return this._summaries;\n    }\n    /**\n     * Sets the column `summaries`.\n     * ```typescript\n     * this.column.summaries = IgxNumberSummaryOperand;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    set summaries(classRef) {\n      if (isConstructor(classRef)) {\n        this._summaries = new classRef();\n      }\n\n      if (this.grid) {\n        this.grid.summaryService.removeSummariesCachePerColumn(this.field);\n        this.grid.summaryPipeTrigger++;\n        this.grid.summaryService.resetSummaryHeight();\n      }\n    }\n    /**\n     * Gets the column `filters`.\n     * ```typescript\n     * let columnFilters = this.column.filters'\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get filters() {\n      return this._filters;\n    }\n    /**\n     * Sets the column `filters`.\n     * ```typescript\n     * this.column.filters = IgxBooleanFilteringOperand.instance().\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    set filters(instance) {\n      this._filters = instance;\n    }\n    /**\n     * Gets the column `sortStrategy`.\n     * ```typescript\n     * let sortStrategy = this.column.sortStrategy\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get sortStrategy() {\n      return this._sortStrategy;\n    }\n    /**\n     * Sets the column `sortStrategy`.\n     * ```typescript\n     * this.column.sortStrategy = new CustomSortingStrategy().\n     * class CustomSortingStrategy extends SortingStrategy {...}\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    set sortStrategy(classRef) {\n      this._sortStrategy = classRef;\n    }\n    /**\n     * Gets the function that compares values for grouping.\n     * ```typescript\n     * let groupingComparer = this.column.groupingComparer'\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get groupingComparer() {\n      return this._groupingComparer;\n    }\n    /**\n     * Sets a custom function to compare values for grouping.\n     * Subsequent values in the sorted data that the function returns 0 for are grouped.\n     * ```typescript\n     * this.column.groupingComparer = (a: any, b: any) => { return a === b ? 0 : -1; }\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    set groupingComparer(funcRef) {\n      this._groupingComparer = funcRef;\n    }\n    /**\n     * Gets the default minimum `width` of the column.\n     * ```typescript\n     * let defaultMinWidth =  this.column.defaultMinWidth;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get defaultMinWidth() {\n      if (!this.grid) {\n        return '80';\n      }\n\n      switch (this.grid.displayDensity) {\n        case DisplayDensity.cosy:\n          return '64';\n\n        case DisplayDensity.compact:\n          return '56';\n\n        default:\n          return '80';\n      }\n    }\n    /**\n     * Returns a reference to the `summaryTemplate`.\n     * ```typescript\n     * let summaryTemplate = this.column.summaryTemplate;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get summaryTemplate() {\n      return this._summaryTemplate;\n    }\n    /**\n     * Sets the summary template.\n     * ```html\n     * <ng-template #summaryTemplate igxSummary let-summaryResults>\n     *    <p>{{ summaryResults[0].label }}: {{ summaryResults[0].summaryResult }}</p>\n     *    <p>{{ summaryResults[1].label }}: {{ summaryResults[1].summaryResult }}</p>\n     * </ng-template>\n     * ```\n     * ```typescript\n     * @ViewChild(\"'summaryTemplate'\", {read: TemplateRef })\n     * public summaryTemplate: TemplateRef<any>;\n     * this.column.summaryTemplate = this.summaryTemplate;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    set summaryTemplate(template) {\n      this._summaryTemplate = template;\n    }\n    /**\n     * Returns a reference to the `bodyTemplate`.\n     * ```typescript\n     * let bodyTemplate = this.column.bodyTemplate;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get bodyTemplate() {\n      return this._bodyTemplate;\n    }\n    /**\n     * Sets the body template.\n     * ```html\n     * <ng-template #bodyTemplate igxCell let-val>\n     *    <div style = \"background-color: yellowgreen\" (click) = \"changeColor(val)\">\n     *       <span> {{val}} </span>\n     *    </div>\n     * </ng-template>\n     * ```\n     * ```typescript\n     * @ViewChild(\"'bodyTemplate'\", {read: TemplateRef })\n     * public bodyTemplate: TemplateRef<any>;\n     * this.column.bodyTemplate = this.bodyTemplate;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    set bodyTemplate(template) {\n      this._bodyTemplate = template;\n    }\n    /**\n     * Returns a reference to the header template.\n     * ```typescript\n     * let headerTemplate = this.column.headerTemplate;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get headerTemplate() {\n      return this._headerTemplate;\n    }\n    /**\n     * Sets the header template.\n     * Note that the column header height is fixed and any content bigger than it will be cut off.\n     * ```html\n     * <ng-template #headerTemplate>\n     *   <div style = \"background-color:black\" (click) = \"changeColor(val)\">\n     *       <span style=\"color:red\" >{{column.field}}</span>\n     *   </div>\n     * </ng-template>\n     * ```\n     * ```typescript\n     * @ViewChild(\"'headerTemplate'\", {read: TemplateRef })\n     * public headerTemplate: TemplateRef<any>;\n     * this.column.headerTemplate = this.headerTemplate;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    set headerTemplate(template) {\n      this._headerTemplate = template;\n    }\n    /**\n     * Returns a reference to the inline editor template.\n     * ```typescript\n     * let inlineEditorTemplate = this.column.inlineEditorTemplate;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get inlineEditorTemplate() {\n      return this._inlineEditorTemplate;\n    }\n    /**\n     * Sets the inline editor template.\n     * ```html\n     * <ng-template #inlineEditorTemplate igxCellEditor let-cell=\"cell\">\n     *     <input type=\"string\" [(ngModel)]=\"cell.value\"/>\n     * </ng-template>\n     * ```\n     * ```typescript\n     * @ViewChild(\"'inlineEditorTemplate'\", {read: TemplateRef })\n     * public inlineEditorTemplate: TemplateRef<any>;\n     * this.column.inlineEditorTemplate = this.inlineEditorTemplate;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    set inlineEditorTemplate(template) {\n      this._inlineEditorTemplate = template;\n    }\n    /**\n     * Returns a reference to the `filterCellTemplate`.\n     * ```typescript\n     * let filterCellTemplate = this.column.filterCellTemplate;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get filterCellTemplate() {\n      return this._filterCellTemplate;\n    }\n    /**\n     * Sets the quick filter template.\n     * ```html\n     * <ng-template #filterCellTemplate IgxFilterCellTemplate let-column=\"column\">\n     *    <input (input)=\"onInput()\">\n     * </ng-template>\n     * ```\n     * ```typescript\n     * @ViewChild(\"'filterCellTemplate'\", {read: TemplateRef })\n     * public filterCellTemplate: TemplateRef<any>;\n     * this.column.filterCellTemplate = this.filterCellTemplate;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    set filterCellTemplate(template) {\n      this._filterCellTemplate = template;\n    }\n    /**\n     * Gets the cells of the column.\n     * ```typescript\n     * let columnCells = this.column.cells;\n     * ```\n     *\n     */\n\n\n    get cells() {\n      return this.grid.dataView.map((rec, index) => {\n        if (!this.grid.isGroupByRecord(rec) && !this.grid.isSummaryRow(rec)) {\n          this.grid.pagingMode === 1 && this.grid.paginator.page !== 0 ? index = index + this.grid.paginator.perPage * this.grid.paginator.page : index = this.grid.dataRowList.first.index + index;\n          const cell = new IgxGridCell(this.grid, index, this.field);\n          return cell;\n        }\n      }).filter(cell => cell);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get _cells() {\n      return this.grid.rowList.filter(row => row instanceof IgxRowDirective).map(row => {\n        if (row._cells) {\n          return row._cells.filter(cell => cell.columnIndex === this.index);\n        }\n      }).reduce((a, b) => a.concat(b), []);\n    }\n    /**\n     * Gets the column visible index.\n     * If the column is not visible, returns `-1`.\n     * ```typescript\n     * let visibleColumnIndex =  this.column.visibleIndex;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get visibleIndex() {\n      if (!isNaN(this._vIndex)) {\n        return this._vIndex;\n      }\n\n      const unpinnedColumns = this.grid.unpinnedColumns.filter(c => !c.columnGroup);\n      const pinnedColumns = this.grid.pinnedColumns.filter(c => !c.columnGroup);\n      let col = this;\n      let vIndex = -1;\n\n      if (this.columnGroup) {\n        col = this.allChildren.filter(c => !c.columnGroup && !c.hidden)[0];\n      }\n\n      if (this.columnLayoutChild) {\n        return this.parent.childrenVisibleIndexes.find(x => x.column === this).index;\n      }\n\n      if (!this.pinned) {\n        const indexInCollection = unpinnedColumns.indexOf(col);\n        vIndex = indexInCollection === -1 ? -1 : this.grid.isPinningToStart ? pinnedColumns.length + indexInCollection : indexInCollection;\n      } else {\n        const indexInCollection = pinnedColumns.indexOf(col);\n        vIndex = this.grid.isPinningToStart ? indexInCollection : unpinnedColumns.length + indexInCollection;\n      }\n\n      this._vIndex = vIndex;\n      return vIndex;\n    }\n    /**\n     * Returns a boolean indicating if the column is a `ColumnGroup`.\n     * ```typescript\n     * let columnGroup =  this.column.columnGroup;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get columnGroup() {\n      return false;\n    }\n    /**\n     * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.\n     * ```typescript\n     * let columnGroup =  this.column.columnGroup;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get columnLayout() {\n      return false;\n    }\n    /**\n     * Returns a boolean indicating if the column is a child of a `ColumnLayout` for multi-row layout.\n     * ```typescript\n     * let columnLayoutChild =  this.column.columnLayoutChild;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get columnLayoutChild() {\n      return this.parent && this.parent.columnLayout;\n    }\n    /**\n     * Returns the children columns collection.\n     * Returns an empty array if the column does not contain children columns.\n     * ```typescript\n     * let childrenColumns =  this.column.allChildren;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get allChildren() {\n      return [];\n    }\n    /**\n     * Returns the level of the column in a column group.\n     * Returns `0` if the column doesn't have a `parent`.\n     * ```typescript\n     * let columnLevel =  this.column.level;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get level() {\n      let ptr = this.parent;\n      let lvl = 0;\n\n      while (ptr) {\n        lvl++;\n        ptr = ptr.parent;\n      }\n\n      return lvl;\n    }\n\n    get isLastPinned() {\n      return this.grid.isPinningToStart && this.grid.pinnedColumns[this.grid.pinnedColumns.length - 1] === this;\n    }\n\n    get isFirstPinned() {\n      const pinnedCols = this.grid.pinnedColumns.filter(x => !x.columnGroup);\n      return !this.grid.isPinningToStart && pinnedCols[0] === this;\n    }\n\n    get rightPinnedOffset() {\n      return this.pinned && !this.grid.isPinningToStart ? -this.grid.pinnedWidth - this.grid.headerFeaturesWidth + 'px' : null;\n    }\n\n    get gridRowSpan() {\n      return this.rowEnd && this.rowStart ? this.rowEnd - this.rowStart : 1;\n    }\n\n    get gridColumnSpan() {\n      return this.colEnd && this.colStart ? this.colEnd - this.colStart : 1;\n    }\n    /**\n     * Indicates whether the column will be visible when its parent is collapsed.\n     * ```html\n     * <igx-column-group>\n     *   <igx-column [visibleWhenCollapsed]=\"true\"></igx-column>\n     * </igx-column-group>\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    set visibleWhenCollapsed(value) {\n      this._visibleWhenCollapsed = value;\n      this.visibleWhenCollapsedChange.emit(this._visibleWhenCollapsed);\n\n      if (this.parent) {\n        this.parent.setExpandCollapseState();\n      }\n    }\n\n    get visibleWhenCollapsed() {\n      return this._visibleWhenCollapsed;\n    }\n    /**\n     * @remarks\n     * Pass optional parameters for DatePipe and/or DecimalPipe to format the display value for date and numeric columns.\n     * Accepts an `IColumnPipeArgs` object with any of the `format`, `timezone` and `digitsInfo` properties.\n     * For more details see https://angular.io/api/common/DatePipe and https://angular.io/api/common/DecimalPipe\n     * @example\n     * ```typescript\n     * const pipeArgs: IColumnPipeArgs = {\n     *      format: 'longDate',\n     *      timezone: 'UTC',\n     *      digitsInfo: '1.1-2'\n     * }\n     * ```\n     * ```html\n     * <igx-column dataType=\"date\" [pipeArgs]=\"pipeArgs\"></igx-column>\n     * <igx-column dataType=\"number\" [pipeArgs]=\"pipeArgs\"></igx-column>\n     * ```\n     * @memberof IgxColumnComponent\n     */\n\n\n    set pipeArgs(value) {\n      this._columnPipeArgs = Object.assign(this._columnPipeArgs, value);\n      this.grid.summaryService.clearSummaryCache();\n      this.grid.pipeTrigger++;\n    }\n\n    get pipeArgs() {\n      return this._columnPipeArgs;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get collapsible() {\n      return false;\n    }\n\n    set collapsible(_value) {}\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get expanded() {\n      return true;\n    }\n\n    set expanded(_value) {}\n    /**\n     * Returns the filteringExpressionsTree of the column.\n     * ```typescript\n     * let tree =  this.column.filteringExpressionsTree;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get filteringExpressionsTree() {\n      return this.grid.filteringExpressionsTree.find(this.field);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isPrimaryColumn() {\n      return this.field !== undefined && this.grid !== undefined && this.field === this.grid.primaryKey;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    resetCaches() {\n      this._vIndex = NaN;\n\n      if (this.grid) {\n        this.cacheCalcWidth();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      this.destroy$.next(true);\n      this.destroy$.complete();\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterContentInit() {\n      if (this.summaryTemplateDirective) {\n        this._summaryTemplate = this.summaryTemplateDirective.template;\n      }\n\n      if (this.cellTemplate) {\n        this._bodyTemplate = this.cellTemplate.template;\n      }\n\n      if (this.headTemplate && this.headTemplate.length) {\n        this._headerTemplate = this.headTemplate.toArray()[0].template;\n      }\n\n      if (this.editorTemplate) {\n        this._inlineEditorTemplate = this.editorTemplate.template;\n      }\n\n      if (this.filterCellTemplateDirective) {\n        this._filterCellTemplate = this.filterCellTemplateDirective.template;\n      }\n\n      if (!this._columnPipeArgs.format) {\n        this._columnPipeArgs.format = this.dataType === GridColumnDataType.Time ? DEFAULT_TIME_FORMAT : this.dataType === GridColumnDataType.DateTime ? DEFAULT_DATE_TIME_FORMAT : DEFAULT_DATE_FORMAT;\n      }\n\n      if (!this.summaries) {\n        switch (this.dataType) {\n          case GridColumnDataType.String:\n          case GridColumnDataType.Boolean:\n            this.summaries = IgxSummaryOperand;\n            break;\n\n          case GridColumnDataType.Number:\n          case GridColumnDataType.Currency:\n          case GridColumnDataType.Percent:\n            this.summaries = IgxNumberSummaryOperand;\n            break;\n\n          case GridColumnDataType.Date:\n          case GridColumnDataType.DateTime:\n            this.summaries = IgxDateSummaryOperand;\n            break;\n\n          case GridColumnDataType.Time:\n            this.summaries = IgxTimeSummaryOperand;\n            break;\n\n          default:\n            this.summaries = IgxSummaryOperand;\n            break;\n        }\n      }\n\n      if (!this.filters) {\n        switch (this.dataType) {\n          case GridColumnDataType.Boolean:\n            this.filters = IgxBooleanFilteringOperand.instance();\n            break;\n\n          case GridColumnDataType.Number:\n          case GridColumnDataType.Currency:\n          case GridColumnDataType.Percent:\n            this.filters = IgxNumberFilteringOperand.instance();\n            break;\n\n          case GridColumnDataType.Date:\n            this.filters = IgxDateFilteringOperand.instance();\n            break;\n\n          case GridColumnDataType.Time:\n            this.filters = IgxTimeFilteringOperand.instance();\n            break;\n\n          case GridColumnDataType.DateTime:\n            this.filters = IgxDateTimeFilteringOperand.instance();\n            break;\n\n          case GridColumnDataType.String:\n          default:\n            this.filters = IgxStringFilteringOperand.instance();\n            break;\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    getGridTemplate(isRow) {\n      if (isRow) {\n        const rowsCount = !this.grid.isPivot ? this.grid.multiRowLayoutRowSize : this.children.length - 1;\n        return `repeat(${rowsCount},1fr)`;\n      } else {\n        return this.getColumnSizesString(this.children);\n      }\n    }\n\n    getInitialChildColumnSizes(children) {\n      const columnSizes = []; // find the smallest col spans\n\n      children.forEach(col => {\n        if (!col.colStart) {\n          return;\n        }\n\n        const newWidthSet = col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;\n        const newSpanSmaller = columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].colSpan > col.gridColumnSpan;\n        const bothWidthsSet = col.widthSetByUser && columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].widthSetByUser;\n        const bothWidthsNotSet = !col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;\n\n        if (columnSizes[col.colStart - 1] === undefined) {\n          // If nothing is defined yet take any column at first\n          // We use colEnd to know where the column actually ends, because not always it starts where we have it set in columnSizes.\n          columnSizes[col.colStart - 1] = {\n            ref: col,\n            width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,\n            colSpan: col.gridColumnSpan,\n            colEnd: col.colStart + col.gridColumnSpan,\n            widthSetByUser: col.widthSetByUser\n          };\n        } else if (newWidthSet || newSpanSmaller && (bothWidthsSet || bothWidthsNotSet)) {\n          // If a column is set already it should either not have width defined or have width with bigger span than the new one.\n\n          /**\n           *  If replaced column has bigger span, we want to fill the remaining columns\n           *  that the replacing column does not fill with the old one.\n           */\n          if (bothWidthsSet && newSpanSmaller) {\n            // Start from where the new column set would end and apply the old column to the rest depending on how much it spans.\n            // We have not yet replaced it so we can use it directly from the columnSizes collection.\n            // This is where colEnd is used because the colStart of the old column is not actually i + 1.\n            for (let i = col.colStart - 1 + col.gridColumnSpan; i < columnSizes[col.colStart - 1].colEnd - 1; i++) {\n              if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {\n                columnSizes[i] = columnSizes[col.colStart - 1];\n              } else {\n                break;\n              }\n            }\n          } // Replace the old column with the new one.\n\n\n          columnSizes[col.colStart - 1] = {\n            ref: col,\n            width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,\n            colSpan: col.gridColumnSpan,\n            colEnd: col.colStart + col.gridColumnSpan,\n            widthSetByUser: col.widthSetByUser\n          };\n        } else if (bothWidthsSet && columnSizes[col.colStart - 1].colSpan < col.gridColumnSpan) {\n          // If the column already in the columnSizes has smaller span, we still need to fill any empty places with the current col.\n          // Start from where the smaller column set would end and apply the bigger column to the rest depending on how much it spans.\n          // Since here we do not have it in columnSizes we set it as a new column keeping the same colSpan.\n          for (let i = col.colStart - 1 + columnSizes[col.colStart - 1].colSpan; i < col.colStart - 1 + col.gridColumnSpan; i++) {\n            if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {\n              columnSizes[i] = {\n                ref: col,\n                width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,\n                colSpan: col.gridColumnSpan,\n                colEnd: col.colStart + col.gridColumnSpan,\n                widthSetByUser: col.widthSetByUser\n              };\n            } else {\n              break;\n            }\n          }\n        }\n      }); // Flatten columnSizes so there are not columns with colSpan > 1\n\n      for (let i = 0; i < columnSizes.length; i++) {\n        if (columnSizes[i] && columnSizes[i].colSpan > 1) {\n          let j = 1; // Replace all empty places depending on how much the current column spans starting from next col.\n\n          for (; j < columnSizes[i].colSpan && i + j + 1 < columnSizes[i].colEnd; j++) {\n            if (columnSizes[i + j] && (!columnSizes[i].width && columnSizes[i + j].width || !columnSizes[i].width && !columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan || !!columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan)) {\n              // If we reach an already defined column that has width and the current doesn't have or\n              // if the reached column has bigger colSpan we stop.\n              break;\n            } else {\n              const width = columnSizes[i].widthSetByUser ? columnSizes[i].width / columnSizes[i].colSpan : columnSizes[i].width;\n              columnSizes[i + j] = {\n                ref: columnSizes[i].ref,\n                width,\n                colSpan: 1,\n                colEnd: columnSizes[i].colEnd,\n                widthSetByUser: columnSizes[i].widthSetByUser\n              };\n            }\n          } // Update the current column width so it is divided between all columns it spans and set it to 1.\n\n\n          columnSizes[i].width = columnSizes[i].widthSetByUser ? columnSizes[i].width / columnSizes[i].colSpan : columnSizes[i].width;\n          columnSizes[i].colSpan = 1; // Update the index based on how much we have replaced. Subtract 1 because we started from 1.\n\n          i += j - 1;\n        }\n      }\n\n      return columnSizes;\n    }\n\n    getFilledChildColumnSizes(children) {\n      const columnSizes = this.getInitialChildColumnSizes(children); // fill the gaps if there are any\n\n      const result = [];\n\n      for (const size of columnSizes) {\n        if (size && !!size.width) {\n          result.push(size.width + 'px');\n        } else {\n          result.push(parseInt(this.grid.getPossibleColumnWidth(), 10) + 'px');\n        }\n      }\n\n      return result;\n    }\n\n    getResizableColUnderEnd() {\n      if (this.columnLayout || !this.columnLayoutChild || this.columnGroup) {\n        return [{\n          target: this,\n          spanUsed: 1\n        }];\n      }\n\n      const columnSized = this.getInitialChildColumnSizes(this.parent.children);\n      const targets = [];\n      const colEnd = this.colEnd ? this.colEnd : this.colStart + 1;\n\n      for (let i = 0; i < columnSized.length; i++) {\n        if (this.colStart <= i + 1 && i + 1 < colEnd) {\n          targets.push({\n            target: columnSized[i].ref,\n            spanUsed: 1\n          });\n        }\n      }\n\n      const targetsSquashed = [];\n\n      for (const target of targets) {\n        if (targetsSquashed.length && targetsSquashed[targetsSquashed.length - 1].target.field === target.target.field) {\n          targetsSquashed[targetsSquashed.length - 1].spanUsed++;\n        } else {\n          targetsSquashed.push(target);\n        }\n      }\n\n      return targetsSquashed;\n    }\n    /**\n     * Pins the column at the provided index in the pinned area.\n     * Defaults to index `0` if not provided, or to the initial index in the pinned area.\n     * Returns `true` if the column is successfully pinned. Returns `false` if the column cannot be pinned.\n     * Column cannot be pinned if:\n     * - Is already pinned\n     * - index argument is out of range\n     * - The pinned area exceeds 80% of the grid width\n     * ```typescript\n     * let success = this.column.pin();\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    pin(index) {\n      // TODO: Probably should the return type of the old functions\n      // should be moved as a event parameter.\n      const grid = this.grid;\n\n      if (this._pinned) {\n        return false;\n      }\n\n      if (this.parent && !this.parent.pinned) {\n        return this.topLevelParent.pin(index);\n      }\n\n      const hasIndex = index !== undefined;\n\n      if (hasIndex && (index < 0 || index > grid.pinnedColumns.length)) {\n        return false;\n      }\n\n      if (!this.parent && !this.pinnable) {\n        return false;\n      }\n\n      const rootPinnedCols = grid._pinnedColumns.filter(c => c.level === 0);\n\n      index = hasIndex ? index : rootPinnedCols.length;\n      const args = {\n        column: this,\n        insertAtIndex: index,\n        isPinned: false,\n        cancel: false\n      };\n      this.grid.columnPin.emit(args);\n\n      if (args.cancel) {\n        return;\n      }\n\n      this.grid.crudService.endEdit(false);\n      this._pinned = true;\n      this.pinnedChange.emit(this._pinned); // it is possible that index is the last position, so will need to find target column by [index-1]\n\n      const targetColumn = args.insertAtIndex === grid._pinnedColumns.length ? grid._pinnedColumns[args.insertAtIndex - 1] : grid._pinnedColumns[args.insertAtIndex];\n\n      if (grid._pinnedColumns.indexOf(this) === -1) {\n        if (!grid.hasColumnGroups) {\n          grid._pinnedColumns.splice(args.insertAtIndex, 0, this);\n        } else {\n          // insert based only on root collection\n          rootPinnedCols.splice(args.insertAtIndex, 0, this);\n          let allPinned = []; // re-create hierarchy\n\n          rootPinnedCols.forEach(group => {\n            allPinned.push(group);\n            allPinned = allPinned.concat(group.allChildren);\n          });\n          grid._pinnedColumns = allPinned;\n        }\n\n        if (grid._unpinnedColumns.indexOf(this) !== -1) {\n          const childrenCount = this.allChildren.length;\n\n          grid._unpinnedColumns.splice(grid._unpinnedColumns.indexOf(this), 1 + childrenCount);\n        }\n      }\n\n      if (hasIndex) {\n        grid._moveColumns(this, targetColumn);\n      }\n\n      if (this.columnGroup) {\n        this.allChildren.forEach(child => child.pin());\n        grid.reinitPinStates();\n      }\n\n      grid.resetCaches();\n      grid.notifyChanges();\n\n      if (this.columnLayoutChild) {\n        this.grid.columnList.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());\n      }\n\n      this.grid.filteringService.refreshExpressions();\n      const eventArgs = {\n        column: this,\n        insertAtIndex: index,\n        isPinned: true\n      };\n      this.grid.columnPinned.emit(eventArgs);\n      return true;\n    }\n    /**\n     * Unpins the column and place it at the provided index in the unpinned area.\n     * Defaults to index `0` if not provided, or to the initial index in the unpinned area.\n     * Returns `true` if the column is successfully unpinned. Returns `false` if the column cannot be unpinned.\n     * Column cannot be unpinned if:\n     * - Is already unpinned\n     * - index argument is out of range\n     * ```typescript\n     * let success = this.column.unpin();\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    unpin(index) {\n      const grid = this.grid;\n\n      if (!this._pinned) {\n        return false;\n      }\n\n      if (this.parent && this.parent.pinned) {\n        return this.topLevelParent.unpin(index);\n      }\n\n      const hasIndex = index !== undefined;\n\n      if (hasIndex && (index < 0 || index > grid._unpinnedColumns.length)) {\n        return false;\n      } // estimate the exact index at which column will be inserted\n      // takes into account initial unpinned index of the column\n\n\n      if (!hasIndex) {\n        const indices = grid.unpinnedColumns.map(col => col.index);\n        indices.push(this.index);\n        indices.sort((a, b) => a - b);\n        index = indices.indexOf(this.index);\n      }\n\n      const args = {\n        column: this,\n        insertAtIndex: index,\n        isPinned: true,\n        cancel: false\n      };\n      this.grid.columnPin.emit(args);\n\n      if (args.cancel) {\n        return;\n      }\n\n      this.grid.crudService.endEdit(false);\n      this._pinned = false;\n      this.pinnedChange.emit(this._pinned); // it is possible that index is the last position, so will need to find target column by [index-1]\n\n      const targetColumn = args.insertAtIndex === grid._unpinnedColumns.length ? grid._unpinnedColumns[args.insertAtIndex - 1] : grid._unpinnedColumns[args.insertAtIndex];\n\n      if (!hasIndex) {\n        grid._unpinnedColumns.splice(index, 0, this);\n\n        if (grid._pinnedColumns.indexOf(this) !== -1) {\n          grid._pinnedColumns.splice(grid._pinnedColumns.indexOf(this), 1);\n        }\n      }\n\n      if (hasIndex) {\n        grid.moveColumn(this, targetColumn);\n      }\n\n      if (this.columnGroup) {\n        this.allChildren.forEach(child => child.unpin());\n      }\n\n      grid.reinitPinStates();\n      grid.resetCaches();\n      grid.notifyChanges();\n\n      if (this.columnLayoutChild) {\n        this.grid.columnList.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());\n      }\n\n      this.grid.filteringService.refreshExpressions();\n      this.grid.columnPinned.emit({\n        column: this,\n        insertAtIndex: index,\n        isPinned: false\n      });\n      return true;\n    }\n    /**\n     * Moves a column to the specified visible index.\n     * If passed index is invalid, or if column would receive a different visible index after moving, moving is not performed.\n     * If passed index would move the column to a different column group. moving is not performed.\n     *\n     * @example\n     * ```typescript\n     * column.move(index);\n     * ```\n     * @memberof IgxColumnComponent\n     */\n\n\n    move(index) {\n      let target;\n      let columns = this.grid.columnList.filter(c => c.visibleIndex > -1); // grid last visible index\n\n      const li = columns.map(c => c.visibleIndex).reduce((a, b) => Math.max(a, b));\n      const parent = this.parent;\n      const isPreceding = this.visibleIndex < index;\n\n      if (index === this.visibleIndex || index < 0 || index > li) {\n        return;\n      }\n\n      if (parent) {\n        columns = columns.filter(c => c.level >= this.level && c !== this && c.parent !== this && c.topLevelParent === this.topLevelParent);\n      }\n      /* eslint-disable max-len */\n      // If isPreceding, find a target such that when the current column is placed after it, current colummn will receive a visibleIndex === index. This takes into account visible children of the columns.\n      // If !isPreceding, finds a column of the same level and visible index that equals the passed index agument (c.visibleIndex === index). No need to consider the children here.\n\n      /* eslint-enable max-len */\n\n\n      if (isPreceding) {\n        columns = columns.filter(c => c.visibleIndex > this.visibleIndex);\n        target = columns.find(c => c.level === this.level && c.visibleIndex + c.calcChildren() - this.calcChildren() === index);\n      } else {\n        columns = columns.filter(c => c.visibleIndex < this.visibleIndex);\n        target = columns.find(c => c.level === this.level && c.visibleIndex === index);\n      }\n\n      if (!target || target.pinned && this.disablePinning) {\n        return;\n      }\n\n      const pos = isPreceding ? DropPosition.AfterDropTarget : DropPosition.BeforeDropTarget;\n      this.grid.moveColumn(this, target, pos);\n    }\n    /**\n     * No children for the column, so will returns 1 or 0, if the column is hidden.\n     *\n     * @hidden\n     */\n\n\n    calcChildren() {\n      const children = this.hidden ? 0 : 1;\n      return children;\n    }\n    /**\n     * Toggles column vibisility and emits the respective event.\n     *\n     * @hidden\n     */\n\n\n    toggleVisibility(value) {\n      const newValue = value !== null && value !== void 0 ? value : !this.hidden;\n      const eventArgs = {\n        column: this,\n        newValue,\n        cancel: false\n      };\n      this.grid.columnVisibilityChanging.emit(eventArgs);\n\n      if (eventArgs.cancel) {\n        return;\n      }\n\n      this.hidden = newValue;\n      this.grid.columnVisibilityChanged.emit({\n        column: this,\n        newValue\n      });\n    }\n    /**\n     * Returns a reference to the top level parent column.\n     * ```typescript\n     * let topLevelParent =  this.column.topLevelParent;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get topLevelParent() {\n      let parent = this.parent;\n\n      while (parent && parent.parent) {\n        parent = parent.parent;\n      }\n\n      return parent;\n    }\n    /**\n     * Returns a reference to the header of the column.\n     * ```typescript\n     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];\n     * let headerCell = column.headerCell;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get headerCell() {\n      return this.grid.headerCellList.find(header => header.column === this);\n    }\n    /**\n     * Returns a reference to the filter cell of the column.\n     * ```typescript\n     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];\n     * let filterell = column.filterell;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get filterCell() {\n      return this.grid.filterCellList.find(filterCell => filterCell.column === this);\n    }\n    /**\n     * Returns a reference to the header group of the column.\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get headerGroup() {\n      return this.grid.headerGroupsList.find(group => group.column === this);\n    }\n    /**\n     * Autosize the column to the longest currently visible cell value, including the header cell.\n     * ```typescript\n     * @ViewChild('grid') grid: IgxGridComponent;\n     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];\n     * column.autosize();\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     * @param byHeaderOnly Set if column should be autosized based only on the header content.\n     */\n\n\n    autosize(byHeaderOnly = false) {\n      if (!this.columnGroup) {\n        this.width = this.getAutoSize(byHeaderOnly);\n        this.grid.reflow();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    getAutoSize(byHeader = false) {\n      const size = !byHeader ? this.getLargestCellWidth() : Object.values(this.getHeaderCellWidths()).reduce((a, b) => a + b) + 'px';\n      const isPercentageWidth = this.width && typeof this.width === 'string' && this.width.indexOf('%') !== -1;\n      let newWidth;\n\n      if (isPercentageWidth) {\n        const gridAvailableSize = this.grid.calcWidth;\n        const percentageSize = parseFloat(size) / gridAvailableSize * 100;\n        newWidth = percentageSize + '%';\n      } else {\n        newWidth = size;\n      }\n\n      const maxWidth = isPercentageWidth ? this.maxWidthPercent : this.maxWidthPx;\n      const minWidth = isPercentageWidth ? this.minWidthPercent : this.minWidthPx;\n\n      if (this.maxWidth && parseFloat(newWidth) > maxWidth) {\n        newWidth = isPercentageWidth ? maxWidth + '%' : maxWidth + 'px';\n      } else if (parseFloat(newWidth) < minWidth) {\n        newWidth = isPercentageWidth ? minWidth + '%' : minWidth + 'px';\n      }\n\n      return newWidth;\n    }\n    /**\n     * @hidden\n     */\n\n\n    getCalcWidth() {\n      if (this._calcWidth && !isNaN(this.calcPixelWidth)) {\n        return this._calcWidth;\n      }\n\n      this.cacheCalcWidth();\n      return this._calcWidth;\n    }\n    /**\n     * @hidden\n     * Returns the width and padding of a header cell.\n     */\n\n\n    getHeaderCellWidths() {\n      return this.grid.getHeaderCellWidth(this.headerCell.nativeElement);\n    }\n    /**\n     * @hidden\n     * Returns the size (in pixels) of the longest currently visible cell, including the header cell.\n     * ```typescript\n     * @ViewChild('grid') grid: IgxGridComponent;\n     *\n     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];\n     * let size = column.getLargestCellWidth();\n     * ```\n     * @memberof IgxColumnComponent\n     */\n\n\n    getLargestCellWidth() {\n      const range = this.grid.document.createRange();\n      const largest = new Map();\n\n      if (this._cells.length > 0) {\n        const cellsContentWidths = [];\n\n        this._cells.forEach(cell => cellsContentWidths.push(cell.calculateSizeToFit(range)));\n\n        const index = cellsContentWidths.indexOf(Math.max(...cellsContentWidths));\n        const cellStyle = this.grid.document.defaultView.getComputedStyle(this._cells[index].nativeElement);\n        const cellPadding = parseFloat(cellStyle.paddingLeft) + parseFloat(cellStyle.paddingRight) + parseFloat(cellStyle.borderLeftWidth) + parseFloat(cellStyle.borderRightWidth);\n        largest.set(Math.max(...cellsContentWidths), cellPadding);\n      }\n\n      if (this.headerCell && this.autosizeHeader) {\n        const headerCellWidths = this.getHeaderCellWidths();\n        largest.set(headerCellWidths.width, headerCellWidths.padding);\n      }\n\n      const largestCell = Math.max(...Array.from(largest.keys()));\n      const width = Math.ceil(largestCell + largest.get(largestCell));\n\n      if (Number.isNaN(width)) {\n        return this.width;\n      } else {\n        return width + 'px';\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    getCellWidth() {\n      const colWidth = this.width;\n      const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;\n\n      if (this.columnLayoutChild) {\n        return '';\n      }\n\n      if (colWidth && !isPercentageWidth) {\n        let cellWidth = colWidth;\n\n        if (typeof cellWidth !== 'string' || cellWidth.endsWith('px') === false) {\n          cellWidth += 'px';\n        }\n\n        return cellWidth;\n      } else {\n        return colWidth;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    populateVisibleIndexes() {}\n\n    getColumnSizesString(children) {\n      const res = this.getFilledChildColumnSizes(children);\n      return res.join(' ');\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    cacheCalcWidth() {\n      const colWidth = this.width;\n      const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;\n\n      if (isPercentageWidth) {\n        this._calcWidth = parseFloat(colWidth) / 100 * this.grid.calcWidth;\n      } else if (!colWidth) {\n        // no width\n        this._calcWidth = this.defaultWidth || this.grid.getPossibleColumnWidth();\n      } else {\n        this._calcWidth = this.width;\n      }\n\n      this.calcPixelWidth = parseFloat(this._calcWidth);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    setExpandCollapseState() {\n      this.children.filter(col => col.visibleWhenCollapsed !== undefined).forEach(c => {\n        if (!this.collapsible) {\n          c.hidden = this.hidden;\n          return;\n        }\n\n        c.hidden = this._expanded ? c.visibleWhenCollapsed : !c.visibleWhenCollapsed;\n      });\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    checkCollapsibleState() {\n      if (!this.children) {\n        return false;\n      }\n\n      const cols = this.children.map(child => child.visibleWhenCollapsed);\n      return cols.some(c => c === true) && cols.some(c => c === false);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get pinnable() {\n      return this.grid._init || !this.pinned;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get applySelectableClass() {\n      return this._applySelectableClass;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set applySelectableClass(value) {\n      if (this.selectable) {\n        this._applySelectableClass = value;\n      }\n    }\n\n  }\n\n  IgxColumnComponent.ɵfac = function IgxColumnComponent_Factory(t) {\n    return new (t || IgxColumnComponent)(i0.ɵɵdirectiveInject(IGX_GRID_BASE), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxColumnComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxColumnComponent,\n    selectors: [[\"igx-column\"]],\n    contentQueries: function IgxColumnComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxFilterCellTemplateDirective, 5, IgxFilterCellTemplateDirective);\n        i0.ɵɵcontentQuery(dirIndex, IgxSummaryTemplateDirective, 5, IgxSummaryTemplateDirective);\n        i0.ɵɵcontentQuery(dirIndex, IgxCellTemplateDirective, 5, IgxCellTemplateDirective);\n        i0.ɵɵcontentQuery(dirIndex, IgxCellEditorTemplateDirective, 5, IgxCellEditorTemplateDirective);\n        i0.ɵɵcontentQuery(dirIndex, IgxCollapsibleIndicatorTemplateDirective, 5, IgxCollapsibleIndicatorTemplateDirective);\n        i0.ɵɵcontentQuery(dirIndex, IgxCellHeaderTemplateDirective, 4, IgxCellHeaderTemplateDirective);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.filterCellTemplateDirective = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.summaryTemplateDirective = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.editorTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.collapseIndicatorTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headTemplate = _t);\n      }\n    },\n    inputs: {\n      field: \"field\",\n      header: \"header\",\n      title: \"title\",\n      sortable: \"sortable\",\n      selectable: \"selectable\",\n      groupable: \"groupable\",\n      editable: \"editable\",\n      filterable: \"filterable\",\n      resizable: \"resizable\",\n      autosizeHeader: \"autosizeHeader\",\n      hasSummary: \"hasSummary\",\n      hidden: \"hidden\",\n      disableHiding: \"disableHiding\",\n      disablePinning: \"disablePinning\",\n      movable: \"movable\",\n      width: \"width\",\n      maxWidth: \"maxWidth\",\n      headerClasses: \"headerClasses\",\n      headerStyles: \"headerStyles\",\n      headerGroupClasses: \"headerGroupClasses\",\n      headerGroupStyles: \"headerGroupStyles\",\n      cellClasses: \"cellClasses\",\n      cellStyles: \"cellStyles\",\n      formatter: \"formatter\",\n      summaryFormatter: \"summaryFormatter\",\n      filteringIgnoreCase: \"filteringIgnoreCase\",\n      sortingIgnoreCase: \"sortingIgnoreCase\",\n      searchable: \"searchable\",\n      dataType: \"dataType\",\n      collapsibleIndicatorTemplate: \"collapsibleIndicatorTemplate\",\n      rowEnd: \"rowEnd\",\n      colEnd: \"colEnd\",\n      rowStart: \"rowStart\",\n      colStart: \"colStart\",\n      additionalTemplateContext: \"additionalTemplateContext\",\n      minWidth: \"minWidth\",\n      pinned: \"pinned\",\n      summaries: \"summaries\",\n      filters: \"filters\",\n      sortStrategy: \"sortStrategy\",\n      groupingComparer: \"groupingComparer\",\n      summaryTemplate: \"summaryTemplate\",\n      bodyTemplate: [\"cellTemplate\", \"bodyTemplate\"],\n      headerTemplate: \"headerTemplate\",\n      inlineEditorTemplate: [\"cellEditorTemplate\", \"inlineEditorTemplate\"],\n      filterCellTemplate: \"filterCellTemplate\",\n      visibleWhenCollapsed: \"visibleWhenCollapsed\",\n      pipeArgs: \"pipeArgs\"\n    },\n    outputs: {\n      hiddenChange: \"hiddenChange\",\n      expandedChange: \"expandedChange\",\n      collapsibleChange: \"collapsibleChange\",\n      visibleWhenCollapsedChange: \"visibleWhenCollapsedChange\",\n      columnChange: \"columnChange\",\n      widthChange: \"widthChange\",\n      pinnedChange: \"pinnedChange\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function IgxColumnComponent_Template(rf, ctx) {},\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  __decorate([notifyChanges(), WatchColumnChanges()], IgxColumnComponent.prototype, \"header\", void 0);\n\n  __decorate([notifyChanges(), WatchColumnChanges()], IgxColumnComponent.prototype, \"title\", void 0);\n\n  __decorate([WatchColumnChanges()], IgxColumnComponent.prototype, \"sortable\", void 0);\n\n  __decorate([WatchColumnChanges()], IgxColumnComponent.prototype, \"selectable\", null);\n\n  __decorate([notifyChanges(true), WatchColumnChanges()], IgxColumnComponent.prototype, \"groupable\", void 0);\n\n  __decorate([WatchColumnChanges()], IgxColumnComponent.prototype, \"editable\", null);\n\n  __decorate([notifyChanges(), WatchColumnChanges()], IgxColumnComponent.prototype, \"filterable\", void 0);\n\n  __decorate([WatchColumnChanges()], IgxColumnComponent.prototype, \"resizable\", void 0);\n\n  __decorate([WatchColumnChanges()], IgxColumnComponent.prototype, \"autosizeHeader\", void 0);\n\n  __decorate([notifyChanges(true), WatchColumnChanges()], IgxColumnComponent.prototype, \"hasSummary\", null);\n\n  __decorate([notifyChanges(true), WatchColumnChanges()], IgxColumnComponent.prototype, \"hidden\", null);\n\n  __decorate([notifyChanges(), WatchColumnChanges()], IgxColumnComponent.prototype, \"disableHiding\", void 0);\n\n  __decorate([notifyChanges(), WatchColumnChanges()], IgxColumnComponent.prototype, \"disablePinning\", void 0);\n\n  __decorate([notifyChanges(true), WatchColumnChanges()], IgxColumnComponent.prototype, \"width\", null);\n\n  __decorate([WatchColumnChanges()], IgxColumnComponent.prototype, \"maxWidth\", void 0);\n\n  __decorate([notifyChanges(), WatchColumnChanges()], IgxColumnComponent.prototype, \"headerClasses\", void 0);\n\n  __decorate([notifyChanges(), WatchColumnChanges()], IgxColumnComponent.prototype, \"headerStyles\", void 0);\n\n  __decorate([notifyChanges(), WatchColumnChanges()], IgxColumnComponent.prototype, \"headerGroupClasses\", void 0);\n\n  __decorate([notifyChanges(), WatchColumnChanges()], IgxColumnComponent.prototype, \"headerGroupStyles\", void 0);\n\n  __decorate([notifyChanges(), WatchColumnChanges()], IgxColumnComponent.prototype, \"cellClasses\", void 0);\n\n  __decorate([notifyChanges(), WatchColumnChanges()], IgxColumnComponent.prototype, \"cellStyles\", void 0);\n\n  __decorate([notifyChanges(), WatchColumnChanges()], IgxColumnComponent.prototype, \"formatter\", void 0);\n\n  __decorate([notifyChanges(), WatchColumnChanges()], IgxColumnComponent.prototype, \"summaryFormatter\", void 0);\n\n  __decorate([WatchColumnChanges()], IgxColumnComponent.prototype, \"filteringIgnoreCase\", void 0);\n\n  __decorate([WatchColumnChanges()], IgxColumnComponent.prototype, \"sortingIgnoreCase\", void 0);\n\n  __decorate([notifyChanges(), WatchColumnChanges()], IgxColumnComponent.prototype, \"searchable\", void 0);\n\n  __decorate([notifyChanges(), WatchColumnChanges()], IgxColumnComponent.prototype, \"minWidth\", null);\n\n  __decorate([WatchColumnChanges()], IgxColumnComponent.prototype, \"pinned\", null);\n\n  __decorate([notifyChanges(true), WatchColumnChanges()], IgxColumnComponent.prototype, \"summaries\", null);\n\n  __decorate([notifyChanges(), WatchColumnChanges()], IgxColumnComponent.prototype, \"summaryTemplate\", null);\n\n  __decorate([notifyChanges(), WatchColumnChanges()], IgxColumnComponent.prototype, \"bodyTemplate\", null);\n\n  __decorate([notifyChanges(), WatchColumnChanges()], IgxColumnComponent.prototype, \"headerTemplate\", null);\n\n  __decorate([notifyChanges(), WatchColumnChanges()], IgxColumnComponent.prototype, \"inlineEditorTemplate\", null);\n\n  __decorate([notifyChanges(), WatchColumnChanges()], IgxColumnComponent.prototype, \"filterCellTemplate\", null);\n\n  __decorate([notifyChanges(true)], IgxColumnComponent.prototype, \"visibleWhenCollapsed\", null);\n\n  __decorate([notifyChanges(), WatchColumnChanges()], IgxColumnComponent.prototype, \"pipeArgs\", null);\n\n  return IgxColumnComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The `<igx-select-item>` is a container intended for row items in\n * a `<igx-select>` container.\n */\n\n\nlet IgxSelectGroupComponent = /*#__PURE__*/(() => {\n  class IgxSelectGroupComponent extends IgxDropDownGroupComponent {}\n\n  IgxSelectGroupComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxSelectGroupComponent_BaseFactory;\n    return function IgxSelectGroupComponent_Factory(t) {\n      return (ɵIgxSelectGroupComponent_BaseFactory || (ɵIgxSelectGroupComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxSelectGroupComponent)))(t || IgxSelectGroupComponent);\n    };\n  }();\n\n  IgxSelectGroupComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxSelectGroupComponent,\n    selectors: [[\"igx-select-item-group\"]],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c133,\n    decls: 3,\n    vars: 2,\n    consts: [[3, \"id\"]],\n    template: function IgxSelectGroupComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c132);\n        i0.ɵɵelementStart(0, \"label\", 0);\n        i0.ɵɵtext(1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵprojection(2);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵpropertyInterpolate(\"id\", ctx.labelId);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx.label);\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxSelectGroupComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxSelectModule = /*#__PURE__*/(() => {\n  class IgxSelectModule {}\n\n  IgxSelectModule.ɵfac = function IgxSelectModule_Factory(t) {\n    return new (t || IgxSelectModule)();\n  };\n\n  IgxSelectModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxSelectModule\n  });\n  IgxSelectModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [],\n    imports: [[CommonModule, FormsModule, IgxButtonModule, IgxDropDownModule, IgxIconModule, IgxInputGroupModule, IgxRippleModule, IgxToggleModule, ReactiveFormsModule], IgxInputGroupModule]\n  });\n  return IgxSelectModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxColumnGroupComponent = /*#__PURE__*/(() => {\n  class IgxColumnGroupComponent extends IgxColumnComponent {\n    constructor() {\n      super(...arguments);\n      this.children = new QueryList();\n      /**\n       * Sets/gets whether the column group is `searchable`.\n       * Default value is `true`.\n       * ```typescript\n       * let isSearchable =  this.columnGroup.searchable;\n       * ```\n       * ```html\n       *  <igx-column-group [searchable] = \"false\"></igx-column-group>\n       * ```\n       *\n       * @memberof IgxColumnGroupComponent\n       */\n\n      this.searchable = true;\n      /**\n       * @hidden\n       */\n\n      this.hiddenChange = new EventEmitter();\n    }\n    /**\n     * Set if the column group is collapsible.\n     * Default value is `false`\n     * ```html\n     *  <igx-column-group [collapsible] = \"true\"></igx-column-group>\n     * ```\n     *\n     * @memberof IgxColumnGroupComponent\n     */\n\n\n    set collapsible(value) {\n      this._collapsible = value;\n      this.collapsibleChange.emit(this._collapsible);\n\n      if (this.children && !this.hidden) {\n        if (this._collapsible) {\n          this.setExpandCollapseState();\n        } else {\n          this.children.forEach(child => child.hidden = false);\n        }\n      }\n    }\n\n    get collapsible() {\n      return this._collapsible && this.checkCollapsibleState();\n    }\n    /**\n     * Set whether the group is expanded or collapsed initially.\n     * Applied only if the collapsible property is set to `true`\n     * Default value is `true`\n     * ```html\n     *  const state = false\n     *  <igx-column-group [(expand)] = \"state\"></igx-column-group>\n     * ```\n     *\n     * @memberof IgxColumnGroupComponent\n     */\n\n\n    set expanded(value) {\n      this._expanded = value;\n      this.expandedChange.emit(this._expanded);\n\n      if (!this.collapsible) {\n        return;\n      }\n\n      if (!this.hidden && this.children) {\n        this.setExpandCollapseState();\n      }\n    }\n\n    get expanded() {\n      return this._expanded;\n    }\n    /**\n     * Gets the column group `summaries`.\n     * ```typescript\n     * let columnGroupSummaries = this.columnGroup.summaries;\n     * ```\n     *\n     * @memberof IgxColumnGroupComponent\n     */\n\n\n    get summaries() {\n      return this._summaries;\n    }\n    /**\n     * Sets the column group `summaries`.\n     * ```typescript\n     * this.columnGroup.summaries = IgxNumberSummaryOperand;\n     * ```\n     *\n     * @memberof IgxColumnGroupComponent\n     */\n\n\n    set summaries(classRef) {}\n    /**\n     * Gets the column group `filters`.\n     * ```typescript\n     * let columnGroupFilters = this.columnGroup.filters;\n     * ```\n     *\n     * @memberof IgxColumnGroupComponent\n     */\n\n\n    get filters() {\n      return this._filters;\n    }\n    /**\n     * Sets the column group `filters`.\n     * ```typescript\n     * this.columnGroup.filters = IgxStringFilteringOperand;\n     * ```\n     *\n     * @memberof IgxColumnGroupComponent\n     */\n\n\n    set filters(classRef) {}\n    /**\n     * Returns if the column group is selectable\n     * ```typescript\n     * let columnGroupSelectable = this.columnGroup.selectable;\n     * ```\n     *\n     * @memberof IgxColumnGroupComponent\n     */\n\n\n    get selectable() {\n      return this.children && this.children.some(child => child.selectable);\n    }\n\n    set selectable(value) {}\n    /**\n     * Returns a reference to the body template.\n     * ```typescript\n     * let bodyTemplate = this.columnGroup.bodyTemplate;\n     * ```\n     *\n     * @memberof IgxColumnGroupComponent\n     */\n\n\n    get bodyTemplate() {\n      return this._bodyTemplate;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set bodyTemplate(template) {}\n    /**\n     * Returns a reference to the inline editor template.\n     * ```typescript\n     * let inlineEditorTemplate = this.columnGroup.inlineEditorTemplate;\n     * ```\n     *\n     * @memberof IgxColumnGroupComponent\n     */\n\n\n    get inlineEditorTemplate() {\n      return this._inlineEditorTemplate;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set inlineEditorTemplate(template) {}\n    /**\n     * Will return empty array. Use this.children.toArray()[index].cells to get the cells for a column that is part of the column group.\n     * ```typescript\n     * let columnCells = this.columnGroup.cells;\n     * ```\n     *\n     * @memberof IgxColumnGroupComponent\n     */\n\n\n    get cells() {\n      return [];\n    }\n    /**\n     * Gets whether the column group is hidden.\n     * ```typescript\n     * let isHidden = this.columnGroup.hidden;\n     * ```\n     *\n     * @memberof IgxColumnGroupComponent\n     */\n\n\n    get hidden() {\n      return this.allChildren.every(c => c.hidden);\n    }\n    /**\n     * Sets the column group hidden property.\n     * ```html\n     * <igx-column [hidden] = \"true\"></igx-column>\n     * ```\n     *\n     * Two-way data binding\n     * ```html\n     * <igx-column [(hidden)] = \"model.columns[0].isHidden\"></igx-column>\n     * ```\n     *\n     * @memberof IgxColumnGroupComponent\n     */\n\n\n    set hidden(value) {\n      this._hidden = value;\n      this.hiddenChange.emit(this._hidden);\n\n      if (this._hidden || !this.collapsible) {\n        this.children.forEach(child => child.hidden = this._hidden);\n      } else {\n        this.children.forEach(c => {\n          if (c.visibleWhenCollapsed === undefined) {\n            c.hidden = false;\n            return;\n          }\n\n          c.hidden = this.expanded ? c.visibleWhenCollapsed : !c.visibleWhenCollapsed;\n        });\n      }\n    }\n    /**\n     * Returns if the column group is selected.\n     * ```typescript\n     * let isSelected = this.columnGroup.selected;\n     * ```\n     *\n     * @memberof IgxColumnGroupComponent\n     */\n\n\n    get selected() {\n      const selectableChildren = this.allChildren.filter(c => !c.columnGroup && c.selectable && !c.hidden);\n      return selectableChildren.length > 0 && selectableChildren.every(c => c.selected);\n    }\n    /**\n     * Select/deselect the column group.\n     * ```typescript\n     * this.columnGroup.selected = true;\n     * ```\n     *\n     * @memberof IgxColumnGroupComponent\n     */\n\n\n    set selected(value) {\n      if (this.selectable) {\n        this.children.forEach(c => {\n          c.selected = value;\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterContentInit() {\n      /*\n          @ContentChildren with descendants still returns the `parent`\n          component in the query list.\n      */\n      if (this.headTemplate && this.headTemplate.length) {\n        this._headerTemplate = this.headTemplate.toArray()[0].template;\n      }\n\n      if (this.collapseIndicatorTemplate) {\n        this.collapsibleIndicatorTemplate = this.collapseIndicatorTemplate.template;\n      } // currently only ivy fixes the issue, we have to slice only if the first child is group\n\n\n      if (this.children.first === this) {\n        this.children.reset(this.children.toArray().slice(1));\n      }\n\n      this.children.forEach(child => {\n        child.parent = this;\n      });\n\n      if (this.collapsible) {\n        this.setExpandCollapseState();\n      }\n    }\n    /**\n     * Returns the children columns collection.\n     * ```typescript\n     * let columns =  this.columnGroup.allChildren;\n     * ```\n     *\n     * @memberof IgxColumnGroupComponent\n     */\n\n\n    get allChildren() {\n      return flatten$1(this.children.toArray());\n    }\n    /**\n     * Returns a boolean indicating if the column is a `ColumnGroup`.\n     * ```typescript\n     * let isColumnGroup =  this.columnGroup.columnGroup\n     * ```\n     *\n     * @memberof IgxColumnGroupComponent\n     */\n\n\n    get columnGroup() {\n      return true;\n    }\n    /**\n     * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.\n     * ```typescript\n     * let columnGroup =  this.column.columnGroup;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get columnLayout() {\n      return false;\n    }\n    /**\n     * Gets the width of the column group.\n     * ```typescript\n     * let columnGroupWidth = this.columnGroup.width;\n     * ```\n     *\n     * @memberof IgxColumnGroupComponent\n     */\n\n\n    get width() {\n      const width = `${this.children.reduce((acc, val) => {\n        if (val.hidden) {\n          return acc;\n        }\n\n        return acc + parseInt(val.calcWidth, 10);\n      }, 0)}`;\n      return width + 'px';\n    }\n\n    set width(val) {}\n    /**\n     * @hidden\n     */\n\n\n    get applySelectableClass() {\n      return this._applySelectableClass;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set applySelectableClass(value) {\n      if (this.selectable) {\n        this._applySelectableClass = value;\n        this.children.forEach(c => {\n          c.applySelectableClass = value;\n        });\n      }\n    }\n    /**\n     * @hidden\n     * Calculates the number of visible columns, based on indexes of first and last visible columns.\n     */\n\n\n    calcChildren() {\n      const visibleChildren = this.allChildren.filter(c => c.visibleIndex > -1);\n      const fi = visibleChildren[0].visibleIndex;\n      const li = visibleChildren[visibleChildren.length - 1].visibleIndex;\n      return li - fi + 1;\n    }\n\n  }\n\n  IgxColumnGroupComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxColumnGroupComponent_BaseFactory;\n    return function IgxColumnGroupComponent_Factory(t) {\n      return (ɵIgxColumnGroupComponent_BaseFactory || (ɵIgxColumnGroupComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxColumnGroupComponent)))(t || IgxColumnGroupComponent);\n    };\n  }();\n\n  IgxColumnGroupComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxColumnGroupComponent,\n    selectors: [[\"igx-column-group\"]],\n    contentQueries: function IgxColumnGroupComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxColumnComponent, 4, IgxColumnComponent);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.children = _t);\n      }\n    },\n    inputs: {\n      collapsible: \"collapsible\",\n      expanded: \"expanded\",\n      summaries: \"summaries\",\n      searchable: \"searchable\",\n      filters: \"filters\",\n      collapsibleIndicatorTemplate: \"collapsibleIndicatorTemplate\",\n      hidden: \"hidden\"\n    },\n    outputs: {\n      hiddenChange: \"hiddenChange\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxColumnComponent,\n      useExisting: forwardRef(() => IgxColumnGroupComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function IgxColumnGroupComponent_Template(rf, ctx) {},\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxColumnGroupComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridBodyDirective = /*#__PURE__*/(() => {\n  class IgxGridBodyDirective {}\n\n  IgxGridBodyDirective.ɵfac = function IgxGridBodyDirective_Factory(t) {\n    return new (t || IgxGridBodyDirective)();\n  };\n\n  IgxGridBodyDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxGridBodyDirective,\n    selectors: [[\"\", \"igxGridBody\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([IgxForOfSyncService])]\n  });\n  return IgxGridBodyDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nclass RowEditPositionStrategy extends ConnectedPositioningStrategy {\n  constructor() {\n    super(...arguments);\n    this.isTop = false;\n    this.isTopInitialPosition = null;\n  }\n\n  position(contentElement, size, document, initialCall, target) {\n    const container = this.settings.container; // grid.tbody\n\n    const targetElement = target || this.settings.target; // current grid.row\n    // Position of the overlay depends on the available space in the grid.\n    // If the bottom space is not enough then the the row overlay will show at the top of the row.\n    // Once shown, either top or bottom, then this position stays until the overlay is closed (isTopInitialPosition property),\n    // which means that when scrolling then overlay may hide, while the row is still visible (UX requirement).\n\n    this.isTop = this.isTopInitialPosition !== null ? this.isTopInitialPosition : container.getBoundingClientRect().bottom < targetElement.getBoundingClientRect().bottom + contentElement.getBoundingClientRect().height; // Set width of the row editing overlay to equal row width, otherwise it fits 100% of the grid.\n\n    contentElement.style.width = targetElement.clientWidth + 'px';\n    this.settings.verticalStartPoint = this.settings.verticalDirection = this.isTop ? VerticalAlignment.Top : VerticalAlignment.Bottom;\n    this.settings.openAnimation = this.isTop ? scaleInVerBottom : scaleInVerTop;\n    super.position(contentElement, {\n      width: targetElement.clientWidth,\n      height: targetElement.clientHeight\n    }, document, initialCall, targetElement);\n  }\n\n} // eslint-disable-next-line @angular-eslint/directive-selector\n\n\nlet IgxExcelTextDirective = /*#__PURE__*/(() => {\n  class IgxExcelTextDirective {}\n\n  IgxExcelTextDirective.ɵfac = function IgxExcelTextDirective_Factory(t) {\n    return new (t || IgxExcelTextDirective)();\n  };\n\n  IgxExcelTextDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxExcelTextDirective,\n    selectors: [[\"\", \"excelText\", \"\"], [\"excel-text\"]]\n  });\n  return IgxExcelTextDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // eslint-disable-next-line @angular-eslint/directive-selector\n\n\nlet IgxCSVTextDirective = /*#__PURE__*/(() => {\n  class IgxCSVTextDirective {}\n\n  IgxCSVTextDirective.ɵfac = function IgxCSVTextDirective_Factory(t) {\n    return new (t || IgxCSVTextDirective)();\n  };\n\n  IgxCSVTextDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxCSVTextDirective,\n    selectors: [[\"\", \"csvText\", \"\"], [\"csv-text\"]]\n  });\n  return IgxCSVTextDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Provides a way to template the title portion of the toolbar in the grid.\n *\n * @igxModule IgxGridToolbarModule\n * @igxParent IgxGridToolbarComponent\n *\n * @example\n * ```html\n * <igx-grid-toolbar-title>My custom title</igx-grid-toolbar-title>\n * ```\n */\n\n\nlet IgxGridToolbarTitleDirective = /*#__PURE__*/(() => {\n  class IgxGridToolbarTitleDirective {\n    constructor() {\n      /**\n       * Host `class.igx-grid-toolbar__title` binding.\n       *\n       * @hidden\n       * @internal\n       */\n      this.cssClass = 'igx-grid-toolbar__title';\n    }\n\n  }\n\n  IgxGridToolbarTitleDirective.ɵfac = function IgxGridToolbarTitleDirective_Factory(t) {\n    return new (t || IgxGridToolbarTitleDirective)();\n  };\n\n  IgxGridToolbarTitleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxGridToolbarTitleDirective,\n    selectors: [[\"\", \"igxGridToolbarTitle\", \"\"], [\"igx-grid-toolbar-title\"]],\n    hostVars: 2,\n    hostBindings: function IgxGridToolbarTitleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-grid-toolbar__title\", ctx.cssClass);\n      }\n    }\n  });\n  return IgxGridToolbarTitleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Provides a way to template the action portion of the toolbar in the grid.\n *\n * @igxModule IgxGridToolbarModule\n * @igxParent IgxGridToolbarComponent\n *\n * @example\n * ```html\n * <igx-grid-toolbar-actions>\n *  <some-toolbar-action-here />\n * </igx-grid-toolbar-actions>\n * ```\n */\n\n\nlet IgxGridToolbarActionsDirective = /*#__PURE__*/(() => {\n  class IgxGridToolbarActionsDirective {\n    constructor() {\n      /**\n       * Host `class.igx-grid-toolbar__actions` binding.\n       *\n       * @hidden\n       * @internal\n       */\n      this.cssClass = 'igx-grid-toolbar__actions';\n    }\n\n  }\n\n  IgxGridToolbarActionsDirective.ɵfac = function IgxGridToolbarActionsDirective_Factory(t) {\n    return new (t || IgxGridToolbarActionsDirective)();\n  };\n\n  IgxGridToolbarActionsDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxGridToolbarActionsDirective,\n    selectors: [[\"\", \"igxGridToolbarActions\", \"\"], [\"igx-grid-toolbar-actions\"]],\n    hostVars: 2,\n    hostBindings: function IgxGridToolbarActionsDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-grid-toolbar__actions\", ctx.cssClass);\n      }\n    }\n  });\n  return IgxGridToolbarActionsDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridToolbarDirective = /*#__PURE__*/(() => {\n  class IgxGridToolbarDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxGridToolbarDirective.ɵfac = function IgxGridToolbarDirective_Factory(t) {\n    return new (t || IgxGridToolbarDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxGridToolbarDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxGridToolbarDirective,\n    selectors: [[\"\", \"igxGridToolbar\", \"\"]]\n  });\n  return IgxGridToolbarDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden @internal */\n\n\nclass IgxToolbarToken {}\n/**\n * Provides a pre-configured button to open the advanced filtering dialog of the grid.\n *\n *\n * @igxModule IgxGridToolbarModule\n * @igxParent IgxGridToolbarComponent\n *\n * @example\n * ```html\n * <igx-grid-toolbar-advanced-filtering></igx-grid-toolbar-advanced-filtering>\n * <igx-grid-toolbar-advanced-filtering>Custom text</igx-grid-toolbar-advanced-filtering>\n * ```\n */\n\n\nlet IgxGridToolbarAdvancedFilteringComponent = /*#__PURE__*/(() => {\n  class IgxGridToolbarAdvancedFilteringComponent {\n    constructor(toolbar) {\n      this.toolbar = toolbar;\n    }\n    /**\n     * Returns the grid containing this component.\n     */\n\n\n    get grid() {\n      return this.toolbar.grid;\n    }\n\n  }\n\n  IgxGridToolbarAdvancedFilteringComponent.ɵfac = function IgxGridToolbarAdvancedFilteringComponent_Factory(t) {\n    return new (t || IgxGridToolbarAdvancedFilteringComponent)(i0.ɵɵdirectiveInject(IgxToolbarToken));\n  };\n\n  IgxGridToolbarAdvancedFilteringComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxGridToolbarAdvancedFilteringComponent,\n    selectors: [[\"igx-grid-toolbar-advanced-filtering\"]],\n    inputs: {\n      overlaySettings: \"overlaySettings\"\n    },\n    ngContentSelectors: _c8,\n    decls: 7,\n    vars: 4,\n    consts: [[\"igxButton\", \"outlined\", \"type\", \"button\", \"name\", \"btnAdvancedFiltering\", \"igxRipple\", \"\", 3, \"displayDensity\", \"title\", \"ngClass\", \"click\"], [\"ref\", \"\"], [4, \"ngIf\"]],\n    template: function IgxGridToolbarAdvancedFilteringComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"button\", 0);\n        i0.ɵɵlistener(\"click\", function IgxGridToolbarAdvancedFilteringComponent_Template_button_click_0_listener() {\n          return ctx.grid.openAdvancedFilteringDialog();\n        });\n        i0.ɵɵelementStart(1, \"igx-icon\");\n        i0.ɵɵtext(2, \"filter_list\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"span\", null, 1);\n        i0.ɵɵprojection(5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(6, IgxGridToolbarAdvancedFilteringComponent_span_6_Template, 2, 1, \"span\", 2);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        const _r0 = i0.ɵɵreference(4);\n\n        i0.ɵɵproperty(\"displayDensity\", ctx.grid.displayDensity)(\"title\", ctx.grid == null ? null : ctx.grid.resourceStrings.igx_grid_toolbar_advanced_filtering_button_tooltip)(\"ngClass\", ctx.grid.advancedFilteringExpressionsTree ? \"igx-grid-toolbar__adv-filter--filtered\" : \"igx-grid-toolbar__adv-filter\");\n        i0.ɵɵadvance(6);\n        i0.ɵɵproperty(\"ngIf\", !_r0.childNodes.length);\n      }\n    },\n    directives: [IgxIconComponent, IgxButtonDirective, IgxRippleDirective, i4.NgClass, i4.NgIf],\n    encapsulation: 2\n  });\n  return IgxGridToolbarAdvancedFilteringComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Provides a context-aware container component for UI operations for the grid components.\n *\n * @igxModule IgxGridToolbarModule\n *\n */\n\n\nlet IgxGridToolbarComponent = /*#__PURE__*/(() => {\n  class IgxGridToolbarComponent extends DisplayDensityBase {\n    constructor(_displayDensityOptions, api, iconService, element) {\n      super(_displayDensityOptions);\n      this._displayDensityOptions = _displayDensityOptions;\n      this.api = api;\n      this.iconService = iconService;\n      this.element = element;\n      /**\n       * When enabled, shows the indeterminate progress bar.\n       *\n       * @remarks\n       * By default this will be toggled, when the default exporter component is present\n       * and an exporting is in progress.\n       */\n\n      this.showProgress = false;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this.defaultStyle = true;\n      this.iconService.addSvgIconFromText(pinLeft.name, pinLeft.value, 'imx-icons');\n      this.iconService.addSvgIconFromText(unpinLeft.name, unpinLeft.value, 'imx-icons');\n    }\n    /**\n     * Gets/sets the grid component for the toolbar component.\n     *\n     * @remarks\n     * Usually you should not set this property in the context of the default grid/tree grid.\n     * The only grids that demands this to be set are the hierarchical child grids. For additional\n     * information check the toolbar topic.\n     */\n\n\n    get grid() {\n      if (this._grid) {\n        return this._grid;\n      }\n\n      return this.api.grid;\n    }\n\n    set grid(value) {\n      this._grid = value;\n    }\n    /** Returns the native DOM element of the toolbar component */\n\n\n    get nativeElement() {\n      return this.element.nativeElement;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get cosyStyle() {\n      return this.displayDensity === 'cosy';\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get compactStyle() {\n      return this.displayDensity === 'compact';\n    }\n    /** @hidden @internal */\n\n\n    ngOnDestroy() {\n      var _a;\n\n      (_a = this.sub) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n    }\n\n  }\n\n  IgxGridToolbarComponent.ɵfac = function IgxGridToolbarComponent_Factory(t) {\n    return new (t || IgxGridToolbarComponent)(i0.ɵɵdirectiveInject(DisplayDensityToken, 8), i0.ɵɵdirectiveInject(IGX_GRID_SERVICE_BASE), i0.ɵɵdirectiveInject(IgxIconService), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxGridToolbarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxGridToolbarComponent,\n    selectors: [[\"igx-grid-toolbar\"]],\n    contentQueries: function IgxGridToolbarComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxGridToolbarActionsDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.hasActions = _t.first);\n      }\n    },\n    hostVars: 6,\n    hostBindings: function IgxGridToolbarComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-grid-toolbar\", ctx.defaultStyle)(\"igx-grid-toolbar--cosy\", ctx.cosyStyle)(\"igx-grid-toolbar--compact\", ctx.compactStyle);\n      }\n    },\n    inputs: {\n      showProgress: \"showProgress\",\n      grid: \"grid\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxToolbarToken,\n      useExisting: IgxGridToolbarComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c135,\n    decls: 8,\n    vars: 3,\n    consts: [[1, \"igx-grid-toolbar__custom-content\"], [\"actions\", \"\"], [4, \"ngIf\"], [4, \"ngTemplateOutlet\"], [\"class\", \"igx-grid-toolbar__progress-bar\", 4, \"ngIf\"], [1, \"igx-grid-toolbar__progress-bar\"], [3, \"indeterminate\"]],\n    template: function IgxGridToolbarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c134);\n        i0.ɵɵprojection(0);\n        i0.ɵɵelementStart(1, \"div\", 0);\n        i0.ɵɵprojection(2, 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, IgxGridToolbarComponent_ng_template_3_Template, 1, 0, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(5, IgxGridToolbarComponent_igx_grid_toolbar_actions_5_Template, 2, 1, \"igx-grid-toolbar-actions\", 2);\n        i0.ɵɵtemplate(6, IgxGridToolbarComponent_ng_container_6_Template, 1, 0, \"ng-container\", 3);\n        i0.ɵɵtemplate(7, IgxGridToolbarComponent_div_7_Template, 2, 1, \"div\", 4);\n      }\n\n      if (rf & 2) {\n        const _r0 = i0.ɵɵreference(4);\n\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"ngIf\", !ctx.hasActions);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", _r0);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showProgress);\n      }\n    },\n    directives: [IgxGridToolbarAdvancedFilteringComponent, IgxLinearProgressBarComponent, i4.NgIf, IgxGridToolbarActionsDirective, i4.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return IgxGridToolbarComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden @internal */\n\n\nlet IgxRowEditTemplateDirective = /*#__PURE__*/(() => {\n  class IgxRowEditTemplateDirective {}\n\n  IgxRowEditTemplateDirective.ɵfac = function IgxRowEditTemplateDirective_Factory(t) {\n    return new (t || IgxRowEditTemplateDirective)();\n  };\n\n  IgxRowEditTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxRowEditTemplateDirective,\n    selectors: [[\"\", \"igxRowEdit\", \"\"]]\n  });\n  return IgxRowEditTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden @internal */\n\n\nlet IgxRowEditTextDirective = /*#__PURE__*/(() => {\n  class IgxRowEditTextDirective {}\n\n  IgxRowEditTextDirective.ɵfac = function IgxRowEditTextDirective_Factory(t) {\n    return new (t || IgxRowEditTextDirective)();\n  };\n\n  IgxRowEditTextDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxRowEditTextDirective,\n    selectors: [[\"\", \"igxRowEditText\", \"\"]]\n  });\n  return IgxRowEditTextDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden @internal */\n\n\nlet IgxRowAddTextDirective = /*#__PURE__*/(() => {\n  class IgxRowAddTextDirective {}\n\n  IgxRowAddTextDirective.ɵfac = function IgxRowAddTextDirective_Factory(t) {\n    return new (t || IgxRowAddTextDirective)();\n  };\n\n  IgxRowAddTextDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxRowAddTextDirective,\n    selectors: [[\"\", \"igxRowAddText\", \"\"]]\n  });\n  return IgxRowAddTextDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden @internal */\n\n\nlet IgxRowEditActionsDirective = /*#__PURE__*/(() => {\n  class IgxRowEditActionsDirective {}\n\n  IgxRowEditActionsDirective.ɵfac = function IgxRowEditActionsDirective_Factory(t) {\n    return new (t || IgxRowEditActionsDirective)();\n  };\n\n  IgxRowEditActionsDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxRowEditActionsDirective,\n    selectors: [[\"\", \"igxRowEditActions\", \"\"]]\n  });\n  return IgxRowEditActionsDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // TODO: Refactor circular ref, deps and logic\n\n/** @hidden @internal */\n\n\nlet IgxRowEditTabStopDirective = /*#__PURE__*/(() => {\n  class IgxRowEditTabStopDirective {\n    constructor(grid, element) {\n      this.grid = grid;\n      this.element = element;\n    }\n\n    handleTab(event) {\n      event.stopPropagation();\n\n      if (this.grid.rowEditTabs.last === this && !event.shiftKey || this.grid.rowEditTabs.first === this && event.shiftKey) {\n        this.move(event);\n      }\n    }\n\n    handleEscape(event) {\n      this.grid.crudService.endEdit(false, event);\n      this.grid.tbody.nativeElement.focus();\n    }\n\n    handleEnter(event) {\n      event.stopPropagation();\n    }\n    /**\n     * Moves focus to first/last editable cell in the editable row and put the cell in edit mode.\n     * If cell is out of view first scrolls to the cell\n     *\n     * @param event keyboard event containing information about whether SHIFT key was pressed\n     */\n\n\n    move(event) {\n      event.preventDefault();\n      this.currentCellIndex = event.shiftKey ? this.grid.lastEditableColumnIndex : this.grid.firstEditableColumnIndex;\n      this.grid.navigation.activeNode.row = this.grid.crudService.rowInEditMode.index;\n      this.grid.navigation.activeNode.column = this.currentCellIndex;\n      this.grid.navigateTo(this.grid.crudService.rowInEditMode.index, this.currentCellIndex, obj => {\n        obj.target.activate(event);\n        this.grid.cdr.detectChanges();\n      });\n    }\n\n  }\n\n  IgxRowEditTabStopDirective.ɵfac = function IgxRowEditTabStopDirective_Factory(t) {\n    return new (t || IgxRowEditTabStopDirective)(i0.ɵɵdirectiveInject(IGX_GRID_BASE), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxRowEditTabStopDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxRowEditTabStopDirective,\n    selectors: [[\"\", \"igxRowEditTabStop\", \"\"]],\n    hostBindings: function IgxRowEditTabStopDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown.Tab\", function IgxRowEditTabStopDirective_keydown_Tab_HostBindingHandler($event) {\n          return ctx.handleTab($event);\n        })(\"keydown.Shift.Tab\", function IgxRowEditTabStopDirective_keydown_Shift_Tab_HostBindingHandler($event) {\n          return ctx.handleTab($event);\n        })(\"keydown.Escape\", function IgxRowEditTabStopDirective_keydown_Escape_HostBindingHandler($event) {\n          return ctx.handleEscape($event);\n        })(\"keydown.Enter\", function IgxRowEditTabStopDirective_keydown_Enter_HostBindingHandler($event) {\n          return ctx.handleEnter($event);\n        });\n      }\n    }\n  });\n  return IgxRowEditTabStopDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass BaseRow {\n  /**\n   * Returns the view index calculated per the grid page.\n   */\n  get viewIndex() {\n    var _a, _b;\n\n    return this.index + (((_a = this.grid.paginator) === null || _a === void 0 ? void 0 : _a.page) || 0) * (((_b = this.grid.paginator) === null || _b === void 0 ? void 0 : _b.perPage) || 0);\n  }\n  /**\n   * Gets the row key.\n   * A row in the grid is identified either by:\n   * - primaryKey data value,\n   * - the whole rowData, if the primaryKey is omitted.\n   *\n   * ```typescript\n   * let rowKey = row.key;\n   * ```\n   */\n\n\n  get key() {\n    var _a;\n\n    const data = (_a = this._data) !== null && _a !== void 0 ? _a : this.grid.dataView[this.index];\n    const primaryKey = this.grid.primaryKey;\n    return primaryKey ? data[primaryKey] : data;\n  }\n  /**\n   * Gets if this represents add row UI\n   *\n   * ```typescript\n   * let isAddRow = row.addRowUI;\n   * ```\n   */\n\n\n  get addRowUI() {\n    return !!this.grid.crudService.row && this.grid.crudService.row.getClassName() === IgxAddRow.name && this.grid.crudService.row.id === this.key;\n  }\n  /**\n   * The data record that populates the row.\n   *\n   * ```typescript\n   * let rowData = row.data;\n   * ```\n   */\n\n\n  get data() {\n    var _a, _b;\n\n    if (this.inEditMode) {\n      return mergeWith(this.grid.dataCloneStrategy.clone((_a = this._data) !== null && _a !== void 0 ? _a : this.grid.dataView[this.index]), this.grid.transactions.getAggregatedValue(this.key, false), (objValue, srcValue) => {\n        if (Array.isArray(srcValue)) {\n          return objValue = srcValue;\n        }\n      });\n    }\n\n    return (_b = this._data) !== null && _b !== void 0 ? _b : this.grid.dataView[this.index];\n  }\n  /**\n   * Returns if the row is currently in edit mode.\n   */\n\n\n  get inEditMode() {\n    if (this.grid.rowEditable) {\n      const editRowState = this.grid.crudService.row;\n      return editRowState && editRowState.id === this.key || false;\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Gets whether the row is pinned.\n   * Default value is `false`.\n   * ```typescript\n   * const isPinned = row.pinned;\n   * ```\n   */\n\n\n  get pinned() {\n    return this.grid.isRecordPinned(this.data);\n  }\n  /**\n   * Sets whether the row is pinned.\n   * Default value is `false`.\n   * ```typescript\n   * row.pinned = !row.pinned;\n   * ```\n   */\n\n\n  set pinned(val) {\n    if (val) {\n      this.pin();\n    } else {\n      this.unpin();\n    }\n  }\n  /**\n   * Gets the row expanded/collapsed state.\n   *\n   * ```typescript\n   * const isExpanded = row.expanded;\n   * ```\n   */\n\n\n  get expanded() {\n    return this.grid.gridAPI.get_row_expansion_state(this.data);\n  }\n  /**\n   * Expands/collapses the row.\n   *\n   * ```typescript\n   * row.expanded = true;\n   * ```\n   */\n\n\n  set expanded(val) {\n    this.grid.gridAPI.set_row_expansion_state(this.key, val);\n  }\n  /**\n   * Gets whether the row is selected.\n   * Default value is `false`.\n   * ```typescript\n   * row.selected = true;\n   * ```\n   */\n\n\n  get selected() {\n    return this.grid.selectionService.isRowSelected(this.key);\n  }\n  /**\n   * Sets whether the row is selected.\n   * Default value is `false`.\n   * ```typescript\n   * row.selected = !row.selected;\n   * ```\n   */\n\n\n  set selected(val) {\n    if (val) {\n      this.grid.selectionService.selectRowsWithNoEvent([this.key]);\n    } else {\n      this.grid.selectionService.deselectRowsWithNoEvent([this.key]);\n    }\n\n    this.grid.cdr.markForCheck();\n  }\n  /**\n   * Returns if the row is in delete state.\n   */\n\n\n  get deleted() {\n    return this.grid.gridAPI.row_deleted_transaction(this.key);\n  }\n  /**\n   * Returns if the row has child rows. Always return false for IgxGridRow.\n   */\n\n\n  get hasChildren() {\n    return false;\n  }\n\n  get disabled() {\n    return this.grid.isGhostRecord(this.data);\n  }\n  /**\n   * Gets the rendered cells in the row component.\n   */\n\n\n  get cells() {\n    const res = [];\n    this.grid.columnList.forEach(col => {\n      const cell = new IgxGridCell(this.grid, this.index, col.field);\n      res.push(cell);\n    });\n    return res;\n  }\n  /**\n   * Pins the specified row.\n   * This method emits `onRowPinning` event.\n   *\n   * ```typescript\n   * // pin the selected row from the grid\n   * this.grid.selectedRows[0].pin();\n   * ```\n   */\n\n\n  pin() {\n    return this.grid.pinRow(this.key, this.index);\n  }\n  /**\n   * Unpins the specified row.\n   * This method emits `onRowPinning` event.\n   *\n   * ```typescript\n   * // unpin the selected row from the grid\n   * this.grid.selectedRows[0].unpin();\n   * ```\n   */\n\n\n  unpin() {\n    return this.grid.unpinRow(this.key);\n  }\n  /**\n   * Updates the specified row object and the data source record with the passed value.\n   *\n   * ```typescript\n   * // update the second selected row's value\n   * let newValue = \"Apple\";\n   * this.grid.selectedRows[1].update(newValue);\n   * ```\n   */\n\n\n  update(value) {\n    const crudService = this.grid.crudService;\n\n    if (crudService.cellInEditMode && crudService.cell.id.rowID === this.key) {\n      this.grid.transactions.endPending(false);\n    }\n\n    const row = new IgxEditRow(this.key, this.index, this.data, this.grid);\n    this.grid.gridAPI.update_row(row, value);\n    this.grid.notifyChanges();\n  }\n  /**\n   * Removes the specified row from the grid's data source.\n   * This method emits `onRowDeleted` event.\n   *\n   * ```typescript\n   * // delete the third selected row from the grid\n   * this.grid.selectedRows[2].delete();\n   * ```\n   */\n\n\n  delete() {\n    this.grid.deleteRowById(this.key);\n  }\n\n}\n\nclass IgxGridRow extends BaseRow {\n  /**\n   * @hidden\n   */\n  constructor(grid, index, data) {\n    super();\n    this.grid = grid;\n    this.index = index;\n    this._data = data && data.addRow && data.recordRef ? data.recordRef : data;\n  }\n  /**\n   * Returns the view index calculated per the grid page.\n   */\n\n\n  get viewIndex() {\n    if (this.grid.paginator) {\n      const precedingDetailRows = [];\n      const precedingGroupRows = [];\n      const firstRow = this.grid.dataView[0];\n      const hasDetailRows = this.grid.expansionStates.size;\n      const hasGroupedRows = this.grid.groupingExpressions.length;\n      let precedingSummaryRows = 0;\n      const firstRowInd = this.grid.groupingFlatResult.indexOf(firstRow); // from groupingFlatResult, resolve two other collections:\n      // precedingGroupedRows -> use it to resolve summaryRow for each group in previous pages\n      // precedingDetailRows -> ise it to resolve the detail row for each expanded grid row in previous pages\n\n      if (hasDetailRows || hasGroupedRows) {\n        this.grid.groupingFlatResult.forEach((r, ind) => {\n          const rowID = this.grid.primaryKey ? r[this.grid.primaryKey] : r;\n\n          if (hasGroupedRows && ind < firstRowInd && this.grid.isGroupByRecord(r)) {\n            precedingGroupRows.push(r);\n          }\n\n          if (this.grid.expansionStates.get(rowID) && ind < firstRowInd && !this.grid.isGroupByRecord(r)) {\n            precedingDetailRows.push(r);\n          }\n        });\n      }\n\n      if (this.grid.summaryCalculationMode !== GridSummaryCalculationMode.rootLevelOnly) {\n        // if firstRow is a child of the last item in precedingGroupRows,\n        // then summaryRow for this given groupedRecord is rendered after firstRow,\n        // i.e. need to decrease firstRowInd to account for the above.\n        precedingSummaryRows = precedingGroupRows.filter(gr => this.grid.isExpandedGroup(gr)).length;\n\n        if (this.grid.summaryPosition === GridSummaryPosition.bottom && precedingGroupRows.length && precedingGroupRows[precedingGroupRows.length - 1].records.indexOf(firstRow) > -1) {\n          precedingSummaryRows += -1;\n        }\n      }\n\n      return precedingDetailRows.length + precedingSummaryRows + firstRowInd + this.index;\n    } else {\n      return this.index;\n    }\n  }\n  /**\n   * Returns the parent row, if grid is grouped.\n   */\n\n\n  get parent() {\n    let parent;\n\n    if (!this.grid.groupingExpressions.length) {\n      return undefined;\n    }\n\n    let i = this.index - 1;\n\n    while (i >= 0 && !parent) {\n      const rec = this.grid.dataView[i];\n\n      if (this.grid.isGroupByRecord(rec)) {\n        parent = new IgxGroupByRow(this.grid, i, rec);\n      }\n\n      i--;\n    }\n\n    return parent;\n  }\n\n}\n\nclass IgxTreeGridRow extends BaseRow {\n  /**\n   * @hidden\n   */\n  constructor(grid, index, data, _treeRow) {\n    super();\n    this.grid = grid;\n    this.index = index;\n    this._treeRow = _treeRow;\n    this._data = data && data.addRow && data.recordRef ? data.recordRef : data;\n  }\n  /**\n   * Returns the view index calculated per the grid page.\n   */\n\n\n  get viewIndex() {\n    var _a, _b, _c;\n\n    if (this.grid.hasSummarizedColumns && (((_a = this.grid.paginator) === null || _a === void 0 ? void 0 : _a.page) || 0) > 0) {\n      if (this.grid.summaryCalculationMode !== GridSummaryCalculationMode.rootLevelOnly) {\n        const firstRowIndex = this.grid.processedExpandedFlatData.indexOf(this.grid.dataView[0].data); // firstRowIndex is based on data result after all pipes triggered, excluding summary pipe\n\n        const precedingSummaryRows = this.grid.summaryPosition === GridSummaryPosition.bottom ? this.grid.rootRecords.indexOf(this.getRootParent(this.grid.dataView[0])) : this.grid.rootRecords.indexOf(this.getRootParent(this.grid.dataView[0])) + 1; // there is a summary row for each root record, so we calculate how many root records are rendered before the current row\n\n        return firstRowIndex + precedingSummaryRows + this.index;\n      }\n    }\n\n    return this.index + (((_b = this.grid.paginator) === null || _b === void 0 ? void 0 : _b.page) || 0) * (((_c = this.grid.paginator) === null || _c === void 0 ? void 0 : _c.perPage) || 0);\n  }\n  /**\n   *  The data passed to the row component.\n   *\n   * ```typescript\n   * let selectedRowData = this.grid.selectedRows[0].data;\n   * ```\n   */\n\n\n  get data() {\n    var _a;\n\n    if (this.inEditMode) {\n      return mergeWith(this.grid.dataCloneStrategy.clone((_a = this._data) !== null && _a !== void 0 ? _a : this.grid.dataView[this.index]), this.grid.transactions.getAggregatedValue(this.key, false), (objValue, srcValue) => {\n        if (Array.isArray(srcValue)) {\n          return objValue = srcValue;\n        }\n      });\n    }\n\n    const rec = this.grid.dataView[this.index];\n    return this._data ? this._data : this.grid.isTreeRow(rec) ? rec.data : rec;\n  }\n  /**\n   * Returns the child rows.\n   */\n\n\n  get children() {\n    const children = [];\n\n    if (this.treeRow.expanded) {\n      this.treeRow.children.forEach((rec, i) => {\n        const row = new IgxTreeGridRow(this.grid, this.index + 1 + i, rec.data);\n        children.push(row);\n      });\n    }\n\n    return children;\n  }\n  /**\n   * Returns the parent row.\n   */\n\n\n  get parent() {\n    var _a;\n\n    const row = this.grid.getRowByKey((_a = this.treeRow.parent) === null || _a === void 0 ? void 0 : _a.key);\n    return row;\n  }\n  /**\n   * Returns true if child rows exist. Always return false for IgxGridRow.\n   */\n\n\n  get hasChildren() {\n    if (this.treeRow.children) {\n      return this.treeRow.children.length > 0;\n    } else {\n      return false;\n    }\n  }\n  /**\n   * The `ITreeGridRecord` with metadata about the row in the context of the tree grid.\n   *\n   * ```typescript\n   * const rowParent = this.treeGrid.getRowByKey(1).treeRow.parent;\n   * ```\n   */\n\n\n  get treeRow() {\n    var _a;\n\n    return (_a = this._treeRow) !== null && _a !== void 0 ? _a : this.grid.records.get(this.key);\n  }\n  /**\n   * Gets whether the row is pinned.\n   *\n   * ```typescript\n   * let isPinned = row.pinned;\n   * ```\n   */\n\n\n  get pinned() {\n    return this.grid.isRecordPinned(this);\n  }\n  /**\n   * Sets whether the row is pinned.\n   * Default value is `false`.\n   * ```typescript\n   * row.pinned = !row.pinned;\n   * ```\n   */\n\n\n  set pinned(val) {\n    if (val) {\n      this.pin();\n    } else {\n      this.unpin();\n    }\n  }\n  /**\n   * Gets whether the row is expanded.\n   *\n   * ```typescript\n   * let esExpanded = row.expanded;\n   * ```\n   */\n\n\n  get expanded() {\n    return this.grid.gridAPI.get_row_expansion_state(this.treeRow);\n  }\n  /**\n   * Expands/collapses the row.\n   *\n   * ```typescript\n   * row.expanded = true;\n   * ```\n   */\n\n\n  set expanded(val) {\n    this.grid.gridAPI.set_row_expansion_state(this.key, val);\n  }\n\n  get disabled() {\n    // TODO cell\n    return this.grid.isGhostRecord(this.data) ? this.treeRow.isFilteredOutParent === undefined : false;\n  }\n\n  getRootParent(row) {\n    while (row.parent) {\n      row = row.parent;\n    }\n\n    return row;\n  }\n\n}\n\nclass IgxHierarchicalGridRow extends BaseRow {\n  /**\n   * @hidden\n   */\n  constructor(grid, index, data) {\n    super();\n    this.grid = grid;\n    this.index = index;\n    this._data = data && data.addRow && data.recordRef ? data.recordRef : data;\n  }\n  /**\n   * Returns true if row islands exist.\n   */\n\n\n  get hasChildren() {\n    return !!this.grid.childLayoutKeys.length;\n  }\n  /**\n   * Returns the view index calculated per the grid page.\n   */\n\n\n  get viewIndex() {\n    const firstRowInd = this.grid.filteredSortedData.indexOf(this.grid.dataView[0]);\n    const expandedRows = this.grid.filteredSortedData.filter((rec, ind) => {\n      const rowID = this.grid.primaryKey ? rec[this.grid.primaryKey] : rec;\n      return this.grid.expansionStates.get(rowID) && ind < firstRowInd;\n    });\n    return firstRowInd + expandedRows.length + this.index;\n  }\n  /**\n   * Gets the rendered cells in the row component.\n   */\n\n\n  get cells() {\n    const res = [];\n    this.grid.columnList.forEach(col => {\n      const cell = new IgxGridCell(this.grid, this.index, col.field);\n      res.push(cell);\n    });\n    return res;\n  }\n\n}\n\nclass IgxGroupByRow {\n  /**\n   * @hidden\n   */\n  constructor(grid, index, _groupRow) {\n    this._groupRow = _groupRow;\n    this.grid = grid;\n    this.index = index;\n    this.isGroupByRow = true;\n  }\n  /**\n   * The IGroupByRecord object, representing the group record, if the row is a GroupByRow.\n   */\n\n\n  get groupRow() {\n    return this._groupRow ? this._groupRow : this.grid.dataView[this.index];\n  }\n  /**\n   * Returns the child rows.\n   */\n\n\n  get children() {\n    const children = [];\n    this.groupRow.records.forEach((rec, i) => {\n      const row = new IgxGridRow(this.grid, this.index + 1 + i, rec);\n      children.push(row);\n    });\n    return children;\n  }\n  /**\n   * Returns the view index calculated per the grid page.\n   */\n\n\n  get viewIndex() {\n    if (this.grid.page) {\n      const precedingDetailRows = [];\n      const precedingGroupRows = [];\n      const firstRow = this.grid.dataView[0];\n      const hasDetailRows = this.grid.expansionStates.size;\n      const hasGroupedRows = this.grid.groupingExpressions.length;\n      let precedingSummaryRows = 0;\n      const firstRowInd = this.grid.groupingFlatResult.indexOf(firstRow); // from groupingFlatResult, resolve two other collections:\n      // precedingGroupedRows -> use it to resolve summaryRow for each group in previous pages\n      // precedingDetailRows -> ise it to resolve the detail row for each expanded grid row in previous pages\n\n      if (hasDetailRows || hasGroupedRows) {\n        this.grid.groupingFlatResult.forEach((r, ind) => {\n          const rowID = this.grid.primaryKey ? r[this.grid.primaryKey] : r;\n\n          if (hasGroupedRows && ind < firstRowInd && this.grid.isGroupByRecord(r)) {\n            precedingGroupRows.push(r);\n          }\n\n          if (this.grid.expansionStates.get(rowID) && ind < firstRowInd && !this.grid.isGroupByRecord(r)) {\n            precedingDetailRows.push(r);\n          }\n        });\n      }\n\n      if (this.grid.summaryCalculationMode !== GridSummaryCalculationMode.rootLevelOnly) {\n        // if firstRow is a child of the last item in precedingGroupRows,\n        // then summaryRow for this given groupedRecord is rendered after firstRow,\n        // i.e. need to decrease firstRowInd to account for the above.\n        precedingSummaryRows = precedingGroupRows.filter(gr => this.grid.isExpandedGroup(gr)).length;\n\n        if (this.grid.summaryPosition === GridSummaryPosition.bottom && precedingGroupRows.length && precedingGroupRows[precedingGroupRows.length - 1].records.indexOf(firstRow) > -1) {\n          precedingSummaryRows += -1;\n        }\n      }\n\n      return precedingDetailRows.length + precedingSummaryRows + firstRowInd + this.index;\n    } else {\n      return this.index;\n    }\n  }\n  /**\n   * Gets whether the row is selected.\n   * Default value is `false`.\n   * ```typescript\n   * row.selected = true;\n   * ```\n   */\n\n\n  get selected() {\n    return this.children.every(row => row.selected);\n  }\n  /**\n   * Sets whether the row is selected.\n   * Default value is `false`.\n   * ```typescript\n   * row.selected = !row.selected;\n   * ```\n   */\n\n\n  set selected(val) {\n    if (val) {\n      this.children.forEach(row => {\n        this.grid.selectionService.selectRowsWithNoEvent([row.key]);\n      });\n    } else {\n      this.children.forEach(row => {\n        this.grid.selectionService.deselectRowsWithNoEvent([row.key]);\n      });\n    }\n\n    this.grid.cdr.markForCheck();\n  }\n  /**\n   * Gets/sets whether the group row is expanded.\n   * ```typescript\n   * const groupRowExpanded = groupRow.expanded;\n   * ```\n   */\n\n\n  get expanded() {\n    return this.grid.isExpandedGroup(this.groupRow);\n  }\n\n  set expanded(value) {\n    this.gridAPI.set_grouprow_expansion_state(this.groupRow, value);\n  }\n\n  isActive() {\n    return this.grid.navigation.activeNode ? this.grid.navigation.activeNode.row === this.index : false;\n  }\n  /**\n   * Toggles the group row expanded/collapsed state.\n   * ```typescript\n   * groupRow.toggle()\n   * ```\n   */\n\n\n  toggle() {\n    this.grid.toggleGroup(this.groupRow);\n  }\n\n  get gridAPI() {\n    return this.grid.gridAPI;\n  }\n\n}\n\nclass IgxSummaryRow {\n  /**\n   * @hidden\n   */\n  constructor(grid, index, _summaries, type) {\n    this._summaries = _summaries;\n    this.grid = grid;\n    this.index = index;\n    this.isSummaryRow = true;\n    this.gridType = type;\n  }\n  /**\n   * The IGroupByRecord object, representing the group record, if the row is a GroupByRow.\n   */\n\n\n  get summaries() {\n    return this._summaries ? this._summaries : this.grid.dataView[this.index].summaries;\n  }\n  /**\n   * Returns the view index calculated per the grid page.\n   */\n\n\n  get viewIndex() {\n    var _a, _b;\n\n    if (this.grid.hasSummarizedColumns && this.grid.page > 0) {\n      if (this.gridType === GridInstanceType.Grid) {\n        if (this.grid.page) {\n          const precedingDetailRows = [];\n          const precedingGroupRows = [];\n          const firstRow = this.grid.dataView[0];\n          const hasDetailRows = this.grid.expansionStates.size;\n          const hasGroupedRows = this.grid.groupingExpressions.length;\n          let precedingSummaryRows = 0;\n          const firstRowInd = this.grid.groupingFlatResult.indexOf(firstRow); // from groupingFlatResult, resolve two other collections:\n          // precedingGroupedRows -> use it to resolve summaryRow for each group in previous pages\n          // precedingDetailRows -> ise it to resolve the detail row for each expanded grid row in previous pages\n\n          if (hasDetailRows || hasGroupedRows) {\n            this.grid.groupingFlatResult.forEach((r, ind) => {\n              const rowID = this.grid.primaryKey ? r[this.grid.primaryKey] : r;\n\n              if (hasGroupedRows && ind < firstRowInd && this.grid.isGroupByRecord(r)) {\n                precedingGroupRows.push(r);\n              }\n\n              if (this.grid.expansionStates.get(rowID) && ind < firstRowInd && !this.grid.isGroupByRecord(r)) {\n                precedingDetailRows.push(r);\n              }\n            });\n          }\n\n          if (this.grid.summaryCalculationMode !== GridSummaryCalculationMode.rootLevelOnly) {\n            // if firstRow is a child of the last item in precedingGroupRows,\n            // then summaryRow for this given groupedRecord is rendered after firstRow,\n            // i.e. need to decrease firstRowInd to account for the above.\n            precedingSummaryRows = precedingGroupRows.filter(gr => this.grid.isExpandedGroup(gr)).length;\n\n            if (this.grid.summaryPosition === GridSummaryPosition.bottom && precedingGroupRows.length && precedingGroupRows[precedingGroupRows.length - 1].records.indexOf(firstRow) > -1) {\n              precedingSummaryRows += -1;\n            }\n          }\n\n          return precedingDetailRows.length + precedingSummaryRows + firstRowInd + this.index;\n        } else {\n          return this.index;\n        }\n      } else if (this.gridType === GridInstanceType.TreeGrid) {\n        if (this.grid.summaryCalculationMode !== GridSummaryCalculationMode.rootLevelOnly) {\n          const firstRowIndex = this.grid.processedExpandedFlatData.indexOf(this.grid.dataView[0].data);\n          const precedingSummaryRows = this.grid.summaryPosition === GridSummaryPosition.bottom ? this.grid.rootRecords.indexOf(this.getRootParent(this.grid.dataView[0])) : this.grid.rootRecords.indexOf(this.getRootParent(this.grid.dataView[0])) + 1;\n          return firstRowIndex + precedingSummaryRows + this.index;\n        }\n      }\n    }\n\n    return this.index + (((_a = this.grid.paginator) === null || _a === void 0 ? void 0 : _a.page) || 0) * (((_b = this.grid.paginator) === null || _b === void 0 ? void 0 : _b.perPage) || 0);\n  }\n\n  getRootParent(row) {\n    while (row.parent) {\n      row = row.parent;\n    }\n\n    return row;\n  }\n\n}\n/**\n * @hidden\n * @internal\n */\n\n\nlet IgxGridCellStyleClassesPipe = /*#__PURE__*/(() => {\n  class IgxGridCellStyleClassesPipe {\n    transform(cssClasses, _, data, field, index, __) {\n      if (!cssClasses) {\n        return '';\n      }\n\n      const result = [];\n\n      for (const cssClass of Object.keys(cssClasses)) {\n        const callbackOrValue = cssClasses[cssClass];\n        const apply = typeof callbackOrValue === 'function' ? callbackOrValue(data, field, resolveNestedPath(data, field), index) : callbackOrValue;\n\n        if (apply) {\n          result.push(cssClass);\n        }\n      }\n\n      return result.join(' ');\n    }\n\n  }\n\n  IgxGridCellStyleClassesPipe.ɵfac = function IgxGridCellStyleClassesPipe_Factory(t) {\n    return new (t || IgxGridCellStyleClassesPipe)();\n  };\n\n  IgxGridCellStyleClassesPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"igxCellStyleClasses\",\n    type: IgxGridCellStyleClassesPipe,\n    pure: true\n  });\n  return IgxGridCellStyleClassesPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n * @internal\n */\n\n\nlet IgxGridCellStylesPipe = /*#__PURE__*/(() => {\n  class IgxGridCellStylesPipe {\n    transform(styles, _, data, field, index, __) {\n      const css = {};\n\n      if (!styles) {\n        return css;\n      }\n\n      for (const prop of Object.keys(styles)) {\n        const res = styles[prop];\n        css[prop] = typeof res === 'function' ? res(data, field, resolveNestedPath(data, field), index) : res;\n      }\n\n      return css;\n    }\n\n  }\n\n  IgxGridCellStylesPipe.ɵfac = function IgxGridCellStylesPipe_Factory(t) {\n    return new (t || IgxGridCellStylesPipe)();\n  };\n\n  IgxGridCellStylesPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"igxCellStyles\",\n    type: IgxGridCellStylesPipe,\n    pure: true\n  });\n  return IgxGridCellStylesPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n * @internal\n */\n\n\nlet IgxGridRowClassesPipe = /*#__PURE__*/(() => {\n  class IgxGridRowClassesPipe {\n    constructor(grid) {\n      this.grid = grid;\n      this.row = new IgxGridRow(this.grid, -1, {});\n    }\n\n    transform(cssClasses, row, editMode, selected, dirty, deleted, dragging, index, mrl, filteredOut, _rowData, _) {\n      const result = new Set(['igx-grid__tr', index % 2 ? row.grid.evenRowCSS : row.grid.oddRowCSS]);\n      const mapping = [[selected, 'igx-grid__tr--selected'], [editMode, 'igx-grid__tr--edit'], [dirty, 'igx-grid__tr--edited'], [deleted, 'igx-grid__tr--deleted'], [dragging, 'igx-grid__tr--drag'], [mrl, 'igx-grid__tr--mrl'], // Tree grid only\n      [filteredOut, 'igx-grid__tr--filtered']];\n\n      for (const [state, _class] of mapping) {\n        if (state) {\n          result.add(_class);\n        }\n      }\n\n      for (const cssClass of Object.keys(cssClasses !== null && cssClasses !== void 0 ? cssClasses : {})) {\n        const callbackOrValue = cssClasses[cssClass];\n        this.row.index = index;\n        this.row._data = row.data;\n        const apply = typeof callbackOrValue === 'function' ? callbackOrValue(this.row) : callbackOrValue;\n\n        if (apply) {\n          result.add(cssClass);\n        }\n      }\n\n      return result;\n    }\n\n  }\n\n  IgxGridRowClassesPipe.ɵfac = function IgxGridRowClassesPipe_Factory(t) {\n    return new (t || IgxGridRowClassesPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxGridRowClassesPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"igxGridRowClasses\",\n    type: IgxGridRowClassesPipe,\n    pure: true\n  });\n  return IgxGridRowClassesPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n * @internal\n */\n\n\nlet IgxGridRowStylesPipe = /*#__PURE__*/(() => {\n  class IgxGridRowStylesPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(styles, rowData, index, __) {\n      const css = {};\n\n      if (!styles) {\n        return css;\n      }\n\n      for (const prop of Object.keys(styles)) {\n        const cb = styles[prop];\n        const row = new IgxGridRow(this.grid, index, rowData);\n        css[prop] = typeof cb === 'function' ? cb(row) : cb;\n      }\n\n      return css;\n    }\n\n  }\n\n  IgxGridRowStylesPipe.ɵfac = function IgxGridRowStylesPipe_Factory(t) {\n    return new (t || IgxGridRowStylesPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxGridRowStylesPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"igxGridRowStyles\",\n    type: IgxGridRowStylesPipe,\n    pure: true\n  });\n  return IgxGridRowStylesPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n * @internal\n */\n\n\nlet IgxGridNotGroupedPipe = /*#__PURE__*/(() => {\n  class IgxGridNotGroupedPipe {\n    transform(value) {\n      return value.filter(item => !item.columnGroup);\n    }\n\n  }\n\n  IgxGridNotGroupedPipe.ɵfac = function IgxGridNotGroupedPipe_Factory(t) {\n    return new (t || IgxGridNotGroupedPipe)();\n  };\n\n  IgxGridNotGroupedPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"igxNotGrouped\",\n    type: IgxGridNotGroupedPipe,\n    pure: true\n  });\n  return IgxGridNotGroupedPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n * @internal\n */\n\n\nlet IgxGridTopLevelColumns = /*#__PURE__*/(() => {\n  class IgxGridTopLevelColumns {\n    transform(value) {\n      return value.filter(item => item.level === 0);\n    }\n\n  }\n\n  IgxGridTopLevelColumns.ɵfac = function IgxGridTopLevelColumns_Factory(t) {\n    return new (t || IgxGridTopLevelColumns)();\n  };\n\n  IgxGridTopLevelColumns.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"igxTopLevel\",\n    type: IgxGridTopLevelColumns,\n    pure: true\n  });\n  return IgxGridTopLevelColumns;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n * @internal\n */\n\n\nlet IgxGridFilterConditionPipe = /*#__PURE__*/(() => {\n  class IgxGridFilterConditionPipe {\n    transform(value) {\n      return value.split(/(?=[A-Z])/).join(' ');\n    }\n\n  }\n\n  IgxGridFilterConditionPipe.ɵfac = function IgxGridFilterConditionPipe_Factory(t) {\n    return new (t || IgxGridFilterConditionPipe)();\n  };\n\n  IgxGridFilterConditionPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"filterCondition\",\n    type: IgxGridFilterConditionPipe,\n    pure: true\n  });\n  return IgxGridFilterConditionPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n * @internal\n */\n\n\nlet IgxGridTransactionPipe = /*#__PURE__*/(() => {\n  class IgxGridTransactionPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(collection, _id, _pipeTrigger) {\n      if (this.grid.transactions.enabled) {\n        const result = DataUtil.mergeTransactions(cloneArray(collection), this.grid.transactions.getAggregatedChanges(true), this.grid.primaryKey, this.grid.dataCloneStrategy);\n        return result;\n      }\n\n      return collection;\n    }\n\n  }\n\n  IgxGridTransactionPipe.ɵfac = function IgxGridTransactionPipe_Factory(t) {\n    return new (t || IgxGridTransactionPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxGridTransactionPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"gridTransaction\",\n    type: IgxGridTransactionPipe,\n    pure: true\n  });\n  return IgxGridTransactionPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n * @internal\n */\n\n\nlet IgxGridPaginatorOptionsPipe = /*#__PURE__*/(() => {\n  class IgxGridPaginatorOptionsPipe {\n    transform(values) {\n      return Array.from(new Set([...values])).sort((a, b) => a - b);\n    }\n\n  }\n\n  IgxGridPaginatorOptionsPipe.ɵfac = function IgxGridPaginatorOptionsPipe_Factory(t) {\n    return new (t || IgxGridPaginatorOptionsPipe)();\n  };\n\n  IgxGridPaginatorOptionsPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"paginatorOptions\",\n    type: IgxGridPaginatorOptionsPipe,\n    pure: true\n  });\n  return IgxGridPaginatorOptionsPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n * @internal\n */\n\n\nlet IgxHasVisibleColumnsPipe = /*#__PURE__*/(() => {\n  class IgxHasVisibleColumnsPipe {\n    transform(values, hasVisibleColumns) {\n      if (!(values && values.length)) {\n        return values;\n      }\n\n      return hasVisibleColumns ? values : [];\n    }\n\n  }\n\n  IgxHasVisibleColumnsPipe.ɵfac = function IgxHasVisibleColumnsPipe_Factory(t) {\n    return new (t || IgxHasVisibleColumnsPipe)();\n  };\n\n  IgxHasVisibleColumnsPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"visibleColumns\",\n    type: IgxHasVisibleColumnsPipe,\n    pure: true\n  });\n  return IgxHasVisibleColumnsPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden @internal */\n\n\nfunction buildDataView() {\n  return function (_target, _propertyKey, descriptor) {\n    const original = descriptor.value;\n\n    descriptor.value = function (...args) {\n      const result = original.apply(this, args);\n      this.grid.buildDataView();\n      return result;\n    };\n\n    return descriptor;\n  };\n}\n/**\n * @hidden\n */\n\n\nlet IgxGridRowPinningPipe = /*#__PURE__*/(() => {\n  class IgxGridRowPinningPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(collection, id, isPinned = false, _pipeTrigger) {\n      if (this.grid.hasPinnedRecords && isPinned) {\n        const result = collection.filter(rec => !this.grid.isSummaryRow(rec) && this.grid.isRecordPinned(rec));\n        result.sort((rec1, rec2) => this.grid.getInitialPinnedIndex(rec1) - this.grid.getInitialPinnedIndex(rec2));\n        return result;\n      }\n\n      this.grid.unpinnedRecords = collection;\n\n      if (!this.grid.hasPinnedRecords) {\n        this.grid.pinnedRecords = [];\n        return isPinned ? [] : collection;\n      }\n\n      return collection.map(rec => !this.grid.isSummaryRow(rec) && this.grid.isRecordPinned(rec) ? {\n        recordRef: rec,\n        ghostRecord: true\n      } : rec);\n    }\n\n  }\n\n  IgxGridRowPinningPipe.ɵfac = function IgxGridRowPinningPipe_Factory(t) {\n    return new (t || IgxGridRowPinningPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxGridRowPinningPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"gridRowPinning\",\n    type: IgxGridRowPinningPipe,\n    pure: true\n  });\n\n  __decorate([buildDataView()], IgxGridRowPinningPipe.prototype, \"transform\", null);\n\n  return IgxGridRowPinningPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridDataMapperPipe = /*#__PURE__*/(() => {\n  class IgxGridDataMapperPipe {\n    transform(data, field, _, val, isNestedPath) {\n      return isNestedPath ? resolveNestedPath(data, field) : val;\n    }\n\n  }\n\n  IgxGridDataMapperPipe.ɵfac = function IgxGridDataMapperPipe_Factory(t) {\n    return new (t || IgxGridDataMapperPipe)();\n  };\n\n  IgxGridDataMapperPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"dataMapper\",\n    type: IgxGridDataMapperPipe,\n    pure: true\n  });\n  return IgxGridDataMapperPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxStringReplacePipe = /*#__PURE__*/(() => {\n  class IgxStringReplacePipe {\n    transform(value, search, replacement) {\n      return value.replace(search, replacement);\n    }\n\n  }\n\n  IgxStringReplacePipe.ɵfac = function IgxStringReplacePipe_Factory(t) {\n    return new (t || IgxStringReplacePipe)();\n  };\n\n  IgxStringReplacePipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"igxStringReplace\",\n    type: IgxStringReplacePipe,\n    pure: true\n  });\n  return IgxStringReplacePipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridTransactionStatePipe = /*#__PURE__*/(() => {\n  class IgxGridTransactionStatePipe {\n    transform(row_id, field, rowEditable, transactions, _, __, ___) {\n      var _a;\n\n      if (rowEditable) {\n        const rowCurrentState = transactions.getAggregatedValue(row_id, false);\n\n        if (rowCurrentState) {\n          const value = resolveNestedPath(rowCurrentState, field);\n          return value !== undefined && value !== null;\n        }\n      } else {\n        const transaction = transactions.getState(row_id);\n        const value = resolveNestedPath((_a = transaction === null || transaction === void 0 ? void 0 : transaction.value) !== null && _a !== void 0 ? _a : {}, field);\n        return transaction && transaction.value && (value || value === 0 || value === false);\n      }\n    }\n\n  }\n\n  IgxGridTransactionStatePipe.ɵfac = function IgxGridTransactionStatePipe_Factory(t) {\n    return new (t || IgxGridTransactionStatePipe)();\n  };\n\n  IgxGridTransactionStatePipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"transactionState\",\n    type: IgxGridTransactionStatePipe,\n    pure: true\n  });\n  return IgxGridTransactionStatePipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxColumnFormatterPipe = /*#__PURE__*/(() => {\n  class IgxColumnFormatterPipe {\n    transform(value, formatter, rowData) {\n      return formatter(value, rowData);\n    }\n\n  }\n\n  IgxColumnFormatterPipe.ɵfac = function IgxColumnFormatterPipe_Factory(t) {\n    return new (t || IgxColumnFormatterPipe)();\n  };\n\n  IgxColumnFormatterPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"columnFormatter\",\n    type: IgxColumnFormatterPipe,\n    pure: true\n  });\n  return IgxColumnFormatterPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxSummaryFormatterPipe = /*#__PURE__*/(() => {\n  class IgxSummaryFormatterPipe {\n    transform(summaryResult, summaryOperand, summaryFormatter) {\n      return summaryFormatter(summaryResult, summaryOperand);\n    }\n\n  }\n\n  IgxSummaryFormatterPipe.ɵfac = function IgxSummaryFormatterPipe_Factory(t) {\n    return new (t || IgxSummaryFormatterPipe)();\n  };\n\n  IgxSummaryFormatterPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"summaryFormatter\",\n    type: IgxSummaryFormatterPipe,\n    pure: true\n  });\n  return IgxSummaryFormatterPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridAddRowPipe = /*#__PURE__*/(() => {\n  class IgxGridAddRowPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(collection, isPinned = false, _pipeTrigger) {\n      if (!this.grid.rowEditable || !this.grid.crudService.row || this.grid.crudService.row.getClassName() !== IgxAddRow.name || !this.grid.crudService.addRowParent || isPinned !== this.grid.crudService.addRowParent.isPinned) {\n        return collection;\n      }\n\n      const copy = collection.slice(0);\n      const rec = this.grid.crudService.row.recordRef;\n      copy.splice(this.grid.crudService.row.index, 0, rec);\n      return copy;\n    }\n\n  }\n\n  IgxGridAddRowPipe.ɵfac = function IgxGridAddRowPipe_Factory(t) {\n    return new (t || IgxGridAddRowPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxGridAddRowPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"gridAddRow\",\n    type: IgxGridAddRowPipe,\n    pure: true\n  });\n  return IgxGridAddRowPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxSummaryCellComponent = /*#__PURE__*/(() => {\n  class IgxSummaryCellComponent {\n    constructor(element) {\n      this.element = element;\n      this.firstCellIndentation = 0;\n      this.hasSummary = false;\n    }\n\n    get visibleColumnIndex() {\n      return this.column.visibleIndex;\n    }\n\n    get attrCellID() {\n      return `${this.grid.id}_${this.rowIndex}_${this.visibleColumnIndex}`;\n    }\n\n    activate() {\n      const currNode = this.grid.navigation.activeNode;\n\n      if (currNode && this.rowIndex === currNode.row && this.visibleColumnIndex === currNode.column) {\n        return;\n      }\n\n      this.grid.navigation.setActiveNode({\n        row: this.rowIndex,\n        column: this.visibleColumnIndex\n      }, 'summaryCell');\n      this.grid.cdr.detectChanges();\n    }\n\n    get selectionNode() {\n      return {\n        row: this.rowIndex,\n        column: this.column.columnLayoutChild ? this.column.parent.visibleIndex : this.visibleColumnIndex,\n        isSummaryRow: true\n      };\n    }\n\n    get width() {\n      return this.column.getCellWidth();\n    }\n\n    get nativeElement() {\n      return this.element.nativeElement;\n    }\n\n    get columnDatatype() {\n      return this.column.dataType;\n    }\n\n    get itemHeight() {\n      return this.column.grid.defaultSummaryHeight;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get grid() {\n      return this.column.grid;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get currencyCode() {\n      return this.column.pipeArgs.currencyCode ? this.column.pipeArgs.currencyCode : getLocaleCurrencyCode(this.grid.locale);\n    }\n\n    translateSummary(summary) {\n      return this.grid.resourceStrings[`igx_grid_summary_${summary.key}`] || summary.label;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    isNumberColumn() {\n      return this.column.dataType === GridColumnDataType.Number;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    isDateKindColumn() {\n      return this.column.dataType === GridColumnDataType.Date || this.column.dataType === GridColumnDataType.DateTime || this.column.dataType === GridColumnDataType.Time;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    isCurrencyColumn() {\n      return this.column.dataType === GridColumnDataType.Currency;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    isPercentColumn() {\n      return this.column.dataType === GridColumnDataType.Percent;\n    }\n\n  }\n\n  IgxSummaryCellComponent.ɵfac = function IgxSummaryCellComponent_Factory(t) {\n    return new (t || IgxSummaryCellComponent)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxSummaryCellComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxSummaryCellComponent,\n    selectors: [[\"igx-grid-summary-cell\"]],\n    hostVars: 5,\n    hostBindings: function IgxSummaryCellComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"pointerdown\", function IgxSummaryCellComponent_pointerdown_HostBindingHandler() {\n          return ctx.activate();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"data-rowIndex\", ctx.rowIndex)(\"data-visibleIndex\", ctx.visibleColumnIndex)(\"id\", ctx.attrCellID);\n        i0.ɵɵclassProp(\"igx-grid-summary--active\", ctx.active);\n      }\n    },\n    inputs: {\n      summaryResults: \"summaryResults\",\n      column: \"column\",\n      firstCellIndentation: \"firstCellIndentation\",\n      hasSummary: \"hasSummary\",\n      density: \"density\",\n      summaryFormatter: \"summaryFormatter\",\n      summaryTemplate: \"summaryTemplate\",\n      active: \"active\",\n      rowIndex: \"rowIndex\"\n    },\n    decls: 3,\n    vars: 1,\n    consts: [[4, \"ngIf\"], [\"defaultSummary\", \"\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [4, \"ngFor\", \"ngForOf\"], [1, \"igx-grid-summary__item\"], [1, \"igx-grid-summary__label\", 3, \"title\"], [1, \"igx-grid-summary__result\", 3, \"title\"]],\n    template: function IgxSummaryCellComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxSummaryCellComponent_ng_container_0_Template, 2, 4, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, IgxSummaryCellComponent_ng_template_1_Template, 1, 1, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.hasSummary);\n      }\n    },\n    directives: [i4.NgIf, i4.NgTemplateOutlet, i4.NgForOf],\n    pipes: [IgxSummaryFormatterPipe, i4.DecimalPipe, i4.DatePipe, i4.CurrencyPipe, i4.PercentPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxSummaryCellComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxSummaryRowComponent = /*#__PURE__*/(() => {\n  class IgxSummaryRowComponent {\n    constructor(grid, element, cdr) {\n      this.grid = grid;\n      this.element = element;\n      this.cdr = cdr;\n      this.firstCellIndentation = -1;\n    }\n\n    get dataRowIndex() {\n      return this.index;\n    }\n\n    get minHeight() {\n      return this.grid.summaryRowHeight - 1;\n    }\n\n    get summaryCells() {\n      const res = new QueryList();\n\n      if (!this._summaryCells) {\n        return res;\n      }\n\n      const cList = this._summaryCells.filter(c => c.nativeElement.isConnected);\n\n      res.reset(cList);\n      return res;\n    }\n\n    set summaryCells(cells) {}\n\n    ngDoCheck() {\n      this.cdr.markForCheck();\n    }\n\n    get nativeElement() {\n      return this.element.nativeElement;\n    }\n\n    getColumnSummaries(columnName) {\n      if (!this.summaries.get(columnName)) {\n        return [];\n      }\n\n      return this.summaries.get(columnName);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    isCellActive(visibleColumnIndex) {\n      const node = this.grid.navigation.activeNode;\n      return node ? node.row === this.index && node.column === visibleColumnIndex : false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get pinnedColumns() {\n      return this.grid.pinnedColumns;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get unpinnedColumns() {\n      return this.grid.unpinnedColumns;\n    }\n\n    getContext(row) {\n      return {\n        $implicit: row\n      };\n    }\n\n  }\n\n  IgxSummaryRowComponent.ɵfac = function IgxSummaryRowComponent_Factory(t) {\n    return new (t || IgxSummaryRowComponent)(i0.ɵɵdirectiveInject(IGX_GRID_BASE), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  IgxSummaryRowComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxSummaryRowComponent,\n    selectors: [[\"igx-grid-summary-row\"]],\n    viewQuery: function IgxSummaryRowComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c21, 5, IgxGridForOfDirective);\n        i0.ɵɵviewQuery(IgxSummaryCellComponent, 5, IgxSummaryCellComponent);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.virtDirRow = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._summaryCells = _t);\n      }\n    },\n    hostVars: 1,\n    hostBindings: function IgxSummaryRowComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"data-rowIndex\", ctx.dataRowIndex);\n      }\n    },\n    inputs: {\n      summaries: \"summaries\",\n      gridID: \"gridID\",\n      index: \"index\",\n      firstCellIndentation: \"firstCellIndentation\"\n    },\n    features: [i0.ɵɵProvidersFeature([IgxForOfSyncService])],\n    decls: 3,\n    vars: 1,\n    consts: [[4, \"ngIf\"], [\"summaryCellTemplate\", \"\"], [\"igxGridFor\", \"\", 3, \"igxGridForOf\", \"igxForScrollContainer\", \"igxForScrollOrientation\", \"igxForContainerSize\", \"igxForTrackBy\", \"igxForSizePropName\"], [\"igxDirRef\", \"\"], [1, \"igx-grid__summaries-patch\", 3, \"pointerdown\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"role\", \"cell\", 1, \"igx-grid-summary\", \"igx-grid-summary--fw\", 3, \"column\", \"rowIndex\", \"firstCellIndentation\", \"summaryResults\", \"summaryTemplate\", \"hasSummary\", \"density\", \"summaryFormatter\", \"active\"], [\"role\", \"cell\", \"class\", \"igx-grid-summary igx-grid-summary--fw igx-grid-summary--pinned\", 3, \"igx-grid-summary--cosy\", \"igx-grid-summary--compact\", \"igx-grid-summary--empty\", \"igx-grid-summary--pinned-first\", \"igx-grid-summary--pinned-last\", \"column\", \"firstCellIndentation\", \"rowIndex\", \"summaryResults\", \"summaryTemplate\", \"hasSummary\", \"density\", \"active\", \"max-height\", \"min-height\", \"min-width\", \"max-width\", \"flex-basis\", \"left\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"cell\", 1, \"igx-grid-summary\", \"igx-grid-summary--fw\", \"igx-grid-summary--pinned\", 3, \"column\", \"firstCellIndentation\", \"rowIndex\", \"summaryResults\", \"summaryTemplate\", \"hasSummary\", \"density\", \"active\"]],\n    template: function IgxSummaryRowComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxSummaryRowComponent_ng_container_0_Template, 7, 11, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, IgxSummaryRowComponent_ng_template_1_Template, 2, 3, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.summaries.size);\n      }\n    },\n    directives: [IgxSummaryCellComponent, i4.NgIf, i4.NgTemplateOutlet, IgxGridForOfDirective, i4.NgForOf],\n    pipes: [IgxGridNotGroupedPipe, IgxStringReplacePipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxSummaryRowComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n * @internal\n */\n\n\nlet IgxColumnResizerDirective = /*#__PURE__*/(() => {\n  class IgxColumnResizerDirective {\n    constructor(element, document, zone) {\n      this.element = element;\n      this.document = document;\n      this.zone = zone;\n      this.restrictHResizeMin = Number.MIN_SAFE_INTEGER;\n      this.restrictHResizeMax = Number.MAX_SAFE_INTEGER;\n      this.resizeEnd = new Subject();\n      this.resizeStart = new Subject(); // eslint-disable-next-line @angular-eslint/no-output-native\n\n      this.resize = new Subject();\n      this._destroy = new Subject();\n      this.resizeStart.pipe(takeUntil(this._destroy), map(event => event.clientX), switchMap(offset => this.resize.pipe(takeUntil(this._destroy), takeUntil(this.resizeEnd), map(event => event.clientX - offset)))).subscribe(pos => {\n        const left = this._left + pos;\n        const min = this._left - this.restrictHResizeMin;\n        const max = this._left + this.restrictHResizeMax;\n        this.left = left < min ? min : left;\n\n        if (left > max) {\n          this.left = max;\n        }\n      });\n    }\n\n    ngOnInit() {\n      this.zone.runOutsideAngular(() => {\n        fromEvent(this.document.defaultView, 'mousemove').pipe(takeUntil(this._destroy), throttle(() => interval(0, animationFrameScheduler))).subscribe(res => this.onMousemove(res));\n        fromEvent(this.document.defaultView, 'mouseup').pipe(takeUntil(this._destroy)).subscribe(res => this.onMouseup(res));\n      });\n    }\n\n    ngOnDestroy() {\n      this._destroy.next(true);\n\n      this._destroy.complete();\n    }\n\n    set left(val) {\n      requestAnimationFrame(() => this.element.nativeElement.style.left = val + 'px');\n    }\n\n    set top(val) {\n      if (this.restrictResizerTop != undefined) {\n        requestAnimationFrame(() => this.element.nativeElement.style.top = this.restrictResizerTop + 'px');\n      } else {\n        requestAnimationFrame(() => this.element.nativeElement.style.top = val + 'px');\n      }\n    }\n\n    onMouseup(event) {\n      this.resizeEnd.next(event);\n      this.resizeEnd.complete();\n    }\n\n    onMousedown(event) {\n      event.preventDefault();\n      const parent = this.element.nativeElement.parentElement.parentElement;\n      this.left = this._left = event.clientX - parent.getBoundingClientRect().left;\n      this.top = event.target.getBoundingClientRect().top - parent.getBoundingClientRect().top;\n      this.resizeStart.next(event);\n    }\n\n    onMousemove(event) {\n      event.preventDefault();\n      this.resize.next(event);\n    }\n\n  }\n\n  IgxColumnResizerDirective.ɵfac = function IgxColumnResizerDirective_Factory(t) {\n    return new (t || IgxColumnResizerDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  IgxColumnResizerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxColumnResizerDirective,\n    selectors: [[\"\", \"igxResizer\", \"\"]],\n    inputs: {\n      restrictHResizeMin: \"restrictHResizeMin\",\n      restrictHResizeMax: \"restrictHResizeMax\",\n      restrictResizerTop: \"restrictResizerTop\"\n    },\n    outputs: {\n      resizeEnd: \"resizeEnd\",\n      resizeStart: \"resizeStart\",\n      resize: \"resize\"\n    }\n  });\n  return IgxColumnResizerDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n * @internal\n */\n\n\nlet IgxColumnResizingService = /*#__PURE__*/(() => {\n  class IgxColumnResizingService {\n    constructor(zone) {\n      this.zone = zone;\n      /**\n       * @hidden\n       */\n\n      this.resizeCursor = null;\n      /**\n       * @hidden\n       */\n\n      this.showResizer = false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    getColumnHeaderRenderedWidth() {\n      return this.column.headerCell.nativeElement.getBoundingClientRect().width;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get resizerHeight() {\n      let height = this.column.grid.getVisibleContentHeight(); // Column height multiplier in case there are Column Layouts. The resizer height need to take into account rowStart.\n\n      let columnHeightMultiplier = 1;\n\n      if (this.column.columnLayoutChild) {\n        columnHeightMultiplier = this.column.grid.multiRowLayoutRowSize - this.column.rowStart + 1;\n      }\n\n      if (this.column.level !== 0) {\n        height -= this.column.topLevelParent.headerGroup.height - this.column.headerGroup.height * columnHeightMultiplier;\n      }\n\n      return height;\n    }\n    /**\n     * Returns the minimal possible width to which the column can be resized.\n     */\n\n\n    get restrictResizeMin() {\n      const actualWidth = this.getColumnHeaderRenderedWidth();\n      const minWidth = this.column.minWidthPx < actualWidth ? this.column.minWidthPx : actualWidth;\n      return actualWidth - minWidth;\n    }\n    /**\n     * Returns the maximal possible width to which the column can be resized.\n     */\n\n\n    get restrictResizeMax() {\n      const actualWidth = this.getColumnHeaderRenderedWidth();\n      const maxWidth = this.column.maxWidthPx;\n\n      if (this.column.maxWidth) {\n        return maxWidth - actualWidth;\n      } else {\n        return Number.MAX_SAFE_INTEGER;\n      }\n    }\n    /**\n     * Autosizes the column to the longest currently visible cell value, including the header cell.\n     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,\n     * then the column is sized to its maxWidth.\n     */\n\n\n    autosizeColumnOnDblClick() {\n      const currentColWidth = this.getColumnHeaderRenderedWidth();\n      this.column.width = this.column.getAutoSize();\n      this.zone.run(() => {});\n      this.column.grid.columnResized.emit({\n        column: this.column,\n        prevWidth: currentColWidth.toString(),\n        newWidth: this.column.width\n      });\n    }\n    /**\n     * Resizes the column regaridng to the column minWidth and maxWidth.\n     */\n\n\n    resizeColumn(event) {\n      this.showResizer = false;\n      const diff = event.clientX - this.startResizePos;\n      const colWidth = this.column.width;\n      const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;\n      let currentColWidth = parseFloat(colWidth);\n      const actualWidth = this.getColumnHeaderRenderedWidth();\n      currentColWidth = Number.isNaN(currentColWidth) ? parseFloat(actualWidth) : currentColWidth;\n\n      if (this.column.grid.hasColumnLayouts) {\n        this.resizeColumnLayoutFor(this.column, diff);\n      } else if (isPercentageWidth) {\n        this._handlePercentageResize(diff, this.column);\n      } else {\n        this._handlePixelResize(diff, this.column);\n      }\n\n      this.zone.run(() => {});\n\n      if (currentColWidth !== parseFloat(this.column.width)) {\n        this.column.grid.columnResized.emit({\n          column: this.column,\n          prevWidth: isPercentageWidth ? currentColWidth + '%' : currentColWidth + 'px',\n          newWidth: this.column.width\n        });\n      }\n\n      this.isColumnResizing = false;\n    }\n\n    _handlePixelResize(diff, column) {\n      const currentColWidth = parseFloat(column.width);\n      const colMinWidth = column.minWidthPx;\n      const colMaxWidth = column.maxWidthPx;\n\n      if (currentColWidth + diff < colMinWidth) {\n        column.width = colMinWidth + 'px';\n      } else if (colMaxWidth && currentColWidth + diff > colMaxWidth) {\n        column.width = colMaxWidth + 'px';\n      } else {\n        column.width = currentColWidth + diff + 'px';\n      }\n    }\n\n    _handlePercentageResize(diff, column) {\n      const currentPercentWidth = parseFloat(column.width);\n      const gridAvailableSize = column.grid.calcWidth;\n      const diffPercentage = diff / gridAvailableSize * 100;\n      const colMinWidth = column.minWidthPercent;\n      const colMaxWidth = column.maxWidthPercent;\n\n      if (currentPercentWidth + diffPercentage < colMinWidth) {\n        column.width = colMinWidth + '%';\n      } else if (colMaxWidth && currentPercentWidth + diffPercentage > colMaxWidth) {\n        column.width = colMaxWidth + '%';\n      } else {\n        column.width = currentPercentWidth + diffPercentage + '%';\n      }\n    }\n\n    getColMinWidth(column) {\n      let currentColWidth = parseFloat(column.width);\n      const actualWidth = column.headerCell.nativeElement.getBoundingClientRect().width;\n      currentColWidth = Number.isNaN(currentColWidth) || currentColWidth < actualWidth ? actualWidth : currentColWidth;\n      const actualMinWidth = parseFloat(column.minWidth);\n      return actualMinWidth < currentColWidth ? actualMinWidth : currentColWidth;\n    }\n\n    resizeColumnLayoutFor(column, diff) {\n      const relativeColumns = column.getResizableColUnderEnd();\n      const combinedSpan = relativeColumns.reduce((acc, col) => acc + col.spanUsed, 0); // Resize first those who might reach min/max width\n\n      let columnsToResize = [...relativeColumns];\n      let updatedDiff = diff;\n      let updatedCombinedSpan = combinedSpan;\n      let setMinMaxCols = false;\n\n      do {\n        // Cycle them until there are not ones that reach min/max size, because the diff accumulates after each cycle.\n        // This is because we can have at first 2 cols reaching min width and then after\n        // recalculating the diff there might be 1 more that reaches min width.\n        setMinMaxCols = false;\n        let newCombinedSpan = updatedCombinedSpan;\n        const newColsToResize = [];\n        columnsToResize.forEach(col => {\n          const currentResizeWidth = parseFloat(col.target.calcWidth);\n          const resizeScaled = diff / updatedCombinedSpan * col.target.gridColumnSpan;\n          const colWidth = col.target.width;\n          const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;\n          const minWidth = col.target.minWidthPx;\n          const maxWidth = col.target.maxWidthPx;\n\n          if (currentResizeWidth + resizeScaled < minWidth) {\n            col.target.width = isPercentageWidth ? col.target.minWidthPercent + '%' : minWidth + 'px';\n            updatedDiff += currentResizeWidth - minWidth;\n            newCombinedSpan -= col.spanUsed;\n            setMinMaxCols = true;\n          } else if (maxWidth && currentResizeWidth + resizeScaled > maxWidth) {\n            col.target.width = isPercentageWidth ? col.target.maxWidthPercent + '%' : col.target.maxWidthPx + 'px';\n            updatedDiff -= maxWidth - currentResizeWidth;\n            newCombinedSpan -= col.spanUsed;\n            setMinMaxCols = true;\n          } else {\n            // Save new ones that can be resized\n            newColsToResize.push(col);\n          }\n        });\n        updatedCombinedSpan = newCombinedSpan;\n        columnsToResize = newColsToResize;\n      } while (setMinMaxCols); // Those left that don't reach min/max size resize them normally.\n\n\n      columnsToResize.forEach(col => {\n        const resizeScaled = updatedDiff / updatedCombinedSpan * col.target.gridColumnSpan;\n        const colWidth = col.target.width;\n        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;\n\n        if (isPercentageWidth) {\n          this._handlePercentageResize(resizeScaled, col.target);\n        } else {\n          this._handlePixelResize(resizeScaled, col.target);\n        }\n      });\n    }\n\n  }\n\n  IgxColumnResizingService.ɵfac = function IgxColumnResizingService_Factory(t) {\n    return new (t || IgxColumnResizingService)(i0.ɵɵinject(i0.NgZone));\n  };\n\n  IgxColumnResizingService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxColumnResizingService,\n    factory: IgxColumnResizingService.ɵfac\n  });\n  return IgxColumnResizingService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridColumnResizerComponent = /*#__PURE__*/(() => {\n  class IgxGridColumnResizerComponent {\n    constructor(colResizingService) {\n      this.colResizingService = colResizingService;\n    }\n\n  }\n\n  IgxGridColumnResizerComponent.ɵfac = function IgxGridColumnResizerComponent_Factory(t) {\n    return new (t || IgxGridColumnResizerComponent)(i0.ɵɵdirectiveInject(IgxColumnResizingService));\n  };\n\n  IgxGridColumnResizerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxGridColumnResizerComponent,\n    selectors: [[\"igx-grid-column-resizer\"]],\n    viewQuery: function IgxGridColumnResizerComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxColumnResizerDirective, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.resizer = _t.first);\n      }\n    },\n    inputs: {\n      restrictResizerTop: \"restrictResizerTop\"\n    },\n    decls: 1,\n    vars: 7,\n    consts: [[\"igxResizer\", \"\", 1, \"igx-grid-th__resize-line\", 3, \"restrictHResizeMax\", \"restrictHResizeMin\", \"restrictResizerTop\", \"resizeEnd\"]],\n    template: function IgxGridColumnResizerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵlistener(\"resizeEnd\", function IgxGridColumnResizerComponent_Template_div_resizeEnd_0_listener($event) {\n          return ctx.colResizingService.resizeColumn($event);\n        });\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"left\", -99999, \"px\")(\"height\", ctx.colResizingService.resizerHeight, \"px\");\n        i0.ɵɵproperty(\"restrictHResizeMax\", ctx.colResizingService.restrictResizeMax)(\"restrictHResizeMin\", ctx.colResizingService.restrictResizeMin)(\"restrictResizerTop\", ctx.restrictResizerTop);\n      }\n    },\n    directives: [IgxColumnResizerDirective],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxGridColumnResizerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n * @internal\n */\n\n\nlet IgxColumnMovingDragDirective = /*#__PURE__*/(() => {\n  class IgxColumnMovingDragDirective extends IgxDragDirective {\n    constructor(element, viewContainer, zone, renderer, cdr, cms, _platformUtil) {\n      super(cdr, element, viewContainer, zone, renderer, _platformUtil);\n      this.element = element;\n      this.viewContainer = viewContainer;\n      this.zone = zone;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.cms = cms;\n      this._ghostClass = 'igx-grid__drag-ghost-image';\n      this.ghostImgIconClass = 'igx-grid__drag-ghost-image-icon';\n      this.ghostImgIconGroupClass = 'igx-grid__drag-ghost-image-icon-group';\n      this.columnSelectedClass = 'igx-grid-th--selected';\n    }\n\n    get draggable() {\n      return this.column && (this.column.grid.moving || this.column.groupable && !this.column.columnGroup);\n    }\n\n    get icon() {\n      return this.cms.icon;\n    }\n\n    ngOnDestroy() {\n      this._unsubscribe();\n    }\n\n    onEscape(event) {\n      this.cms.cancelDrop = true;\n      this.onPointerUp(event);\n    }\n\n    onPointerDown(event) {\n      if (!this.draggable || event.target.getAttribute('draggable') === 'false') {\n        return;\n      }\n\n      event.preventDefault();\n      event.stopPropagation();\n      this._removeOnDestroy = false;\n      this.cms.column = this.column;\n      this.ghostClass = this._ghostClass;\n      super.onPointerDown(event);\n      this.column.grid.cdr.detectChanges();\n      const args = {\n        source: this.column\n      };\n      this.column.grid.columnMovingStart.emit(args);\n      this.subscription$ = fromEvent(this.column.grid.document.defaultView, 'keydown').subscribe(ev => {\n        if (ev.key === this.platformUtil.KEYMAP.ESCAPE) {\n          this.onEscape(ev);\n        }\n      });\n    }\n\n    onPointerMove(event) {\n      event.preventDefault();\n      super.onPointerMove(event);\n\n      if (this._dragStarted && this.ghostElement && !this.cms.column) {\n        this.cms.column = this.column;\n        this.column.grid.cdr.detectChanges();\n      }\n\n      if (this.cms.column) {\n        const args = {\n          source: this.column,\n          cancel: false\n        };\n        this.column.grid.columnMoving.emit(args);\n\n        if (args.cancel) {\n          this.onEscape(event);\n        }\n      }\n    }\n\n    onPointerUp(event) {\n      // Run it explicitly inside the zone because sometimes onPointerUp executes after the code below.\n      this.zone.run(() => {\n        super.onPointerUp(event);\n        this.cms.column = null;\n        this.column.grid.cdr.detectChanges();\n      });\n\n      this._unsubscribe();\n    }\n\n    createGhost(pageX, pageY) {\n      super.createGhost(pageX, pageY);\n      this.ghostElement.style.height = null;\n      this.ghostElement.style.minWidth = null;\n      this.ghostElement.style.flexBasis = null;\n      this.ghostElement.style.position = null;\n      this.renderer.removeClass(this.ghostElement, this.columnSelectedClass);\n      const icon = document.createElement('i');\n      const text = document.createTextNode('block');\n      icon.appendChild(text);\n      icon.classList.add('material-icons');\n      this.cms.icon = icon;\n\n      if (!this.column.columnGroup) {\n        this.renderer.addClass(icon, this.ghostImgIconClass);\n        this.ghostElement.insertBefore(icon, this.ghostElement.firstElementChild);\n        this.ghostLeft = this._ghostStartX = pageX - this.ghostElement.getBoundingClientRect().width / 3 * 2;\n        this.ghostTop = this._ghostStartY = pageY - this.ghostElement.getBoundingClientRect().height / 3 * 2;\n      } else {\n        this.ghostElement.insertBefore(icon, this.ghostElement.childNodes[0]);\n        this.renderer.addClass(icon, this.ghostImgIconGroupClass);\n        this.ghostElement.children[0].style.paddingLeft = '0px';\n        this.ghostLeft = this._ghostStartX = pageX - this.ghostElement.getBoundingClientRect().width / 3 * 2;\n        this.ghostTop = this._ghostStartY = pageY - this.ghostElement.getBoundingClientRect().height / 3 * 2;\n      }\n    }\n\n    _unsubscribe() {\n      if (this.subscription$) {\n        this.subscription$.unsubscribe();\n        this.subscription$ = null;\n      }\n    }\n\n  }\n\n  IgxColumnMovingDragDirective.ɵfac = function IgxColumnMovingDragDirective_Factory(t) {\n    return new (t || IgxColumnMovingDragDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(IgxColumnMovingService), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxColumnMovingDragDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxColumnMovingDragDirective,\n    selectors: [[\"\", \"igxColumnMovingDrag\", \"\"]],\n    inputs: {\n      column: [\"igxColumnMovingDrag\", \"column\"]\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return IgxColumnMovingDragDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * An internal component representing a base group-by drop area.\n *\n * @hidden @internal\n */\n\n\nlet IgxGroupByAreaDirective = /*#__PURE__*/(() => {\n  class IgxGroupByAreaDirective {\n    constructor(ref, platform) {\n      this.ref = ref;\n      this.platform = platform;\n      this.density = DisplayDensity.comfortable;\n      this.defaultClass = true;\n      this.expressionsChange = new EventEmitter();\n      this._expressions = [];\n    }\n\n    get cosyStyle() {\n      return this.density === 'cosy';\n    }\n\n    get compactStyle() {\n      return this.density === 'compact';\n    }\n    /**\n     * The group-by expressions provided by the parent grid.\n     */\n\n\n    get expressions() {\n      return this._expressions;\n    }\n\n    set expressions(value) {\n      this._expressions = value;\n      this.chipExpressions = this._expressions;\n      this.expressionsChanged();\n      this.expressionsChange.emit(this._expressions);\n    }\n    /**\n     * The default message for the default drop area template.\n     * Obviously, if another template is provided, this is ignored.\n     */\n\n\n    get dropAreaMessage() {\n      var _a;\n\n      return (_a = this._dropAreaMessage) !== null && _a !== void 0 ? _a : this.grid.resourceStrings.igx_grid_groupByArea_message;\n    }\n\n    set dropAreaMessage(value) {\n      this._dropAreaMessage = value;\n    }\n    /** The native DOM element. Used in sizing calculations. */\n\n\n    get nativeElement() {\n      return this.ref.nativeElement;\n    }\n\n    get dropAreaVisible() {\n      return this.grid.columnInDrag && this.grid.columnInDrag.groupable || !this.expressions.length;\n    }\n\n    handleKeyDown(id, event) {\n      if (this.platform.isActivationKey(event)) {\n        this.updateSorting(id);\n      }\n    }\n\n    handleClick(id) {\n      if (!this.grid.getColumnByName(id).groupable) {\n        return;\n      }\n\n      this.updateSorting(id);\n    }\n\n    onDragDrop(event) {\n      var _a;\n\n      const drag = event.detail.owner;\n\n      if (drag instanceof IgxColumnMovingDragDirective) {\n        const column = drag.column;\n\n        if (!this.grid.columnList.find(c => c === column)) {\n          return;\n        }\n\n        const isGrouped = this.expressions.findIndex(item => item.fieldName === column.field) !== -1;\n\n        if (column.groupable && !isGrouped && !column.columnGroup && !!column.field) {\n          const groupingExpression = {\n            fieldName: column.field,\n            dir: ((_a = this.grid.sortingExpressions.find(expr => expr.fieldName === column.field)) === null || _a === void 0 ? void 0 : _a.dir) || SortingDirection.Asc,\n            ignoreCase: column.sortingIgnoreCase,\n            strategy: column.sortStrategy,\n            groupingComparer: column.groupingComparer\n          };\n          this.groupBy(groupingExpression);\n        }\n      }\n    }\n\n    getReorderedExpressions(chipsArray) {\n      const newExpressions = [];\n      chipsArray.forEach(chip => {\n        var _a;\n\n        const expr = this.expressions.find(item => item.fieldName === chip.id); // disallow changing order if there are columns with groupable: false\n\n        if (!((_a = this.grid.getColumnByName(expr.fieldName)) === null || _a === void 0 ? void 0 : _a.groupable)) {\n          return;\n        }\n\n        newExpressions.push(expr);\n      });\n      return newExpressions;\n    }\n\n    updateSorting(id) {\n      const expr = this.grid.sortingExpressions.find(e => e.fieldName === id);\n      expr.dir = 3 - expr.dir;\n      this.grid.sort(expr);\n    }\n\n    expressionsChanged() {}\n\n  }\n\n  IgxGroupByAreaDirective.ɵfac = function IgxGroupByAreaDirective_Factory(t) {\n    return new (t || IgxGroupByAreaDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxGroupByAreaDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxGroupByAreaDirective,\n    viewQuery: function IgxGroupByAreaDirective_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxChipComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chips = _t);\n      }\n    },\n    hostVars: 6,\n    hostBindings: function IgxGroupByAreaDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-grid-grouparea\", ctx.defaultClass)(\"igx-grid-grouparea--cosy\", ctx.cosyStyle)(\"igx-grid-grouparea--compact\", ctx.compactStyle);\n      }\n    },\n    inputs: {\n      dropAreaTemplate: \"dropAreaTemplate\",\n      density: \"density\",\n      grid: \"grid\",\n      expressions: \"expressions\",\n      dropAreaMessage: \"dropAreaMessage\"\n    },\n    outputs: {\n      expressionsChange: \"expressionsChange\"\n    }\n  });\n  return IgxGroupByAreaDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A pipe to circumvent the use of getters/methods just to get some additional\n * information from the grouping expression and pass it to the chip representing\n * that expression.\n *\n * @hidden @internal\n */\n\n\nlet IgxGroupByMetaPipe = /*#__PURE__*/(() => {\n  class IgxGroupByMetaPipe {\n    transform(key, grid) {\n      const column = grid.getColumnByName(key);\n      return {\n        groupable: !!(column === null || column === void 0 ? void 0 : column.groupable),\n        title: (column === null || column === void 0 ? void 0 : column.header) || key\n      };\n    }\n\n  }\n\n  IgxGroupByMetaPipe.ɵfac = function IgxGroupByMetaPipe_Factory(t) {\n    return new (t || IgxGroupByMetaPipe)();\n  };\n\n  IgxGroupByMetaPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"igxGroupByMeta\",\n    type: IgxGroupByMetaPipe,\n    pure: true\n  });\n  return IgxGroupByMetaPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxGroupByRowTemplateDirective = /*#__PURE__*/(() => {\n  class IgxGroupByRowTemplateDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxGroupByRowTemplateDirective.ɵfac = function IgxGroupByRowTemplateDirective_Factory(t) {\n    return new (t || IgxGroupByRowTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxGroupByRowTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxGroupByRowTemplateDirective,\n    selectors: [[\"\", \"igxGroupByRow\", \"\"]]\n  });\n  return IgxGroupByRowTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxGridDetailTemplateDirective = /*#__PURE__*/(() => {\n  class IgxGridDetailTemplateDirective {}\n\n  IgxGridDetailTemplateDirective.ɵfac = function IgxGridDetailTemplateDirective_Factory(t) {\n    return new (t || IgxGridDetailTemplateDirective)();\n  };\n\n  IgxGridDetailTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxGridDetailTemplateDirective,\n    selectors: [[\"\", \"igxGridDetail\", \"\"]]\n  });\n  return IgxGridDetailTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxRowExpandedIndicatorDirective = /*#__PURE__*/(() => {\n  class IgxRowExpandedIndicatorDirective {}\n\n  IgxRowExpandedIndicatorDirective.ɵfac = function IgxRowExpandedIndicatorDirective_Factory(t) {\n    return new (t || IgxRowExpandedIndicatorDirective)();\n  };\n\n  IgxRowExpandedIndicatorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxRowExpandedIndicatorDirective,\n    selectors: [[\"\", \"igxRowExpandedIndicator\", \"\"]]\n  });\n  return IgxRowExpandedIndicatorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxRowCollapsedIndicatorDirective = /*#__PURE__*/(() => {\n  class IgxRowCollapsedIndicatorDirective {}\n\n  IgxRowCollapsedIndicatorDirective.ɵfac = function IgxRowCollapsedIndicatorDirective_Factory(t) {\n    return new (t || IgxRowCollapsedIndicatorDirective)();\n  };\n\n  IgxRowCollapsedIndicatorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxRowCollapsedIndicatorDirective,\n    selectors: [[\"\", \"igxRowCollapsedIndicator\", \"\"]]\n  });\n  return IgxRowCollapsedIndicatorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxHeaderExpandIndicatorDirective = /*#__PURE__*/(() => {\n  class IgxHeaderExpandIndicatorDirective {}\n\n  IgxHeaderExpandIndicatorDirective.ɵfac = function IgxHeaderExpandIndicatorDirective_Factory(t) {\n    return new (t || IgxHeaderExpandIndicatorDirective)();\n  };\n\n  IgxHeaderExpandIndicatorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxHeaderExpandIndicatorDirective,\n    selectors: [[\"\", \"igxHeaderExpandedIndicator\", \"\"]]\n  });\n  return IgxHeaderExpandIndicatorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxHeaderCollapseIndicatorDirective = /*#__PURE__*/(() => {\n  class IgxHeaderCollapseIndicatorDirective {}\n\n  IgxHeaderCollapseIndicatorDirective.ɵfac = function IgxHeaderCollapseIndicatorDirective_Factory(t) {\n    return new (t || IgxHeaderCollapseIndicatorDirective)();\n  };\n\n  IgxHeaderCollapseIndicatorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxHeaderCollapseIndicatorDirective,\n    selectors: [[\"\", \"igxHeaderCollapsedIndicator\", \"\"]]\n  });\n  return IgxHeaderCollapseIndicatorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxExcelStyleHeaderIconDirective = /*#__PURE__*/(() => {\n  class IgxExcelStyleHeaderIconDirective {}\n\n  IgxExcelStyleHeaderIconDirective.ɵfac = function IgxExcelStyleHeaderIconDirective_Factory(t) {\n    return new (t || IgxExcelStyleHeaderIconDirective)();\n  };\n\n  IgxExcelStyleHeaderIconDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxExcelStyleHeaderIconDirective,\n    selectors: [[\"\", \"igxExcelStyleHeaderIcon\", \"\"]]\n  });\n  return IgxExcelStyleHeaderIconDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxSortHeaderIconDirective = /*#__PURE__*/(() => {\n  class IgxSortHeaderIconDirective {}\n\n  IgxSortHeaderIconDirective.ɵfac = function IgxSortHeaderIconDirective_Factory(t) {\n    return new (t || IgxSortHeaderIconDirective)();\n  };\n\n  IgxSortHeaderIconDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxSortHeaderIconDirective,\n    selectors: [[\"\", \"igxSortHeaderIcon\", \"\"]]\n  });\n  return IgxSortHeaderIconDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxSortAscendingHeaderIconDirective = /*#__PURE__*/(() => {\n  class IgxSortAscendingHeaderIconDirective {}\n\n  IgxSortAscendingHeaderIconDirective.ɵfac = function IgxSortAscendingHeaderIconDirective_Factory(t) {\n    return new (t || IgxSortAscendingHeaderIconDirective)();\n  };\n\n  IgxSortAscendingHeaderIconDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxSortAscendingHeaderIconDirective,\n    selectors: [[\"\", \"igxSortAscendingHeaderIcon\", \"\"]]\n  });\n  return IgxSortAscendingHeaderIconDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxSortDescendingHeaderIconDirective = /*#__PURE__*/(() => {\n  class IgxSortDescendingHeaderIconDirective {}\n\n  IgxSortDescendingHeaderIconDirective.ɵfac = function IgxSortDescendingHeaderIconDirective_Factory(t) {\n    return new (t || IgxSortDescendingHeaderIconDirective)();\n  };\n\n  IgxSortDescendingHeaderIconDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxSortDescendingHeaderIconDirective,\n    selectors: [[\"\", \"igxSortDescendingHeaderIcon\", \"\"]]\n  });\n  return IgxSortDescendingHeaderIconDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxGroupAreaDropDirective = /*#__PURE__*/(() => {\n  class IgxGroupAreaDropDirective extends IgxDropDirective {\n    constructor(groupArea, elementRef, renderer, zone) {\n      super(elementRef, renderer, zone);\n      this.groupArea = groupArea;\n      this.elementRef = elementRef;\n      this.hovered = false;\n    }\n\n    onDragEnter(event) {\n      const drag = event.detail.owner;\n      const column = drag.column;\n\n      if (!this.columnBelongsToGrid(column)) {\n        return;\n      }\n\n      const isGrouped = this.groupArea.expressions ? this.groupArea.expressions.findIndex(item => item.fieldName === column.field) !== -1 : false;\n\n      if (column.groupable && !isGrouped && !column.columnGroup && !!column.field) {\n        drag.icon.innerText = 'group_work';\n        this.hovered = true;\n      } else {\n        drag.icon.innerText = 'block';\n        this.hovered = false;\n      }\n    }\n\n    onDragLeave(event) {\n      const drag = event.detail.owner;\n      const column = drag.column;\n\n      if (!this.columnBelongsToGrid(column)) {\n        return;\n      }\n\n      event.detail.owner.icon.innerText = 'block';\n      this.hovered = false;\n    }\n\n    closestParentByAttr(elem, attr) {\n      return elem.hasAttribute(attr) ? elem : this.closestParentByAttr(elem.parentElement, attr);\n    }\n\n    columnBelongsToGrid(column) {\n      const elem = this.elementRef.nativeElement;\n      const closestGridID = this.closestParentByAttr(elem, 'igxGroupAreaDrop').getAttribute('gridId');\n\n      if (!column) {\n        return false;\n      } else {\n        const grid = column.grid;\n\n        if (!grid || grid.id !== closestGridID) {\n          return false;\n        }\n\n        return true;\n      }\n    }\n\n  }\n\n  IgxGroupAreaDropDirective.ɵfac = function IgxGroupAreaDropDirective_Factory(t) {\n    return new (t || IgxGroupAreaDropDirective)(i0.ɵɵdirectiveInject(IgxGroupByAreaDirective), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  IgxGroupAreaDropDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxGroupAreaDropDirective,\n    selectors: [[\"\", \"igxGroupAreaDrop\", \"\"]],\n    hostVars: 2,\n    hostBindings: function IgxGroupAreaDropDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-drop-area--hover\", ctx.hovered);\n      }\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return IgxGroupAreaDropDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nclass ExpressionItem {\n  constructor(parent) {\n    this.parent = parent;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass ExpressionGroupItem extends ExpressionItem {\n  constructor(operator, parent) {\n    super(parent);\n    this.operator = operator;\n    this.children = [];\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass ExpressionOperandItem extends ExpressionItem {\n  constructor(expression, parent) {\n    super(parent);\n    this.expression = expression;\n  }\n\n}\n/**\n * A component used for presenting advanced filtering UI for a Grid.\n * It is used internally in the Grid, but could also be hosted in a container outside of it.\n *\n * Example:\n * ```html\n * <igx-advanced-filtering-dialog\n *     [grid]=\"grid1\">\n * </igx-advanced-filtering-dialog>\n * ```\n */\n\n\nlet IgxAdvancedFilteringDialogComponent = /*#__PURE__*/(() => {\n  class IgxAdvancedFilteringDialogComponent {\n    constructor(cdr, platform) {\n      this.cdr = cdr;\n      this.platform = platform;\n      /**\n       * @hidden @internal\n       */\n\n      this.display = 'block';\n      /**\n       * @hidden @internal\n       */\n\n      this.inline = true;\n      /**\n       * @hidden @internal\n       */\n\n      this.selectedExpressions = [];\n      /**\n       * @hidden @internal\n       */\n\n      this.selectedGroups = [];\n      /**\n       * @hidden @internal\n       */\n\n      this.lastActiveNode = {};\n      /**\n       * @hidden @internal\n       */\n\n      this.columnSelectOverlaySettings = {\n        scrollStrategy: new AbsoluteScrollStrategy(),\n        modal: false,\n        closeOnOutsideClick: false\n      };\n      /**\n       * @hidden @internal\n       */\n\n      this.conditionSelectOverlaySettings = {\n        scrollStrategy: new AbsoluteScrollStrategy(),\n        modal: false,\n        closeOnOutsideClick: false\n      };\n      this.destroy$ = new Subject();\n      this._dblClickDelay = 200;\n      this._preventChipClick = false;\n      this._positionSettings = {\n        horizontalStartPoint: HorizontalAlignment.Right,\n        verticalStartPoint: VerticalAlignment.Top\n      };\n      this._overlaySettings = {\n        closeOnOutsideClick: false,\n        modal: false,\n        positionStrategy: new ConnectedPositioningStrategy(this._positionSettings),\n        scrollStrategy: new CloseScrollStrategy()\n      };\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    set editingInputsContainer(value) {\n      if (value && !this._editingInputsContainer || value && this._editingInputsContainer && this._editingInputsContainer.nativeElement !== value.nativeElement) {\n        requestAnimationFrame(() => {\n          this.scrollElementIntoView(value.nativeElement);\n        });\n      }\n\n      this._editingInputsContainer = value;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get editingInputsContainer() {\n      return this._editingInputsContainer;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    set addModeContainer(value) {\n      if (value && !this._addModeContainer || value && this._addModeContainer && this._addModeContainer.nativeElement !== value.nativeElement) {\n        requestAnimationFrame(() => {\n          this.scrollElementIntoView(value.nativeElement);\n        });\n      }\n\n      this._addModeContainer = value;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get addModeContainer() {\n      return this._addModeContainer;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    set currentGroupButtonsContainer(value) {\n      if (value && !this._currentGroupButtonsContainer || value && this._currentGroupButtonsContainer && this._currentGroupButtonsContainer.nativeElement !== value.nativeElement) {\n        requestAnimationFrame(() => {\n          this.scrollElementIntoView(value.nativeElement);\n        });\n      }\n\n      this._currentGroupButtonsContainer = value;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get currentGroupButtonsContainer() {\n      return this._currentGroupButtonsContainer;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    ngAfterViewInit() {\n      this._overlaySettings.outlet = this.overlayOutlet;\n      this.columnSelectOverlaySettings.outlet = this.overlayOutlet;\n      this.conditionSelectOverlaySettings.outlet = this.overlayOutlet;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    ngOnDestroy() {\n      this.destroy$.next(true);\n      this.destroy$.complete();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get displayDensity() {\n      return this.grid.displayDensity;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get selectedColumn() {\n      return this._selectedColumn;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    set selectedColumn(value) {\n      const oldValue = this._selectedColumn;\n\n      if (this._selectedColumn !== value) {\n        this._selectedColumn = value;\n\n        if (oldValue && this._selectedColumn && this._selectedColumn.dataType !== oldValue.dataType) {\n          this.selectedCondition = null;\n          this.searchValue = null;\n          this.cdr.detectChanges();\n        }\n      }\n    }\n    /**\n     * An @Input property that sets the grid.\n     */\n\n\n    set grid(grid) {\n      this._grid = grid;\n\n      if (this._filteringChange) {\n        this._filteringChange.unsubscribe();\n      }\n\n      if (this._grid) {\n        this._grid.filteringService.registerSVGIcons();\n\n        this._filteringChange = this._grid.advancedFilteringExpressionsTreeChange.pipe(takeUntil(this.destroy$)).subscribe(() => {\n          this.init();\n        });\n        this.init();\n      }\n    }\n    /**\n     * Returns the grid.\n     */\n\n\n    get grid() {\n      return this._grid;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get filterableColumns() {\n      return this.grid.columnList.filter(col => !col.columnGroup && col.filterable);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get hasEditedExpression() {\n      return this.editedExpression !== undefined && this.editedExpression !== null;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    dragStart(dragArgs) {\n      if (!this._overlayComponentId) {\n        dragArgs.cancel = true;\n        return;\n      }\n\n      if (!this.contextMenuToggle.collapsed) {\n        this.contextMenuToggle.element.style.display = 'none';\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    dragEnd() {\n      if (!this.contextMenuToggle.collapsed) {\n        this.calculateContextMenuTarget();\n        this.contextMenuToggle.reposition();\n        this.contextMenuToggle.element.style.display = '';\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onDragMove(e) {\n      const deltaX = e.nextPageX - e.pageX;\n      const deltaY = e.nextPageY - e.pageY;\n      e.cancel = true;\n\n      this._overlayService.setOffset(this._overlayComponentId, deltaX, deltaY);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    addCondition(parent, afterExpression) {\n      this.cancelOperandAdd();\n      const operandItem = new ExpressionOperandItem({\n        fieldName: null,\n        condition: null,\n        ignoreCase: true,\n        searchVal: null\n      }, parent);\n\n      if (afterExpression) {\n        const index = parent.children.indexOf(afterExpression);\n        parent.children.splice(index + 1, 0, operandItem);\n      } else {\n        parent.children.push(operandItem);\n      }\n\n      this.enterExpressionEdit(operandItem);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    addAndGroup(parent, afterExpression) {\n      this.addGroup(FilteringLogic.And, parent, afterExpression);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    addOrGroup(parent, afterExpression) {\n      this.addGroup(FilteringLogic.Or, parent, afterExpression);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    endGroup(groupItem) {\n      this.currentGroup = groupItem.parent;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    commitOperandEdit() {\n      if (this.editedExpression) {\n        this.editedExpression.expression.fieldName = this.selectedColumn.field;\n        this.editedExpression.expression.condition = this.selectedColumn.filters.condition(this.selectedCondition);\n        this.editedExpression.expression.searchVal = DataUtil.parseValue(this.selectedColumn.dataType, this.searchValue);\n        this.editedExpression.columnHeader = this.selectedColumn.header;\n        this.editedExpression.inEditMode = false;\n        this.editedExpression = null;\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    cancelOperandAdd() {\n      if (this.addModeExpression) {\n        this.addModeExpression.inAddMode = false;\n        this.addModeExpression = null;\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    cancelOperandEdit() {\n      if (this.editedExpression) {\n        this.editedExpression.inEditMode = false;\n\n        if (!this.editedExpression.expression.fieldName) {\n          this.deleteItem(this.editedExpression);\n        }\n\n        this.editedExpression = null;\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    operandCanBeCommitted() {\n      return this.selectedColumn && this.selectedCondition && (!!this.searchValue || this.selectedColumn.filters.condition(this.selectedCondition).isUnary);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    exitOperandEdit() {\n      if (!this.editedExpression) {\n        return;\n      }\n\n      if (this.operandCanBeCommitted()) {\n        this.commitOperandEdit();\n      } else {\n        this.cancelOperandEdit();\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    isExpressionGroup(expression) {\n      return expression instanceof ExpressionGroupItem;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onChipRemove(expressionItem) {\n      this.deleteItem(expressionItem);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onChipClick(expressionItem) {\n      this._clickTimer = setTimeout(() => {\n        if (!this._preventChipClick) {\n          this.onToggleExpression(expressionItem);\n        }\n\n        this._preventChipClick = false;\n      }, this._dblClickDelay);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onChipDblClick(expressionItem) {\n      clearTimeout(this._clickTimer);\n      this._preventChipClick = true;\n      this.enterExpressionEdit(expressionItem);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    enterExpressionEdit(expressionItem) {\n      var _a, _b;\n\n      this.clearSelection();\n      this.exitOperandEdit();\n      this.cancelOperandAdd();\n\n      if (this.editedExpression) {\n        this.editedExpression.inEditMode = false;\n      }\n\n      expressionItem.hovered = false;\n      this.selectedColumn = expressionItem.expression.fieldName ? this.grid.getColumnByName(expressionItem.expression.fieldName) : null;\n      this.selectedCondition = expressionItem.expression.condition ? expressionItem.expression.condition.name : null;\n      this.searchValue = expressionItem.expression.searchVal;\n      expressionItem.inEditMode = true;\n      this.editedExpression = expressionItem;\n      this.cdr.detectChanges();\n      this.columnSelectOverlaySettings.target = this.columnSelect.element;\n      this.columnSelectOverlaySettings.excludeFromOutsideClick = [this.columnSelect.element];\n      this.columnSelectOverlaySettings.positionStrategy = new AutoPositionStrategy();\n      this.conditionSelectOverlaySettings.target = this.conditionSelect.element;\n      this.conditionSelectOverlaySettings.excludeFromOutsideClick = [this.conditionSelect.element];\n      this.conditionSelectOverlaySettings.positionStrategy = new AutoPositionStrategy();\n\n      if (!this.selectedColumn) {\n        this.columnSelect.input.nativeElement.focus();\n      } else if (this.selectedColumn.filters.condition(this.selectedCondition).isUnary) {\n        this.conditionSelect.input.nativeElement.focus();\n      } else {\n        const input = ((_a = this.searchValueInput) === null || _a === void 0 ? void 0 : _a.nativeElement) || ((_b = this.picker) === null || _b === void 0 ? void 0 : _b.getEditElement());\n        input.focus();\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    clearSelection() {\n      for (const group of this.selectedGroups) {\n        group.selected = false;\n      }\n\n      this.selectedGroups = [];\n\n      for (const expr of this.selectedExpressions) {\n        expr.selected = false;\n      }\n\n      this.selectedExpressions = [];\n      this.toggleContextMenu();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    enterExpressionAdd(expressionItem) {\n      this.clearSelection();\n      this.exitOperandEdit();\n\n      if (this.addModeExpression) {\n        this.addModeExpression.inAddMode = false;\n      }\n\n      expressionItem.inAddMode = true;\n      this.addModeExpression = expressionItem;\n\n      if (expressionItem.selected) {\n        this.toggleExpression(expressionItem);\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    contextMenuClosed() {\n      this.contextualGroup = null;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onKeyDown(eventArgs) {\n      eventArgs.stopPropagation();\n      const key = eventArgs.key;\n\n      if (!this.contextMenuToggle.collapsed && key === this.platform.KEYMAP.ESCAPE) {\n        this.clearSelection();\n      } else if (key === this.platform.KEYMAP.ESCAPE) {\n        this.closeDialog();\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    createAndGroup() {\n      this.createGroup(FilteringLogic.And);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    createOrGroup() {\n      this.createGroup(FilteringLogic.Or);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    deleteFilters() {\n      for (const expr of this.selectedExpressions) {\n        this.deleteItem(expr);\n      }\n\n      this.clearSelection();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onGroupClick(groupItem) {\n      this.toggleGroup(groupItem);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    ungroup() {\n      const selectedGroup = this.contextualGroup;\n      const parent = selectedGroup.parent;\n\n      if (parent) {\n        const index = parent.children.indexOf(selectedGroup);\n        parent.children.splice(index, 1, ...selectedGroup.children);\n\n        for (const expr of selectedGroup.children) {\n          expr.parent = parent;\n        }\n      }\n\n      this.clearSelection();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    deleteGroup() {\n      const selectedGroup = this.contextualGroup;\n      const parent = selectedGroup.parent;\n\n      if (parent) {\n        const index = parent.children.indexOf(selectedGroup);\n        parent.children.splice(index, 1);\n      } else {\n        this.rootGroup = null;\n      }\n\n      this.clearSelection();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    selectFilteringLogic(event) {\n      this.contextualGroup.operator = event.index;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    getConditionFriendlyName(name) {\n      return this.grid.resourceStrings[`igx_grid_filter_${name}`] || name;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    isDate(value) {\n      return value instanceof Date;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onExpressionsScrolled() {\n      if (!this.contextMenuToggle.collapsed) {\n        this.calculateContextMenuTarget();\n        this.contextMenuToggle.reposition();\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    invokeClick(eventArgs) {\n      if (this.platform.isActivationKey(eventArgs)) {\n        eventArgs.preventDefault();\n        eventArgs.currentTarget.click();\n      }\n    }\n    /** @hidden @internal */\n\n\n    openPicker(args) {\n      if (this.platform.isActivationKey(args)) {\n        args.preventDefault();\n        this.picker.open();\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onOutletPointerDown(event) {\n      // This prevents closing the select's dropdown when clicking the scroll\n      event.preventDefault();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    getConditionList() {\n      return this.selectedColumn ? this.selectedColumn.filters.conditionList() : [];\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    initialize(grid, overlayService, overlayComponentId) {\n      this.inline = false;\n      this.grid = grid;\n      this._overlayService = overlayService;\n      this._overlayComponentId = overlayComponentId;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    getFormatter(field) {\n      return this.grid.getColumnByName(field).formatter;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    getFormat(field) {\n      return this.grid.getColumnByName(field).pipeArgs.format;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    getTimezone(field) {\n      return this.grid.getColumnByName(field).pipeArgs.timezone;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    setAddButtonFocus() {\n      if (this.addRootAndGroupButton) {\n        this.addRootAndGroupButton.nativeElement.focus();\n      } else if (this.addConditionButton) {\n        this.addConditionButton.nativeElement.focus();\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    context(expression, afterExpression) {\n      return {\n        $implicit: expression,\n        afterExpression\n      };\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onClearButtonClick(event) {\n      this.grid.crudService.endEdit(false, event);\n      this.grid.advancedFilteringExpressionsTree = null;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    closeDialog() {\n      if (this._overlayComponentId) {\n        this._overlayService.hide(this._overlayComponentId);\n      }\n\n      this.grid.navigation.activeNode = this.lastActiveNode;\n\n      if (this.grid.navigation.activeNode && this.grid.navigation.activeNode.row === -1) {\n        this.grid.theadRow.nativeElement.focus();\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    applyChanges(event) {\n      this.grid.crudService.endEdit(false, event);\n      this.exitOperandEdit();\n      this.grid.advancedFilteringExpressionsTree = this.createExpressionsTreeFromGroupItem(this.rootGroup);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    cancelChanges() {\n      if (!this._overlayComponentId) {\n        this.init();\n      }\n\n      this.closeDialog();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onApplyButtonClick(event) {\n      this.applyChanges(event);\n      this.closeDialog();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onChipSelectionEnd() {\n      const contextualGroup = this.findSingleSelectedGroup();\n\n      if (contextualGroup || this.selectedExpressions.length > 1) {\n        this.contextualGroup = contextualGroup;\n        this.calculateContextMenuTarget();\n\n        if (this.contextMenuToggle.collapsed) {\n          this.contextMenuToggle.open(this._overlaySettings);\n        } else {\n          this.contextMenuToggle.reposition();\n        }\n      }\n    }\n\n    onToggleExpression(expressionItem) {\n      this.exitOperandEdit();\n      this.toggleExpression(expressionItem);\n      this.toggleContextMenu();\n    }\n\n    toggleExpression(expressionItem) {\n      expressionItem.selected = !expressionItem.selected;\n\n      if (expressionItem.selected) {\n        this.selectedExpressions.push(expressionItem);\n      } else {\n        const index = this.selectedExpressions.indexOf(expressionItem);\n        this.selectedExpressions.splice(index, 1);\n        this.deselectParentRecursive(expressionItem);\n      }\n    }\n\n    addGroup(operator, parent, afterExpression) {\n      this.cancelOperandAdd();\n      const groupItem = new ExpressionGroupItem(operator, parent);\n\n      if (parent) {\n        if (afterExpression) {\n          const index = parent.children.indexOf(afterExpression);\n          parent.children.splice(index + 1, 0, groupItem);\n        } else {\n          parent.children.push(groupItem);\n        }\n      } else {\n        this.rootGroup = groupItem;\n      }\n\n      this.addCondition(groupItem);\n      this.currentGroup = groupItem;\n    }\n\n    createExpressionGroupItem(expressionTree, parent) {\n      let groupItem;\n\n      if (expressionTree) {\n        groupItem = new ExpressionGroupItem(expressionTree.operator, parent);\n\n        for (const expr of expressionTree.filteringOperands) {\n          if (expr instanceof FilteringExpressionsTree) {\n            groupItem.children.push(this.createExpressionGroupItem(expr, groupItem));\n          } else {\n            const filteringExpr = expr;\n            const exprCopy = {\n              fieldName: filteringExpr.fieldName,\n              condition: filteringExpr.condition,\n              searchVal: filteringExpr.searchVal,\n              ignoreCase: filteringExpr.ignoreCase\n            };\n            const operandItem = new ExpressionOperandItem(exprCopy, groupItem);\n            const column = this.grid.getColumnByName(filteringExpr.fieldName);\n            operandItem.columnHeader = column.header;\n            groupItem.children.push(operandItem);\n          }\n        }\n      }\n\n      return groupItem;\n    }\n\n    createExpressionsTreeFromGroupItem(groupItem) {\n      if (!groupItem) {\n        return null;\n      }\n\n      const expressionsTree = new FilteringExpressionsTree(groupItem.operator);\n\n      for (const item of groupItem.children) {\n        if (item instanceof ExpressionGroupItem) {\n          const subTree = this.createExpressionsTreeFromGroupItem(item);\n          expressionsTree.filteringOperands.push(subTree);\n        } else {\n          expressionsTree.filteringOperands.push(item.expression);\n        }\n      }\n\n      return expressionsTree;\n    }\n\n    toggleContextMenu() {\n      const contextualGroup = this.findSingleSelectedGroup();\n\n      if (contextualGroup || this.selectedExpressions.length > 1) {\n        this.contextualGroup = contextualGroup;\n\n        if (contextualGroup) {\n          this.filteringLogics = [{\n            label: this.grid.resourceStrings.igx_grid_filter_operator_and,\n            selected: contextualGroup.operator === FilteringLogic.And\n          }, {\n            label: this.grid.resourceStrings.igx_grid_filter_operator_or,\n            selected: contextualGroup.operator === FilteringLogic.Or\n          }];\n        }\n      } else if (this.contextMenuToggle) {\n        this.contextMenuToggle.close();\n      }\n    }\n\n    findSingleSelectedGroup() {\n      for (const group of this.selectedGroups) {\n        const containsAllSelectedExpressions = this.selectedExpressions.every(op => this.isInsideGroup(op, group));\n\n        if (containsAllSelectedExpressions) {\n          return group;\n        }\n      }\n\n      return null;\n    }\n\n    isInsideGroup(item, group) {\n      if (!item) {\n        return false;\n      }\n\n      if (item.parent === group) {\n        return true;\n      }\n\n      return this.isInsideGroup(item.parent, group);\n    }\n\n    deleteItem(expressionItem) {\n      if (!expressionItem.parent) {\n        this.rootGroup = null;\n        this.currentGroup = null;\n        return;\n      }\n\n      if (expressionItem === this.currentGroup) {\n        this.currentGroup = this.currentGroup.parent;\n      }\n\n      const children = expressionItem.parent.children;\n      const index = children.indexOf(expressionItem);\n      children.splice(index, 1);\n\n      if (!children.length) {\n        this.deleteItem(expressionItem.parent);\n      }\n    }\n\n    createGroup(operator) {\n      const chips = this.chips.toArray();\n      const minIndex = this.selectedExpressions.reduce((i, e) => Math.min(i, chips.findIndex(c => c.data === e)), Number.MAX_VALUE);\n      const firstExpression = chips[minIndex].data;\n      const parent = firstExpression.parent;\n      const groupItem = new ExpressionGroupItem(operator, parent);\n      const index = parent.children.indexOf(firstExpression);\n      parent.children.splice(index, 0, groupItem);\n\n      for (const expr of this.selectedExpressions) {\n        this.deleteItem(expr);\n        groupItem.children.push(expr);\n        expr.parent = groupItem;\n      }\n\n      this.clearSelection();\n    }\n\n    toggleGroup(groupItem) {\n      this.exitOperandEdit();\n\n      if (groupItem.children && groupItem.children.length) {\n        this.toggleGroupRecursive(groupItem, !groupItem.selected);\n\n        if (!groupItem.selected) {\n          this.deselectParentRecursive(groupItem);\n        }\n\n        this.toggleContextMenu();\n      }\n    }\n\n    toggleGroupRecursive(groupItem, selected) {\n      if (groupItem.selected !== selected) {\n        groupItem.selected = selected;\n\n        if (groupItem.selected) {\n          this.selectedGroups.push(groupItem);\n        } else {\n          const index = this.selectedGroups.indexOf(groupItem);\n          this.selectedGroups.splice(index, 1);\n        }\n      }\n\n      for (const expr of groupItem.children) {\n        if (expr instanceof ExpressionGroupItem) {\n          this.toggleGroupRecursive(expr, selected);\n        } else {\n          const operandExpression = expr;\n\n          if (operandExpression.selected !== selected) {\n            this.toggleExpression(operandExpression);\n          }\n        }\n      }\n    }\n\n    deselectParentRecursive(expressionItem) {\n      const parent = expressionItem.parent;\n\n      if (parent) {\n        if (parent.selected) {\n          parent.selected = false;\n          const index = this.selectedGroups.indexOf(parent);\n          this.selectedGroups.splice(index, 1);\n        }\n\n        this.deselectParentRecursive(parent);\n      }\n    }\n\n    calculateContextMenuTarget() {\n      const containerRect = this.expressionsContainer.nativeElement.getBoundingClientRect();\n      const chips = this.chips.filter(c => this.selectedExpressions.indexOf(c.data) !== -1);\n      let minTop = chips.reduce((t, c) => Math.min(t, c.nativeElement.getBoundingClientRect().top), Number.MAX_VALUE);\n      minTop = Math.max(containerRect.top, minTop);\n      minTop = Math.min(containerRect.bottom, minTop);\n      let maxRight = chips.reduce((r, c) => Math.max(r, c.nativeElement.getBoundingClientRect().right), 0);\n      maxRight = Math.max(maxRight, containerRect.left);\n      maxRight = Math.min(maxRight, containerRect.right);\n      this._overlaySettings.target = new Point(maxRight, minTop);\n    }\n\n    scrollElementIntoView(target) {\n      const container = this.expressionsContainer.nativeElement;\n      const targetOffset = target.offsetTop - container.offsetTop;\n      const delta = 10;\n\n      if (container.scrollTop + delta > targetOffset) {\n        container.scrollTop = targetOffset - delta;\n      } else if (container.scrollTop + container.clientHeight < targetOffset + target.offsetHeight + delta) {\n        container.scrollTop = targetOffset + target.offsetHeight + delta - container.clientHeight;\n      }\n    }\n\n    init() {\n      this.clearSelection();\n      this.cancelOperandAdd();\n      this.cancelOperandEdit();\n      this.rootGroup = this.createExpressionGroupItem(this.grid.advancedFilteringExpressionsTree);\n      this.currentGroup = this.rootGroup;\n    }\n\n  }\n\n  IgxAdvancedFilteringDialogComponent.ɵfac = function IgxAdvancedFilteringDialogComponent_Factory(t) {\n    return new (t || IgxAdvancedFilteringDialogComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxAdvancedFilteringDialogComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxAdvancedFilteringDialogComponent,\n    selectors: [[\"igx-advanced-filtering-dialog\"]],\n    viewQuery: function IgxAdvancedFilteringDialogComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c136, 5, IgxSelectComponent);\n        i0.ɵɵviewQuery(_c137, 5, IgxSelectComponent);\n        i0.ɵɵviewQuery(_c138, 5, ElementRef);\n        i0.ɵɵviewQuery(_c94, 5);\n        i0.ɵɵviewQuery(_c139, 5, ElementRef);\n        i0.ɵɵviewQuery(_c140, 5, ElementRef);\n        i0.ɵɵviewQuery(_c141, 5, ElementRef);\n        i0.ɵɵviewQuery(_c142, 5, ElementRef);\n        i0.ɵɵviewQuery(_c143, 5, ElementRef);\n        i0.ɵɵviewQuery(IgxToggleDirective, 5);\n        i0.ɵɵviewQuery(_c98, 5);\n        i0.ɵɵviewQuery(_c81, 7, IgxOverlayOutletDirective);\n        i0.ɵɵviewQuery(IgxChipComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.columnSelect = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.conditionSelect = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.searchValueInput = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.picker = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.addRootAndGroupButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.addConditionButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.editingInputsContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.addModeContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.currentGroupButtonsContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contextMenuToggle = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.expressionsContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.overlayOutlet = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chips = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function IgxAdvancedFilteringDialogComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"display\", ctx.display);\n      }\n    },\n    inputs: {\n      grid: \"grid\"\n    },\n    decls: 3,\n    vars: 1,\n    consts: [[\"class\", \"igx-advanced-filter\", \"igxDrag\", \"\", 3, \"ghost\", \"dragTolerance\", \"ngClass\", \"dragStart\", \"dragEnd\", \"dragMove\", \"keydown\", 4, \"ngIf\"], [\"igxOverlayOutlet\", \"\", 1, \"igx-advanced-filter__outlet\", 3, \"pointerdown\"], [\"overlayOutlet\", \"\"], [\"igxDrag\", \"\", 1, \"igx-advanced-filter\", 3, \"ghost\", \"dragTolerance\", \"ngClass\", \"dragStart\", \"dragEnd\", \"dragMove\", \"keydown\"], [\"igxDragHandle\", \"\", 1, \"igx-advanced-filter__header\"], [1, \"igx-typography__h6\", 2, \"pointer-events\", \"none\"], [1, \"igx-filter-legend\"], [1, \"igx-filter-legend__item--and\"], [1, \"igx-filter-legend__item--or\"], [1, \"igx-advanced-filter__main\", 3, \"scroll\"], [\"expressionsContainer\", \"\"], [4, \"ngIf\"], [\"addExpressionsTemplate\", \"\"], [\"filterOperandTemplate\", \"\"], [\"expressionTreeTemplate\", \"\"], [\"igxToggle\", \"\", 1, \"igx-filter-contextual-menu\", 3, \"ngClass\", \"keydown\", \"closed\"], [\"igxButton\", \"icon\", 1, \"igx-filter-contextual-menu__close-btn\", 3, \"click\"], [1, \"igx-excel-filter__secondary-footer\"], [1, \"igx-excel-filter__clear\"], [\"igxButton\", \"flat\", \"type\", \"button\", 3, \"displayDensity\", \"click\"], [1, \"igx-excel-filter__cancel\"], [1, \"igx-excel-filter__apply\"], [\"igxButton\", \"raised\", \"type\", \"button\", 3, \"displayDensity\", \"click\"], [\"igxButton\", \"outlined\", 3, \"displayDensity\", \"click\"], [\"addRootAndGroupButton\", \"\"], [1, \"igx-filter-empty\"], [1, \"igx-filter-empty__title\"], [\"igxButton\", \"outlined\", 3, \"displayDensity\", \"disabled\", \"click\"], [\"addConditionButton\", \"\"], [\"class\", \"igx-filter-tree__expression-item\", 3, \"mouseenter\", \"mouseleave\", 4, \"ngIf\"], [\"class\", \"igx-filter-tree__inputs\", 4, \"ngIf\"], [\"class\", \"igx-filter-tree__buttons\", 4, \"ngIf\"], [1, \"igx-filter-tree__expression-item\", 3, \"mouseenter\", \"mouseleave\"], [3, \"data\", \"displayDensity\", \"removable\", \"selected\", \"keydown\", \"click\", \"dblclick\", \"remove\", \"selectedChanged\"], [\"igxPrefix\", \"\", 1, \"igx-filter-tree__expression-column\"], [\"family\", \"imx-icons\", 3, \"name\"], [1, \"igx-filter-tree__expression-condition\"], [\"igxSuffix\", \"\", 4, \"ngIf\"], [\"class\", \"igx-filter-tree__expression-actions\", 4, \"ngIf\"], [\"igxSuffix\", \"\"], [1, \"igx-filter-tree__expression-actions\"], [\"tabindex\", \"0\", 3, \"keydown\", \"click\"], [\"tabindex\", \"0\", 3, \"keydown\", \"click\", 4, \"ngIf\"], [1, \"igx-filter-tree__inputs\"], [\"editingInputsContainer\", \"\"], [\"type\", \"box\", 3, \"displayDensity\", \"overlaySettings\", \"placeholder\", \"ngModel\", \"ngModelChange\"], [\"columnSelect\", \"\"], [3, \"value\", 4, \"ngFor\", \"ngForOf\"], [\"type\", \"box\", 3, \"displayDensity\", \"overlaySettings\", \"placeholder\", \"ngModel\", \"disabled\", \"ngModelChange\"], [\"conditionSelect\", \"\"], [3, \"value\", \"text\", 4, \"ngFor\", \"ngForOf\"], [\"type\", \"box\", 3, \"displayDensity\", 4, \"ngIf\"], [\"type\", \"box\", 3, \"value\", \"formatter\", \"displayFormat\", \"readOnly\", \"displayDensity\", \"locale\", \"outlet\", \"placeholder\", \"disabled\", \"valueChange\", \"keydown\", \"click\", 4, \"ngIf\"], [\"type\", \"box\", 3, \"inputFormat\", \"value\", \"formatter\", \"locale\", \"outlet\", \"displayDensity\", \"placeholder\", \"readOnly\", \"disabled\", \"valueChange\", \"click\", \"keydown\", 4, \"ngIf\"], [\"type\", \"box\", \"type\", \"box\", 3, \"displayDensity\", 4, \"ngIf\"], [1, \"igx-filter-tree__inputs-actions\"], [\"igxButton\", \"icon\", 3, \"displayDensity\", \"disabled\", \"click\"], [\"igxButton\", \"icon\", 3, \"displayDensity\", \"click\"], [3, \"value\"], [3, \"value\", \"text\"], [1, \"igx-grid__filtering-dropdown-items\"], [1, \"igx-grid__filtering-dropdown-text\"], [\"type\", \"box\", 3, \"displayDensity\"], [\"igxInput\", \"\", 3, \"disabled\", \"type\", \"placeholder\", \"ngModel\", \"ngModelChange\"], [\"searchValueInput\", \"\"], [\"type\", \"box\", 3, \"value\", \"formatter\", \"displayFormat\", \"readOnly\", \"displayDensity\", \"locale\", \"outlet\", \"placeholder\", \"disabled\", \"valueChange\", \"keydown\", \"click\"], [\"picker\", \"\"], [\"type\", \"box\", 3, \"inputFormat\", \"value\", \"formatter\", \"locale\", \"outlet\", \"displayDensity\", \"placeholder\", \"readOnly\", \"disabled\", \"valueChange\", \"click\", \"keydown\"], [\"type\", \"box\", \"type\", \"box\", 3, \"displayDensity\"], [\"inputGroup\", \"\"], [\"igxInput\", \"\", \"tabindex\", \"0\", 3, \"placeholder\", \"igxDateTimeEditor\", \"ngModel\", \"disabled\", \"ngModelChange\"], [\"input\", \"\"], [1, \"igx-filter-tree__buttons\"], [\"addModeContainer\", \"\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"igx-filter-tree\"], [\"tabindex\", \"0\", 1, \"igx-filter-tree__line\", 3, \"ngClass\", \"keydown\", \"click\"], [1, \"igx-filter-tree__expression\"], [4, \"ngFor\", \"ngForOf\"], [\"currentGroupButtonsContainer\", \"\"], [\"igxButton\", \"outlined\", 3, \"displayDensity\", \"disabled\", \"click\", 4, \"ngIf\"], [\"type\", \"outline\", 3, \"displayDensity\", \"multiSelection\", \"values\", \"selected\"], [\"family\", \"imx-icons\", \"name\", \"ungroup\"], [\"igxButton\", \"outlined\", 1, \"igx-filter-contextual-menu__delete-btn\", 3, \"displayDensity\", \"click\"]],\n    template: function IgxAdvancedFilteringDialogComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxAdvancedFilteringDialogComponent_article_0_Template, 37, 24, \"article\", 0);\n        i0.ɵɵelementStart(1, \"div\", 1, 2);\n        i0.ɵɵlistener(\"pointerdown\", function IgxAdvancedFilteringDialogComponent_Template_div_pointerdown_1_listener($event) {\n          return ctx.onOutletPointerDown($event);\n        });\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.grid);\n      }\n    },\n    directives: [IgxIconComponent, IgxChipComponent, IgxSelectComponent, IgxSelectItemComponent, IgxInputGroupComponent, IgxDatePickerComponent, IgxPickerToggleComponent, IgxPickerClearComponent, IgxTimePickerComponent, IgxButtonGroupComponent, i4.NgIf, IgxDragDirective, i4.NgClass, IgxDragHandleDirective, IgxButtonDirective, IgxPrefixDirective, IgxSuffixDirective, i12.NgControlStatus, i12.NgModel, i4.NgForOf, i12.DefaultValueAccessor, IgxInputDirective, IgxDateTimeEditorDirective, i4.NgTemplateOutlet, IgxToggleDirective, IgxOverlayOutletDirective],\n    pipes: [IgxColumnFormatterPipe, i4.DatePipe],\n    encapsulation: 2\n  });\n  return IgxAdvancedFilteringDialogComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n * @internal\n */\n\n\nlet IgxRowSelectorDirective = /*#__PURE__*/(() => {\n  class IgxRowSelectorDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  IgxRowSelectorDirective.ɵfac = function IgxRowSelectorDirective_Factory(t) {\n    return new (t || IgxRowSelectorDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxRowSelectorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxRowSelectorDirective,\n    selectors: [[\"\", \"igxRowSelector\", \"\"]]\n  });\n  return IgxRowSelectorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n * @internal\n */\n\n\nlet IgxGroupByRowSelectorDirective = /*#__PURE__*/(() => {\n  class IgxGroupByRowSelectorDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  IgxGroupByRowSelectorDirective.ɵfac = function IgxGroupByRowSelectorDirective_Factory(t) {\n    return new (t || IgxGroupByRowSelectorDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxGroupByRowSelectorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxGroupByRowSelectorDirective,\n    selectors: [[\"\", \"igxGroupByRowSelector\", \"\"]]\n  });\n  return IgxGroupByRowSelectorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n * @internal\n */\n\n\nlet IgxHeadSelectorDirective = /*#__PURE__*/(() => {\n  class IgxHeadSelectorDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  IgxHeadSelectorDirective.ɵfac = function IgxHeadSelectorDirective_Factory(t) {\n    return new (t || IgxHeadSelectorDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxHeadSelectorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxHeadSelectorDirective,\n    selectors: [[\"\", \"igxHeadSelector\", \"\"]]\n  });\n  return IgxHeadSelectorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst ghostBackgroundClass = 'igx-grid__tr--ghost';\nconst gridCellClass = 'igx-grid__td';\nconst rowSelectedClass = 'igx-grid__tr--selected';\nconst cellSelectedClass = 'igx-grid__td--selected';\nconst cellActiveClass = 'igx-grid__td--active';\n/**\n * @hidden\n */\n\nlet IgxRowDragDirective = /*#__PURE__*/(() => {\n  class IgxRowDragDirective extends IgxDragDirective {\n    constructor() {\n      super(...arguments);\n      this._rowDragStarted = false;\n\n      this.transitionEndEvent = () => {\n        if (this.ghostElement) {\n          this.ghostElement.removeEventListener('transitionend', this.transitionEndEvent, false);\n        }\n\n        this.endDragging();\n      };\n    }\n\n    set data(value) {\n      this._data = value;\n    }\n\n    get data() {\n      return this._data.grid.createRow(this._data.index, this._data.data);\n    }\n\n    get row() {\n      return this._data;\n    }\n\n    onPointerDown(event) {\n      event.preventDefault();\n      this._rowDragStarted = false;\n      this._removeOnDestroy = false;\n      super.onPointerDown(event);\n    }\n\n    onPointerMove(event) {\n      super.onPointerMove(event);\n\n      if (this._dragStarted && !this._rowDragStarted) {\n        this._rowDragStarted = true;\n        const args = {\n          dragDirective: this,\n          dragData: this.data,\n          dragElement: this.row.nativeElement,\n          cancel: false,\n          owner: this.row.grid\n        };\n        this.row.grid.rowDragStart.emit(args);\n\n        if (args.cancel) {\n          this.ghostElement.parentNode.removeChild(this.ghostElement);\n          this.ghostElement = null;\n          this._dragStarted = false;\n          this._clicked = false;\n          return;\n        }\n\n        this.row.grid.dragRowID = this.row.key;\n        this.row.grid.rowDragging = true;\n        this.row.grid.cdr.detectChanges();\n        this.subscription$ = fromEvent(this.row.grid.document.defaultView, 'keydown').subscribe(ev => {\n          if (ev.key === this.platformUtil.KEYMAP.ESCAPE) {\n            this._lastDropArea = false;\n            this.onPointerUp(event);\n          }\n        });\n      }\n    }\n\n    onPointerUp(event) {\n      if (!this._clicked) {\n        return;\n      }\n\n      const args = {\n        dragDirective: this,\n        dragData: this.data,\n        dragElement: this.row.nativeElement,\n        animation: false,\n        owner: this.row.grid\n      };\n      this.zone.run(() => {\n        this.row.grid.rowDragEnd.emit(args);\n      });\n      const dropArea = this._lastDropArea;\n      super.onPointerUp(event);\n\n      if (!dropArea && this.ghostElement) {\n        this.ghostElement.addEventListener('transitionend', this.transitionEndEvent, false);\n      } else {\n        this.endDragging();\n      }\n    }\n\n    createGhost(pageX, pageY) {\n      this.row.grid.gridAPI.crudService.endEdit(false);\n      this.row.grid.cdr.detectChanges();\n      this.ghostContext = {\n        $implicit: this.row.data,\n        data: this.row.data,\n        grid: this.row.grid\n      };\n      super.createGhost(pageX, pageY, this.row.nativeElement); // check if there is an expander icon and create the ghost at the corresponding position\n\n      if (this.isHierarchicalGrid) {\n        const row = this.row;\n\n        if (row.expander) {\n          const expanderWidth = row.expander.nativeElement.getBoundingClientRect().width;\n          this._ghostHostX += expanderWidth;\n        }\n      }\n\n      const ghost = this.ghostElement;\n      const gridRect = this.row.grid.nativeElement.getBoundingClientRect();\n      const rowRect = this.row.nativeElement.getBoundingClientRect();\n      ghost.style.overflow = 'hidden';\n      ghost.style.width = gridRect.width + 'px';\n      ghost.style.height = rowRect.height + 'px';\n      this.renderer.addClass(ghost, ghostBackgroundClass);\n      this.renderer.removeClass(ghost, rowSelectedClass);\n      const ghostCells = ghost.getElementsByClassName(gridCellClass);\n\n      for (const cell of ghostCells) {\n        this.renderer.removeClass(cell, cellSelectedClass);\n        this.renderer.removeClass(cell, cellActiveClass);\n      }\n    }\n\n    _unsubscribe() {\n      if (this.subscription$ && !this.subscription$.closed) {\n        this.subscription$.unsubscribe();\n      }\n    }\n\n    endDragging() {\n      this.onTransitionEnd(null);\n      this.row.grid.dragRowID = null;\n      this.row.grid.rowDragging = false;\n      this.row.grid.cdr.detectChanges();\n\n      this._unsubscribe();\n    }\n\n    get isHierarchicalGrid() {\n      return this.row.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';\n    }\n\n  }\n\n  IgxRowDragDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxRowDragDirective_BaseFactory;\n    return function IgxRowDragDirective_Factory(t) {\n      return (ɵIgxRowDragDirective_BaseFactory || (ɵIgxRowDragDirective_BaseFactory = i0.ɵɵgetInheritedFactory(IgxRowDragDirective)))(t || IgxRowDragDirective);\n    };\n  }();\n\n  IgxRowDragDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxRowDragDirective,\n    selectors: [[\"\", \"igxRowDrag\", \"\"]],\n    inputs: {\n      data: [\"igxRowDrag\", \"data\"]\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return IgxRowDragDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxDragIndicatorIconDirective = /*#__PURE__*/(() => {\n  class IgxDragIndicatorIconDirective {}\n\n  IgxDragIndicatorIconDirective.ɵfac = function IgxDragIndicatorIconDirective_Factory(t) {\n    return new (t || IgxDragIndicatorIconDirective)();\n  };\n\n  IgxDragIndicatorIconDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxDragIndicatorIconDirective,\n    selectors: [[\"\", \"igxDragIndicatorIcon\", \"\"]]\n  });\n  return IgxDragIndicatorIconDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxRowDragGhostDirective = /*#__PURE__*/(() => {\n  class IgxRowDragGhostDirective {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  }\n\n  IgxRowDragGhostDirective.ɵfac = function IgxRowDragGhostDirective_Factory(t) {\n    return new (t || IgxRowDragGhostDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxRowDragGhostDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxRowDragGhostDirective,\n    selectors: [[\"\", \"igxRowDragGhost\", \"\"]]\n  });\n  return IgxRowDragGhostDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxRowDragModule = /*#__PURE__*/(() => {\n  class IgxRowDragModule {}\n\n  IgxRowDragModule.ɵfac = function IgxRowDragModule_Factory(t) {\n    return new (t || IgxRowDragModule)();\n  };\n\n  IgxRowDragModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxRowDragModule\n  });\n  IgxRowDragModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return IgxRowDragModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxNotificationsDirective = /*#__PURE__*/(() => {\n  class IgxNotificationsDirective extends IgxToggleDirective {\n    constructor() {\n      super(...arguments);\n      /**\n       * Sets/gets the `aria-live` attribute.\n       * If not set, `aria-live` will have value `\"polite\"`.\n       */\n\n      this.ariaLive = 'polite';\n      /**\n       * Sets/gets whether the element will be hidden after the `displayTime` is over.\n       * Default value is `true`.\n       */\n\n      this.autoHide = true;\n      /**\n       * Sets/gets the duration of time span (in milliseconds) which the element will be visible\n       * after it is being shown.\n       * Default value is `4000`.\n       */\n\n      this.displayTime = 4000;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this.textMessage = '';\n      this.d$ = new Subject();\n    }\n    /**\n     * Enables/Disables the visibility of the element.\n     * If not set, the `isVisible` attribute will have value `false`.\n     */\n\n\n    get isVisible() {\n      return !this.collapsed;\n    }\n\n    set isVisible(value) {\n      if (value !== this.isVisible) {\n        if (value) {\n          requestAnimationFrame(() => {\n            this.open();\n          });\n        } else {\n          this.close();\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    open() {\n      clearInterval(this.timeoutId);\n      const overlaySettings = {\n        positionStrategy: this.strategy,\n        closeOnEscape: false,\n        closeOnOutsideClick: false,\n        modal: false,\n        outlet: this.outlet\n      };\n      super.open(overlaySettings);\n\n      if (this.autoHide) {\n        this.timeoutId = window.setTimeout(() => {\n          this.close();\n        }, this.displayTime);\n      }\n    }\n    /**\n     * Hides the element.\n     */\n\n\n    close() {\n      clearTimeout(this.timeoutId);\n      super.close();\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      this.d$.next(true);\n      this.d$.complete();\n    }\n\n  }\n\n  IgxNotificationsDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxNotificationsDirective_BaseFactory;\n    return function IgxNotificationsDirective_Factory(t) {\n      return (ɵIgxNotificationsDirective_BaseFactory || (ɵIgxNotificationsDirective_BaseFactory = i0.ɵɵgetInheritedFactory(IgxNotificationsDirective)))(t || IgxNotificationsDirective);\n    };\n  }();\n\n  IgxNotificationsDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxNotificationsDirective,\n    hostVars: 1,\n    hostBindings: function IgxNotificationsDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-live\", ctx.ariaLive);\n      }\n    },\n    inputs: {\n      ariaLive: \"ariaLive\",\n      autoHide: \"autoHide\",\n      displayTime: \"displayTime\",\n      outlet: \"outlet\",\n      isVisible: \"isVisible\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return IgxNotificationsDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$a = 0;\n/**\n * **Ignite UI for Angular Snackbar** -\n * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/snackbar.html)\n *\n * The Ignite UI Snack Bar provides feedback about an operation with a single-line message, which can\n * include a link to an action such as Undo.\n *\n * Example:\n * ```html\n * <button (click)=\"snackbar.show()\">Send message</button>\n * <div>\n *   <igx-snackbar #snackbar>\n *      Message sent\n *   </igx-snackbar>\n * </div>\n * ```\n */\n\nlet IgxSnackbarComponent = /*#__PURE__*/(() => {\n  class IgxSnackbarComponent extends IgxNotificationsDirective {\n    constructor() {\n      super(...arguments);\n      /**\n       * Sets/gets the `id` of the snackbar.\n       * If not set, the `id` of the first snackbar component  will be `\"igx-snackbar-0\"`;\n       * ```html\n       * <igx-snackbar id = \"Snackbar1\"></igx-snackbar>\n       * ```\n       * ```typescript\n       * let snackbarId = this.snackbar.id;\n       * ```\n       *\n       * @memberof IgxSnackbarComponent\n       */\n\n      this.id = `igx-snackbar-${NEXT_ID$a++}`;\n      /**\n       * The default css class applied to the component.\n       *\n       * @hidden\n       * @internal\n       */\n\n      this.cssClass = 'igx-snackbar';\n      /**\n       * An event that will be emitted when the action button is clicked.\n       * Provides reference to the `IgxSnackbarComponent` as an argument.\n       * ```html\n       * <igx-snackbar (clicked)=\"clickedHandler($event)\"></igx-snackbar>\n       * ```\n       */\n\n      this.clicked = new EventEmitter();\n      /**\n       * An event that will be emitted when the snackbar animation starts.\n       * Provides reference to the `ToggleViewEventArgs` interface as an argument.\n       * ```html\n       * <igx-snackbar (animationStarted) = \"animationStarted($event)\"></igx-snackbar>\n       * ```\n       */\n\n      this.animationStarted = new EventEmitter();\n      /**\n       * An event that will be emitted when the snackbar animation ends.\n       * Provides reference to the `ToggleViewEventArgs` interface as an argument.\n       * ```html\n       * <igx-snackbar (animationDone) = \"animationDone($event)\"></igx-snackbar>\n       * ```\n       */\n\n      this.animationDone = new EventEmitter();\n      this._positionSettings = {\n        horizontalDirection: HorizontalAlignment.Center,\n        verticalDirection: VerticalAlignment.Bottom,\n        openAnimation: useAnimation(fadeIn, {\n          params: {\n            duration: '.35s',\n            easing: 'cubic-bezier(0.0, 0.0, 0.2, 1)',\n            fromPosition: 'translateY(100%)',\n            toPosition: 'translateY(0)'\n          }\n        }),\n        closeAnimation: useAnimation(fadeOut, {\n          params: {\n            duration: '.2s',\n            easing: 'cubic-bezier(0.4, 0.0, 1, 1)',\n            fromPosition: 'translateY(0)',\n            toPosition: 'translateY(100%)'\n          }\n        })\n      };\n    }\n    /**\n     * Get the position and animation settings used by the snackbar.\n     * ```typescript\n     * @ViewChild('snackbar', { static: true }) public snackbar: IgxSnackbarComponent;\n     * let currentPosition: PositionSettings = this.snackbar.positionSettings\n     * ```\n     */\n\n\n    get positionSettings() {\n      return this._positionSettings;\n    }\n    /**\n     * Set the position and animation settings used by the snackbar.\n     * ```html\n     * <igx-snackbar [positionSettings]=\"newPositionSettings\"></igx-snackbar>\n     * ```\n     * ```typescript\n     * import { slideInTop, slideOutBottom } from 'igniteui-angular';\n     * ...\n     * @ViewChild('snackbar', { static: true }) public snackbar: IgxSnackbarComponent;\n     *  public newPositionSettings: PositionSettings = {\n     *      openAnimation: useAnimation(slideInTop, { params: { duration: '1000ms', fromPosition: 'translateY(100%)'}}),\n     *      closeAnimation: useAnimation(slideOutBottom, { params: { duration: '1000ms', fromPosition: 'translateY(0)'}}),\n     *      horizontalDirection: HorizontalAlignment.Left,\n     *      verticalDirection: VerticalAlignment.Middle,\n     *      horizontalStartPoint: HorizontalAlignment.Left,\n     *      verticalStartPoint: VerticalAlignment.Middle,\n     *      minSize: { height: 100, width: 100 }\n     *  };\n     * this.snackbar.positionSettings = this.newPositionSettings;\n     * ```\n     */\n\n\n    set positionSettings(settings) {\n      this._positionSettings = settings;\n    }\n    /**\n     * Shows the snackbar and hides it after the `displayTime` is over if `autoHide` is set to `true`.\n     * ```typescript\n     * this.snackbar.open();\n     * ```\n     */\n\n\n    open(message) {\n      if (message !== undefined) {\n        this.textMessage = message;\n      }\n\n      this.strategy = this.outlet ? new ContainerPositionStrategy(this.positionSettings) : new GlobalPositionStrategy(this.positionSettings);\n      super.open();\n    }\n    /**\n     * Opens or closes the snackbar, depending on its current state.\n     *\n     * ```typescript\n     * this.snackbar.toggle();\n     * ```\n     */\n\n\n    toggle() {\n      if (this.collapsed || this.isClosing) {\n        this.open();\n      } else {\n        this.close();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    triggerAction() {\n      this.clicked.emit(this);\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      this.opened.pipe(takeUntil(this.d$)).subscribe(() => {\n        const openedEventArgs = {\n          owner: this,\n          id: this._overlayId\n        };\n        this.animationStarted.emit(openedEventArgs);\n      });\n      this.closed.pipe(takeUntil(this.d$)).subscribe(() => {\n        const closedEventArgs = {\n          owner: this,\n          id: this._overlayId\n        };\n        this.animationDone.emit(closedEventArgs);\n      });\n    }\n\n  }\n\n  IgxSnackbarComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxSnackbarComponent_BaseFactory;\n    return function IgxSnackbarComponent_Factory(t) {\n      return (ɵIgxSnackbarComponent_BaseFactory || (ɵIgxSnackbarComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxSnackbarComponent)))(t || IgxSnackbarComponent);\n    };\n  }();\n\n  IgxSnackbarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxSnackbarComponent,\n    selectors: [[\"igx-snackbar\"]],\n    hostVars: 3,\n    hostBindings: function IgxSnackbarComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id);\n        i0.ɵɵclassProp(\"igx-snackbar\", ctx.cssClass);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      actionText: \"actionText\",\n      positionSettings: \"positionSettings\"\n    },\n    outputs: {\n      clicked: \"clicked\",\n      animationStarted: \"animationStarted\",\n      animationDone: \"animationDone\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c8,\n    decls: 4,\n    vars: 2,\n    consts: [[1, \"igx-snackbar__message\"], [\"class\", \"igx-snackbar__button\", \"igxRipple\", \"white\", 3, \"click\", 4, \"ngIf\"], [\"igxRipple\", \"white\", 1, \"igx-snackbar__button\", 3, \"click\"]],\n    template: function IgxSnackbarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵtext(1);\n        i0.ɵɵprojection(2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, IgxSnackbarComponent_button_3_Template, 2, 1, \"button\", 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate1(\" \", ctx.textMessage, \" \");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.actionText);\n      }\n    },\n    directives: [i4.NgIf],\n    encapsulation: 2\n  });\n  return IgxSnackbarComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxSnackbarModule = /*#__PURE__*/(() => {\n  class IgxSnackbarModule {}\n\n  IgxSnackbarModule.ɵfac = function IgxSnackbarModule_Factory(t) {\n    return new (t || IgxSnackbarModule)();\n  };\n\n  IgxSnackbarModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxSnackbarModule\n  });\n  IgxSnackbarModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return IgxSnackbarModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxPaginatorTemplateDirective = /*#__PURE__*/(() => {\n  class IgxPaginatorTemplateDirective {\n    constructor() {\n      /**\n       * @internal\n       * @hidden\n       */\n      this.cssClass = 'igx-paginator-content';\n    }\n\n  }\n\n  IgxPaginatorTemplateDirective.ɵfac = function IgxPaginatorTemplateDirective_Factory(t) {\n    return new (t || IgxPaginatorTemplateDirective)();\n  };\n\n  IgxPaginatorTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxPaginatorTemplateDirective,\n    selectors: [[\"\", \"igxPaginatorContent\", \"\"], [\"igx-paginator-content\"]],\n    hostVars: 2,\n    hostBindings: function IgxPaginatorTemplateDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-paginator-content\", ctx.cssClass);\n      }\n    }\n  });\n  return IgxPaginatorTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxPaginatorComponent = /*#__PURE__*/(() => {\n  class IgxPaginatorComponent extends DisplayDensityBase {\n    constructor(_displayDensityOptions, elementRef, cdr) {\n      super(_displayDensityOptions);\n      this._displayDensityOptions = _displayDensityOptions;\n      this.elementRef = elementRef;\n      this.cdr = cdr;\n      /**\n       * Emitted when `perPage` property value of the paginator is changed.\n       *\n       * @example\n       * ```html\n       * <igx-paginator (perPageChange)=\"onPerPageChange($event)\"></igx-paginator>\n       * ```\n       * ```typescript\n       * public onPerPageChange(perPage: number) {\n       *   this.perPage = perPage;\n       * }\n       * ```\n       */\n\n      this.perPageChange = new EventEmitter();\n      /**\n       * Emitted after the current page is changed.\n       *\n       * @example\n       * ```html\n       * <igx-paginator (pageChange)=\"onPageChange($event)\"></igx-paginator>\n       * ```\n       * ```typescript\n       * public onPageChange(page: number) {\n       *   this.currentPage = page;\n       * }\n       * ```\n       */\n\n      this.pageChange = new EventEmitter();\n      /**\n       * Emitted before paging is performed.\n       *\n       * @remarks\n       * Returns an object consisting of the current and next pages.\n       * @example\n       * ```html\n       * <igx-paginator (paging)=\"pagingHandler($event)\"></igx-paginator>\n       * ```\n       */\n\n      this.paging = new EventEmitter();\n      /**\n       * Emitted after paging is performed.\n       *\n       * @remarks\n       * Returns an object consisting of the previous and current pages.\n       * @example\n       * ```html\n       * <igx-paginator (pagingDone)=\"pagingDone($event)\"></igx-paginator>\n       * ```\n       */\n\n      this.pagingDone = new EventEmitter();\n      this._page = 0;\n      this._selectOptions = [5, 10, 15, 25, 50, 100, 500];\n      this._perPage = 15;\n      this._resourceStrings = CurrentResourceStrings.PaginatorResStrings;\n      this._overlaySettings = {};\n      this.defaultSelectValues = [5, 10, 15, 25, 50, 100, 500];\n    }\n    /**\n     * Sets the class of the IgxPaginatorComponent based\n     * on the provided displayDensity.\n     */\n\n\n    get classCosy() {\n      return this.displayDensity === DisplayDensity.cosy;\n    }\n\n    get classCompact() {\n      return this.displayDensity === DisplayDensity.compact;\n    }\n\n    get classComfortable() {\n      return this.displayDensity === DisplayDensity.comfortable;\n    }\n    /**\n     * An @Input property, sets current page of the `IgxPaginatorComponent`.\n     * The default is 0.\n     * ```typescript\n     * let page = this.paginator.page;\n     * ```\n     *\n     * @memberof IgxPaginatorComponent\n     */\n\n\n    get page() {\n      return this._page;\n    }\n\n    set page(value) {\n      if (this._page === value || value < 0 || value > this.totalPages) {\n        return;\n      }\n\n      const cancelEventArgs = {\n        current: this._page,\n        next: value,\n        cancel: false\n      };\n      const eventArgs = {\n        previous: this._page,\n        current: value\n      };\n      this.paging.emit(cancelEventArgs);\n\n      if (cancelEventArgs.cancel) {\n        return;\n      }\n\n      this._page = value;\n      this.pageChange.emit(this._page);\n      this.pagingDone.emit(eventArgs);\n    }\n    /**\n     * An @Input property, sets number of visible items per page in the `IgxPaginatorComponent`.\n     * The default is 15.\n     * ```typescript\n     * let itemsPerPage = this.paginator.perPage;\n     * ```\n     *\n     * @memberof IgxPaginatorComponent\n     */\n\n\n    get perPage() {\n      return this._perPage;\n    }\n\n    set perPage(value) {\n      if (value < 0 || this.perPage === value) {\n        return;\n      }\n\n      this._perPage = Number(value);\n      this.perPageChange.emit(this._perPage);\n      this._selectOptions = this.sortUniqueOptions(this.defaultSelectValues, this._perPage);\n      this.totalPages = Math.ceil(this.totalRecords / this._perPage);\n\n      if (this.totalPages !== 0 && this.page >= this.totalPages) {\n        this.page = this.totalPages - 1;\n      }\n    }\n    /**\n     * An @Input property that sets the total records.\n     * ```typescript\n     * let totalRecords = this.paginator.totalRecords;\n     * ```\n     *\n     * @memberof IgxPaginatorComponent\n     */\n\n\n    get totalRecords() {\n      return this._totalRecords;\n    }\n\n    set totalRecords(value) {\n      this._totalRecords = value;\n      this.totalPages = Math.ceil(this.totalRecords / this.perPage);\n\n      if (this.page > this.totalPages) {\n        this.page = 0;\n      }\n\n      this.cdr.detectChanges();\n    }\n    /**\n     * An @Input property that sets custom options in the select of the paginator\n     * ```typescript\n     * let options = this.paginator.selectOptions;\n     * ```\n     *\n     * @memberof IgxPaginatorComponent\n     */\n\n\n    get selectOptions() {\n      return this._selectOptions;\n    }\n\n    set selectOptions(value) {\n      this._selectOptions = this.sortUniqueOptions(value, this._perPage);\n      this.defaultSelectValues = [...value];\n    }\n    /**\n     * An @Input property that sets custom OverlaySettings.\n     * ```html\n     * <igx-paginator [overlaySettings] = \"customOverlaySettings\"></igx-paginator>\n     * ```\n     */\n\n\n    get overlaySettings() {\n      return this._overlaySettings;\n    }\n\n    set overlaySettings(value) {\n      this._overlaySettings = Object.assign({}, this._overlaySettings, value);\n    }\n    /**\n     * An accessor that sets the resource strings.\n     * By default it uses EN resources.\n     */\n\n\n    set resourceStrings(value) {\n      this._resourceStrings = Object.assign({}, this._resourceStrings, value);\n    }\n    /**\n     * An accessor that returns the resource strings.\n     */\n\n\n    get resourceStrings() {\n      return this._resourceStrings;\n    }\n    /**\n     * Returns if the current page is the last page.\n     * ```typescript\n     * const lastPage = this.paginator.isLastPage;\n     * ```\n     */\n\n\n    get isLastPage() {\n      return this.page + 1 >= this.totalPages;\n    }\n    /**\n     * Returns if the current page is the first page.\n     * ```typescript\n     * const lastPage = this.paginator.isFirstPage;\n     * ```\n     */\n\n\n    get isFirstPage() {\n      return this.page === 0;\n    }\n    /**\n     * Returns if the first pager buttons should be disabled\n     */\n\n\n    get isFirstPageDisabled() {\n      return this.isFirstPage;\n    }\n    /**\n     * Returns if the last pager buttons should be disabled\n     */\n\n\n    get isLastPageDisabled() {\n      return this.isLastPage;\n    }\n\n    get nativeElement() {\n      return this.elementRef.nativeElement;\n    }\n    /**\n     * Sets DisplayDensity for the <select> inside the paginator\n     *\n     * @hidden\n     */\n\n\n    get paginatorSelectDisplayDensity() {\n      if (this.displayDensity === DisplayDensity.comfortable) {\n        return DisplayDensity.cosy;\n      }\n\n      return DisplayDensity.compact;\n    }\n    /**\n     * Goes to the next page of the `IgxPaginatorComponent`, if the paginator is not already at the last page.\n     * ```typescript\n     * this.paginator.nextPage();\n     * ```\n     *\n     * @memberof IgxPaginatorComponent\n     */\n\n\n    nextPage() {\n      if (!this.isLastPage) {\n        this.page += 1;\n      }\n    }\n    /**\n     * Goes to the previous page of the `IgxPaginatorComponent`, if the paginator is not already at the first page.\n     * ```typescript\n     * this.paginator.previousPage();\n     * ```\n     *\n     * @memberof IgxPaginatorComponent\n     */\n\n\n    previousPage() {\n      if (!this.isFirstPage) {\n        this.page -= 1;\n      }\n    }\n    /**\n     * Goes to the desired page index.\n     * ```typescript\n     * this.paginator.paginate(1);\n     * ```\n     *\n     * @param val\n     * @memberof IgxPaginatorComponent\n     */\n\n\n    paginate(val) {\n      if (val < 0 || val > this.totalPages - 1) {\n        return;\n      }\n\n      this.page = val;\n    }\n\n    sortUniqueOptions(values, newOption) {\n      return Array.from(new Set([...values, newOption])).sort((a, b) => a - b);\n    }\n\n  }\n\n  IgxPaginatorComponent.ɵfac = function IgxPaginatorComponent_Factory(t) {\n    return new (t || IgxPaginatorComponent)(i0.ɵɵdirectiveInject(DisplayDensityToken, 8), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  IgxPaginatorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxPaginatorComponent,\n    selectors: [[\"igx-paginator\"]],\n    contentQueries: function IgxPaginatorComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxPaginatorTemplateDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.customContent = _t.first);\n      }\n    },\n    hostVars: 6,\n    hostBindings: function IgxPaginatorComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-paginator--cosy\", ctx.classCosy)(\"igx-paginator--compact\", ctx.classCompact)(\"igx-paginator\", ctx.classComfortable);\n      }\n    },\n    inputs: {\n      page: \"page\",\n      perPage: \"perPage\",\n      totalRecords: \"totalRecords\",\n      selectOptions: \"selectOptions\",\n      overlaySettings: \"overlaySettings\",\n      resourceStrings: \"resourceStrings\"\n    },\n    outputs: {\n      perPageChange: \"perPageChange\",\n      pageChange: \"pageChange\",\n      paging: \"paging\",\n      pagingDone: \"pagingDone\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c148,\n    decls: 3,\n    vars: 2,\n    consts: [[4, \"ngIf\"]],\n    template: function IgxPaginatorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c147);\n        i0.ɵɵprojection(0);\n        i0.ɵɵtemplate(1, IgxPaginatorComponent_igx_page_size_1_Template, 1, 0, \"igx-page-size\", 0);\n        i0.ɵɵtemplate(2, IgxPaginatorComponent_igx_page_nav_2_Template, 1, 0, \"igx-page-nav\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.customContent);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.customContent);\n      }\n    },\n    directives: function () {\n      return [IgxPageSizeSelectorComponent, IgxPageNavigationComponent, i4.NgIf];\n    },\n    encapsulation: 2\n  });\n  return IgxPaginatorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxPageSizeSelectorComponent = /*#__PURE__*/(() => {\n  class IgxPageSizeSelectorComponent {\n    constructor(paginator) {\n      this.paginator = paginator;\n      /**\n       * @internal\n       * @hidden\n       */\n\n      this.cssClass = 'igx-page-size';\n    }\n\n  }\n\n  IgxPageSizeSelectorComponent.ɵfac = function IgxPageSizeSelectorComponent_Factory(t) {\n    return new (t || IgxPageSizeSelectorComponent)(i0.ɵɵdirectiveInject(IgxPaginatorComponent, 1));\n  };\n\n  IgxPageSizeSelectorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxPageSizeSelectorComponent,\n    selectors: [[\"igx-page-size\"]],\n    hostVars: 2,\n    hostBindings: function IgxPageSizeSelectorComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-page-size\", ctx.cssClass);\n      }\n    },\n    decls: 7,\n    vars: 7,\n    consts: [[1, \"igx-page-size__label\"], [1, \"igx-page-size__select\"], [\"type\", \"border\", 3, \"overlaySettings\", \"ngModel\", \"displayDensity\", \"ngModelChange\"], [\"igxLabel\", \"\", 3, \"hidden\"], [3, \"value\", 4, \"ngFor\", \"ngForOf\"], [3, \"value\"]],\n    template: function IgxPageSizeSelectorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"label\", 0);\n        i0.ɵɵtext(1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(2, \"div\", 1)(3, \"igx-select\", 2);\n        i0.ɵɵlistener(\"ngModelChange\", function IgxPageSizeSelectorComponent_Template_igx_select_ngModelChange_3_listener($event) {\n          return ctx.paginator.perPage = $event;\n        });\n        i0.ɵɵelementStart(4, \"label\", 3);\n        i0.ɵɵtext(5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(6, IgxPageSizeSelectorComponent_igx_select_item_6_Template, 2, 2, \"igx-select-item\", 4);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx.paginator.resourceStrings.igx_paginator_label);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"overlaySettings\", ctx.paginator.overlaySettings)(\"ngModel\", ctx.paginator.perPage)(\"displayDensity\", ctx.paginator.paginatorSelectDisplayDensity);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"hidden\", true);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx.paginator.resourceStrings.igx_paginator_label);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.paginator.selectOptions);\n      }\n    },\n    directives: [IgxSelectComponent, IgxSelectItemComponent, i12.NgControlStatus, i12.NgModel, IgxLabelDirective, i4.NgForOf],\n    encapsulation: 2\n  });\n  return IgxPageSizeSelectorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxPageNavigationComponent = /*#__PURE__*/(() => {\n  class IgxPageNavigationComponent {\n    constructor(paginator) {\n      this.paginator = paginator;\n      /**\n       * @internal\n       * @hidden\n       */\n\n      this.cssClass = 'igx-page-nav';\n      /**\n       * An @Input property that sets the `role` attribute of the element.\n       */\n\n      this.role = 'navigation';\n    }\n\n  }\n\n  IgxPageNavigationComponent.ɵfac = function IgxPageNavigationComponent_Factory(t) {\n    return new (t || IgxPageNavigationComponent)(i0.ɵɵdirectiveInject(IgxPaginatorComponent, 1));\n  };\n\n  IgxPageNavigationComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxPageNavigationComponent,\n    selectors: [[\"igx-page-nav\"]],\n    hostVars: 3,\n    hostBindings: function IgxPageNavigationComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"igx-page-nav\", ctx.cssClass);\n      }\n    },\n    inputs: {\n      role: \"role\"\n    },\n    decls: 19,\n    vars: 19,\n    consts: [[\"igxButton\", \"icon\", \"igxRipple\", \"\", 3, \"title\", \"disabled\", \"igxRippleCentered\", \"click\"], [\"aria-current\", \"page\", 1, \"igx-page-nav__text\"], [\"igxRipple\", \"\", \"igxButton\", \"icon\", 3, \"title\", \"disabled\", \"igxRippleCentered\", \"click\"]],\n    template: function IgxPageNavigationComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"button\", 0);\n        i0.ɵɵlistener(\"click\", function IgxPageNavigationComponent_Template_button_click_0_listener() {\n          return ctx.paginator.paginate(0);\n        });\n        i0.ɵɵelementStart(1, \"igx-icon\");\n        i0.ɵɵtext(2, \"first_page\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(3, \"button\", 0);\n        i0.ɵɵlistener(\"click\", function IgxPageNavigationComponent_Template_button_click_3_listener() {\n          return ctx.paginator.previousPage();\n        });\n        i0.ɵɵelementStart(4, \"igx-icon\");\n        i0.ɵɵtext(5, \"chevron_left\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(6, \"div\", 1)(7, \"span\");\n        i0.ɵɵtext(8);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(9, \"span\");\n        i0.ɵɵtext(10);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(11, \"span\");\n        i0.ɵɵtext(12);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(13, \"button\", 2);\n        i0.ɵɵlistener(\"click\", function IgxPageNavigationComponent_Template_button_click_13_listener() {\n          return ctx.paginator.nextPage();\n        });\n        i0.ɵɵelementStart(14, \"igx-icon\");\n        i0.ɵɵtext(15, \"chevron_right\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(16, \"button\", 0);\n        i0.ɵɵlistener(\"click\", function IgxPageNavigationComponent_Template_button_click_16_listener() {\n          return ctx.paginator.paginate(ctx.paginator.totalPages - 1);\n        });\n        i0.ɵɵelementStart(17, \"igx-icon\");\n        i0.ɵɵtext(18, \"last_page\");\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"title\", ctx.paginator.resourceStrings.igx_paginator_first_page_button_text)(\"disabled\", ctx.paginator.isFirstPageDisabled)(\"igxRippleCentered\", true);\n        i0.ɵɵattribute(\"aria-disabled\", ctx.paginator.isFirstPageDisabled);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"title\", ctx.paginator.resourceStrings.igx_paginator_previous_page_button_text)(\"disabled\", ctx.paginator.isFirstPageDisabled)(\"igxRippleCentered\", true);\n        i0.ɵɵattribute(\"aria-disabled\", ctx.paginator.isFirstPageDisabled);\n        i0.ɵɵadvance(5);\n        i0.ɵɵtextInterpolate(ctx.paginator.page + 1);\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate1(\"\\xA0\", ctx.paginator.resourceStrings.igx_paginator_pager_text, \"\\xA0\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate(ctx.paginator.totalPages);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"title\", ctx.paginator.resourceStrings.igx_paginator_next_page_button_text)(\"disabled\", ctx.paginator.isLastPageDisabled)(\"igxRippleCentered\", true);\n        i0.ɵɵattribute(\"aria-disabled\", ctx.paginator.isLastPageDisabled);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"title\", ctx.paginator.resourceStrings.igx_paginator_last_page_button_text)(\"disabled\", ctx.paginator.isLastPageDisabled)(\"igxRippleCentered\", true);\n        i0.ɵɵattribute(\"aria-disabled\", ctx.paginator.isLastPageDisabled);\n      }\n    },\n    directives: [IgxIconComponent, IgxButtonDirective, IgxRippleDirective],\n    encapsulation: 2\n  });\n  return IgxPageNavigationComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nclass ExcelStylePositionStrategy extends AutoPositionStrategy {\n  shouldFitInViewPort() {\n    return true;\n  }\n\n  fitInViewport(element, connectedFit) {\n    const heightOverflow = connectedFit.contentElementRect.height - connectedFit.viewPortRect.height;\n\n    if (heightOverflow > 0) {\n      element.style.width = 'auto';\n      element.style.height = `${connectedFit.viewPortRect.height}px`;\n    } else {\n      element.style.height = `${Math.max(connectedFit.viewPortRect.height - connectedFit.targetRect.bottom - 1, connectedFit.contentElementRect.height)}px`;\n    }\n\n    super.fitInViewport(element, connectedFit);\n  }\n\n}\n/**\n * @hidden\n */\n\n\nlet IgxFilteringService = /*#__PURE__*/(() => {\n  class IgxFilteringService {\n    constructor(iconService, _overlayService) {\n      this.iconService = iconService;\n      this._overlayService = _overlayService;\n      this.isFilterRowVisible = false;\n      this.filteredColumn = null;\n      this.selectedExpression = null;\n      this.columnToMoreIconHidden = new Map();\n      this.activeFilterCell = 0;\n      this.columnsWithComplexFilter = new Set();\n      this.areEventsSubscribed = false;\n      this.destroy$ = new Subject();\n      this.isFiltering = false;\n      this.columnToExpressionsMap = new Map();\n      this.columnStartIndex = -1;\n      this._filterMenuOverlaySettings = {\n        closeOnEscape: true,\n        closeOnOutsideClick: true,\n        modal: false,\n        positionStrategy: new ExcelStylePositionStrategy({\n          verticalStartPoint: VerticalAlignment.Bottom,\n          openAnimation: useAnimation(fadeIn, {\n            params: {\n              duration: '250ms'\n            }\n          }),\n          closeAnimation: null\n        }),\n        scrollStrategy: new AbsoluteScrollStrategy()\n      };\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next(true);\n      this.destroy$.complete();\n    }\n\n    toggleFilterDropdown(element, column) {\n      const filterIcon = column.filteringExpressionsTree ? 'igx-excel-filter__icon--filtered' : 'igx-excel-filter__icon';\n      const filterIconTarget = element.querySelector(`.${filterIcon}`) || element;\n      const {\n        id,\n        ref\n      } = this.grid.createFilterDropdown(column, Object.assign(Object.assign({}, this._filterMenuOverlaySettings), {\n        target: filterIconTarget\n      }));\n\n      this._overlayService.opening.pipe(first$1(overlay => overlay.id === id), takeUntil(this.destroy$)).subscribe(() => this.lastActiveNode = this.grid.navigation.activeNode);\n\n      this._overlayService.closed.pipe(first$1(overlay => overlay.id === id), takeUntil(this.destroy$)).subscribe(() => {\n        this._overlayService.detach(id);\n\n        ref === null || ref === void 0 ? void 0 : ref.destroy();\n        this.grid.navigation.activeNode = this.lastActiveNode;\n        this.grid.theadRow.nativeElement.focus();\n      });\n\n      this.grid.columnPinned.pipe(first$1()).subscribe(() => ref === null || ref === void 0 ? void 0 : ref.destroy());\n\n      this._overlayService.show(id);\n    }\n    /**\n     * Subscribe to grid's events.\n     */\n\n\n    subscribeToEvents() {\n      if (!this.areEventsSubscribed) {\n        this.areEventsSubscribed = true;\n        this.grid.columnResized.pipe(takeUntil(this.destroy$)).subscribe(eventArgs => {\n          this.updateFilteringCell(eventArgs.column);\n        });\n        this.grid.parentVirtDir.chunkLoad.pipe(takeUntil(this.destroy$)).subscribe(eventArgs => {\n          if (eventArgs.startIndex !== this.columnStartIndex) {\n            this.columnStartIndex = eventArgs.startIndex;\n            this.grid.filterCellList.forEach(filterCell => {\n              filterCell.updateFilterCellArea();\n            });\n          }\n        });\n        this.grid.columnMovingEnd.pipe(takeUntil(this.destroy$)).subscribe(() => {\n          this.grid.filterCellList.forEach(filterCell => {\n            filterCell.updateFilterCellArea();\n          });\n        });\n      }\n    }\n    /**\n     * Close filtering row if a column is hidden.\n     */\n\n\n    hideFilteringRowOnColumnVisibilityChange(col) {\n      const filteringRow = this.grid.filteringRow;\n\n      if (filteringRow && filteringRow.column && filteringRow.column === col) {\n        filteringRow.close();\n      }\n    }\n    /**\n     * Internal method to create expressionsTree and filter grid used in both filter modes.\n     */\n\n\n    filterInternal(field, expressions = null) {\n      this.isFiltering = true;\n      let expressionsTree;\n\n      if (expressions instanceof FilteringExpressionsTree) {\n        expressionsTree = expressions;\n      } else {\n        expressionsTree = this.createSimpleFilteringTree(field, expressions);\n      }\n\n      if (expressionsTree.filteringOperands.length === 0) {\n        this.clearFilter(field);\n      } else {\n        this.filter(field, null, expressionsTree);\n      }\n\n      this.isFiltering = false;\n    }\n    /**\n     * Execute filtering on the grid.\n     */\n\n\n    filter(field, value, conditionOrExpressionTree, ignoreCase) {\n      const grid = this.grid;\n      const col = grid.getColumnByName(field);\n      const filteringIgnoreCase = ignoreCase || (col ? col.filteringIgnoreCase : false);\n      const filteringTree = grid.filteringExpressionsTree;\n      const columnFilteringExpressionsTree = filteringTree.find(field);\n      conditionOrExpressionTree = conditionOrExpressionTree !== null && conditionOrExpressionTree !== void 0 ? conditionOrExpressionTree : columnFilteringExpressionsTree;\n      const fieldFilterIndex = filteringTree.findIndex(field);\n      const newFilteringTree = this.prepare_filtering_expression(filteringTree, field, value, conditionOrExpressionTree, filteringIgnoreCase, fieldFilterIndex, true);\n      const eventArgs = {\n        owner: grid,\n        filteringExpressions: newFilteringTree.find(field),\n        cancel: false\n      };\n      this.grid.filtering.emit(eventArgs);\n\n      if (eventArgs.cancel) {\n        return;\n      }\n\n      if (conditionOrExpressionTree) {\n        this.filter_internal(field, value, conditionOrExpressionTree, filteringIgnoreCase);\n      } else {\n        const expressionsTreeForColumn = this.grid.filteringExpressionsTree.find(field);\n\n        if (!expressionsTreeForColumn) {\n          throw new Error('Invalid condition or Expression Tree!');\n        } else if (expressionsTreeForColumn instanceof FilteringExpressionsTree) {\n          this.filter_internal(field, value, expressionsTreeForColumn, filteringIgnoreCase);\n        } else {\n          const expressionForColumn = expressionsTreeForColumn;\n          this.filter_internal(field, value, expressionForColumn.condition, filteringIgnoreCase);\n        }\n      }\n\n      const doneEventArgs = this.grid.filteringExpressionsTree.find(field); // Wait for the change detection to update filtered data through the pipes and then emit the event.\n\n      requestAnimationFrame(() => this.grid.filteringDone.emit(doneEventArgs));\n    }\n\n    filter_global(term, condition, ignoreCase) {\n      if (!condition) {\n        return;\n      }\n\n      const grid = this.grid;\n      const filteringTree = grid.filteringExpressionsTree;\n      grid.crudService.endEdit(false);\n\n      if (grid.paginator) {\n        grid.paginator.page = 0;\n      }\n\n      filteringTree.filteringOperands = [];\n\n      for (const column of grid.columnList) {\n        this.prepare_filtering_expression(filteringTree, column.field, term, condition, ignoreCase || column.filteringIgnoreCase);\n      }\n\n      grid.filteringExpressionsTree = filteringTree;\n    }\n    /**\n     * Clears the filter of a given column if name is provided. Otherwise clears the filters of all columns.\n     */\n\n\n    clearFilter(field) {\n      if (field) {\n        const column = this.grid.getColumnByName(field);\n\n        if (!column) {\n          return;\n        }\n      }\n\n      const emptyFilter = new FilteringExpressionsTree(null, field);\n      const onFilteringEventArgs = {\n        owner: this.grid,\n        filteringExpressions: emptyFilter,\n        cancel: false\n      };\n      this.grid.filtering.emit(onFilteringEventArgs);\n\n      if (onFilteringEventArgs.cancel) {\n        return;\n      }\n\n      this.isFiltering = true;\n      this.clear_filter(field); // Wait for the change detection to update filtered data through the pipes and then emit the event.\n\n      requestAnimationFrame(() => this.grid.filteringDone.emit(emptyFilter));\n\n      if (field) {\n        const expressions = this.getExpressions(field);\n        expressions.length = 0;\n      } else {\n        this.grid.columnList.forEach(c => {\n          const expressions = this.getExpressions(c.field);\n          expressions.length = 0;\n        });\n      }\n\n      this.isFiltering = false;\n    }\n\n    clear_filter(fieldName) {\n      const grid = this.grid;\n      grid.crudService.endEdit(false);\n      const filteringState = grid.filteringExpressionsTree;\n      const index = filteringState.findIndex(fieldName);\n\n      if (index > -1) {\n        filteringState.filteringOperands.splice(index, 1);\n      } else if (!fieldName) {\n        filteringState.filteringOperands = [];\n      }\n\n      grid.filteringExpressionsTree = filteringState;\n    }\n    /**\n     * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.\n     */\n\n\n    filterGlobal(value, condition, ignoreCase) {\n      if (!condition) {\n        return;\n      }\n\n      const grid = this.grid;\n      const filteringTree = grid.filteringExpressionsTree;\n      const newFilteringTree = new FilteringExpressionsTree(filteringTree.operator, filteringTree.fieldName);\n\n      for (const column of grid.columnList) {\n        this.prepare_filtering_expression(newFilteringTree, column.field, value, condition, ignoreCase || column.filteringIgnoreCase);\n      }\n\n      const eventArgs = {\n        owner: grid,\n        filteringExpressions: newFilteringTree,\n        cancel: false\n      };\n      grid.filtering.emit(eventArgs);\n\n      if (eventArgs.cancel) {\n        return;\n      }\n\n      this.grid.crudService.endEdit(false);\n\n      if (grid.paginator) {\n        grid.paginator.page = 0;\n      }\n\n      grid.filteringExpressionsTree = newFilteringTree; // Wait for the change detection to update filtered data through the pipes and then emit the event.\n\n      requestAnimationFrame(() => this.grid.filteringDone.emit(this.grid.filteringExpressionsTree));\n    }\n    /**\n     * Register filtering SVG icons in the icon service.\n     */\n\n\n    registerSVGIcons() {\n      const editorIcons = editor;\n      editorIcons.forEach(icon => this.iconService.addSvgIconFromText(icon.name, icon.value, 'imx-icons'));\n      this.iconService.addSvgIconFromText(pinLeft.name, pinLeft.value, 'imx-icons');\n      this.iconService.addSvgIconFromText(unpinLeft.name, unpinLeft.value, 'imx-icons');\n    }\n    /**\n     * Returns the ExpressionUI array for a given column.\n     */\n\n\n    getExpressions(columnId) {\n      if (!this.columnToExpressionsMap.has(columnId)) {\n        const column = this.grid.columnList.find(col => col.field === columnId);\n        const expressionUIs = new Array();\n\n        if (column) {\n          this.generateExpressionsList(column.filteringExpressionsTree, this.grid.filteringExpressionsTree.operator, expressionUIs);\n          this.columnToExpressionsMap.set(columnId, expressionUIs);\n        }\n\n        return expressionUIs;\n      }\n\n      return this.columnToExpressionsMap.get(columnId);\n    }\n    /**\n     * Recreates all ExpressionUIs for all columns. Executed after filtering to refresh the cache.\n     */\n\n\n    refreshExpressions() {\n      if (!this.isFiltering) {\n        this.columnsWithComplexFilter.clear();\n        this.columnToExpressionsMap.forEach((value, key) => {\n          const column = this.grid.columnList.find(col => col.field === key);\n\n          if (column) {\n            value.length = 0;\n            this.generateExpressionsList(column.filteringExpressionsTree, this.grid.filteringExpressionsTree.operator, value);\n            const isComplex = this.isFilteringTreeComplex(column.filteringExpressionsTree);\n\n            if (isComplex) {\n              this.columnsWithComplexFilter.add(key);\n            }\n\n            this.updateFilteringCell(column);\n          } else {\n            this.columnToExpressionsMap.delete(key);\n          }\n        });\n      }\n    }\n    /**\n     * Remove an ExpressionUI for a given column.\n     */\n\n\n    removeExpression(columnId, indexToRemove) {\n      const expressionsList = this.getExpressions(columnId);\n\n      if (indexToRemove === 0 && expressionsList.length > 1) {\n        expressionsList[1].beforeOperator = null;\n      } else if (indexToRemove === expressionsList.length - 1) {\n        expressionsList[indexToRemove - 1].afterOperator = null;\n      } else {\n        expressionsList[indexToRemove - 1].afterOperator = expressionsList[indexToRemove + 1].beforeOperator;\n        expressionsList[0].beforeOperator = null;\n        expressionsList[expressionsList.length - 1].afterOperator = null;\n      }\n\n      expressionsList.splice(indexToRemove, 1);\n    }\n    /**\n     * Generate filtering tree for a given column from existing ExpressionUIs.\n     */\n\n\n    createSimpleFilteringTree(columnId, expressionUIList = null) {\n      const expressionsList = expressionUIList ? expressionUIList : this.getExpressions(columnId);\n      const expressionsTree = new FilteringExpressionsTree(FilteringLogic.Or, columnId);\n      let currAndBranch;\n\n      for (const currExpressionUI of expressionsList) {\n        if (!currExpressionUI.expression.condition.isUnary && currExpressionUI.expression.searchVal === null) {\n          if (currExpressionUI.afterOperator === FilteringLogic.And && !currAndBranch) {\n            currAndBranch = new FilteringExpressionsTree(FilteringLogic.And, columnId);\n            expressionsTree.filteringOperands.push(currAndBranch);\n          }\n\n          continue;\n        }\n\n        if ((currExpressionUI.beforeOperator === undefined || currExpressionUI.beforeOperator === null || currExpressionUI.beforeOperator === FilteringLogic.Or) && currExpressionUI.afterOperator === FilteringLogic.And) {\n          currAndBranch = new FilteringExpressionsTree(FilteringLogic.And, columnId);\n          expressionsTree.filteringOperands.push(currAndBranch);\n          currAndBranch.filteringOperands.push(currExpressionUI.expression);\n        } else if (currExpressionUI.beforeOperator === FilteringLogic.And) {\n          currAndBranch.filteringOperands.push(currExpressionUI.expression);\n        } else {\n          expressionsTree.filteringOperands.push(currExpressionUI.expression);\n          currAndBranch = null;\n        }\n      }\n\n      return expressionsTree;\n    }\n    /**\n     * Returns whether a complex filter is applied to a given column.\n     */\n\n\n    isFilterComplex(columnId) {\n      if (this.columnsWithComplexFilter.has(columnId)) {\n        return true;\n      }\n\n      const column = this.grid.columnList.find(col => col.field === columnId);\n      const isComplex = column && this.isFilteringTreeComplex(column.filteringExpressionsTree);\n\n      if (isComplex) {\n        this.columnsWithComplexFilter.add(columnId);\n      }\n\n      return isComplex;\n    }\n    /**\n     * Returns the string representation of the FilteringLogic operator.\n     */\n\n\n    getOperatorAsString(operator) {\n      if (operator === 0) {\n        return this.grid.resourceStrings.igx_grid_filter_operator_and;\n      } else {\n        return this.grid.resourceStrings.igx_grid_filter_operator_or;\n      }\n    }\n    /**\n     * Generate the label of a chip from a given filtering expression.\n     */\n\n\n    getChipLabel(expression) {\n      if (expression.condition.isUnary) {\n        return this.grid.resourceStrings[`igx_grid_filter_${expression.condition.name}`] || expression.condition.name;\n      } else if (expression.searchVal instanceof Date) {\n        const column = this.grid.getColumnByName(expression.fieldName);\n        const formatter = column.formatter;\n\n        if (formatter) {\n          return formatter(expression.searchVal, undefined);\n        }\n\n        const pipeArgs = column.pipeArgs;\n        return formatDate(expression.searchVal, pipeArgs.format, this.grid.locale);\n      } else {\n        return expression.searchVal;\n      }\n    }\n    /**\n     * Updates the content of a filterCell.\n     */\n\n\n    updateFilteringCell(column) {\n      const filterCell = column.filterCell;\n\n      if (filterCell) {\n        filterCell.updateFilterCellArea();\n      }\n    }\n\n    generateExpressionsList(expressions, operator, expressionsUIs) {\n      generateExpressionsList(expressions, operator, expressionsUIs);\n    }\n\n    isFilteringExpressionsTreeEmpty(expressionTree) {\n      if (FilteringExpressionsTree.empty(expressionTree)) {\n        return true;\n      }\n\n      for (const expr of expressionTree.filteringOperands) {\n        if (expr instanceof FilteringExpressionsTree) {\n          const exprTree = expr;\n\n          if (exprTree.filteringOperands && exprTree.filteringOperands.length) {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    filter_internal(fieldName, term, conditionOrExpressionsTree, ignoreCase) {\n      const grid = this.grid;\n      const filteringTree = grid.filteringExpressionsTree;\n      this.grid.crudService.endEdit(false);\n\n      if (grid.paginator) {\n        grid.paginator.page = 0;\n      }\n\n      const fieldFilterIndex = filteringTree.findIndex(fieldName);\n      this.prepare_filtering_expression(filteringTree, fieldName, term, conditionOrExpressionsTree, ignoreCase, fieldFilterIndex);\n      grid.filteringExpressionsTree = filteringTree;\n    }\n    /** Modifies the filteringState object to contain the newly added filtering conditions/expressions.\n     * If createNewTree is true, filteringState will not be modified (because it directly affects the grid.filteringExpressionsTree),\n     * but a new object is created and returned.\n     */\n\n\n    prepare_filtering_expression(filteringState, fieldName, searchVal, conditionOrExpressionsTree, ignoreCase, insertAtIndex = -1, createNewTree = false) {\n      let expressionsTree = conditionOrExpressionsTree instanceof FilteringExpressionsTree ? conditionOrExpressionsTree : null;\n      const condition = conditionOrExpressionsTree instanceof FilteringExpressionsTree ? null : conditionOrExpressionsTree;\n      let newExpressionsTree = filteringState;\n\n      if (createNewTree) {\n        newExpressionsTree = new FilteringExpressionsTree(filteringState.operator, filteringState.fieldName);\n        newExpressionsTree.filteringOperands = [...filteringState.filteringOperands];\n      }\n\n      if (condition) {\n        const newExpression = {\n          fieldName,\n          searchVal,\n          condition,\n          ignoreCase\n        };\n        expressionsTree = new FilteringExpressionsTree(filteringState.operator, fieldName);\n        expressionsTree.filteringOperands.push(newExpression);\n      }\n\n      if (expressionsTree) {\n        if (insertAtIndex > -1) {\n          newExpressionsTree.filteringOperands[insertAtIndex] = expressionsTree;\n        } else {\n          newExpressionsTree.filteringOperands.push(expressionsTree);\n        }\n      }\n\n      return newExpressionsTree;\n    }\n\n    isFilteringTreeComplex(expressions) {\n      if (!expressions) {\n        return false;\n      }\n\n      if (expressions instanceof FilteringExpressionsTree) {\n        const expressionsTree = expressions;\n\n        if (expressionsTree.operator === FilteringLogic.Or) {\n          const andOperatorsCount = this.getChildAndOperatorsCount(expressionsTree); // having more than one 'And' operator in the sub-tree means that the filter could not be represented without parentheses.\n\n          return andOperatorsCount > 1;\n        }\n\n        let isComplex = false;\n\n        for (const operand of expressionsTree.filteringOperands) {\n          isComplex = isComplex || this.isFilteringTreeComplex(operand);\n        }\n\n        return isComplex;\n      }\n\n      return false;\n    }\n\n    getChildAndOperatorsCount(expressions) {\n      let count = 0;\n      let operand;\n\n      for (let i = 0; i < expressions.filteringOperands.length; i++) {\n        operand = expressions[i];\n\n        if (operand instanceof FilteringExpressionsTree) {\n          if (operand.operator === FilteringLogic.And) {\n            count++;\n          }\n\n          count = count + this.getChildAndOperatorsCount(operand);\n        }\n      }\n\n      return count;\n    }\n\n  }\n\n  IgxFilteringService.ɵfac = function IgxFilteringService_Factory(t) {\n    return new (t || IgxFilteringService)(i0.ɵɵinject(IgxIconService), i0.ɵɵinject(IgxOverlayService));\n  };\n\n  IgxFilteringService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxFilteringService,\n    factory: IgxFilteringService.ɵfac\n  });\n  return IgxFilteringService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxGridFilteringRowComponent = /*#__PURE__*/(() => {\n  class IgxGridFilteringRowComponent {\n    constructor(filteringService, ref, cdr, platform) {\n      this.filteringService = filteringService;\n      this.ref = ref;\n      this.cdr = cdr;\n      this.platform = platform;\n      this.defaultCSSClass = true;\n      this._positionSettings = {\n        horizontalStartPoint: HorizontalAlignment.Left,\n        verticalStartPoint: VerticalAlignment.Bottom\n      };\n      this._conditionsOverlaySettings = {\n        closeOnOutsideClick: true,\n        modal: false,\n        scrollStrategy: new AbsoluteScrollStrategy(),\n        positionStrategy: new ConnectedPositioningStrategy(this._positionSettings)\n      };\n      this._operatorsOverlaySettings = {\n        closeOnOutsideClick: true,\n        modal: false,\n        scrollStrategy: new AbsoluteScrollStrategy(),\n        positionStrategy: new ConnectedPositioningStrategy(this._positionSettings)\n      };\n      this.chipAreaScrollOffset = 0;\n      this._column = null;\n      this.isKeyPressed = false;\n      this.isComposing = false;\n      this._cancelChipClick = false;\n      /** switch to icon buttons when width is below 432px */\n\n      this.NARROW_WIDTH_THRESHOLD = 432;\n      this.$destroyer = new Subject();\n    }\n\n    get column() {\n      return this._column;\n    }\n\n    set column(val) {\n      if (this._column) {\n        this.expressionsList.forEach(exp => exp.isSelected = false);\n      }\n\n      if (val) {\n        this._column = val;\n        this.expressionsList = this.filteringService.getExpressions(this._column.field);\n        this.resetExpression();\n        this.chipAreaScrollOffset = 0;\n        this.transform(this.chipAreaScrollOffset);\n      }\n    }\n\n    get value() {\n      return this.expression ? this.expression.searchVal : null;\n    }\n\n    set value(val) {\n      if (!val && val !== 0) {\n        this.expression.searchVal = null;\n        const index = this.expressionsList.findIndex(item => item.expression === this.expression);\n\n        if (index === 0 && this.expressionsList.length === 1) {\n          this.filteringService.clearFilter(this.column.field);\n\n          if (this.expression.condition.isUnary) {\n            this.resetExpression();\n          }\n\n          return;\n        }\n      } else {\n        const oldValue = this.expression.searchVal;\n\n        if (isEqual(oldValue, val)) {\n          return;\n        }\n\n        this.expression.searchVal = DataUtil.parseValue(this.column.dataType, val);\n\n        if (this.expressionsList.find(item => item.expression === this.expression) === undefined) {\n          this.addExpression(true);\n        }\n\n        this.filter();\n      }\n    }\n\n    get displayDensity() {\n      return this.column.grid.displayDensity === DisplayDensity.comfortable ? DisplayDensity.cosy : this.column.grid.displayDensity;\n    }\n\n    get compactCSSClass() {\n      return this.column.grid.displayDensity === DisplayDensity.compact;\n    }\n\n    get cosyCSSClass() {\n      return this.column.grid.displayDensity === DisplayDensity.cosy;\n    }\n\n    get nativeElement() {\n      return this.ref.nativeElement;\n    }\n\n    onKeydownHandler(evt) {\n      if (this.platform.isFilteringKeyCombo(evt)) {\n        evt.preventDefault();\n        evt.stopPropagation();\n        this.close();\n      }\n    }\n\n    ngAfterViewInit() {\n      this._conditionsOverlaySettings.outlet = this.column.grid.outlet;\n      this._operatorsOverlaySettings.outlet = this.column.grid.outlet;\n      const selectedItem = this.expressionsList.find(expr => expr.isSelected === true);\n\n      if (selectedItem) {\n        this.expression = selectedItem.expression;\n      }\n\n      this.filteringService.grid.localeChange.pipe(takeUntil(this.$destroyer)).subscribe(() => {\n        this.cdr.markForCheck();\n      });\n      requestAnimationFrame(() => this.focusEditElement());\n    }\n\n    get disabled() {\n      return !(this.column.filteringExpressionsTree && this.column.filteringExpressionsTree.filteringOperands.length > 0);\n    }\n\n    get template() {\n      if (this.column.dataType === GridColumnDataType.Date) {\n        return this.defaultDateUI;\n      }\n\n      if (this.column.dataType === GridColumnDataType.Time) {\n        return this.defaultTimeUI;\n      }\n\n      if (this.column.dataType === GridColumnDataType.DateTime) {\n        return this.defaultDateTimeUI;\n      }\n\n      return this.defaultFilterUI;\n    }\n\n    get type() {\n      switch (this.column.dataType) {\n        case GridColumnDataType.String:\n        case GridColumnDataType.Boolean:\n          return 'text';\n\n        case GridColumnDataType.Number:\n        case GridColumnDataType.Currency:\n          return 'number';\n      }\n    }\n\n    get conditions() {\n      return this.column.filters.conditionList();\n    }\n\n    get isUnaryCondition() {\n      if (this.expression.condition) {\n        return this.expression.condition.isUnary;\n      } else {\n        return true;\n      }\n    }\n\n    get placeholder() {\n      if (this.expression.condition && this.expression.condition.isUnary) {\n        return this.filteringService.getChipLabel(this.expression);\n      } else if (this.column.dataType === GridColumnDataType.Date) {\n        return this.filteringService.grid.resourceStrings.igx_grid_filter_row_date_placeholder;\n      } else if (this.column.dataType === GridColumnDataType.Boolean) {\n        return this.filteringService.grid.resourceStrings.igx_grid_filter_row_boolean_placeholder;\n      } else {\n        return this.filteringService.grid.resourceStrings.igx_grid_filter_row_placeholder;\n      }\n    }\n    /**\n     * Event handler for keydown on the input group's prefix.\n     */\n\n\n    onPrefixKeyDown(event) {\n      if (this.platform.isActivationKey(event) && this.dropDownConditions.collapsed) {\n        this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);\n        event.stopImmediatePropagation();\n      } else if (event.key === this.platform.KEYMAP.TAB && !this.dropDownConditions.collapsed) {\n        this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);\n      }\n    }\n    /**\n     * Event handler for keydown on the input.\n     */\n\n\n    onInputKeyDown(event) {\n      this.isKeyPressed = true;\n      event.stopPropagation();\n\n      if (this.column.dataType === GridColumnDataType.Boolean) {\n        if (this.platform.isActivationKey(event)) {\n          this.inputGroupPrefix.nativeElement.focus();\n          this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);\n          return;\n        }\n      }\n\n      if (event.key === this.platform.KEYMAP.ENTER) {\n        if (this.isComposing) {\n          return;\n        }\n\n        this.commitInput();\n      } else if (event.altKey && event.key === this.platform.KEYMAP.ARROW_DOWN) {\n        this.inputGroupPrefix.nativeElement.focus();\n        this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);\n      } else if (this.platform.isFilteringKeyCombo(event)) {\n        event.preventDefault();\n        this.close();\n      }\n    }\n    /**\n     * Event handler for keyup on the input.\n     */\n\n\n    onInputKeyUp() {\n      this.isKeyPressed = false;\n    }\n    /**\n     * Event handler for input on the input.\n     */\n\n\n    onInput(eventArgs) {\n      // The 'iskeyPressed' flag is needed for a case in IE, because the input event is fired on focus and for some reason,\n      // when you have a japanese character as a placeholder, on init the value here is empty string .\n      const target = eventArgs.target;\n\n      if (this.column.dataType === GridColumnDataType.DateTime) {\n        this.value = eventArgs;\n        return;\n      }\n\n      if (this.platform.isEdge && target.type !== 'number' || this.isKeyPressed || target.value || target.checkValidity()) {\n        this.value = target.value;\n      }\n    }\n    /**\n     * Event handler for compositionstart on the input.\n     */\n\n\n    onCompositionStart() {\n      this.isComposing = true;\n    }\n    /**\n     * Event handler for compositionend on the input.\n     */\n\n\n    onCompositionEnd() {\n      this.isComposing = false;\n    }\n    /**\n     * Event handler for input click event.\n     */\n\n\n    onInputClick() {\n      if (this.column.dataType === GridColumnDataType.Boolean && this.dropDownConditions.collapsed) {\n        this.inputGroupPrefix.nativeElement.focus();\n        this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);\n      }\n    }\n    /**\n     * Returns the filtering operation condition for a given value.\n     */\n\n\n    getCondition(value) {\n      return this.column.filters.condition(value);\n    }\n    /**\n     * Returns the translated condition name for a given value.\n     */\n\n\n    translateCondition(value) {\n      return this.filteringService.grid.resourceStrings[`igx_grid_filter_${this.getCondition(value).name}`] || value;\n    }\n    /**\n     * Returns the icon name of the current condition.\n     */\n\n\n    getIconName() {\n      if (this.column.dataType === GridColumnDataType.Boolean && this.expression.condition === null) {\n        return this.getCondition(this.conditions[0]).iconName;\n      } else {\n        return this.expression.condition.iconName;\n      }\n    }\n    /**\n     * Returns whether a given condition is selected in dropdown.\n     */\n\n\n    isConditionSelected(conditionName) {\n      if (this.expression.condition) {\n        return this.expression.condition.name === conditionName;\n      } else {\n        return false;\n      }\n    }\n    /**\n     * Clears the current filtering.\n     */\n\n\n    clearFiltering() {\n      this.filteringService.clearFilter(this.column.field);\n      this.resetExpression();\n\n      if (this.input) {\n        this.input.nativeElement.focus();\n      }\n\n      this.cdr.detectChanges();\n      this.chipAreaScrollOffset = 0;\n      this.transform(this.chipAreaScrollOffset);\n    }\n    /**\n     * Commits the value of the input.\n     */\n\n\n    commitInput() {\n      const selectedItem = this.expressionsList.filter(ex => ex.isSelected === true);\n      selectedItem.forEach(e => e.isSelected = false);\n      let indexToDeselect = -1;\n\n      for (let index = 0; index < this.expressionsList.length; index++) {\n        const expression = this.expressionsList[index].expression;\n\n        if (expression.searchVal === null && !expression.condition.isUnary) {\n          indexToDeselect = index;\n        }\n      }\n\n      if (indexToDeselect !== -1) {\n        this.removeExpression(indexToDeselect, this.expression);\n      }\n\n      this.resetExpression();\n      this.scrollChipsWhenAddingExpression();\n    }\n    /**\n     * Clears the value of the input.\n     */\n\n\n    clearInput(event) {\n      event === null || event === void 0 ? void 0 : event.stopPropagation();\n      this.value = null;\n    }\n    /**\n     * Event handler for keydown on clear button.\n     */\n\n\n    onClearKeyDown(eventArgs) {\n      if (this.platform.isActivationKey(eventArgs)) {\n        eventArgs.preventDefault();\n        this.clearInput();\n        this.focusEditElement();\n      }\n    }\n    /**\n     * Event handler for click on clear button.\n     */\n\n\n    onClearClick() {\n      this.clearInput();\n      this.focusEditElement();\n    }\n    /**\n     * Event handler for keydown on commit button.\n     */\n\n\n    onCommitKeyDown(eventArgs) {\n      if (this.platform.isActivationKey(eventArgs)) {\n        eventArgs.preventDefault();\n        this.commitInput();\n        this.focusEditElement();\n      }\n    }\n    /**\n     * Event handler for click on commit button.\n     */\n\n\n    onCommitClick(event) {\n      event === null || event === void 0 ? void 0 : event.stopPropagation();\n      this.commitInput();\n      this.focusEditElement();\n    }\n    /**\n     * Event handler for focusout on the input group.\n     */\n\n\n    onInputGroupFocusout() {\n      if (!this.value && this.value !== 0 && this.expression.condition && !this.expression.condition.isUnary) {\n        return;\n      }\n\n      requestAnimationFrame(() => {\n        const focusedElement = document.activeElement;\n\n        if (focusedElement.classList.contains('igx-chip__remove') || focusedElement.tagName === 'IGX-DAY-ITEM') {\n          return;\n        }\n\n        if (!(focusedElement && this.editorsContain(focusedElement)) && this.dropDownConditions.collapsed) {\n          this.commitInput();\n        }\n      });\n    }\n    /**\n     * Closes the filtering edit row.\n     */\n\n\n    close() {\n      if (this.expressionsList.length === 1 && this.expressionsList[0].expression.searchVal === null && this.expressionsList[0].expression.condition.isUnary === false) {\n        this.filteringService.getExpressions(this.column.field).pop();\n        this.filter();\n      } else {\n        const condToRemove = this.expressionsList.filter(ex => ex.expression.searchVal === null && !ex.expression.condition.isUnary);\n\n        if (condToRemove && condToRemove.length > 0) {\n          condToRemove.forEach(c => this.filteringService.removeExpression(this.column.field, this.expressionsList.indexOf(c)));\n          this.filter();\n        }\n      }\n\n      this.filteringService.isFilterRowVisible = false;\n      this.filteringService.updateFilteringCell(this.column);\n      this.filteringService.filteredColumn = null;\n      this.filteringService.selectedExpression = null;\n      this.filteringService.grid.theadRow.nativeElement.focus();\n      this.chipAreaScrollOffset = 0;\n      this.transform(this.chipAreaScrollOffset);\n    }\n    /**\n     *  Event handler for date picker's selection.\n     */\n\n\n    onDateSelected(value) {\n      this.value = value;\n    }\n    /** @hidden @internal */\n\n\n    inputGroupPrefixClick(event) {\n      event.stopPropagation();\n      event.currentTarget.focus();\n      this.toggleConditionsDropDown(event.currentTarget);\n    }\n    /**\n     * Opens the conditions dropdown.\n     */\n\n\n    toggleConditionsDropDown(target) {\n      this._conditionsOverlaySettings.target = target;\n      this._conditionsOverlaySettings.excludeFromOutsideClick = [target];\n      this.dropDownConditions.toggle(this._conditionsOverlaySettings);\n    }\n    /**\n     * Opens the logic operators dropdown.\n     */\n\n\n    toggleOperatorsDropDown(eventArgs, index) {\n      this._operatorsOverlaySettings.target = eventArgs.target.parentElement;\n      this._operatorsOverlaySettings.excludeFromOutsideClick = [eventArgs.target.parentElement];\n      this.dropDownOperators.toArray()[index].toggle(this._operatorsOverlaySettings);\n    }\n    /**\n     * Event handler for change event in conditions dropdown.\n     */\n\n\n    onConditionsChanged(eventArgs) {\n      const value = eventArgs.newSelection.value;\n      this.expression.condition = this.getCondition(value);\n\n      if (this.expression.condition.isUnary) {\n        // update grid's filtering on the next cycle to ensure the drop-down is closed\n        // if the drop-down is not closed this event handler will be invoked multiple times\n        requestAnimationFrame(() => this.unaryConditionChangedCallback());\n      } else {\n        requestAnimationFrame(() => this.conditionChangedCallback());\n      } // Add requestAnimationFrame because of an issue in IE, where you are still able to write in the input,\n      // if it has been focused and then set to readonly.\n\n\n      requestAnimationFrame(() => this.focusEditElement());\n    }\n\n    onChipPointerdown(args, chip) {\n      const activeElement = document.activeElement;\n      this._cancelChipClick = chip.selected && activeElement && this.editorsContain(activeElement);\n    }\n\n    onChipClick(args, item) {\n      if (this._cancelChipClick) {\n        this._cancelChipClick = false;\n        return;\n      }\n\n      this.expressionsList.forEach(ex => ex.isSelected = false);\n      this.toggleChip(item);\n    }\n\n    toggleChip(item) {\n      item.isSelected = !item.isSelected;\n\n      if (item.isSelected) {\n        this.expression = item.expression;\n        this.focusEditElement();\n      }\n    }\n    /**\n     * Event handler for chip keydown event.\n     */\n\n\n    onChipKeyDown(eventArgs, item) {\n      if (eventArgs.key === this.platform.KEYMAP.ENTER) {\n        eventArgs.preventDefault();\n        this.toggleChip(item);\n      }\n    }\n    /**\n     * Scrolls the first chip into view if the tab key is pressed on the left arrow.\n     */\n\n\n    onLeftArrowKeyDown(event) {\n      if (event.key === this.platform.KEYMAP.TAB) {\n        this.chipAreaScrollOffset = 0;\n        this.transform(this.chipAreaScrollOffset);\n      }\n    }\n    /**\n     * Event handler for chip removed event.\n     */\n\n\n    onChipRemoved(eventArgs, item) {\n      const indexToRemove = this.expressionsList.indexOf(item);\n      this.removeExpression(indexToRemove, item.expression);\n      this.scrollChipsOnRemove();\n    }\n    /**\n     * Event handler for logic operator changed event.\n     */\n\n\n    onLogicOperatorChanged(eventArgs, expression) {\n      if (eventArgs.oldSelection) {\n        expression.afterOperator = eventArgs.newSelection.value;\n        this.expressionsList[this.expressionsList.indexOf(expression) + 1].beforeOperator = expression.afterOperator; // update grid's filtering on the next cycle to ensure the drop-down is closed\n        // if the drop-down is not closed this event handler will be invoked multiple times\n\n        requestAnimationFrame(() => this.filter());\n      }\n    }\n    /**\n     * Scrolls the chips into the chip area when left or right arrows are pressed.\n     */\n\n\n    scrollChipsOnArrowPress(arrowPosition) {\n      let count = 0;\n      const chipAraeChildren = this.chipsArea.element.nativeElement.children;\n      const containerRect = this.container.nativeElement.getBoundingClientRect();\n\n      if (arrowPosition === 'right') {\n        for (const chip of chipAraeChildren) {\n          if (Math.ceil(chip.getBoundingClientRect().right) < Math.ceil(containerRect.right)) {\n            count++;\n          }\n        }\n\n        if (count < chipAraeChildren.length) {\n          this.chipAreaScrollOffset -= Math.ceil(chipAraeChildren[count].getBoundingClientRect().right) - Math.ceil(containerRect.right) + 1;\n          this.transform(this.chipAreaScrollOffset);\n        }\n      }\n\n      if (arrowPosition === 'left') {\n        for (const chip of chipAraeChildren) {\n          if (Math.ceil(chip.getBoundingClientRect().left) < Math.ceil(containerRect.left)) {\n            count++;\n          }\n        }\n\n        if (count > 0) {\n          this.chipAreaScrollOffset += Math.ceil(containerRect.left) - Math.ceil(chipAraeChildren[count - 1].getBoundingClientRect().left) + 1;\n          this.transform(this.chipAreaScrollOffset);\n        }\n      }\n    }\n    /**\n     * @hidden\n     * Resets the chips area\n     * @memberof IgxGridFilteringRowComponent\n     */\n\n\n    resetChipsArea() {\n      this.chipAreaScrollOffset = 0;\n      this.transform(this.chipAreaScrollOffset);\n      this.showHideArrowButtons();\n    }\n    /** @hidden @internal */\n\n\n    focusEditElement() {\n      if (this.input) {\n        this.input.nativeElement.focus();\n      } else if (this.picker) {\n        this.picker.getEditElement().focus();\n      }\n    }\n\n    ngOnDestroy() {\n      this.$destroyer.next();\n    }\n\n    showHideArrowButtons() {\n      requestAnimationFrame(() => {\n        if (this.filteringService.isFilterRowVisible) {\n          const containerWidth = this.container.nativeElement.getBoundingClientRect().width;\n          this.chipsAreaWidth = this.chipsArea.element.nativeElement.getBoundingClientRect().width;\n          this.showArrows = this.chipsAreaWidth >= containerWidth && this.isColumnFiltered; // TODO: revise the cdr.detectChanges() usage here\n\n          if (!this.cdr.destroyed) {\n            this.cdr.detectChanges();\n          }\n        }\n      });\n    }\n\n    addExpression(isSelected) {\n      const exprUI = new ExpressionUI();\n      exprUI.expression = this.expression;\n      exprUI.beforeOperator = this.expressionsList.length > 0 ? FilteringLogic.And : null;\n      exprUI.isSelected = isSelected;\n      this.expressionsList.push(exprUI);\n      const length = this.expressionsList.length;\n\n      if (this.expressionsList[length - 2]) {\n        this.expressionsList[length - 2].afterOperator = this.expressionsList[length - 1].beforeOperator;\n      }\n\n      this.showHideArrowButtons();\n    }\n\n    removeExpression(indexToRemove, expression) {\n      if (indexToRemove === 0 && this.expressionsList.length === 1) {\n        this.clearFiltering();\n        return;\n      }\n\n      this.filteringService.removeExpression(this.column.field, indexToRemove);\n      this.filter();\n\n      if (this.expression === expression) {\n        this.resetExpression();\n      }\n\n      this.showHideArrowButtons();\n    }\n\n    resetExpression() {\n      this.expression = {\n        fieldName: this.column.field,\n        condition: null,\n        searchVal: null,\n        ignoreCase: this.column.filteringIgnoreCase\n      };\n\n      if (this.column.dataType !== GridColumnDataType.Boolean) {\n        this.expression.condition = this.getCondition(this.conditions[0]);\n      }\n\n      if (this.column.dataType === GridColumnDataType.Date && this.input) {\n        this.input.nativeElement.value = null;\n      }\n\n      this.showHideArrowButtons();\n    }\n\n    scrollChipsWhenAddingExpression() {\n      const chipAraeChildren = this.chipsArea.element.nativeElement.children;\n\n      if (!chipAraeChildren || chipAraeChildren.length === 0) {\n        return;\n      }\n\n      const chipsContainerWidth = this.container.nativeElement.offsetWidth;\n      const chipsAreaWidth = this.chipsArea.element.nativeElement.offsetWidth;\n\n      if (chipsAreaWidth > chipsContainerWidth) {\n        this.chipAreaScrollOffset = chipsContainerWidth - chipsAreaWidth;\n        this.transform(this.chipAreaScrollOffset);\n      }\n    }\n\n    transform(offset) {\n      requestAnimationFrame(() => {\n        this.chipsArea.element.nativeElement.style.transform = `translate(${offset}px)`;\n      });\n    }\n\n    scrollChipsOnRemove() {\n      let count = 0;\n      const chipAraeChildren = this.chipsArea.element.nativeElement.children;\n      const containerRect = this.container.nativeElement.getBoundingClientRect();\n\n      for (const chip of chipAraeChildren) {\n        if (Math.ceil(chip.getBoundingClientRect().right) < Math.ceil(containerRect.left)) {\n          count++;\n        }\n      }\n\n      if (count <= 2) {\n        this.chipAreaScrollOffset = 0;\n      } else {\n        const dif = chipAraeChildren[count].id === 'chip' ? count - 2 : count - 1;\n        this.chipAreaScrollOffset += Math.ceil(containerRect.left) - Math.ceil(chipAraeChildren[dif].getBoundingClientRect().left) + 1;\n      }\n\n      this.transform(this.chipAreaScrollOffset);\n    }\n\n    conditionChangedCallback() {\n      if (!!this.expression.searchVal || this.expression.searchVal === 0) {\n        this.filter();\n      } else if (this.value) {\n        this.value = null;\n      }\n    }\n\n    unaryConditionChangedCallback() {\n      if (this.value) {\n        this.value = null;\n      }\n\n      if (this.expressionsList.find(item => item.expression === this.expression) === undefined) {\n        this.addExpression(true);\n      }\n\n      this.filter();\n    }\n\n    filter() {\n      this.filteringService.filterInternal(this.column.field);\n    }\n\n    editorsContain(child) {\n      // if the first check is false and the second is undefined this will return undefined\n      // make sure it always returns boolean\n      return !!(this.inputGroup && this.inputGroup.nativeElement.contains(child) || this.picker && this.picker.element.nativeElement.contains(child));\n    }\n\n    get isColumnFiltered() {\n      return this.column.filteringExpressionsTree && this.column.filteringExpressionsTree.filteringOperands.length > 0;\n    }\n\n    get isNarrowWidth() {\n      return this.nativeElement.offsetWidth < this.NARROW_WIDTH_THRESHOLD;\n    }\n\n  }\n\n  IgxGridFilteringRowComponent.ɵfac = function IgxGridFilteringRowComponent_Factory(t) {\n    return new (t || IgxGridFilteringRowComponent)(i0.ɵɵdirectiveInject(IgxFilteringService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxGridFilteringRowComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxGridFilteringRowComponent,\n    selectors: [[\"igx-grid-filtering-row\"]],\n    viewQuery: function IgxGridFilteringRowComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c149, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c150, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c151, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c152, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c78, 5, ElementRef);\n        i0.ɵɵviewQuery(_c153, 7, IgxDropDownComponent);\n        i0.ɵɵviewQuery(_c154, 7, IgxChipsAreaComponent);\n        i0.ɵɵviewQuery(_c62, 5, ElementRef);\n        i0.ɵɵviewQuery(_c94, 5);\n        i0.ɵɵviewQuery(_c155, 5, ElementRef);\n        i0.ɵɵviewQuery(_c6, 7);\n        i0.ɵɵviewQuery(_c156, 5);\n        i0.ɵɵviewQuery(_c157, 7);\n        i0.ɵɵviewQuery(_c158, 5, IgxDropDownComponent);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultFilterUI = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultDateUI = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultTimeUI = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultDateTimeUI = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.input = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropDownConditions = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chipsArea = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputGroup = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.picker = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputGroupPrefix = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.operand = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.closeButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropDownOperators = _t);\n      }\n    },\n    hostVars: 6,\n    hostBindings: function IgxGridFilteringRowComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function IgxGridFilteringRowComponent_keydown_HostBindingHandler($event) {\n          return ctx.onKeydownHandler($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-grid__filtering-row\", ctx.defaultCSSClass)(\"igx-grid__filtering-row--compact\", ctx.compactCSSClass)(\"igx-grid__filtering-row--cosy\", ctx.cosyCSSClass);\n      }\n    },\n    inputs: {\n      column: \"column\",\n      value: \"value\"\n    },\n    decls: 33,\n    vars: 19,\n    consts: [[3, \"displayDensity\", \"height\", \"selectionChanging\"], [\"inputGroupConditions\", \"\"], [3, \"value\", \"selected\", 4, \"ngFor\", \"ngForOf\"], [\"defaultFilterUI\", \"\"], [\"defaultDateUI\", \"\"], [\"defaultTimeUI\", \"\"], [\"defaultDateTimeUI\", \"\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"igxButton\", \"icon\", \"class\", \"igx-grid__filtering-row-scroll-start\", 3, \"keydown\", \"click\", 4, \"ngIf\"], [1, \"igx-grid__filtering-row-main\"], [\"container\", \"\"], [\"chipsArea\", \"\"], [\"tabindex\", \"0\", 4, \"ngFor\", \"ngForOf\"], [\"igxButton\", \"icon\", \"class\", \"igx-grid__filtering-row-scroll-end\", 3, \"click\", 4, \"ngIf\"], [3, \"ngClass\"], [\"buttonsContainer\", \"\"], [\"igxRipple\", \"\", 3, \"displayDensity\", \"igxButton\", \"disabled\", \"tabindex\", \"click\"], [\"igxRipple\", \"\", 3, \"displayDensity\", \"igxButton\", \"click\"], [\"closeButton\", \"\"], [3, \"value\", \"selected\"], [1, \"igx-grid__filtering-dropdown-items\"], [\"family\", \"imx-icons\", 3, \"name\"], [1, \"igx-grid__filtering-dropdown-text\"], [\"type\", \"box\", 3, \"displayDensity\", \"focusout\"], [\"inputGroup\", \"\"], [\"tabindex\", \"0\", 3, \"igxDropDownItemNavigation\", \"click\", \"keydown\"], [\"inputGroupPrefix\", \"\"], [\"igxInput\", \"\", \"tabindex\", \"0\", \"autocomplete\", \"off\", 3, \"placeholder\", \"value\", \"type\", \"readonly\", \"input\", \"click\", \"compositionstart\", \"compositionend\", \"keydown\", \"keyup\"], [\"input\", \"\"], [4, \"ngIf\"], [\"tabindex\", \"0\", 3, \"keydown\", \"click\"], [\"type\", \"box\", 3, \"value\", \"readOnly\", \"outlet\", \"locale\", \"displayFormat\", \"formatter\", \"placeholder\", \"displayDensity\", \"valueChange\", \"click\", \"keydown\", \"focusout\", \"closed\"], [\"picker\", \"\"], [\"type\", \"box\", 3, \"value\", \"inputFormat\", \"locale\", \"formatter\", \"outlet\", \"displayDensity\", \"readOnly\", \"placeholder\", \"valueChange\", \"closed\", \"focusout\", \"keydown\", \"click\"], [\"igxInput\", \"\", \"tabindex\", \"0\", 3, \"placeholder\", \"igxDateTimeEditor\", \"value\", \"readonly\", \"valueChange\", \"click\", \"keydown\", \"keyup\"], [\"igxButton\", \"icon\", 1, \"igx-grid__filtering-row-scroll-start\", 3, \"keydown\", \"click\"], [\"tabindex\", \"0\"], [\"id\", \"chip\", 3, \"selectable\", \"selected\", \"displayDensity\", \"removable\", \"pointerdown\", \"click\", \"keydown\", \"remove\"], [\"chip\", \"\"], [\"igxPrefix\", \"\", \"family\", \"imx-icons\", 3, \"name\"], [\"id\", \"operand\", 4, \"ngIf\"], [\"id\", \"operand\"], [\"igxButton\", \"\", 3, \"igxDropDownItemNavigation\", \"displayDensity\", \"click\"], [3, \"displayDensity\", \"selectionChanging\"], [\"operators\", \"\"], [\"igxButton\", \"icon\", 1, \"igx-grid__filtering-row-scroll-end\", 3, \"click\"]],\n    template: function IgxGridFilteringRowComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"igx-drop-down\", 0, 1);\n        i0.ɵɵlistener(\"selectionChanging\", function IgxGridFilteringRowComponent_Template_igx_drop_down_selectionChanging_0_listener($event) {\n          return ctx.onConditionsChanged($event);\n        });\n        i0.ɵɵtemplate(2, IgxGridFilteringRowComponent_igx_drop_down_item_2_Template, 5, 4, \"igx-drop-down-item\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, IgxGridFilteringRowComponent_ng_template_3_Template, 8, 8, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(5, IgxGridFilteringRowComponent_ng_template_5_Template, 8, 11, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(7, IgxGridFilteringRowComponent_ng_template_7_Template, 8, 11, \"ng-template\", null, 5, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(9, IgxGridFilteringRowComponent_ng_template_9_Template, 8, 8, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(11, IgxGridFilteringRowComponent_ng_container_11_Template, 1, 0, \"ng-container\", 7);\n        i0.ɵɵtemplate(12, IgxGridFilteringRowComponent_button_12_Template, 3, 0, \"button\", 8);\n        i0.ɵɵelementStart(13, \"div\", 9, 10)(15, \"div\")(16, \"igx-chips-area\", null, 11);\n        i0.ɵɵtemplate(18, IgxGridFilteringRowComponent_ng_container_18_Template, 7, 7, \"ng-container\", 12);\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵtemplate(19, IgxGridFilteringRowComponent_button_19_Template, 3, 0, \"button\", 13);\n        i0.ɵɵelementStart(20, \"div\", 14, 15)(22, \"button\", 16);\n        i0.ɵɵlistener(\"click\", function IgxGridFilteringRowComponent_Template_button_click_22_listener() {\n          return ctx.clearFiltering();\n        });\n        i0.ɵɵelementStart(23, \"igx-icon\");\n        i0.ɵɵtext(24, \"refresh\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(25, \"span\");\n        i0.ɵɵtext(26);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(27, \"button\", 17, 18);\n        i0.ɵɵlistener(\"click\", function IgxGridFilteringRowComponent_Template_button_click_27_listener() {\n          return ctx.close();\n        });\n        i0.ɵɵelementStart(29, \"igx-icon\");\n        i0.ɵɵtext(30, \"close\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(31, \"span\");\n        i0.ɵɵtext(32);\n        i0.ɵɵelementEnd()()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"displayDensity\", ctx.displayDensity)(\"height\", \"200px\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngForOf\", ctx.conditions);\n        i0.ɵɵadvance(9);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(17, _c24, ctx));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showArrows);\n        i0.ɵɵadvance(6);\n        i0.ɵɵproperty(\"ngForOf\", ctx.expressionsList);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showArrows);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngClass\", ctx.isNarrowWidth ? \"igx-grid__filtering-row-editing-buttons--small\" : \"igx-grid__filtering-row-editing-buttons\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"displayDensity\", ctx.column.grid.displayDensity)(\"igxButton\", ctx.isNarrowWidth ? \"icon\" : \"flat\")(\"disabled\", ctx.disabled)(\"tabindex\", ctx.disabled);\n        i0.ɵɵadvance(4);\n        i0.ɵɵtextInterpolate(ctx.isNarrowWidth ? \"\" : ctx.filteringService.grid.resourceStrings.igx_grid_filter_row_reset);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"displayDensity\", ctx.column.grid.displayDensity)(\"igxButton\", ctx.isNarrowWidth ? \"icon\" : \"flat\");\n        i0.ɵɵadvance(5);\n        i0.ɵɵtextInterpolate(ctx.isNarrowWidth ? \"\" : ctx.filteringService.grid.resourceStrings.igx_grid_filter_row_close);\n      }\n    },\n    directives: [IgxDropDownComponent, IgxDropDownItemComponent, IgxIconComponent, IgxInputGroupComponent, IgxDatePickerComponent, IgxPickerToggleComponent, IgxPickerClearComponent, IgxTimePickerComponent, IgxChipsAreaComponent, IgxChipComponent, i4.NgForOf, IgxPrefixDirective, IgxDropDownItemNavigationDirective, IgxInputDirective, i4.NgIf, IgxSuffixDirective, IgxDateTimeEditorDirective, i4.NgTemplateOutlet, IgxButtonDirective, i4.NgClass, IgxRippleDirective],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxGridFilteringRowComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet SortingIndexPipe = /*#__PURE__*/(() => {\n  class SortingIndexPipe {\n    transform(columnField, sortingExpressions) {\n      let sortIndex = sortingExpressions.findIndex(expression => expression.fieldName === columnField);\n      return sortIndex !== -1 ? ++sortIndex : null;\n    }\n\n  }\n\n  SortingIndexPipe.ɵfac = function SortingIndexPipe_Factory(t) {\n    return new (t || SortingIndexPipe)();\n  };\n\n  SortingIndexPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"sortingIndex\",\n    type: SortingIndexPipe,\n    pure: true\n  });\n  return SortingIndexPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxHeaderGroupWidthPipe = /*#__PURE__*/(() => {\n  class IgxHeaderGroupWidthPipe {\n    transform(width, minWidth, hasLayout) {\n      return hasLayout ? '' : `${Math.max(parseFloat(width), minWidth)}px`;\n    }\n\n  }\n\n  IgxHeaderGroupWidthPipe.ɵfac = function IgxHeaderGroupWidthPipe_Factory(t) {\n    return new (t || IgxHeaderGroupWidthPipe)();\n  };\n\n  IgxHeaderGroupWidthPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"igxHeaderGroupWidth\",\n    type: IgxHeaderGroupWidthPipe,\n    pure: true\n  });\n  return IgxHeaderGroupWidthPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxHeaderGroupStylePipe = /*#__PURE__*/(() => {\n  class IgxHeaderGroupStylePipe {\n    transform(styles, column, _) {\n      const css = {};\n\n      if (!styles) {\n        return css;\n      }\n\n      for (const prop of Object.keys(styles)) {\n        const res = styles[prop];\n        css[prop] = typeof res === 'function' ? res(column) : res;\n      }\n\n      return css;\n    }\n\n  }\n\n  IgxHeaderGroupStylePipe.ɵfac = function IgxHeaderGroupStylePipe_Factory(t) {\n    return new (t || IgxHeaderGroupStylePipe)();\n  };\n\n  IgxHeaderGroupStylePipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"igxHeaderGroupStyle\",\n    type: IgxHeaderGroupStylePipe,\n    pure: true\n  });\n  return IgxHeaderGroupStylePipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxGridHeaderComponent = /*#__PURE__*/(() => {\n  class IgxGridHeaderComponent {\n    constructor(grid, colResizingService, cdr, ref) {\n      this.grid = grid;\n      this.colResizingService = colResizingService;\n      this.cdr = cdr;\n      this.ref = ref;\n      this.sortDirection = SortingDirection.None;\n      this._destroy$ = new Subject();\n    }\n    /**\n     * Returns the `aria-selected` of the header.\n     */\n\n\n    get ariaSelected() {\n      return this.column.selected;\n    }\n\n    get columnGroupStyle() {\n      return !this.column.columnGroup;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get cosyStyle() {\n      return this.density === 'cosy';\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get compactStyle() {\n      return this.density === 'compact';\n    }\n\n    get sortAscendingStyle() {\n      return this.sortDirection === SortingDirection.Asc;\n    }\n\n    get sortDescendingStyle() {\n      return this.sortDirection === SortingDirection.Desc;\n    }\n\n    get numberStyle() {\n      return this.column.dataType === GridColumnDataType.Number;\n    }\n\n    get sortableStyle() {\n      return this.column.sortable;\n    }\n\n    get selectableStyle() {\n      return this.selectable;\n    }\n\n    get filterableStyle() {\n      return this.column.filterable && this.grid.filteringService.isFilterRowVisible;\n    }\n\n    get sortedStyle() {\n      return this.sorted;\n    }\n\n    get selectedStyle() {\n      return this.selected;\n    }\n\n    get height() {\n      if (!this.grid.hasColumnGroups || this.grid.isPivot) {\n        return null;\n      }\n\n      return (this.grid.maxLevelHeaderDepth + 1 - this.column.level) * this.grid.defaultRowHeight / this.grid._baseFontSize;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get esfIconTemplate() {\n      return this.grid.excelStyleHeaderIconTemplate || this.defaultESFHeaderIconTemplate;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get sortIconTemplate() {\n      if (this.sortDirection === SortingDirection.None && this.grid.sortHeaderIconTemplate) {\n        return this.grid.sortHeaderIconTemplate;\n      } else if (this.sortDirection === SortingDirection.Asc && this.grid.sortAscendingHeaderIconTemplate) {\n        return this.grid.sortAscendingHeaderIconTemplate;\n      } else if (this.sortDirection === SortingDirection.Desc && this.grid.sortDescendingHeaderIconTemplate) {\n        return this.grid.sortDescendingHeaderIconTemplate;\n      } else {\n        return this.defaultSortHeaderIconTemplate;\n      }\n    }\n\n    get sorted() {\n      return this.sortDirection !== SortingDirection.None;\n    }\n\n    get filterIconClassName() {\n      return this.column.filteringExpressionsTree ? 'igx-excel-filter__icon--filtered' : 'igx-excel-filter__icon';\n    }\n\n    get selectable() {\n      return this.grid.columnSelection !== GridSelectionMode.none && this.column.applySelectableClass && !this.column.selected && !this.grid.filteringService.isFilterRowVisible;\n    }\n\n    get selected() {\n      return this.column.selected && (!this.grid.filteringService.isFilterRowVisible || this.grid.filteringService.filteredColumn !== this.column);\n    }\n\n    get title() {\n      return this.column.title || this.column.header || this.column.field;\n    }\n\n    get nativeElement() {\n      return this.ref.nativeElement;\n    }\n\n    onClick(event) {\n      if (!this.colResizingService.isColumnResizing) {\n        if (this.grid.filteringService.isFilterRowVisible) {\n          if (this.column.filterCellTemplate) {\n            this.grid.filteringRow.close();\n            return;\n          }\n\n          if (this.column.filterable && !this.column.columnGroup && !this.grid.filteringService.isFilterComplex(this.column.field)) {\n            this.grid.filteringService.filteredColumn = this.column;\n          }\n        } else if (this.grid.columnSelection !== GridSelectionMode.none && this.column.selectable) {\n          const clearSelection = this.grid.columnSelection === GridSelectionMode.single || !event.ctrlKey;\n          const rangeSelection = this.grid.columnSelection === GridSelectionMode.multiple && event.shiftKey;\n\n          if (!this.column.selected || this.grid.selectionService.getSelectedColumns().length > 1 && clearSelection) {\n            this.grid.selectionService.selectColumn(this.column.field, clearSelection, rangeSelection, event);\n          } else {\n            this.grid.selectionService.deselectColumn(this.column.field, event);\n          }\n        }\n      }\n\n      this.grid.theadRow.nativeElement.focus();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onPinterEnter() {\n      this.column.applySelectableClass = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onPointerLeave() {\n      this.column.applySelectableClass = false;\n    }\n\n    ngDoCheck() {\n      this.getSortDirection();\n      this.cdr.markForCheck();\n    }\n\n    ngOnDestroy() {\n      this._destroy$.next(true);\n\n      this._destroy$.complete();\n    }\n\n    onFilteringIconClick(event) {\n      event.stopPropagation();\n      this.grid.filteringService.toggleFilterDropdown(this.nativeElement, this.column);\n    }\n\n    onSortingIconClick(event) {\n      event.stopPropagation();\n      this.triggerSort();\n    }\n\n    getSortDirection() {\n      const expr = this.grid.sortingExpressions.find(x => x.fieldName === this.column.field);\n      this.sortDirection = expr ? expr.dir : SortingDirection.None;\n    }\n\n    triggerSort() {\n      var _a, _b;\n\n      const groupingExpr = this.grid.groupingExpressions ? this.grid.groupingExpressions.find(expr => expr.fieldName === this.column.field) : ((_a = this.grid.groupArea) === null || _a === void 0 ? void 0 : _a.expressions) ? (_b = this.grid.groupArea) === null || _b === void 0 ? void 0 : _b.expressions.find(expr => expr.fieldName === this.column.field) : null;\n      const sortDir = groupingExpr ? this.sortDirection + 1 > SortingDirection.Desc ? SortingDirection.Asc : SortingDirection.Desc : this.sortDirection + 1 > SortingDirection.Desc ? SortingDirection.None : this.sortDirection + 1;\n      this.sortDirection = sortDir;\n      this.grid.sort({\n        fieldName: this.column.field,\n        dir: this.sortDirection,\n        ignoreCase: this.column.sortingIgnoreCase,\n        strategy: this.column.sortStrategy\n      });\n    }\n\n  }\n\n  IgxGridHeaderComponent.ɵfac = function IgxGridHeaderComponent_Factory(t) {\n    return new (t || IgxGridHeaderComponent)(i0.ɵɵdirectiveInject(IGX_GRID_BASE), i0.ɵɵdirectiveInject(IgxColumnResizingService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxGridHeaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxGridHeaderComponent,\n    selectors: [[\"igx-grid-header\"]],\n    viewQuery: function IgxGridHeaderComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c159, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c160, 7, TemplateRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultESFHeaderIconTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultSortHeaderIconTemplate = _t.first);\n      }\n    },\n    hostVars: 25,\n    hostBindings: function IgxGridHeaderComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function IgxGridHeaderComponent_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        })(\"pointerenter\", function IgxGridHeaderComponent_pointerenter_HostBindingHandler() {\n          return ctx.onPinterEnter();\n        })(\"pointerleave\", function IgxGridHeaderComponent_pointerleave_HostBindingHandler() {\n          return ctx.onPointerLeave();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-selected\", ctx.ariaSelected);\n        i0.ɵɵstyleProp(\"height\", ctx.height, \"rem\");\n        i0.ɵɵclassProp(\"igx-grid-th\", ctx.columnGroupStyle)(\"igx-grid-th--cosy\", ctx.cosyStyle)(\"igx-grid-th--compact\", ctx.compactStyle)(\"asc\", ctx.sortAscendingStyle)(\"desc\", ctx.sortDescendingStyle)(\"igx-grid-th--number\", ctx.numberStyle)(\"igx-grid-th--sortable\", ctx.sortableStyle)(\"igx-grid-th--selectable\", ctx.selectableStyle)(\"igx-grid-th--filtrable\", ctx.filterableStyle)(\"igx-grid-th--sorted\", ctx.sortedStyle)(\"igx-grid-th--selected\", ctx.selectedStyle);\n      }\n    },\n    inputs: {\n      column: \"column\",\n      density: \"density\"\n    },\n    decls: 9,\n    vars: 6,\n    consts: [[\"defaultColumn\", \"\"], [\"defaultESFHeaderIconTemplate\", \"\"], [\"defaultSortHeaderIconTemplate\", \"\"], [1, \"igx-grid-th__title\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [4, \"ngIf\"], [3, \"title\"], [1, \"igx-grid-th__icons\"], [1, \"sort-icon\", 3, \"click\", \"pointerdown\"], [3, \"ngClass\", \"click\", \"pointerdown\"]],\n    template: function IgxGridHeaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxGridHeaderComponent_ng_template_0_Template, 2, 2, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, IgxGridHeaderComponent_ng_template_2_Template, 2, 0, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(4, IgxGridHeaderComponent_ng_template_4_Template, 2, 1, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementStart(6, \"span\", 3);\n        i0.ɵɵtemplate(7, IgxGridHeaderComponent_ng_container_7_Template, 1, 0, \"ng-container\", 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(8, IgxGridHeaderComponent_ng_container_8_Template, 4, 2, \"ng-container\", 5);\n      }\n\n      if (rf & 2) {\n        const _r0 = i0.ɵɵreference(1);\n\n        i0.ɵɵadvance(7);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.column.headerTemplate ? ctx.column.headerTemplate : _r0)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(3, _c161, ctx.column, ctx.column));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.column.columnGroup);\n      }\n    },\n    directives: [IgxIconComponent, i4.NgTemplateOutlet, i4.NgIf, i4.NgClass],\n    pipes: [SortingIndexPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxGridHeaderComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxGridFilteringCellComponent = /*#__PURE__*/(() => {\n  class IgxGridFilteringCellComponent {\n    constructor(cdr, filteringService) {\n      this.cdr = cdr;\n      this.filteringService = filteringService;\n      this.moreFiltersCount = 0;\n      this.baseClass = 'igx-grid__filtering-cell-indicator';\n      this.filteringService.subscribeToEvents();\n    }\n\n    get styleClasses() {\n      let classes = this.column && this.column.selected ? 'igx-grid__filtering-cell--selected' : 'igx-grid__filtering-cell';\n\n      switch (this.column.grid.displayDensity) {\n        case DisplayDensity.compact:\n          classes = classes + ' igx-grid__filtering-cell--compact';\n          break;\n\n        case DisplayDensity.cosy:\n          classes = classes + ' igx-grid__filtering-cell--cosy';\n          break;\n      }\n\n      return classes;\n    }\n\n    ngOnInit() {\n      this.filteringService.columnToMoreIconHidden.set(this.column.field, true);\n    }\n\n    ngAfterViewInit() {\n      this.updateFilterCellArea();\n    }\n\n    ngDoCheck() {\n      this.updateFilterCellArea();\n    }\n    /**\n     * Returns whether a chip with a given index is visible or not.\n     */\n\n\n    isChipVisible(index) {\n      const expression = this.expressionsList[index];\n      return !!(expression && expression.isVisible);\n    }\n    /**\n     * Updates the filtering cell area.\n     */\n\n\n    updateFilterCellArea() {\n      this.expressionsList = this.filteringService.getExpressions(this.column.field);\n      this.updateVisibleFilters();\n    }\n\n    get displayDensity() {\n      return this.column.grid.displayDensity === DisplayDensity.comfortable ? DisplayDensity.cosy : this.column.grid.displayDensity;\n    }\n\n    get template() {\n      if (!this.column.filterable) {\n        return null;\n      }\n\n      if (this.column.filterCellTemplate) {\n        return this.column.filterCellTemplate;\n      }\n\n      const expressionTree = this.column.filteringExpressionsTree;\n\n      if (!expressionTree || expressionTree.filteringOperands.length === 0) {\n        return this.emptyFilter;\n      }\n\n      if (this.filteringService.isFilterComplex(this.column.field)) {\n        return this.complexFilter;\n      }\n\n      return this.defaultFilter;\n    }\n    /**\n     * Gets the context passed to the filter template.\n     *\n     * @memberof IgxGridFilteringCellComponent\n     */\n\n\n    get context() {\n      return {\n        column: this.column\n      };\n    }\n    /**\n     * Chip clicked event handler.\n     */\n\n\n    onChipClicked(expression) {\n      if (expression) {\n        this.expressionsList.forEach(item => {\n          item.isSelected = item.expression === expression;\n        });\n      } else if (this.expressionsList.length > 0) {\n        this.expressionsList.forEach(item => {\n          item.isSelected = false;\n        });\n        this.expressionsList[0].isSelected = true;\n      }\n\n      this.filteringService.grid.navigation.performHorizontalScrollToCell(this.column.visibleIndex);\n      this.filteringService.filteredColumn = this.column;\n      this.filteringService.isFilterRowVisible = true;\n      this.filteringService.selectedExpression = expression;\n    }\n    /**\n     * Chip removed event handler.\n     */\n\n\n    onChipRemoved(eventArgs, item) {\n      const indexToRemove = this.expressionsList.indexOf(item);\n      this.removeExpression(indexToRemove);\n      this.filteringService.grid.theadRow.nativeElement.focus();\n    }\n    /**\n     * Clears the filtering.\n     */\n\n\n    clearFiltering() {\n      this.filteringService.clearFilter(this.column.field);\n      this.cdr.detectChanges();\n    }\n    /**\n     * Returns the filtering indicator class.\n     */\n\n\n    filteringIndicatorClass() {\n      return {\n        [this.baseClass]: !this.isMoreIconHidden(),\n        [`${this.baseClass}--hidden`]: this.isMoreIconHidden()\n      };\n    }\n\n    removeExpression(indexToRemove) {\n      if (indexToRemove === 0 && this.expressionsList.length === 1) {\n        this.clearFiltering();\n        return;\n      }\n\n      this.filteringService.removeExpression(this.column.field, indexToRemove);\n      this.updateVisibleFilters();\n      this.filteringService.filterInternal(this.column.field);\n    }\n\n    isMoreIconHidden() {\n      return this.filteringService.columnToMoreIconHidden.get(this.column.field);\n    }\n\n    updateVisibleFilters() {\n      this.expressionsList.forEach(ex => ex.isVisible = true);\n\n      if (this.moreIcon) {\n        this.filteringService.columnToMoreIconHidden.set(this.column.field, true);\n      }\n\n      this.cdr.detectChanges();\n\n      if (this.chipsArea && this.expressionsList.length > 1) {\n        const areaWidth = this.chipsArea.element.nativeElement.offsetWidth;\n        let viewWidth = 0;\n        const chipsAreaElements = this.chipsArea.element.nativeElement.children;\n        let visibleChipsCount = 0;\n        const moreIconWidth = this.moreIcon.nativeElement.offsetWidth - parseInt(document.defaultView.getComputedStyle(this.moreIcon.nativeElement)['margin-left'], 10);\n\n        for (let index = 0; index < chipsAreaElements.length - 1; index++) {\n          if (viewWidth + chipsAreaElements[index].offsetWidth < areaWidth) {\n            viewWidth += chipsAreaElements[index].offsetWidth;\n\n            if (index % 2 === 0) {\n              visibleChipsCount++;\n            } else {\n              viewWidth += parseInt(document.defaultView.getComputedStyle(chipsAreaElements[index])['margin-left'], 10);\n              viewWidth += parseInt(document.defaultView.getComputedStyle(chipsAreaElements[index])['margin-right'], 10);\n            }\n          } else {\n            if (index % 2 !== 0 && viewWidth + moreIconWidth > areaWidth) {\n              visibleChipsCount--;\n            } else if (visibleChipsCount > 0 && viewWidth - chipsAreaElements[index - 1].offsetWidth + moreIconWidth > areaWidth) {\n              visibleChipsCount--;\n            }\n\n            this.moreFiltersCount = this.expressionsList.length - visibleChipsCount;\n            this.filteringService.columnToMoreIconHidden.set(this.column.field, false);\n            break;\n          }\n        }\n\n        for (let i = visibleChipsCount; i < this.expressionsList.length; i++) {\n          this.expressionsList[i].isVisible = false;\n        }\n\n        this.cdr.detectChanges();\n      }\n    }\n\n  }\n\n  IgxGridFilteringCellComponent.ɵfac = function IgxGridFilteringCellComponent_Factory(t) {\n    return new (t || IgxGridFilteringCellComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(IgxFilteringService));\n  };\n\n  IgxGridFilteringCellComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxGridFilteringCellComponent,\n    selectors: [[\"igx-grid-filtering-cell\"]],\n    viewQuery: function IgxGridFilteringCellComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c162, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c163, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c164, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c154, 5, IgxChipsAreaComponent);\n        i0.ɵɵviewQuery(_c165, 5, ElementRef);\n        i0.ɵɵviewQuery(_c166, 5, IgxChipComponent);\n        i0.ɵɵviewQuery(_c167, 5, IgxChipComponent);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.emptyFilter = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultFilter = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.complexFilter = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chipsArea = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.moreIcon = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.ghostChip = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.complexChip = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function IgxGridFilteringCellComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.styleClasses);\n      }\n    },\n    inputs: {\n      column: \"column\"\n    },\n    decls: 7,\n    vars: 2,\n    consts: [[\"emptyFilter\", \"\"], [\"defaultFilter\", \"\"], [\"complexFilter\", \"\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"igx-filtering-chips\"], [3, \"displayDensity\", \"tabIndex\", \"click\"], [\"ghostChip\", \"\"], [\"igxPrefix\", \"\"], [\"chipsArea\", \"\"], [4, \"ngFor\", \"ngForOf\"], [3, \"ngClass\", \"click\"], [\"moreIcon\", \"\"], [3, \"value\"], [3, \"removable\", \"tabIndex\", \"displayDensity\", \"click\", \"remove\", 4, \"ngIf\"], [\"class\", \"igx-filtering-chips__connector\", 4, \"ngIf\"], [3, \"removable\", \"tabIndex\", \"displayDensity\", \"click\", \"remove\"], [\"igxPrefix\", \"\", \"family\", \"imx-icons\", 3, \"name\"], [\"label\", \"\"], [1, \"igx-filtering-chips__connector\"], [3, \"removable\", \"displayDensity\", \"tabIndex\", \"remove\"], [\"complexChip\", \"\"]],\n    template: function IgxGridFilteringCellComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxGridFilteringCellComponent_ng_template_0_Template, 7, 7, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, IgxGridFilteringCellComponent_ng_template_2_Template, 8, 3, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(4, IgxGridFilteringCellComponent_ng_template_4_Template, 6, 4, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(6, IgxGridFilteringCellComponent_ng_container_6_Template, 1, 0, \"ng-container\", 3);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(6);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template)(\"ngTemplateOutletContext\", ctx.context);\n      }\n    },\n    directives: [IgxChipsAreaComponent, IgxChipComponent, IgxIconComponent, IgxBadgeComponent, IgxPrefixDirective, i4.NgForOf, i4.NgIf, i4.NgClass, i4.NgTemplateOutlet],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxGridFilteringCellComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // import { IgxGridHeaderGroupComponent } from '../headers/grid-header-group.component';\n\n\nlet IgxColumnMovingDropDirective = /*#__PURE__*/(() => {\n  class IgxColumnMovingDropDirective extends IgxDropDirective {\n    constructor(ref, renderer, _, cms) {\n      super(ref, renderer, _);\n      this.ref = ref;\n      this.renderer = renderer;\n      this._ = _;\n      this.cms = cms;\n      this._dropIndicator = null;\n      this._lastDropIndicator = null;\n      this._dragLeave = new Subject();\n      this._dropIndicatorClass = 'igx-grid-th__drop-indicator--active';\n    }\n\n    set data(val) {\n      if (val instanceof IgxGridForOfDirective) {\n        this._displayContainer = val;\n      } else {\n        this._column = val;\n      }\n    }\n\n    get column() {\n      return this._column;\n    }\n\n    get isDropTarget() {\n      var _a, _b;\n\n      return this.column && this.column.grid.moving && (!this.column.pinned && ((_a = this.cms.column) === null || _a === void 0 ? void 0 : _a.disablePinning) || !((_b = this.cms.column) === null || _b === void 0 ? void 0 : _b.disablePinning));\n    }\n\n    get horizontalScroll() {\n      if (this._displayContainer) {\n        return this._displayContainer;\n      }\n    }\n\n    get nativeElement() {\n      return this.ref.nativeElement;\n    }\n\n    ngOnDestroy() {\n      this._dragLeave.next(true);\n\n      this._dragLeave.complete();\n    }\n\n    onDragOver(event) {\n      const drag = event.detail.owner;\n\n      if (!(drag instanceof IgxColumnMovingDragDirective)) {\n        return;\n      }\n\n      if (this.isDropTarget && this.cms.column !== this.column && this.cms.column.level === this.column.level && this.cms.column.parent === this.column.parent) {\n        if (this._lastDropIndicator) {\n          this.renderer.removeClass(this._dropIndicator, this._dropIndicatorClass);\n        }\n\n        const clientRect = this.nativeElement.getBoundingClientRect();\n        const pos = clientRect.left + clientRect.width / 2;\n        const parent = this.nativeElement.parentElement;\n\n        if (event.detail.pageX < pos) {\n          this._dropPos = DropPosition.BeforeDropTarget;\n          this._lastDropIndicator = this._dropIndicator = parent.firstElementChild;\n        } else {\n          this._dropPos = DropPosition.AfterDropTarget;\n          this._lastDropIndicator = this._dropIndicator = parent.lastElementChild;\n        }\n\n        if (this.cms.icon.innerText !== 'block') {\n          this.renderer.addClass(this._dropIndicator, this._dropIndicatorClass);\n        }\n      }\n    }\n\n    onDragEnter(event) {\n      const drag = event.detail.owner;\n\n      if (!(drag instanceof IgxColumnMovingDragDirective)) {\n        return;\n      }\n\n      if (this.column && this.cms.column.grid.id !== this.column.grid.id) {\n        this.cms.icon.innerText = 'block';\n        return;\n      }\n\n      if (this.isDropTarget && this.cms.column !== this.column && this.cms.column.level === this.column.level && this.cms.column.parent === this.column.parent) {\n        if (!this.column.pinned || this.column.pinned && this.cms.column.pinned) {\n          this.cms.icon.innerText = 'swap_horiz';\n        }\n\n        this.cms.icon.innerText = 'save_alt';\n      } else {\n        this.cms.icon.innerText = 'block';\n      }\n\n      if (this.horizontalScroll) {\n        this.cms.icon.innerText = event.target.id === 'right' ? 'arrow_forward' : 'arrow_back';\n        interval(0, animationFrameScheduler).pipe(takeUntil(this._dragLeave)).subscribe(() => {\n          if (event.target.id === 'right') {\n            this.horizontalScroll.scrollPosition += 10;\n          } else {\n            this.horizontalScroll.scrollPosition -= 10;\n          }\n        });\n      }\n    }\n\n    onDragLeave(event) {\n      const drag = event.detail.owner;\n\n      if (!(drag instanceof IgxColumnMovingDragDirective)) {\n        return;\n      }\n\n      this.cms.icon.innerText = 'block';\n\n      if (this._dropIndicator) {\n        this.renderer.removeClass(this._dropIndicator, this._dropIndicatorClass);\n      }\n\n      if (this.horizontalScroll) {\n        this._dragLeave.next(true);\n      }\n    }\n\n    onDragDrop(event) {\n      event.preventDefault();\n      const drag = event.detail.owner;\n\n      if (!(drag instanceof IgxColumnMovingDragDirective)) {\n        return;\n      }\n\n      if (this.column && this.cms.column.grid.id !== this.column.grid.id) {\n        return;\n      }\n\n      if (this.horizontalScroll) {\n        this._dragLeave.next(true);\n      }\n\n      if (this.isDropTarget) {\n        this.column.grid.moveColumn(this.cms.column, this.column, this._dropPos);\n        this.cms.column = null;\n        this.column.grid.cdr.detectChanges();\n      }\n    }\n\n  }\n\n  IgxColumnMovingDropDirective.ɵfac = function IgxColumnMovingDropDirective_Factory(t) {\n    return new (t || IgxColumnMovingDropDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(IgxColumnMovingService));\n  };\n\n  IgxColumnMovingDropDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxColumnMovingDropDirective,\n    selectors: [[\"\", \"igxColumnMovingDrop\", \"\"]],\n    inputs: {\n      data: [\"igxColumnMovingDrop\", \"data\"]\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return IgxColumnMovingDropDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n * @internal\n */\n\n\nlet IgxResizeHandleDirective = /*#__PURE__*/(() => {\n  class IgxResizeHandleDirective {\n    constructor(zone, element, colResizingService) {\n      this.zone = zone;\n      this.element = element;\n      this.colResizingService = colResizingService;\n      /**\n       * @hidden\n       */\n\n      this._dblClick = false;\n      /**\n       * @hidden\n       */\n\n      this.destroy$ = new Subject();\n      this.DEBOUNCE_TIME = 200;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onMouseOver() {\n      this.colResizingService.resizeCursor = 'col-resize';\n    }\n    /**\n     * @hidden\n     */\n\n\n    onDoubleClick() {\n      this._dblClick = true;\n      this.initResizeService();\n      this.colResizingService.autosizeColumnOnDblClick();\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      this.destroy$.next(true);\n      this.destroy$.complete();\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterViewInit() {\n      if (!this.column.columnGroup && this.column.resizable) {\n        this.zone.runOutsideAngular(() => {\n          fromEvent(this.element.nativeElement, 'mousedown').pipe(debounceTime(this.DEBOUNCE_TIME), takeUntil(this.destroy$)).subscribe(event => {\n            if (this._dblClick) {\n              this._dblClick = false;\n              return;\n            }\n\n            if (event.button === 0) {\n              this._onResizeAreaMouseDown(event);\n\n              this.column.grid.resizeLine.resizer.onMousedown(event);\n            }\n          });\n        });\n        fromEvent(this.element.nativeElement, 'mouseup').pipe(debounceTime(this.DEBOUNCE_TIME), takeUntil(this.destroy$)).subscribe(() => {\n          this.colResizingService.isColumnResizing = false;\n          this.colResizingService.showResizer = false;\n          this.column.grid.cdr.detectChanges();\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    _onResizeAreaMouseDown(event) {\n      this.initResizeService(event);\n      this.colResizingService.showResizer = true;\n      this.column.grid.cdr.detectChanges();\n    }\n    /**\n     * @hidden\n     */\n\n\n    initResizeService(event = null) {\n      this.colResizingService.column = this.column;\n\n      if (event) {\n        this.colResizingService.isColumnResizing = true;\n        this.colResizingService.startResizePos = event.clientX;\n      }\n    }\n\n  }\n\n  IgxResizeHandleDirective.ɵfac = function IgxResizeHandleDirective_Factory(t) {\n    return new (t || IgxResizeHandleDirective)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(IgxColumnResizingService));\n  };\n\n  IgxResizeHandleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxResizeHandleDirective,\n    selectors: [[\"\", \"igxResizeHandle\", \"\"]],\n    hostBindings: function IgxResizeHandleDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"mouseover\", function IgxResizeHandleDirective_mouseover_HostBindingHandler() {\n          return ctx.onMouseOver();\n        })(\"dblclick\", function IgxResizeHandleDirective_dblclick_HostBindingHandler() {\n          return ctx.onDoubleClick();\n        });\n      }\n    },\n    inputs: {\n      column: [\"igxResizeHandle\", \"column\"]\n    }\n  });\n  return IgxResizeHandleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst Z_INDEX = 9999;\n/**\n * @hidden\n */\n\nlet IgxGridHeaderGroupComponent = /*#__PURE__*/(() => {\n  class IgxGridHeaderGroupComponent {\n    constructor(cdr, grid, ref, colResizingService, filteringService, platform) {\n      this.cdr = cdr;\n      this.grid = grid;\n      this.ref = ref;\n      this.colResizingService = colResizingService;\n      this.filteringService = filteringService;\n      this.platform = platform;\n      this.defaultCss = true;\n    }\n\n    get rowEnd() {\n      return this.column.rowEnd;\n    }\n\n    get colEnd() {\n      return this.column.colEnd;\n    }\n\n    get rowStart() {\n      return this.column.rowStart;\n    }\n\n    get colStart() {\n      return this.column.colStart;\n    }\n\n    get headerID() {\n      return `${this.grid.id}_-1_${this.column.level}_${this.column.visibleIndex}`;\n    }\n\n    get active() {\n      const node = this.grid.navigation.activeNode;\n      return node && !this.column.columnGroup ? node.row === -1 && node.column === this.column.visibleIndex && node.level === this.column.level : false;\n    }\n\n    get activeGroup() {\n      const node = this.grid.navigation.activeNode;\n      return node ? node.row === -1 && node.column === this.column.visibleIndex && node.level === this.column.level : false;\n    }\n    /**\n     * Gets the width of the header group.\n     *\n     * @memberof IgxGridHeaderGroupComponent\n     */\n\n\n    get width() {\n      return this.grid.getHeaderGroupWidth(this.column);\n    }\n\n    get pinnedCss() {\n      return this.isPinned;\n    }\n\n    get pinnedLastCss() {\n      return this.isLastPinned;\n    }\n\n    get pinnedFirstCSS() {\n      return this.isFirstPinned;\n    }\n\n    get headerDragCss() {\n      return this.isHeaderDragged;\n    }\n\n    get filteringCss() {\n      return this.isFiltered;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get zIndex() {\n      if (!this.column.pinned) {\n        return null;\n      }\n\n      return Z_INDEX - this.grid.pinnedColumns.indexOf(this.column);\n    }\n    /**\n     * Gets whether the header group belongs to a column that is filtered.\n     *\n     * @memberof IgxGridHeaderGroupComponent\n     */\n\n\n    get isFiltered() {\n      return this.filteringService.filteredColumn === this.column;\n    }\n    /**\n     * Gets whether the header group is stored in the last column in the pinned area.\n     *\n     * @memberof IgxGridHeaderGroupComponent\n     */\n\n\n    get isLastPinned() {\n      return !this.grid.hasColumnLayouts ? this.column.isLastPinned : false;\n    }\n    /**\n     * Gets whether the header group is stored in the first column of the right pinned area.\n     */\n\n\n    get isFirstPinned() {\n      return !this.grid.hasColumnLayouts ? this.column.isFirstPinned : false;\n    }\n\n    get groupDisplayStyle() {\n      return this.grid.hasColumnLayouts && this.column.children ? 'flex' : '';\n    }\n    /**\n     * Gets whether the header group is stored in a pinned column.\n     *\n     * @memberof IgxGridHeaderGroupComponent\n     */\n\n\n    get isPinned() {\n      return this.column.pinned;\n    }\n    /**\n     * Gets whether the header group belongs to a column that is moved.\n     *\n     * @memberof IgxGridHeaderGroupComponent\n     */\n\n\n    get isHeaderDragged() {\n      return this.grid.columnInDrag === this.column;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hasLastPinnedChildColumn() {\n      return this.column.allChildren.some(child => child.isLastPinned);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hasFirstPinnedChildColumn() {\n      return this.column.allChildren.some(child => child.isFirstPinned);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get selectable() {\n      const selectableChildren = this.column.allChildren.filter(c => !c.hidden && c.selectable && !c.columnGroup);\n      return this.grid.columnSelection !== GridSelectionMode.none && this.column.applySelectableClass && !this.selected && selectableChildren.length > 0 && !this.grid.filteringService.isFilterRowVisible;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get selected() {\n      return this.column.selected;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get height() {\n      return this.nativeElement.getBoundingClientRect().height;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get title() {\n      return this.column.title || this.column.header;\n    }\n\n    get nativeElement() {\n      return this.ref.nativeElement;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onMouseDown(event) {\n      // hack for preventing text selection in IE and Edge while dragging the resize element\n      event.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n\n\n    groupClicked(event) {\n      const columnsToSelect = this.column.allChildren.filter(c => !c.hidden && c.selectable && !c.columnGroup).map(c => c.field);\n\n      if (this.grid.columnSelection !== GridSelectionMode.none && columnsToSelect.length > 0 && !this.grid.filteringService.isFilterRowVisible) {\n        const clearSelection = this.grid.columnSelection === GridSelectionMode.single || !event.ctrlKey;\n        const rangeSelection = this.grid.columnSelection === GridSelectionMode.multiple && event.shiftKey;\n\n        if (!this.selected) {\n          this.grid.selectionService.selectColumns(columnsToSelect, clearSelection, rangeSelection, event);\n        } else {\n          const selectedFields = this.grid.selectionService.getSelectedColumns();\n\n          if (selectedFields.length === columnsToSelect.length && selectedFields.every(el => columnsToSelect.includes(el)) || !clearSelection) {\n            this.grid.selectionService.deselectColumns(columnsToSelect, event);\n          } else {\n            this.grid.selectionService.selectColumns(columnsToSelect, clearSelection, rangeSelection, event);\n          }\n        }\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    toggleExpandState(event) {\n      event.stopPropagation();\n      this.column.expanded = !this.column.expanded;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    pointerdown(event) {\n      event.stopPropagation();\n      this.activate();\n      this.grid.theadRow.nativeElement.focus();\n    }\n    /*\n     * This method is necessary due to some specifics related with implementation of column moving\n     * @hidden\n     */\n\n\n    activate() {\n      this.grid.navigation.setActiveNode(this.activeNode);\n      this.grid.theadRow.nativeElement.focus();\n    }\n\n    ngDoCheck() {\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onPinterEnter() {\n      this.column.applySelectableClass = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onPointerLeave() {\n      this.column.applySelectableClass = false;\n    }\n\n    get activeNode() {\n      return {\n        row: -1,\n        column: this.column.visibleIndex,\n        level: this.column.level,\n        mchCache: {\n          level: this.column.level,\n          visibleIndex: this.column.visibleIndex\n        },\n        layout: this.column.columnLayoutChild ? {\n          rowStart: this.column.rowStart,\n          colStart: this.column.colStart,\n          rowEnd: this.column.rowEnd,\n          colEnd: this.column.colEnd,\n          columnVisibleIndex: this.column.visibleIndex\n        } : null\n      };\n    }\n\n  }\n\n  IgxGridHeaderGroupComponent.ɵfac = function IgxGridHeaderGroupComponent_Factory(t) {\n    return new (t || IgxGridHeaderGroupComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(IGX_GRID_BASE), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(IgxColumnResizingService), i0.ɵɵdirectiveInject(IgxFilteringService), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxGridHeaderGroupComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxGridHeaderGroupComponent,\n    selectors: [[\"igx-grid-header-group\"]],\n    viewQuery: function IgxGridHeaderGroupComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxGridHeaderComponent, 5);\n        i0.ɵɵviewQuery(IgxGridFilteringCellComponent, 5);\n        i0.ɵɵviewQuery(IgxGridHeaderGroupComponent, 5, IgxGridHeaderGroupComponent);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.header = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.filter = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.children = _t);\n      }\n    },\n    hostVars: 27,\n    hostBindings: function IgxGridHeaderGroupComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"mousedown\", function IgxGridHeaderGroupComponent_mousedown_HostBindingHandler($event) {\n          return ctx.onMouseDown($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.headerID);\n        i0.ɵɵstyleProp(\"grid-row-end\", ctx.rowEnd)(\"grid-column-end\", ctx.colEnd)(\"grid-row-start\", ctx.rowStart)(\"grid-column-start\", ctx.colStart)(\"z-index\", ctx.zIndex)(\"display\", ctx.groupDisplayStyle);\n        i0.ɵɵclassProp(\"igx-grid-th--active\", ctx.active)(\"igx-grid-thead__item\", ctx.defaultCss)(\"igx-grid-th--pinned\", ctx.pinnedCss)(\"igx-grid-th--pinned-last\", ctx.pinnedLastCss)(\"igx-grid-th--pinned-first\", ctx.pinnedFirstCSS)(\"igx-grid__drag-col-header\", ctx.headerDragCss)(\"igx-grid-th--filtering\", ctx.filteringCss);\n      }\n    },\n    inputs: {\n      column: \"column\"\n    },\n    decls: 7,\n    vars: 3,\n    consts: [[4, \"ngIf\"], [\"defaultColumn\", \"\"], [\"defaultCollapseIndicator\", \"\"], [\"class\", \"igx-grid-th__drop-indicator-left\", 4, \"ngIf\"], [1, \"igx-grid-thead__group\", \"igx-grid__mrl-block\", 3, \"ngClass\", \"ngStyle\"], [4, \"ngFor\", \"ngForOf\"], [\"class\", \"igx-grid-th__drop-indicator-right\", 4, \"ngIf\"], [1, \"igx-grid-th__drop-indicator-left\"], [\"class\", \"igx-grid-thead__subgroup\", 3, \"ngClass\", \"ngStyle\", \"column\", \"igxColumnMovingDrag\", \"ghostHost\", \"igxColumnMovingDrop\", 4, \"ngIf\"], [1, \"igx-grid-thead__subgroup\", 3, \"ngClass\", \"ngStyle\", \"column\", \"igxColumnMovingDrag\", \"ghostHost\", \"igxColumnMovingDrop\"], [1, \"igx-grid-th__drop-indicator-right\"], [1, \"igx-grid-th__group-title\", 3, \"title\"], [\"role\", \"columnheader\", 1, \"igx-grid-thead__title\", 3, \"ngClass\", \"igxColumnMovingDrag\", \"ghostHost\", \"igxColumnMovingDrop\", \"pointerdown\", \"click\", \"pointerenter\", \"pointerleave\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"class\", \"igx-grid-thead__group\", 4, \"ngIf\"], [1, \"igx-grid-th__expander\", 3, \"click\"], [1, \"igx-grid-thead__group\"], [\"class\", \"igx-grid-thead__subgroup\", 3, \"ngClass\", \"ngStyle\", \"column\", \"min-width\", \"flex-basis\", 4, \"ngIf\"], [1, \"igx-grid-thead__subgroup\", 3, \"ngClass\", \"ngStyle\", \"column\"], [\"role\", \"columnheader\", 1, \"igx-grid-th--fw\", 3, \"id\", \"ngClass\", \"ngStyle\", \"igxColumnMovingDrag\", \"ghostHost\", \"igxColumnMovingDrop\", \"column\", \"density\", \"pointerdown\"], [3, \"column\", 4, \"ngIf\"], [\"class\", \"igx-grid-th__resize-handle\", 3, \"igxResizeHandle\", \"cursor\", 4, \"ngIf\"], [3, \"column\"], [1, \"igx-grid-th__resize-handle\", 3, \"igxResizeHandle\"]],\n    template: function IgxGridHeaderGroupComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxGridHeaderGroupComponent_ng_container_0_Template, 5, 11, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, IgxGridHeaderGroupComponent_ng_template_1_Template, 2, 2, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(3, IgxGridHeaderGroupComponent_ng_template_3_Template, 2, 2, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(5, IgxGridHeaderGroupComponent_ng_container_5_Template, 7, 24, \"ng-container\", 0);\n        i0.ɵɵtemplate(6, IgxGridHeaderGroupComponent_ng_container_6_Template, 7, 17, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.grid.hasColumnLayouts && ctx.column.columnGroup);\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"ngIf\", !ctx.grid.hasColumnLayouts && ctx.column.columnGroup);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.column.columnGroup);\n      }\n    },\n    directives: [IgxGridHeaderGroupComponent, IgxIconComponent, IgxGridHeaderComponent, IgxGridFilteringCellComponent, i4.NgIf, i4.NgClass, i4.NgStyle, i4.NgForOf, IgxColumnMovingDragDirective, IgxColumnMovingDropDirective, i4.NgTemplateOutlet, IgxResizeHandleDirective],\n    pipes: [IgxHeaderGroupStylePipe, IgxHeaderGroupWidthPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxGridHeaderGroupComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n *\n * For all intents & purposes treat this component as what a <thead> usually is in the default <table> element.\n *\n * This container holds the grid header elements and their behavior/interactions.\n *\n * @hidden @internal\n */\n\n\nlet IgxGridHeaderRowComponent = /*#__PURE__*/(() => {\n  class IgxGridHeaderRowComponent {\n    constructor(ref, cdr) {\n      this.ref = ref;\n      this.cdr = cdr;\n      /** Pinned columns of the grid. */\n\n      this.pinnedColumnCollection = [];\n      /** Unpinned columns of the grid. */\n\n      this.unpinnedColumnCollection = [];\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get cosyStyle() {\n      return this.density === 'cosy';\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get compactStyle() {\n      return this.density === 'compact';\n    }\n    /**\n     * The flattened header groups collection.\n     *\n     * @hidden @internal\n     */\n\n\n    get groups() {\n      var _a, _b;\n\n      return flatten$1((_b = (_a = this._groups) === null || _a === void 0 ? void 0 : _a.toArray()) !== null && _b !== void 0 ? _b : []);\n    }\n    /** Header components in the header row. */\n\n\n    get headers() {\n      return this.groups.map(group => group.header);\n    }\n    /** Filtering cell components in the header row. */\n\n\n    get filters() {\n      return this.groups.map(group => group.filter);\n    }\n\n    get headerForOf() {\n      return this.headerContainer;\n    }\n\n    get navigation() {\n      return this.grid.navigation;\n    }\n\n    get nativeElement() {\n      return this.ref.nativeElement;\n    }\n    /**\n     * Returns whether the current grid instance is a hierarchical grid.\n     * as only hierarchical grids have the `isHierarchicalRecord` method.\n     *\n     * @hidden @internal\n     */\n\n\n    get isHierarchicalGrid() {\n      return !!this.grid.isHierarchicalRecord;\n    }\n\n    get indentationCSSClasses() {\n      return `igx-grid__header-indentation igx-grid__row-indentation--level-${this.grid.groupingExpressions.length}`;\n    }\n\n    get rowSelectorsContext() {\n      const ctx = {\n        $implicit: {\n          selectedCount: this.grid.selectionService.filteredSelectedRowIds.length,\n          totalCount: this.grid.totalRowsCountAfterFilter\n        }\n      };\n\n      if (this.isHierarchicalGrid) {\n        ctx.$implicit.selectAll = () => this.grid.selectAllRows();\n\n        ctx.$implicit.deselectAll = () => this.grid.deselectAllRows();\n      }\n\n      return ctx;\n    }\n    /**\n     * This hook exists as a workaround for the unfortunate fact\n     * that when we have pinned columns in the grid, the unpinned columns headers\n     * are affected by a delayed change detection cycle after a horizontal scroll :(\n     * Thus, we tell the parent grid change detector to check us at each cycle.\n     *\n     * @hidden @internal\n     */\n\n\n    ngDoCheck() {\n      this.cdr.markForCheck();\n    }\n\n    headerRowSelection(event) {\n      if (!this.grid.isMultiRowSelectionEnabled) {\n        return;\n      }\n\n      if (this.grid.selectionService.areAllRowSelected()) {\n        this.grid.selectionService.clearRowSelection(event);\n      } else {\n        this.grid.selectionService.selectAllRows(event);\n      }\n    }\n\n  }\n\n  IgxGridHeaderRowComponent.ɵfac = function IgxGridHeaderRowComponent_Factory(t) {\n    return new (t || IgxGridHeaderRowComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  IgxGridHeaderRowComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxGridHeaderRowComponent,\n    selectors: [[\"igx-grid-header-row\"]],\n    viewQuery: function IgxGridHeaderRowComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c171, 7, IgxGridForOfDirective);\n        i0.ɵɵviewQuery(_c172, 5);\n        i0.ɵɵviewQuery(_c173, 5);\n        i0.ɵɵviewQuery(_c174, 5);\n        i0.ɵɵviewQuery(_c175, 5);\n        i0.ɵɵviewQuery(IgxGridFilteringRowComponent, 5);\n        i0.ɵɵviewQuery(_c176, 5);\n        i0.ɵɵviewQuery(IgxGridHeaderGroupComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerDragContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerSelectorContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerGroupContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headSelectorBaseTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.filterRow = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerHierarchyExpander = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._groups = _t);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function IgxGridHeaderRowComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-grid-thead--cosy\", ctx.cosyStyle)(\"igx-grid-thead--compact\", ctx.compactStyle);\n      }\n    },\n    inputs: {\n      grid: \"grid\",\n      pinnedColumnCollection: \"pinnedColumnCollection\",\n      unpinnedColumnCollection: \"unpinnedColumnCollection\",\n      activeDescendant: \"activeDescendant\",\n      hasMRL: \"hasMRL\",\n      width: \"width\",\n      density: \"density\"\n    },\n    decls: 18,\n    vars: 27,\n    consts: [[\"role\", \"rowgroup\", 1, \"igx-grid-thead__wrapper\"], [\"role\", \"row\", 1, \"igx-grid__tr\"], [4, \"ngIf\"], [\"igxGridFor\", \"\", 3, \"igxGridForOf\", \"igxForScrollContainer\", \"igxForContainerSize\", \"igxForTrackBy\", \"igxForSizePropName\", \"igxForScrollOrientation\"], [\"headerVirtualContainer\", \"\"], [1, \"igx-grid-thead__thumb\", 3, \"hidden\"], [\"igxHeadSelector\", \"\"], [\"headSelectorBaseTemplate\", \"\"], [\"id\", \"left\", \"droppable\", \"true\", 1, \"igx-grid__scroll-on-drag-left\", 3, \"igxColumnMovingDrop\"], [\"id\", \"left\", \"droppable\", \"true\", 1, \"igx-grid__scroll-on-drag-pinned\", 3, \"igxColumnMovingDrop\"], [1, \"igx-grid__drag-indicator\", \"igx-grid__tr-action\", 3, \"pointerdown\"], [\"headerDragContainer\", \"\"], [2, \"visibility\", \"hidden\"], [4, \"ngTemplateOutlet\"], [1, \"igx-grid__cbx-selection\", \"igx-grid__tr-action\", 3, \"click\", \"pointerdown\"], [\"headerSelectorContainer\", \"\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"headSelector\", \"\"], [3, \"hidden\", \"ngClass\", \"click\", \"pointerdown\"], [\"headerHierarchyExpander\", \"\"], [3, \"click\", \"pointerdown\"], [\"headerGroupContainer\", \"\"], [4, \"ngFor\", \"ngForOf\"], [3, \"ngClass\", \"ngStyle\", \"column\"], [3, \"column\"], [\"filteringRow\", \"\"], [\"id\", \"right\", \"droppable\", \"true\", 1, \"igx-grid__scroll-on-drag-right\", 3, \"igxColumnMovingDrop\"], [1, \"igx-grid__cbx-padding\"], [3, \"tabindex\", \"readonly\", \"checked\", \"disableRipple\", \"ngStyle\", \"indeterminate\", \"aria-label\"], [\"headerCheckbox\", \"\"]],\n    template: function IgxGridHeaderRowComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1);\n        i0.ɵɵtemplate(2, IgxGridHeaderRowComponent_ng_container_2_Template, 2, 3, \"ng-container\", 2);\n        i0.ɵɵtemplate(3, IgxGridHeaderRowComponent_ng_container_3_Template, 2, 3, \"ng-container\", 2);\n        i0.ɵɵtemplate(4, IgxGridHeaderRowComponent_ng_container_4_Template, 5, 3, \"ng-container\", 2);\n        i0.ɵɵtemplate(5, IgxGridHeaderRowComponent_ng_container_5_Template, 4, 4, \"ng-container\", 2);\n        i0.ɵɵtemplate(6, IgxGridHeaderRowComponent_ng_container_6_Template, 4, 10, \"ng-container\", 2);\n        i0.ɵɵtemplate(7, IgxGridHeaderRowComponent_ng_container_7_Template, 4, 4, \"ng-container\", 2);\n        i0.ɵɵtemplate(8, IgxGridHeaderRowComponent_ng_container_8_Template, 3, 3, \"ng-container\", 2);\n        i0.ɵɵtemplate(9, IgxGridHeaderRowComponent_ng_template_9_Template, 4, 19, \"ng-template\", 3, 4, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵpipe(11, \"igxTopLevel\");\n        i0.ɵɵtemplate(12, IgxGridHeaderRowComponent_ng_container_12_Template, 3, 3, \"ng-container\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(13, IgxGridHeaderRowComponent_ng_container_13_Template, 3, 3, \"ng-container\", 2);\n        i0.ɵɵtemplate(14, IgxGridHeaderRowComponent_ng_container_14_Template, 2, 1, \"ng-container\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(15, \"div\", 5);\n        i0.ɵɵtemplate(16, IgxGridHeaderRowComponent_ng_template_16_Template, 3, 9, \"ng-template\", 6, 7, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"width\", ctx.width, \"px\");\n        i0.ɵɵclassProp(\"igx-grid__tr--mrl\", ctx.hasMRL);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.width, \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.grid.moving && ctx.grid.columnInDrag && ctx.pinnedColumnCollection.length <= 0);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.grid.moving && ctx.grid.columnInDrag && ctx.pinnedColumnCollection.length > 0);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.grid.rowDraggable);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.grid.showRowSelectors);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isHierarchicalGrid);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.grid == null ? null : ctx.grid.groupingExpressions == null ? null : ctx.grid.groupingExpressions.length);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.pinnedColumnCollection.length && ctx.grid.isPinningToStart);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"igxGridForOf\", i0.ɵɵpipeBind1(11, 25, ctx.unpinnedColumnCollection))(\"igxForScrollContainer\", ctx.grid.parentVirtDir)(\"igxForContainerSize\", ctx.grid.unpinnedWidth)(\"igxForTrackBy\", ctx.grid.trackColumnChanges)(\"igxForSizePropName\", \"calcPixelWidth\")(\"igxForScrollOrientation\", \"horizontal\");\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.pinnedColumnCollection.length && !ctx.grid.isPinningToStart);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.grid.filteringService.isFilterRowVisible);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.grid.moving && ctx.grid.columnInDrag);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.grid.scrollSize, \"px\");\n        i0.ɵɵproperty(\"hidden\", !ctx.grid.hasVerticalScroll());\n      }\n    },\n    directives: [IgxGridHeaderGroupComponent, IgxGridFilteringRowComponent, IgxCheckboxComponent, i4.NgIf, IgxColumnMovingDropDirective, i4.NgTemplateOutlet, i4.NgClass, i4.NgForOf, i4.NgStyle, IgxGridForOfDirective],\n    pipes: [IgxGridTopLevelColumns, IgxHeaderGroupStylePipe, IgxHeaderGroupWidthPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxGridHeaderRowComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * An internal component representing the group-by drop area for the igx-grid component.\n *\n * @hidden @internal\n */\n\n\nlet IgxGridGroupByAreaComponent = /*#__PURE__*/(() => {\n  class IgxGridGroupByAreaComponent extends IgxGroupByAreaDirective {\n    constructor(ref, platform) {\n      super(ref, platform);\n      this.sortingExpressions = [];\n    }\n\n    handleReorder(event) {\n      const {\n        chipsArray,\n        originalEvent\n      } = event;\n      const newExpressions = this.getReorderedExpressions(chipsArray);\n      this.grid.groupingExpansionState = [];\n      this.expressions = newExpressions; // When reordered using keyboard navigation, we don't have `onMoveEnd` event.\n\n      if (originalEvent instanceof KeyboardEvent) {\n        this.grid.groupingExpressions = newExpressions;\n      }\n    }\n\n    handleMoveEnd() {\n      this.grid.groupingExpressions = this.expressions;\n    }\n\n    groupBy(expression) {\n      this.grid.groupBy(expression);\n    }\n\n    clearGrouping(name) {\n      this.grid.clearGrouping(name);\n    }\n\n  }\n\n  IgxGridGroupByAreaComponent.ɵfac = function IgxGridGroupByAreaComponent_Factory(t) {\n    return new (t || IgxGridGroupByAreaComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxGridGroupByAreaComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxGridGroupByAreaComponent,\n    selectors: [[\"igx-grid-group-by-area\"]],\n    inputs: {\n      sortingExpressions: \"sortingExpressions\",\n      grid: \"grid\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxGroupByAreaDirective,\n      useExisting: IgxGridGroupByAreaComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 6,\n    vars: 7,\n    consts: [[3, \"reorder\", \"moveEnd\"], [4, \"ngFor\", \"ngForOf\"], [\"igxGroupAreaDrop\", \"\", 3, \"hidden\", \"igxDrop\"], [4, \"ngTemplateOutlet\"], [\"default\", \"\"], [3, \"id\", \"title\", \"displayDensity\", \"removable\", \"draggable\", \"disabled\", \"keyDown\", \"remove\", \"chipClick\"], [\"igxSuffix\", \"\"], [1, \"igx-grid-grouparea__connector\"], [3, \"hidden\"], [1, \"igx-drop-area__icon\"], [1, \"igx-drop-area__text\"]],\n    template: function IgxGridGroupByAreaComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"igx-chips-area\", 0);\n        i0.ɵɵlistener(\"reorder\", function IgxGridGroupByAreaComponent_Template_igx_chips_area_reorder_0_listener($event) {\n          return ctx.handleReorder($event);\n        })(\"moveEnd\", function IgxGridGroupByAreaComponent_Template_igx_chips_area_moveEnd_0_listener() {\n          return ctx.handleMoveEnd();\n        });\n        i0.ɵɵtemplate(1, IgxGridGroupByAreaComponent_ng_container_1_Template, 14, 24, \"ng-container\", 1);\n        i0.ɵɵelementStart(2, \"div\", 2);\n        i0.ɵɵlistener(\"igxDrop\", function IgxGridGroupByAreaComponent_Template_div_igxDrop_2_listener($event) {\n          return ctx.onDragDrop($event);\n        });\n        i0.ɵɵtemplate(3, IgxGridGroupByAreaComponent_ng_container_3_Template, 1, 0, \"ng-container\", 3);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵtemplate(4, IgxGridGroupByAreaComponent_ng_template_4_Template, 4, 1, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        const _r2 = i0.ɵɵreference(5);\n\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.chipExpressions);\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassMapInterpolate1(\"igx-drop-area\", ctx.density !== \"comfortable\" ? \"--\" + ctx.density : \"\", \"\");\n        i0.ɵɵproperty(\"hidden\", !ctx.dropAreaVisible);\n        i0.ɵɵattribute(\"gridId\", ctx.grid.id);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.dropAreaTemplate || _r2);\n      }\n    },\n    directives: [IgxChipsAreaComponent, IgxChipComponent, IgxIconComponent, i4.NgForOf, IgxSuffixDirective, IgxGroupAreaDropDirective, IgxDropDirective, i4.NgTemplateOutlet],\n    pipes: [IgxGroupByMetaPipe],\n    encapsulation: 2\n  });\n  return IgxGridGroupByAreaComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst IgxGridTransaction = new InjectionToken('IgxGridTransaction');\n/** @hidden */\n\nlet IgxGridNavigationService = /*#__PURE__*/(() => {\n  class IgxGridNavigationService {\n    constructor(platform) {\n      this.platform = platform;\n      this._activeNode = {};\n      this.lastActiveNode = {};\n      this.pendingNavigation = false;\n    }\n\n    get activeNode() {\n      return this._activeNode;\n    }\n\n    set activeNode(value) {\n      this._activeNode = value;\n    }\n\n    handleNavigation(event) {\n      const key = event.key.toLowerCase();\n\n      if (NAVIGATION_KEYS.has(key)) {\n        event.stopPropagation();\n      }\n\n      if (this.grid.crudService.cell && NAVIGATION_KEYS.has(key)) {\n        return;\n      }\n\n      if (event.repeat && SUPPORTED_KEYS.has(key) || key === 'tab' && this.grid.crudService.cell) {\n        event.preventDefault();\n      }\n\n      if (event.repeat) {\n        setTimeout(() => this.dispatchEvent(event), 1);\n      } else {\n        this.dispatchEvent(event);\n      }\n    }\n\n    dispatchEvent(event) {\n      const key = event.key.toLowerCase();\n\n      if (!this.activeNode || !(SUPPORTED_KEYS.has(key) || key === 'tab' && this.grid.crudService.cell) && !this.grid.crudService.rowEditingBlocked && !this.grid.crudService.rowInEditMode) {\n        return;\n      }\n\n      const shift = event.shiftKey;\n      const ctrl = event.ctrlKey;\n\n      if (NAVIGATION_KEYS.has(key) && this.pendingNavigation) {\n        event.preventDefault();\n        return;\n      }\n\n      const type = this.isDataRow(this.activeNode.row) ? 'dataCell' : this.isDataRow(this.activeNode.row, true) ? 'summaryCell' : 'groupRow';\n\n      if (this.emitKeyDown(type, this.activeNode.row, event)) {\n        return;\n      }\n\n      if (event.altKey) {\n        this.handleAlt(key, event);\n        return;\n      }\n\n      if ([' ', 'spacebar', 'space'].indexOf(key) === -1) {\n        this.grid.selectionService.keyboardStateOnKeydown(this.activeNode, shift, shift && key === 'tab');\n      }\n\n      const position = this.getNextPosition(this.activeNode.row, this.activeNode.column, key, shift, ctrl, event);\n\n      if (NAVIGATION_KEYS.has(key)) {\n        event.preventDefault();\n        this.navigateInBody(position.rowIndex, position.colIndex, obj => {\n          obj.target.activate(event);\n          this.grid.cdr.detectChanges();\n        });\n      }\n\n      this.grid.cdr.detectChanges();\n    }\n\n    summaryNav(event) {\n      if (this.grid.hasSummarizedColumns) {\n        this.horizontalNav(event, event.key.toLowerCase(), this.grid.dataView.length, 'summaryCell');\n      }\n    }\n\n    headerNavigation(event) {\n      const key = event.key.toLowerCase();\n\n      if (!HEADER_KEYS.has(key)) {\n        return;\n      }\n\n      event.preventDefault();\n      const ctrl = event.ctrlKey;\n      const shift = event.shiftKey;\n      const alt = event.altKey;\n      this.performHeaderKeyCombination(this.currentActiveColumn, key, shift, ctrl, alt, event);\n\n      if (shift || alt || ctrl && (key.includes('down') || key.includes('down'))) {\n        return;\n      }\n\n      if (this.grid.hasColumnGroups) {\n        this.handleMCHeaderNav(key, ctrl);\n      } else {\n        this.horizontalNav(event, key, -1, 'headerCell');\n      }\n    }\n\n    focusTbody(event) {\n      var _a;\n\n      const gridRows = (_a = this.grid.verticalScrollContainer.totalItemCount) !== null && _a !== void 0 ? _a : this.grid.dataView.length;\n\n      if (gridRows < 1) {\n        this.activeNode = null;\n        return;\n      }\n\n      if (!this.activeNode || !Object.keys(this.activeNode).length || this.activeNode.row < 0 || this.activeNode.row > gridRows - 1) {\n        const hasLastActiveNode = Object.keys(this.lastActiveNode).length;\n        const shouldClearSelection = hasLastActiveNode && (this.lastActiveNode.row < 0 || this.lastActiveNode.row > gridRows - 1);\n        this.setActiveNode(this.lastActiveNode.row >= 0 && this.lastActiveNode.row < gridRows ? this.firstVisibleNode(this.lastActiveNode.row) : this.firstVisibleNode());\n\n        if (shouldClearSelection || this.grid.cellSelection !== GridSelectionMode.multiple) {\n          this.grid.clearCellSelection();\n          this.grid.navigateTo(this.activeNode.row, this.activeNode.column, obj => {\n            var _a;\n\n            (_a = obj.target) === null || _a === void 0 ? void 0 : _a.activate(event);\n            this.grid.cdr.detectChanges();\n          });\n        } else {\n          const range = {\n            rowStart: this.activeNode.row,\n            rowEnd: this.activeNode.row,\n            columnStart: this.activeNode.column,\n            columnEnd: this.activeNode.column\n          };\n          this.grid.selectRange(range);\n          this.grid.notifyChanges();\n        }\n      }\n    }\n\n    focusFirstCell(header = true) {\n      if ((header || this.grid.dataView.length) && this.activeNode && (this.activeNode.row === -1 || this.activeNode.row === this.grid.dataView.length || !header && !this.grid.hasSummarizedColumns)) {\n        return;\n      }\n\n      const shouldScrollIntoView = this.lastActiveNode && header && this.lastActiveNode.row !== -1 || !header && this.lastActiveNode.row !== this.grid.dataView.length;\n      this.setActiveNode(this.firstVisibleNode(header ? -1 : this.grid.dataView.length));\n\n      if (shouldScrollIntoView) {\n        this.performHorizontalScrollToCell(this.activeNode.column);\n      }\n    }\n\n    isColumnFullyVisible(columnIndex) {\n      if (columnIndex < 0 || this.isColumnPinned(columnIndex, this.forOfDir())) {\n        return true;\n      }\n\n      const index = this.getColumnUnpinnedIndex(columnIndex);\n      const width = this.forOfDir().getColumnScrollLeft(index + 1) - this.forOfDir().getColumnScrollLeft(index);\n\n      if (this.displayContainerWidth < width && this.displayContainerScrollLeft === this.forOfDir().getColumnScrollLeft(index)) {\n        return true;\n      }\n\n      return this.displayContainerWidth >= this.forOfDir().getColumnScrollLeft(index + 1) - this.displayContainerScrollLeft && this.displayContainerScrollLeft <= this.forOfDir().getColumnScrollLeft(index);\n    }\n\n    shouldPerformHorizontalScroll(visibleColIndex, rowIndex = -1) {\n      if (visibleColIndex < 0 || visibleColIndex > this.grid.visibleColumns.length - 1) {\n        return false;\n      }\n\n      if (rowIndex < 0 || rowIndex > this.grid.dataView.length - 1) {\n        return !this.isColumnFullyVisible(visibleColIndex);\n      }\n\n      const row = this.grid.dataView[rowIndex];\n      return row.expression || row.detailsData ? false : !this.isColumnFullyVisible(visibleColIndex);\n    }\n\n    shouldPerformVerticalScroll(targetRowIndex, visibleColIndex) {\n      if (this.grid.isRecordPinnedByViewIndex(targetRowIndex)) {\n        return false;\n      }\n\n      const scrollRowIndex = this.grid.hasPinnedRecords && this.grid.isRowPinningToTop ? targetRowIndex - this.grid.pinnedDataView.length : targetRowIndex;\n      const targetRow = this.getRowElementByIndex(targetRowIndex);\n      const rowHeight = this.grid.verticalScrollContainer.getSizeAt(scrollRowIndex);\n      const containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;\n      const endTopOffset = targetRow ? targetRow.offsetTop + rowHeight + this.containerTopOffset : containerHeight + rowHeight; // this is workaround: endTopOffset - containerHeight > 5 and should be replaced with: containerHeight < endTopOffset\n      // when the page is zoomed the grid does not scroll the row completely in the view\n\n      return !targetRow || targetRow.offsetTop < Math.abs(this.containerTopOffset) || containerHeight && endTopOffset - containerHeight > 5;\n    }\n\n    performVerticalScrollToCell(rowIndex, visibleColIndex = -1, cb) {\n      if (!this.shouldPerformVerticalScroll(rowIndex, visibleColIndex)) {\n        return;\n      }\n\n      this.pendingNavigation = true; // Only for top pinning we need to subtract pinned count because virtualization indexing doesn't count pinned rows.\n\n      const scrollRowIndex = this.grid.hasPinnedRecords && this.grid.isRowPinningToTop ? rowIndex - this.grid.pinnedDataView.length : rowIndex;\n      this.grid.verticalScrollContainer.scrollTo(scrollRowIndex);\n      this.grid.verticalScrollContainer.chunkLoad.pipe(first$1()).subscribe(() => {\n        this.pendingNavigation = false;\n\n        if (cb) {\n          cb();\n        }\n      });\n    }\n\n    performHorizontalScrollToCell(visibleColumnIndex, cb) {\n      if (this.grid.rowList < 1 && this.grid.summariesRowList.length < 1 && this.grid.hasColumnGroups) {\n        let column = this.grid.getColumnByVisibleIndex(visibleColumnIndex);\n\n        while (column.parent) {\n          column = column.parent;\n        }\n\n        visibleColumnIndex = this.forOfDir().igxForOf.indexOf(column);\n      }\n\n      if (!this.shouldPerformHorizontalScroll(visibleColumnIndex)) {\n        return;\n      }\n\n      this.pendingNavigation = true;\n      this.grid.parentVirtDir.chunkLoad.pipe(first$1()).subscribe(() => {\n        this.pendingNavigation = false;\n\n        if (cb) {\n          cb();\n        }\n      });\n      this.forOfDir().scrollTo(this.getColumnUnpinnedIndex(visibleColumnIndex));\n    }\n\n    isDataRow(rowIndex, includeSummary = false) {\n      let curRow;\n\n      if (rowIndex < 0 || rowIndex > this.grid.dataView.length - 1) {\n        curRow = this.grid.dataView[rowIndex - this.grid.virtualizationState.startIndex];\n\n        if (!curRow) {\n          // if data is remote, record might not be in the view yet.\n          return this.grid.verticalScrollContainer.isRemote && rowIndex >= 0 && rowIndex <= this.grid.totalItemCount - 1;\n        }\n      } else {\n        curRow = this.grid.dataView[rowIndex];\n      }\n\n      return curRow && !this.grid.isGroupByRecord(curRow) && !this.grid.isDetailRecord(curRow) && !curRow.childGridsData && (includeSummary || !curRow.summaries);\n    }\n\n    isGroupRow(rowIndex) {\n      if (rowIndex < 0 || rowIndex > this.grid.dataView.length - 1) {\n        return false;\n      }\n\n      const curRow = this.grid.dataView[rowIndex];\n      return curRow && this.grid.isGroupByRecord(curRow);\n    }\n\n    setActiveNode(activeNode) {\n      if (!this.isActiveNodeChanged(activeNode)) {\n        return;\n      }\n\n      if (!this.activeNode) {\n        this.activeNode = activeNode;\n      }\n\n      Object.assign(this.activeNode, activeNode);\n      const currRow = this.grid.dataView[activeNode.row];\n      const type = activeNode.row < 0 ? 'headerCell' : this.isDataRow(activeNode.row) ? 'dataCell' : currRow && this.grid.isGroupByRecord(currRow) ? 'groupRow' : currRow && this.grid.isDetailRecord(currRow) ? 'masterDetailRow' : 'summaryCell';\n      const args = {\n        row: this.activeNode.row,\n        column: this.activeNode.column,\n        level: this.activeNode.level,\n        tag: type\n      };\n      this.grid.activeNodeChange.emit(args);\n    }\n\n    isActiveNodeChanged(activeNode) {\n      let isChanged = false;\n\n      const checkInnerProp = (aciveNode, prop) => {\n        if (!aciveNode) {\n          isChanged = true;\n          return;\n        }\n\n        props = Object.getOwnPropertyNames(aciveNode);\n\n        for (const propName of props) {\n          if (this.activeNode[prop][propName] !== aciveNode[propName]) {\n            isChanged = true;\n          }\n        }\n      };\n\n      if (!this.activeNode) {\n        return isChanged = true;\n      }\n\n      let props = Object.getOwnPropertyNames(activeNode);\n\n      for (const propName of props) {\n        if (!!this.activeNode[propName] && typeof this.activeNode[propName] === 'object') {\n          checkInnerProp(activeNode[propName], propName);\n        } else if (this.activeNode[propName] !== activeNode[propName]) {\n          isChanged = true;\n        }\n      }\n\n      return isChanged;\n    }\n\n    getNextPosition(rowIndex, colIndex, key, shift, ctrl, event) {\n      if (!this.isDataRow(rowIndex, true) && (key.indexOf('down') < 0 || key.indexOf('up') < 0) && ctrl) {\n        return {\n          rowIndex,\n          colIndex\n        };\n      }\n\n      switch (key) {\n        case 'pagedown':\n        case 'pageup':\n          event.preventDefault();\n\n          if (key === 'pagedown') {\n            this.grid.verticalScrollContainer.scrollNextPage();\n          } else {\n            this.grid.verticalScrollContainer.scrollPrevPage();\n          }\n\n          const editCell = this.grid.crudService.cell;\n          this.grid.verticalScrollContainer.chunkLoad.pipe(first$1()).subscribe(() => {\n            if (editCell && this.grid.rowList.map(r => r.index).indexOf(editCell.rowIndex) < 0) {\n              this.grid.tbody.nativeElement.focus({\n                preventScroll: true\n              });\n            }\n          });\n          break;\n\n        case 'tab':\n          this.handleEditing(shift, event);\n          break;\n\n        case 'end':\n          rowIndex = ctrl ? this.findLastDataRowIndex() : this.activeNode.row;\n          colIndex = this.lastColumnIndex;\n          break;\n\n        case 'home':\n          rowIndex = ctrl ? this.findFirstDataRowIndex() : this.activeNode.row;\n          colIndex = 0;\n          break;\n\n        case 'arrowleft':\n        case 'left':\n          colIndex = ctrl ? 0 : this.activeNode.column - 1;\n          break;\n\n        case 'arrowright':\n        case 'right':\n          colIndex = ctrl ? this.lastColumnIndex : this.activeNode.column + 1;\n          break;\n\n        case 'arrowup':\n        case 'up':\n          if (ctrl && !this.isDataRow(rowIndex) || this.grid.rowEditable && this.grid.crudService.rowEditingBlocked) {\n            break;\n          }\n\n          colIndex = this.activeNode.column !== undefined ? this.activeNode.column : 0;\n          rowIndex = ctrl ? this.findFirstDataRowIndex() : this.activeNode.row - 1;\n          break;\n\n        case 'arrowdown':\n        case 'down':\n          if (ctrl && !this.isDataRow(rowIndex) || this.grid.rowEditable && this.grid.crudService.rowEditingBlocked) {\n            break;\n          }\n\n          colIndex = this.activeNode.column !== undefined ? this.activeNode.column : 0;\n          rowIndex = ctrl ? this.findLastDataRowIndex() : this.activeNode.row + 1;\n          break;\n\n        case 'enter':\n        case 'f2':\n          const cell = this.grid.gridAPI.get_cell_by_visible_index(this.activeNode.row, this.activeNode.column);\n\n          if (!this.isDataRow(rowIndex) || !cell.editable) {\n            break;\n          }\n\n          this.grid.crudService.enterEditMode(cell, event);\n          break;\n\n        case 'escape':\n        case 'esc':\n          if (!this.isDataRow(rowIndex)) {\n            break;\n          }\n\n          if (this.grid.crudService.isInCompositionMode) {\n            return;\n          }\n\n          if (this.grid.crudService.cellInEditMode || this.grid.crudService.rowInEditMode) {\n            this.grid.crudService.endEdit(false, event);\n\n            if (this.platform.isEdge) {\n              this.grid.cdr.detectChanges();\n            }\n\n            this.grid.tbody.nativeElement.focus();\n          }\n\n          break;\n\n        case ' ':\n        case 'spacebar':\n        case 'space':\n          const rowObj = this.grid.gridAPI.get_row_by_index(this.activeNode.row);\n\n          if (this.grid.isRowSelectable && rowObj) {\n            if (this.isDataRow(rowIndex)) {\n              if (rowObj.selected) {\n                this.grid.selectionService.deselectRow(rowObj.key, event);\n              } else {\n                this.grid.selectionService.selectRowById(rowObj.key, false, event);\n              }\n            }\n\n            if (this.isGroupRow(rowIndex)) {\n              rowObj.onGroupSelectorClick(event);\n            }\n          }\n\n          break;\n\n        default:\n          return;\n      }\n\n      return {\n        rowIndex,\n        colIndex\n      };\n    }\n\n    horizontalNav(event, key, rowIndex, tag) {\n      const ctrl = event.ctrlKey;\n\n      if (!HORIZONTAL_NAV_KEYS.has(event.key.toLowerCase())) {\n        return;\n      }\n\n      event.preventDefault();\n      this.activeNode.row = rowIndex;\n\n      if (rowIndex > 0) {\n        if (this.emitKeyDown('summaryCell', this.activeNode.row, event)) {\n          return;\n        }\n      }\n\n      const newActiveNode = {\n        column: this.activeNode.column,\n        mchCache: {\n          level: this.activeNode.level,\n          visibleIndex: this.activeNode.column\n        }\n      };\n\n      if ((key.includes('left') || key === 'home') && this.activeNode.column > 0) {\n        newActiveNode.column = ctrl || key === 'home' ? 0 : this.activeNode.column - 1;\n      }\n\n      if ((key.includes('right') || key === 'end') && this.activeNode.column < this.lastColumnIndex) {\n        newActiveNode.column = ctrl || key === 'end' ? this.lastColumnIndex : this.activeNode.column + 1;\n      }\n\n      if (tag === 'headerCell') {\n        const column = this.grid.getColumnByVisibleIndex(newActiveNode.column);\n        newActiveNode.mchCache.level = column.level;\n        newActiveNode.mchCache.visibleIndex = column.visibleIndex;\n      }\n\n      this.setActiveNode({\n        row: this.activeNode.row,\n        column: newActiveNode.column,\n        mchCache: newActiveNode.mchCache\n      });\n      this.performHorizontalScrollToCell(this.activeNode.column);\n    }\n\n    get lastColumnIndex() {\n      return Math.max(...this.grid.visibleColumns.map(col => col.visibleIndex));\n    }\n\n    get displayContainerWidth() {\n      return Math.round(this.grid.parentVirtDir.dc.instance._viewContainer.element.nativeElement.offsetWidth);\n    }\n\n    get displayContainerScrollLeft() {\n      return Math.ceil(this.grid.headerContainer.scrollPosition);\n    }\n\n    get containerTopOffset() {\n      return parseInt(this.grid.verticalScrollContainer.dc.instance._viewContainer.element.nativeElement.style.top, 10);\n    }\n\n    getColumnUnpinnedIndex(visibleColumnIndex) {\n      const column = this.grid.unpinnedColumns.find(col => !col.columnGroup && col.visibleIndex === visibleColumnIndex);\n      return this.grid.pinnedColumns.length ? this.grid.unpinnedColumns.filter(c => !c.columnGroup).indexOf(column) : visibleColumnIndex;\n    }\n\n    forOfDir() {\n      const forOfDir = this.grid.dataRowList.length > 0 ? this.grid.dataRowList.first.virtDirRow : this.grid.summariesRowList.length ? this.grid.summariesRowList.first.virtDirRow : this.grid.headerContainer;\n      return forOfDir;\n    }\n\n    handleAlt(key, event) {\n      event.preventDefault(); // todo TODO ROW\n\n      const row = this.grid.gridAPI.get_row_by_index(this.activeNode.row);\n\n      if (!(this.isToggleKey(key) || this.isAddKey(key)) || !row) {\n        return;\n      }\n\n      if (this.isAddKey(key)) {\n        if (!this.grid.rowEditable) {\n          console.warn('The grid must be in row edit mode to perform row adding!');\n          return;\n        }\n\n        if (event.shiftKey && row.treeRow !== undefined) {\n          this.grid.crudService.enterAddRowMode(row, true, event);\n        } else if (!event.shiftKey) {\n          this.grid.crudService.enterAddRowMode(row, false, event);\n        }\n      } else if (!row.expanded && ROW_EXPAND_KEYS.has(key)) {\n        if (row.key === undefined) {\n          // TODO use expanded row.expanded = !row.expanded;\n          row.toggle();\n        } else {\n          this.grid.gridAPI.set_row_expansion_state(row.key, true, event);\n        }\n      } else if (row.expanded && ROW_COLLAPSE_KEYS.has(key)) {\n        if (row.key === undefined) {\n          // TODO use expanded row.expanded = !row.expanded;\n          row.toggle();\n        } else {\n          this.grid.gridAPI.set_row_expansion_state(row.key, false, event);\n        }\n      }\n\n      this.grid.notifyChanges();\n    }\n\n    handleEditing(shift, event) {\n      const next = shift ? this.grid.getPreviousCell(this.activeNode.row, this.activeNode.column, col => col.editable) : this.grid.getNextCell(this.activeNode.row, this.activeNode.column, col => col.editable);\n\n      if (!this.grid.crudService.rowInEditMode && this.isActiveNode(next.rowIndex, next.visibleColumnIndex)) {\n        this.grid.crudService.endEdit(true, event);\n        this.grid.tbody.nativeElement.focus();\n        return;\n      }\n\n      event.preventDefault();\n\n      if (this.grid.crudService.rowInEditMode && this.grid.rowEditTabs.length && (this.activeNode.row !== next.rowIndex || this.isActiveNode(next.rowIndex, next.visibleColumnIndex))) {\n        const args = this.grid.crudService.updateCell(true, event);\n\n        if (args.cancel) {\n          return;\n        } else if (shift) {\n          this.grid.rowEditTabs.last.element.nativeElement.focus();\n        } else {\n          this.grid.rowEditTabs.first.element.nativeElement.focus();\n        }\n\n        return;\n      }\n\n      if (this.grid.crudService.rowInEditMode && !this.grid.rowEditTabs.length) {\n        if (shift && next.rowIndex === this.activeNode.row && next.visibleColumnIndex === this.activeNode.column) {\n          next.visibleColumnIndex = this.grid.lastEditableColumnIndex;\n        } else if (!shift && next.rowIndex === this.activeNode.row && next.visibleColumnIndex === this.activeNode.column) {\n          next.visibleColumnIndex = this.grid.firstEditableColumnIndex;\n        } else {\n          next.rowIndex = this.activeNode.row;\n        }\n      }\n\n      this.navigateInBody(next.rowIndex, next.visibleColumnIndex, obj => {\n        obj.target.activate(event);\n        this.grid.cdr.detectChanges();\n      });\n    }\n\n    navigateInBody(rowIndex, visibleColIndex, cb = null) {\n      if (!this.isValidPosition(rowIndex, visibleColIndex) || this.isActiveNode(rowIndex, visibleColIndex)) {\n        return;\n      }\n\n      this.grid.navigateTo(rowIndex, visibleColIndex, cb);\n    }\n\n    emitKeyDown(type, rowIndex, event) {\n      var _a, _b;\n\n      const row = this.grid.summariesRowList.toArray().concat(this.grid.rowList.toArray()).find(r => r.index === rowIndex);\n\n      if (!row) {\n        return;\n      }\n\n      const target = type === 'groupRow' ? row : type === 'dataCell' ? (_a = row.cells) === null || _a === void 0 ? void 0 : _a.find(c => c.visibleColumnIndex === this.activeNode.column) : (_b = row.summaryCells) === null || _b === void 0 ? void 0 : _b.find(c => c.visibleColumnIndex === this.activeNode.column);\n      const keydownArgs = {\n        targetType: type,\n        event,\n        cancel: false,\n        target\n      };\n      this.grid.gridKeydown.emit(keydownArgs);\n\n      if (keydownArgs.cancel && type === 'dataCell') {\n        this.grid.selectionService.clear();\n        this.grid.selectionService.keyboardState.active = true;\n        return keydownArgs.cancel;\n      }\n    }\n\n    isColumnPinned(columnIndex, forOfDir) {\n      var _a;\n\n      const horizontalScroll = forOfDir.getScroll();\n      return !horizontalScroll.clientWidth || ((_a = this.grid.getColumnByVisibleIndex(columnIndex)) === null || _a === void 0 ? void 0 : _a.pinned);\n    }\n\n    findFirstDataRowIndex() {\n      return this.grid.dataView.findIndex(rec => !this.grid.isGroupByRecord(rec) && !this.grid.isDetailRecord(rec) && !rec.summaries);\n    }\n\n    findLastDataRowIndex() {\n      if (this.grid.totalItemCount) {\n        return this.grid.totalItemCount - 1;\n      }\n\n      let i = this.grid.dataView.length;\n\n      while (i--) {\n        if (this.isDataRow(i)) {\n          return i;\n        }\n      }\n    }\n\n    getRowElementByIndex(index) {\n      var _a;\n\n      if (this.grid.hasDetails) {\n        const detail = this.grid.nativeElement.querySelector(`[detail=\"true\"][data-rowindex=\"${index}\"]`);\n\n        if (detail) {\n          return detail;\n        }\n      }\n\n      return (_a = this.grid.rowList.toArray().concat(this.grid.summariesRowList.toArray()).find(r => r.index === index)) === null || _a === void 0 ? void 0 : _a.nativeElement;\n    }\n\n    isValidPosition(rowIndex, colIndex) {\n      var _a;\n\n      const length = (_a = this.grid.totalItemCount) !== null && _a !== void 0 ? _a : this.grid.dataView.length;\n\n      if (rowIndex < 0 || colIndex < 0 || length - 1 < rowIndex || this.lastColumnIndex < colIndex) {\n        return false;\n      }\n\n      return this.activeNode.column !== colIndex && !this.isDataRow(rowIndex, true) ? false : true;\n    }\n\n    performHeaderKeyCombination(column, key, shift, ctrl, alt, event) {\n      var _a;\n\n      let direction = (_a = this.grid.sortingExpressions.find(expr => expr.fieldName === column.field)) === null || _a === void 0 ? void 0 : _a.dir;\n\n      if (ctrl && key.includes('up') && column.sortable && !column.columnGroup) {\n        direction = direction === SortingDirection.Asc ? SortingDirection.None : SortingDirection.Asc;\n        this.grid.sort({\n          fieldName: column.field,\n          dir: direction,\n          ignoreCase: false\n        });\n        return;\n      }\n\n      if (ctrl && key.includes('down') && column.sortable && !column.columnGroup) {\n        direction = direction === SortingDirection.Desc ? SortingDirection.None : SortingDirection.Desc;\n        this.grid.sort({\n          fieldName: column.field,\n          dir: direction,\n          ignoreCase: false\n        });\n        return;\n      }\n\n      if (shift && alt && this.isToggleKey(key) && !column.columnGroup && column.groupable) {\n        direction = direction || SortingDirection.Asc;\n\n        if (key.includes('right')) {\n          this.grid.groupBy({\n            fieldName: column.field,\n            dir: direction,\n            ignoreCase: column.sortingIgnoreCase,\n            strategy: column.sortStrategy,\n            groupingComparer: column.groupingComparer\n          });\n        } else {\n          this.grid.clearGrouping(column.field);\n        }\n\n        this.activeNode.column = key.includes('right') && this.grid.hideGroupedColumns && column.visibleIndex === this.lastColumnIndex ? this.lastColumnIndex - 1 : this.activeNode.column;\n        return;\n      }\n\n      if (alt && (ROW_EXPAND_KEYS.has(key) || ROW_COLLAPSE_KEYS.has(key))) {\n        this.handleMCHExpandCollapse(key, column);\n        return;\n      }\n\n      if ([' ', 'spacebar', 'space'].indexOf(key) !== -1) {\n        this.handleColumnSelection(column, event);\n      }\n\n      if (alt && (key === 'l' || key === '¬') && this.grid.allowAdvancedFiltering) {\n        this.grid.openAdvancedFilteringDialog();\n      }\n\n      if (ctrl && shift && key === 'l' && this.grid.allowFiltering && !column.columnGroup && column.filterable) {\n        if (this.grid.filterMode === FilterMode.excelStyleFilter) {\n          const headerEl = this.grid.headerGroups.find(g => g.active).nativeElement;\n          this.grid.filteringService.toggleFilterDropdown(headerEl, column);\n        } else {\n          this.performHorizontalScrollToCell(column.visibleIndex);\n          this.grid.filteringService.filteredColumn = column;\n          this.grid.filteringService.isFilterRowVisible = true;\n        }\n      }\n    }\n\n    firstVisibleNode(rowIndex) {\n      var _a, _b, _c, _d;\n\n      const colIndex = this.lastActiveNode.column !== undefined ? this.lastActiveNode.column : (_a = this.grid.visibleColumns.sort((c1, c2) => c1.visibleIndex - c2.visibleIndex).find(c => this.isColumnFullyVisible(c.visibleIndex))) === null || _a === void 0 ? void 0 : _a.visibleIndex;\n      const column = this.grid.visibleColumns.find(col => !col.columnLayout && col.visibleIndex === colIndex);\n      const rowInd = rowIndex ? rowIndex : (_b = this.grid.rowList.find(r => !this.shouldPerformVerticalScroll(r.index, colIndex))) === null || _b === void 0 ? void 0 : _b.index;\n      const node = {\n        row: rowInd !== null && rowInd !== void 0 ? rowInd : 0,\n        column: (_c = column === null || column === void 0 ? void 0 : column.visibleIndex) !== null && _c !== void 0 ? _c : 0,\n        level: (_d = column === null || column === void 0 ? void 0 : column.level) !== null && _d !== void 0 ? _d : 0,\n        mchCache: column ? {\n          level: column.level,\n          visibleIndex: column.visibleIndex\n        } : {},\n        layout: column && column.columnLayoutChild ? {\n          rowStart: column.rowStart,\n          colStart: column.colStart,\n          rowEnd: column.rowEnd,\n          colEnd: column.colEnd,\n          columnVisibleIndex: column.visibleIndex\n        } : null\n      };\n      return node;\n    }\n\n    handleMCHeaderNav(key, ctrl) {\n      const newHeaderNode = {\n        visibleIndex: this.activeNode.mchCache.visibleIndex,\n        level: this.activeNode.mchCache.level\n      };\n      const activeCol = this.currentActiveColumn;\n      const lastGroupIndex = Math.max(...this.grid.visibleColumns.filter(c => c.level <= this.activeNode.level).map(col => col.visibleIndex));\n      let nextCol = activeCol;\n\n      if ((key.includes('left') || key === 'home') && this.activeNode.column > 0) {\n        const index = ctrl || key === 'home' ? 0 : this.activeNode.column - 1;\n        nextCol = this.getNextColumnMCH(index);\n        newHeaderNode.visibleIndex = nextCol.visibleIndex;\n      }\n\n      if ((key.includes('right') || key === 'end') && activeCol.visibleIndex < lastGroupIndex) {\n        const nextVIndex = activeCol.children ? Math.max(...activeCol.allChildren.map(c => c.visibleIndex)) + 1 : activeCol.visibleIndex + 1;\n        nextCol = ctrl || key === 'end' ? this.getNextColumnMCH(this.lastColumnIndex) : this.getNextColumnMCH(nextVIndex);\n        newHeaderNode.visibleIndex = nextCol.visibleIndex;\n      }\n\n      if (!ctrl && key.includes('up') && this.activeNode.level > 0) {\n        nextCol = activeCol.parent;\n        newHeaderNode.level = nextCol.level;\n      }\n\n      if (!ctrl && key.includes('down') && activeCol.children) {\n        nextCol = activeCol.children.find(c => c.visibleIndex === newHeaderNode.visibleIndex) || activeCol.children.toArray().sort((a, b) => b.visibleIndex - a.visibleIndex).filter(col => col.visibleIndex < newHeaderNode.visibleIndex)[0];\n        newHeaderNode.level = nextCol.level;\n      }\n\n      this.setActiveNode({\n        row: this.activeNode.row,\n        column: nextCol.visibleIndex,\n        level: nextCol.level,\n        mchCache: newHeaderNode\n      });\n      this.performHorizontalScrollToCell(nextCol.visibleIndex);\n    }\n\n    handleMCHExpandCollapse(key, column) {\n      if (!column.children || !column.collapsible) {\n        return;\n      }\n\n      if (!column.expanded && ROW_EXPAND_KEYS.has(key)) {\n        column.expanded = true;\n      } else if (column.expanded && ROW_COLLAPSE_KEYS.has(key)) {\n        column.expanded = false;\n      }\n    }\n\n    handleColumnSelection(column, event) {\n      if (!column.selectable || this.grid.columnSelection === GridSelectionMode.none) {\n        return;\n      }\n\n      const clearSelection = this.grid.columnSelection === GridSelectionMode.single;\n      const columnsToSelect = !column.children ? [column.field] : column.allChildren.filter(c => !c.hidden && c.selectable && !c.columnGroup).map(c => c.field);\n\n      if (column.selected) {\n        this.grid.selectionService.deselectColumns(columnsToSelect, event);\n      } else {\n        this.grid.selectionService.selectColumns(columnsToSelect, clearSelection, false, event);\n      }\n    }\n\n    getNextColumnMCH(visibleIndex) {\n      let col = this.grid.getColumnByVisibleIndex(visibleIndex);\n      let parent = col.parent;\n\n      while (parent && col.level > this.activeNode.mchCache.level) {\n        col = col.parent;\n        parent = col.parent;\n      }\n\n      return col;\n    }\n\n    get currentActiveColumn() {\n      return this.grid.visibleColumns.find(c => c.visibleIndex === this.activeNode.column && c.level === this.activeNode.level);\n    }\n\n    isActiveNode(rIndex, cIndex) {\n      return this.activeNode ? this.activeNode.row === rIndex && this.activeNode.column === cIndex : false;\n    }\n\n    isToggleKey(key) {\n      return ROW_COLLAPSE_KEYS.has(key) || ROW_EXPAND_KEYS.has(key);\n    }\n\n    isAddKey(key) {\n      return ROW_ADD_KEYS.has(key);\n    }\n\n  }\n\n  IgxGridNavigationService.ɵfac = function IgxGridNavigationService_Factory(t) {\n    return new (t || IgxGridNavigationService)(i0.ɵɵinject(PlatformUtil));\n  };\n\n  IgxGridNavigationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxGridNavigationService,\n    factory: IgxGridNavigationService.ɵfac\n  });\n  return IgxGridNavigationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxGridSummaryService = /*#__PURE__*/(() => {\n  class IgxGridSummaryService {\n    constructor() {\n      this.rootSummaryID = 'igxGridRootSummary';\n      this.summaryHeight = 0;\n      this.maxSummariesLenght = 0;\n      this.groupingExpressions = [];\n      this.retriggerRootPipe = 0;\n      this.deleteOperation = false;\n      this.summaryCacheMap = new Map();\n    }\n\n    recalculateSummaries() {\n      this.resetSummaryHeight();\n      this.grid.notifyChanges(true);\n    }\n\n    clearSummaryCache(args) {\n      if (!this.summaryCacheMap.size) {\n        return;\n      }\n\n      if (!args) {\n        this.summaryCacheMap.clear();\n\n        if (this.grid && this.grid.rootSummariesEnabled) {\n          this.retriggerRootPipe++;\n        }\n\n        return;\n      }\n\n      if (args.data) {\n        const rowID = this.grid.primaryKey ? args.data[this.grid.primaryKey] : args.data;\n        this.removeSummaries(rowID);\n      }\n\n      if (args.rowID !== undefined && args.rowID !== null) {\n        let columnName = args.cellID ? this.grid.columnList.find(col => col.index === args.cellID.columnID).field : undefined;\n\n        if (columnName && this.grid.rowEditable) {\n          return;\n        }\n\n        const isGroupedColumn = this.grid.groupingExpressions && this.grid.groupingExpressions.map(expr => expr.fieldName).indexOf(columnName) !== -1;\n\n        if (columnName && isGroupedColumn) {\n          columnName = undefined;\n        }\n\n        this.removeSummaries(args.rowID, columnName);\n      }\n    }\n\n    removeSummaries(rowID, columnName) {\n      this.deleteSummaryCache(this.rootSummaryID, columnName);\n\n      if (this.summaryCacheMap.size === 1 && this.summaryCacheMap.has(this.rootSummaryID)) {\n        return;\n      }\n\n      if (this.isTreeGrid) {\n        if (this.grid.transactions.enabled && this.deleteOperation) {\n          this.deleteOperation = false; // TODO: this.removeChildRowSummaries(rowID, columnName);\n\n          this.summaryCacheMap.clear();\n          return;\n        }\n\n        this.removeAllTreeGridSummaries(rowID, columnName);\n      } else if (this.isHierarchicalGrid) {\n        if (this.grid.transactions.enabled && this.deleteOperation) {\n          this.deleteOperation = false;\n          this.summaryCacheMap.clear();\n        }\n      } else {\n        const summaryIds = this.getSummaryID(rowID, this.grid.groupingExpressions);\n        summaryIds.forEach(id => {\n          this.deleteSummaryCache(id, columnName);\n        });\n      }\n    }\n\n    removeSummariesCachePerColumn(columnName) {\n      this.summaryCacheMap.forEach(cache => {\n        if (cache.get(columnName)) {\n          cache.delete(columnName);\n        }\n      });\n\n      if (this.grid.rootSummariesEnabled) {\n        this.retriggerRootPipe++;\n      }\n    }\n\n    calcMaxSummaryHeight() {\n      if (this.summaryHeight) {\n        return this.summaryHeight;\n      }\n\n      if (!this.grid.data) {\n        return this.summaryHeight = 0;\n      }\n\n      let maxSummaryLength = 0;\n      this.grid.columnList.filter(col => col.hasSummary && !col.hidden).forEach(column => {\n        const getCurrentSummaryColumn = column.summaries.operate([], [], column.field).length;\n\n        if (getCurrentSummaryColumn) {\n          if (maxSummaryLength < getCurrentSummaryColumn) {\n            maxSummaryLength = getCurrentSummaryColumn;\n          }\n        }\n      });\n      this.maxSummariesLenght = maxSummaryLength;\n      this.summaryHeight = maxSummaryLength * this.grid.defaultSummaryHeight;\n      return this.summaryHeight;\n    }\n\n    calculateSummaries(rowID, data) {\n      let rowSummaries = this.summaryCacheMap.get(rowID);\n\n      if (!rowSummaries) {\n        rowSummaries = new Map();\n        this.summaryCacheMap.set(rowID, rowSummaries);\n      }\n\n      if (!this.hasSummarizedColumns || !data) {\n        return rowSummaries;\n      }\n\n      this.grid.columnList.filter(col => col.hasSummary).forEach(column => {\n        if (!rowSummaries.get(column.field)) {\n          const summaryResult = column.summaries.operate(data.map(r => resolveNestedPath(r, column.field)), data, column.field, this.grid.locale, column.pipeArgs);\n          rowSummaries.set(column.field, summaryResult);\n        }\n      });\n      return rowSummaries;\n    }\n\n    resetSummaryHeight() {\n      this.summaryHeight = 0;\n      this.grid.summaryPipeTrigger++;\n\n      if (this.grid.rootSummariesEnabled) {\n        this.retriggerRootPipe++;\n        Promise.resolve().then(() => this.grid.notifyChanges(true));\n      }\n    }\n\n    updateSummaryCache(groupingArgs) {\n      if (this.summaryCacheMap.size === 0 || !this.hasSummarizedColumns) {\n        return;\n      }\n\n      if (this.groupingExpressions.length === 0) {\n        this.groupingExpressions = groupingArgs.expressions.map(record => record.fieldName);\n        return;\n      }\n\n      if (groupingArgs.length === 0) {\n        this.groupingExpressions = [];\n        this.clearSummaryCache();\n        return;\n      }\n\n      this.compareGroupingExpressions(this.groupingExpressions, groupingArgs);\n      this.groupingExpressions = groupingArgs.expressions.map(record => record.fieldName);\n    }\n\n    get hasSummarizedColumns() {\n      const summarizedColumns = this.grid.columnList.filter(col => col.hasSummary && !col.hidden);\n      return summarizedColumns.length > 0;\n    }\n\n    deleteSummaryCache(id, columnName) {\n      if (this.summaryCacheMap.get(id)) {\n        const filteringApplied = columnName && this.grid.filteringExpressionsTree && this.grid.filteringExpressionsTree.filteringOperands.map(expr => expr.fieldName).indexOf(columnName) !== -1;\n\n        if (columnName && this.summaryCacheMap.get(id).get(columnName) && !filteringApplied) {\n          this.summaryCacheMap.get(id).delete(columnName);\n        } else {\n          this.summaryCacheMap.delete(id);\n        }\n\n        if (id === this.rootSummaryID && this.grid.rootSummariesEnabled) {\n          this.retriggerRootPipe++;\n        }\n      }\n    }\n\n    getSummaryID(rowID, groupingExpressions) {\n      if (groupingExpressions.length === 0) {\n        return [];\n      }\n\n      const summaryIDs = [];\n      let data = this.grid.data;\n\n      if (this.grid.transactions.enabled) {\n        data = DataUtil.mergeTransactions(cloneArray(this.grid.data), this.grid.transactions.getAggregatedChanges(true), this.grid.primaryKey, this.grid.dataCloneStrategy);\n      }\n\n      const rowData = this.grid.primaryKey ? data.find(rec => rec[this.grid.primaryKey] === rowID) : rowID;\n      let id = '{ ';\n      groupingExpressions.forEach(expr => {\n        id += `'${expr.fieldName}': '${rowData[expr.fieldName]}'`;\n        summaryIDs.push(id.concat(' }'));\n        id += ', ';\n      });\n      return summaryIDs;\n    }\n\n    removeAllTreeGridSummaries(rowID, columnName) {\n      let row = this.grid.records.get(rowID);\n\n      if (!row) {\n        return;\n      }\n\n      row = row.children ? row : row.parent;\n\n      while (row) {\n        rowID = row.key;\n        this.deleteSummaryCache(rowID, columnName);\n        row = row.parent;\n      }\n    } // TODO: remove only deleted rows\n    // private removeChildRowSummaries(rowID, columnName?) {\n    // }\n\n\n    compareGroupingExpressions(current, groupingArgs) {\n      const newExpressions = groupingArgs.expressions.map(record => record.fieldName);\n      const removedCols = groupingArgs.ungroupedColumns;\n\n      if (current.length <= newExpressions.length) {\n        const newExpr = newExpressions.slice(0, current.length).toString();\n\n        if (current.toString() !== newExpr) {\n          this.clearSummaryCache();\n        }\n      } else {\n        const currExpr = current.slice(0, newExpressions.length).toString();\n\n        if (currExpr !== newExpressions.toString()) {\n          this.clearSummaryCache();\n          return;\n        }\n\n        removedCols.map(col => col.field).forEach(colName => {\n          this.summaryCacheMap.forEach((cache, id) => {\n            if (id.indexOf(colName) !== -1) {\n              this.summaryCacheMap.delete(id);\n            }\n          });\n        });\n      }\n    }\n\n    get isTreeGrid() {\n      return this.grid.nativeElement.tagName.toLowerCase() === 'igx-tree-grid';\n    }\n\n    get isHierarchicalGrid() {\n      return this.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';\n    }\n\n  }\n\n  IgxGridSummaryService.ɵfac = function IgxGridSummaryService_Factory(t) {\n    return new (t || IgxGridSummaryService)();\n  };\n\n  IgxGridSummaryService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxGridSummaryService,\n    factory: IgxGridSummaryService.ɵfac\n  });\n  return IgxGridSummaryService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet FAKE_ROW_ID = -1;\nconst DEFAULT_ITEMS_PER_PAGE = 15;\nconst MINIMUM_COLUMN_WIDTH$2 = 136;\nconst FILTER_ROW_HEIGHT = 50; // By default row editing overlay outlet is inside grid body so that overlay is hidden below grid header when scrolling.\n// In cases when grid has 1-2 rows there isn't enough space in grid body and row editing overlay should be shown above header.\n// Default row editing overlay height is higher then row height that is why the case is valid also for row with 2 rows.\n// More accurate calculation is not possible, cause row editing overlay is still not shown and we don't know its height,\n// but in the same time we need to set row editing overlay outlet before opening the overlay itself.\n\nconst MIN_ROW_EDITING_COUNT_THRESHOLD = 2;\nlet IgxGridBaseDirective = /*#__PURE__*/(() => {\n  class IgxGridBaseDirective extends DisplayDensityBase {\n    constructor(selectionService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, appRef, moduleRef, injector, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, localeId, platform, _diTransactions) {\n      super(_displayDensityOptions);\n      this.selectionService = selectionService;\n      this.colResizingService = colResizingService;\n      this.gridAPI = gridAPI;\n      this.transactionFactory = transactionFactory;\n      this.elementRef = elementRef;\n      this.zone = zone;\n      this.document = document;\n      this.cdr = cdr;\n      this.resolver = resolver;\n      this.differs = differs;\n      this.viewRef = viewRef;\n      this.appRef = appRef;\n      this.moduleRef = moduleRef;\n      this.injector = injector;\n      this.navigation = navigation;\n      this.filteringService = filteringService;\n      this.overlayService = overlayService;\n      this.summaryService = summaryService;\n      this._displayDensityOptions = _displayDensityOptions;\n      this.localeId = localeId;\n      this.platform = platform;\n      this._diTransactions = _diTransactions;\n      /**\n       * Gets/Sets the display time for the row adding snackbar notification.\n       *\n       * @remarks\n       * By default it is 6000ms.\n       */\n\n      this.snackbarDisplayTime = 6000;\n      /**\n       * Gets/Sets whether to auto-generate the columns.\n       *\n       * @remarks\n       * The default value is false. When set to true, it will override all columns declared through code or in markup.\n       * @example\n       * ```html\n       * <igx-grid [data]=\"Data\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       */\n\n      this.autoGenerate = false;\n      /**\n       * Controls whether columns moving is enabled in the grid.\n       *\n       */\n\n      this.moving = false;\n      /**\n       * Controls the copy behavior of the grid.\n       */\n\n      this.clipboardOptions = {\n        /**\n         * Enables/disables the copy behavior\n         */\n        enabled: true,\n\n        /**\n         * Include the columns headers in the clipboard output.\n         */\n        copyHeaders: true,\n\n        /**\n         * Apply the columns formatters (if any) on the data in the clipboard output.\n         */\n        copyFormatters: true,\n\n        /**\n         * The separator used for formatting the copy output. Defaults to `\\t`.\n         */\n        separator: '\\t'\n      };\n      /**\n       * Emitted after filtering is performed.\n       *\n       * @remarks\n       * Returns the filtering expressions tree of the column for which filtering was performed.\n       * @example\n       * ```html\n       * <igx-grid #grid [data]=\"localData\" [height]=\"'305px'\" [autoGenerate]=\"true\"\n       *              (filteringExpressionsTreeChange)=\"filteringExprTreeChange($event)\"></igx-grid>\n       * ```\n       */\n\n      this.filteringExpressionsTreeChange = new EventEmitter();\n      /**\n       * Emitted after advanced filtering is performed.\n       *\n       * @remarks\n       * Returns the advanced filtering expressions tree.\n       * @example\n       * ```html\n       * <igx-grid #grid [data]=\"localData\" [height]=\"'305px'\" [autoGenerate]=\"true\"\n       *           (advancedFilteringExpressionsTreeChange)=\"advancedFilteringExprTreeChange($event)\"></igx-grid>\n       * ```\n       */\n\n      this.advancedFilteringExpressionsTreeChange = new EventEmitter();\n      /**\n       * Emitted when grid is scrolled horizontally/vertically.\n       *\n       * @example\n       * ```html\n       * <igx-grid #grid [data]=\"localData\" [height]=\"'305px'\" [autoGenerate]=\"true\"\n       *              (gridScroll)=\"onScroll($event)\"></igx-grid>\n       * ```\n       */\n\n      this.gridScroll = new EventEmitter();\n      /**\n       * @deprecated in version 12.1.0. Use the corresponding output exposed by the `igx-paginator` component instead\n       *\n       * Emitted after the current page is changed.\n       *\n       *\n       * @example\n       * ```html\n       * <igx-grid (pageChange)=\"onPageChange($event)\"></igx-grid>\n       * ```\n       * ```typescript\n       * public onPageChange(page: number) {\n       *   this.currentPage = page;\n       * }\n       * ```\n       */\n\n      this.pageChange = new EventEmitter();\n      /**\n       * @deprecated in version 12.1.0. Use the corresponding output exposed by the `igx-paginator` component instead\n       *\n       * Emitted when `perPage` property value of the grid is changed.\n       *\n       *\n       * @example\n       * ```html\n       * <igx-grid #grid (perPageChange)=\"onPerPageChange($event)\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       * ```typescript\n       * public onPerPageChange(perPage: number) {\n       *   this.perPage = perPage;\n       * }\n       * ```\n       */\n\n      this.perPageChange = new EventEmitter();\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this.class = '';\n      /**\n       * @deprecated in version 12.2.0. We suggest using `rowClasses` property instead\n       *\n       * Gets/Sets the styling classes applied to all even `IgxGridRowComponent`s in the grid.\n       *\n       *\n       * @example\n       * ```html\n       * <igx-grid #grid [data]=\"Data\" [evenRowCSS]=\"'igx-grid--my-even-class'\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       */\n\n      this.evenRowCSS = 'igx-grid__tr--even';\n      /**\n       * @deprecated in version 12.2.0. We suggest using `rowClasses` property instead\n       *\n       * Gets/Sets the styling classes applied to all odd `IgxGridRowComponent`s in the grid.\n       *\n       *\n       * @example\n       * ```html\n       * <igx-grid #grid [data]=\"Data\" [evenRowCSS]=\"'igx-grid--my-odd-class'\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       */\n\n      this.oddRowCSS = 'igx-grid__tr--odd';\n      /**\n       * Sets conditional style properties on the grid row element.\n       * It accepts an object literal where the keys are\n       * the style properties and the value is an expression to be evaluated.\n       * ```typescript\n       * styles = {\n       *  background: 'yellow',\n       *  color: (row: RowType) => row.selected : 'red': 'white'\n       * }\n       * ```\n       * ```html\n       * <igx-grid #grid [data]=\"Data\" [rowStyles]=\"styles\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       *\n       * @memberof IgxColumnComponent\n       */\n\n      this.rowStyles = null;\n      /**\n       * Emitted when a cell is clicked.\n       *\n       * @remarks\n       * Returns the `IgxGridCell`.\n       * @example\n       * ```html\n       * <igx-grid #grid (cellClick)=\"cellClick($event)\" [data]=\"localData\" [height]=\"'305px'\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       */\n\n      this.cellClick = new EventEmitter();\n      /**\n       * Emitted when a cell is selected.\n       *\n       * @remarks\n       *  Returns the `IgxGridCell`.\n       * @example\n       * ```html\n       * <igx-grid #grid (selected)=\"onCellSelect($event)\" [data]=\"localData\" [height]=\"'305px'\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       */\n\n      this.selected = new EventEmitter();\n      /**\n       *  Emitted when `IgxGridRowComponent` is selected.\n       *\n       * @example\n       * ```html\n       * <igx-grid #grid (rowSelectionChanging)=\"rowSelectionChanging($event)\" [data]=\"localData\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       */\n\n      this.rowSelectionChanging = new EventEmitter();\n      /**\n       *  Emitted when `IgxColumnComponent` is selected.\n       *\n       * @example\n       * ```html\n       * <igx-grid #grid (columnSelectionChanging)=\"columnSelectionChanging($event)\" [data]=\"localData\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       */\n\n      this.columnSelectionChanging = new EventEmitter();\n      /**\n       * Emitted before `IgxColumnComponent` is pinned.\n       *\n       * @remarks\n       * The index at which to insert the column may be changed through the `insertAtIndex` property.\n       * @example\n       * ```typescript\n       * public columnPinning(event) {\n       *     if (event.column.field === \"Name\") {\n       *       event.insertAtIndex = 0;\n       *     }\n       * }\n       * ```\n       */\n\n      this.columnPin = new EventEmitter();\n      /**\n       * Emitted after `IgxColumnComponent` is pinned.\n       *\n       * @remarks\n       * The index that the column is inserted at may be changed through the `insertAtIndex` property.\n       * @example\n       * ```typescript\n       * public columnPinning(event) {\n       *     if (event.column.field === \"Name\") {\n       *       event.insertAtIndex = 0;\n       *     }\n       * }\n       * ```\n       */\n\n      this.columnPinned = new EventEmitter();\n      /**\n       * Emitted when cell enters edit mode.\n       *\n       * @remarks\n       * This event is cancelable.\n       * @example\n       * ```html\n       * <igx-grid #grid3 (cellEditEnter)=\"editStart($event)\" [data]=\"data\" [primaryKey]=\"'ProductID'\">\n       * </igx-grid>\n       * ```\n       */\n\n      this.cellEditEnter = new EventEmitter();\n      /**\n       * Emitted when cell exits edit mode.\n       *\n       * @example\n       * ```html\n       * <igx-grid #grid3 (cellEditExit)=\"editExit($event)\" [data]=\"data\" [primaryKey]=\"'ProductID'\">\n       * </igx-grid>\n       * ```\n       */\n\n      this.cellEditExit = new EventEmitter();\n      /**\n       * Emitted when cell has been edited.\n       *\n       * @remarks\n       * Event is fired after editing is completed, when the cell is exiting edit mode.\n       * This event is cancelable.\n       * @example\n       * ```html\n       * <igx-grid #grid3 (cellEdit)=\"editDone($event)\" [data]=\"data\" [primaryKey]=\"'ProductID'\">\n       * </igx-grid>\n       * ```\n       */\n\n      this.cellEdit = new EventEmitter();\n      /**\n       * Emitted after cell has been edited and editing has been committed.\n       *\n       * @example\n       * ```html\n       * <igx-grid #grid3 (cellEditDone)=\"editDone($event)\" [data]=\"data\" [primaryKey]=\"'ProductID'\">\n       * </igx-grid>\n       * ```\n       */\n\n      this.cellEditDone = new EventEmitter();\n      /**\n       * Emitted when a row enters edit mode.\n       *\n       * @remarks\n       * Emitted when [rowEditable]=\"true\".\n       * This event is cancelable.\n       * @example\n       * ```html\n       * <igx-grid #grid3 (rowEditEnter)=\"editStart($event)\" [primaryKey]=\"'ProductID'\" [rowEditable]=\"true\">\n       * </igx-grid>\n       * ```\n       */\n\n      this.rowEditEnter = new EventEmitter();\n      /**\n       * Emitted when exiting edit mode for a row.\n       *\n       * @remarks\n       * Emitted when [rowEditable]=\"true\" & `endEdit(true)` is called.\n       * Emitted when changing rows during edit mode, selecting an un-editable cell in the edited row,\n       * performing paging operation, column resizing, pinning, moving or hitting `Done`\n       * button inside of the rowEditingOverlay, or hitting the `Enter` key while editing a cell.\n       * This event is cancelable.\n       * @example\n       * ```html\n       * <igx-grid #grid3 (rowEdit)=\"editDone($event)\" [data]=\"data\" [primaryKey]=\"'ProductID'\" [rowEditable]=\"true\">\n       * </igx-grid>\n       * ```\n       */\n\n      this.rowEdit = new EventEmitter();\n      /**\n       * Emitted after exiting edit mode for a row and editing has been committed.\n       *\n       * @remarks\n       * Emitted when [rowEditable]=\"true\" & `endEdit(true)` is called.\n       * Emitted when changing rows during edit mode, selecting an un-editable cell in the edited row,\n       * performing paging operation, column resizing, pinning, moving or hitting `Done`\n       * button inside of the rowEditingOverlay, or hitting the `Enter` key while editing a cell.\n       * @example\n       * ```html\n       * <igx-grid #grid3 (rowEditDone)=\"editDone($event)\" [data]=\"data\" [primaryKey]=\"'ProductID'\" [rowEditable]=\"true\">\n       * </igx-grid>\n       * ```\n       */\n\n      this.rowEditDone = new EventEmitter();\n      /**\n       * Emitted when row editing is canceled.\n       *\n       * @remarks\n       * Emits when [rowEditable]=\"true\" & `endEdit(false)` is called.\n       * Emitted when changing hitting `Esc` key during cell editing and when click on the `Cancel` button\n       * in the row editing overlay.\n       * @example\n       * ```html\n       * <igx-grid #grid3 (rowEditExit)=\"editExit($event)\" [data]=\"data\" [primaryKey]=\"'ProductID'\" [rowEditable]=\"true\">\n       * </igx-grid>\n       * ```\n       */\n\n      this.rowEditExit = new EventEmitter();\n      /**\n       * Emitted when a column is initialized.\n       *\n       * @remarks\n       * Returns the column object.\n       * @example\n       * ```html\n       * <igx-grid #grid [data]=\"localData\" (columnInit)=\"initColumns($event)\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       */\n\n      this.columnInit = new EventEmitter();\n      /**\n       * Emitted before sorting expressions are applied.\n       *\n       * @remarks\n       * Returns an `ISortingEventArgs` object. `sortingExpressions` key holds the sorting expressions.\n       * @example\n       * ```html\n       * <igx-grid #grid [data]=\"localData\" [autoGenerate]=\"true\" (sorting)=\"sorting($event)\"></igx-grid>\n       * ```\n       */\n\n      this.sorting = new EventEmitter();\n      /**\n       * Emitted after sorting is completed.\n       *\n       * @remarks\n       * Returns the sorting expression.\n       * @example\n       * ```html\n       * <igx-grid #grid [data]=\"localData\" [autoGenerate]=\"true\" (sortingDone)=\"sortingDone($event)\"></igx-grid>\n       * ```\n       */\n\n      this.sortingDone = new EventEmitter();\n      /**\n       * Emitted before filtering expressions are applied.\n       *\n       * @remarks\n       * Returns an `IFilteringEventArgs` object. `filteringExpressions` key holds the filtering expressions for the column.\n       * @example\n       * ```html\n       * <igx-grid #grid [data]=\"localData\" [height]=\"'305px'\" [autoGenerate]=\"true\" (filtering)=\"filtering($event)\"></igx-grid>\n       * ```\n       */\n\n      this.filtering = new EventEmitter();\n      /**\n       * Emitted after filtering is performed through the UI.\n       *\n       * @remarks\n       * Returns the filtering expressions tree of the column for which filtering was performed.\n       * @example\n       * ```html\n       * <igx-grid #grid [data]=\"localData\" [height]=\"'305px'\" [autoGenerate]=\"true\" (filteringDone)=\"filteringDone($event)\"></igx-grid>\n       * ```\n       */\n\n      this.filteringDone = new EventEmitter();\n      /**\n       * @deprecated in version 12.1.0. Use the corresponding output exposed by the `igx-paginator` component instead\n       *\n       * Emitted after paging is performed.\n       *\n       *\n       * @remarks\n       * Returns an object consisting of the previous and next pages.\n       * @example\n       * ```html\n       * <igx-grid #grid [data]=\"localData\" [height]=\"'305px'\" [autoGenerate]=\"true\" (pagingDone)=\"pagingDone($event)\"></igx-grid>\n       * ```\n       */\n\n      this.pagingDone = new EventEmitter();\n      /**\n       * Emitted when a row is added.\n       *\n       * @remarks\n       * Returns the data for the new `IgxGridRowComponent` object.\n       * @example\n       * ```html\n       * <igx-grid #grid [data]=\"localData\" (rowAdded)=\"rowAdded($event)\" [height]=\"'305px'\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       */\n\n      this.rowAdded = new EventEmitter();\n      /**\n       * Emitted when a row is deleted.\n       *\n       * @remarks\n       * Returns an `IRowDataEventArgs` object.\n       * @example\n       * ```html\n       * <igx-grid #grid [data]=\"localData\" (rowDeleted)=\"rowDeleted($event)\" [height]=\"'305px'\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       */\n\n      this.rowDeleted = new EventEmitter();\n      /**\n       * Emmited when deleting a row.\n       *\n       * @remarks\n       * This event is cancelable.\n       * Returns an `IGridEditEventArgs` object.\n       * @example\n       * ```html\n       * <igx-grid #grid [data]=\"localData\" (rowDelete)=\"rowDelete($event)\" [height]=\"'305px'\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       */\n\n      this.rowDelete = new EventEmitter();\n      /**\n       * Emmited just before the newly added row is commited.\n       *\n       * @remarks\n       * This event is cancelable.\n       * Returns an `IGridEditEventArgs` object.\n       * @example\n       * ```html\n       * <igx-grid #grid [data]=\"localData\" (rowAdd)=\"rowAdd($event)\" [height]=\"'305px'\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       */\n\n      this.rowAdd = new EventEmitter();\n      /**\n       * Emitted after column is resized.\n       *\n       * @remarks\n       * Returns the `IgxColumnComponent` object's old and new width.\n       * @example\n       * ```html\n       * <igx-grid #grid [data]=\"localData\" (columnResized)=\"resizing($event)\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       */\n\n      this.columnResized = new EventEmitter();\n      /**\n       * Emitted when a cell is right clicked.\n       *\n       * @remarks\n       * Returns the `IgxGridCell` object.\n       * ```html\n       * <igx-grid #grid [data]=\"localData\" (contextMenu)=\"contextMenu($event)\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       */\n\n      this.contextMenu = new EventEmitter();\n      /**\n       * Emitted when a cell is double clicked.\n       *\n       * @remarks\n       * Returns the `IgxGridCell` object.\n       * @example\n       * ```html\n       * <igx-grid #grid [data]=\"localData\" (doubleClick)=\"dblClick($event)\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       */\n\n      this.doubleClick = new EventEmitter();\n      /**\n       * Emitted before column visibility is changed.\n       *\n       * @remarks\n       * Args: { column: any, newValue: boolean }\n       * @example\n       * ```html\n       * <igx-grid (columnVisibilityChanging)=\"visibilityChanging($event)\"></igx-grid>\n       * ```\n       */\n\n      this.columnVisibilityChanging = new EventEmitter();\n      /**\n       * Emitted after column visibility is changed.\n       *\n       * @remarks\n       * Args: { column: IgxColumnComponent, newValue: boolean }\n       * @example\n       * ```html\n       * <igx-grid (columnVisibilityChanged)=\"visibilityChanged($event)\"></igx-grid>\n       * ```\n       */\n\n      this.columnVisibilityChanged = new EventEmitter();\n      /**\n       * Emitted when column moving starts.\n       *\n       * @remarks\n       * Returns the moved `IgxColumnComponent` object.\n       * @example\n       * ```html\n       * <igx-grid (columnMovingStart)=\"movingStart($event)\"></igx-grid>\n       * ```\n       */\n\n      this.columnMovingStart = new EventEmitter();\n      /**\n       * Emitted during the column moving operation.\n       *\n       * @remarks\n       * Returns the source and target `IgxColumnComponent` objects. This event is cancelable.\n       * @example\n       * ```html\n       * <igx-grid (columnMoving)=\"moving($event)\"></igx-grid>\n       * ```\n       */\n\n      this.columnMoving = new EventEmitter();\n      /**\n       * Emitted when column moving ends.\n       *\n       * @remarks\n       * Returns the source and target `IgxColumnComponent` objects.\n       * @example\n       * ```html\n       * <igx-grid (columnMovingEnd)=\"movingEnds($event)\"></igx-grid>\n       * ```\n       */\n\n      this.columnMovingEnd = new EventEmitter();\n      /**\n       * Emitted when keydown is triggered over element inside grid's body.\n       *\n       * @remarks\n       * This event is fired only if the key combination is supported in the grid.\n       * Return the target type, target object and the original event. This event is cancelable.\n       * @example\n       * ```html\n       *  <igx-grid (gridKeydown)=\"customKeydown($event)\"></igx-grid>\n       * ```\n       */\n\n      this.gridKeydown = new EventEmitter();\n      /**\n       * Emitted when start dragging a row.\n       *\n       * @remarks\n       * Return the dragged row.\n       */\n\n      this.rowDragStart = new EventEmitter();\n      /**\n       * Emitted when dropping a row.\n       *\n       * @remarks\n       * Return the dropped row.\n       */\n\n      this.rowDragEnd = new EventEmitter();\n      /**\n       * Emitted when a copy operation is executed.\n       *\n       * @remarks\n       * Fired only if copy behavior is enabled through the [`clipboardOptions`]{@link IgxGridBaseDirective#clipboardOptions}.\n       */\n\n      this.gridCopy = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.expansionStatesChange = new EventEmitter();\n      /**\n       * Emitted when the expanded state of a row gets changed.\n       *\n       * @example\n       * ```html\n       * <igx-grid [data]=\"employeeData\" (rowToggle)=\"rowToggle($event)\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       */\n\n      this.rowToggle = new EventEmitter();\n      /**\n       * Emitted when the pinned state of a row is changed.\n       *\n       * @example\n       * ```html\n       * <igx-grid [data]=\"employeeData\" (rowPinning)=\"rowPin($event)\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       */\n\n      this.rowPinning = new EventEmitter();\n      /**\n       * Emitted when the pinned state of a row is changed.\n       *\n       * @example\n       * ```html\n       * <igx-grid [data]=\"employeeData\" (rowPinned)=\"rowPin($event)\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       */\n\n      this.rowPinned = new EventEmitter();\n      /**\n       * Emmited when the active node is changed.\n       *\n       * @example\n       * ```\n       * <igx-grid [data]=\"data\" [autoGenerate]=\"true\" (activeNodeChange)=\"activeNodeChange($event)\"></igx-grid>\n       * ```\n       */\n\n      this.activeNodeChange = new EventEmitter();\n      /**\n       * Emitted before sorting is performed.\n       *\n       * @remarks\n       * Returns the sorting expressions.\n       * @example\n       * ```html\n       * <igx-grid #grid [data]=\"localData\" [autoGenerate]=\"true\" (sortingExpressionsChange)=\"sortingExprChange($event)\"></igx-grid>\n       * ```\n       */\n\n      this.sortingExpressionsChange = new EventEmitter();\n      /**\n       * Emitted when an export process is initiated by the user.\n       *\n       * @example\n       * ```typescript\n       * toolbarExporting(event: IGridToolbarExportEventArgs){\n       *     const toolbarExporting = event;\n       * }\n       * ```\n       */\n\n      this.toolbarExporting = new EventEmitter();\n      /* End of toolbar related definitions */\n\n      /**\n       * Emitted when making a range selection.\n       *\n       * @remarks\n       * Range selection can be made either through drag selection or through keyboard selection.\n       */\n\n      this.rangeSelected = new EventEmitter();\n      /** Emitted after the ngAfterViewInit hook. At this point the grid exists in the DOM */\n\n      this.rendered = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.localeChange = new EventEmitter();\n      /**\n       * Emitted before the grid's data view is changed because of a data operation, rebinding, etc.\n       *\n       * @example\n       * ```typescript\n       *  <igx-grid #grid [data]=\"localData\" [autoGenerate]=\"true\" (dataChanging)='handleDataChangingEvent()'></igx-grid>\n       * ```\n       */\n\n      this.dataChanging = new EventEmitter();\n      /**\n       * Emitted after the grid's data view is changed because of a data operation, rebinding, etc.\n       *\n       * @example\n       * ```typescript\n       *  <igx-grid #grid [data]=\"localData\" [autoGenerate]=\"true\" (dataChanged)='handleDataChangedEvent()'></igx-grid>\n       * ```\n       */\n\n      this.dataChanged = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.columnList = new QueryList();\n      /**\n       * @hidden @internal\n       */\n\n      this.tmpOutlets = new QueryList();\n      /**\n       * The custom template, if any, that should be used when rendering a row expand indicator.\n       */\n\n      this.rowExpandedIndicatorTemplate = null;\n      /**\n       * The custom template, if any, that should be used when rendering a row collapse indicator.\n       */\n\n      this.rowCollapsedIndicatorTemplate = null;\n      /**\n       * The custom template, if any, that should be used when rendering a header expand indicator.\n       */\n\n      this.headerExpandIndicatorTemplate = null;\n      /**\n       * The custom template, if any, that should be used when rendering a header collapse indicator.\n       */\n\n      this.headerCollapseIndicatorTemplate = null;\n      /**\n       * The custom template, if any, that should be used when rendering a row expand indicator.\n       */\n\n      this.excelStyleHeaderIconTemplate = null;\n      /**\n       * The custom template, if any, that should be used when rendering a header sorting indicator when columns are sorted in asc order.\n       */\n\n      this.sortAscendingHeaderIconTemplate = null;\n      /**\n       * The custom template, if any, that should be used when rendering a header sorting indicator when columns are sorted in desc order.\n       */\n\n      this.sortDescendingHeaderIconTemplate = null;\n      /**\n       * The custom template, if any, that should be used when rendering a header sorting indicator when columns are not sorted.\n       */\n\n      this.sortHeaderIconTemplate = null;\n      /**\n       * @hidden @internal\n       */\n\n      this.tabindex = 0;\n      /**\n       * @hidden @internal\n       */\n\n      this.hostRole = 'grid';\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this.rowDragging = false;\n      /**\n       * Gets the row ID that is being dragged.\n       *\n       * @remarks\n       * The row ID is either the primaryKey value or the data record instance.\n       */\n\n      this.dragRowID = null;\n      /**\n       * @hidden @internal\n       */\n\n      this.snackbarActionText = this.resourceStrings.igx_grid_snackbar_addrow_actiontext;\n      /**\n       * @hidden @internal\n       */\n\n      this.calcHeight = 0;\n      /**\n       * @hidden @internal\n       */\n\n      this.disableTransitions = false;\n      /**\n       * @hidden @internal\n       */\n\n      this.lastSearchInfo = {\n        searchText: '',\n        caseSensitive: false,\n        exactMatch: false,\n        activeMatchIndex: 0,\n        matchInfoCache: []\n      };\n      /**\n       * @hidden @internal\n       */\n\n      this.columnWidthSetByUser = false;\n      /**\n       * @hidden @internal\n       */\n\n      this.rendered$ = this.rendered.asObservable().pipe(shareReplay({\n        bufferSize: 1,\n        refCount: true\n      }));\n      /** @hidden @internal */\n\n      this.resizeNotify = new Subject();\n      /** @hidden @internal */\n\n      this.rowAddedNotifier = new Subject();\n      /** @hidden @internal */\n\n      this.rowDeletedNotifier = new Subject();\n      /** @hidden @internal */\n\n      this.pipeTriggerNotifier = new Subject();\n      /**\n       * @hidden @internal\n       */\n\n      this._destroyed = false;\n      /**\n       * @hidden @internal\n       */\n\n      this._totalRecords = -1;\n      /**\n       * @hidden @internal\n       */\n\n      this.columnsWithNoSetWidths = null;\n      /**\n       * @hidden @internal\n       */\n\n      this.pipeTrigger = 0;\n      /**\n       * @hidden @internal\n       */\n\n      this.filteringPipeTrigger = 0;\n      /**\n       * @hidden @internal\n       */\n\n      this.summaryPipeTrigger = 0;\n      /**\n      * @hidden @internal\n      */\n\n      this.EMPTY_DATA = [];\n      this.isPivot = false;\n      /**\n       * @hidden\n       */\n\n      this.destroy$ = new Subject();\n      /**\n       * @hidden\n       */\n\n      this._perPage = DEFAULT_ITEMS_PER_PAGE;\n      /**\n       * @hidden\n       */\n\n      this._paging = false;\n      /**\n       * @hidden\n       */\n\n      this._pagingMode = GridPagingMode.Local;\n      /**\n       * @hidden\n       */\n\n      this._hideRowSelectors = false;\n      /**\n       * @hidden\n       */\n\n      this._rowDrag = false;\n      /**\n       * @hidden\n       */\n\n      this._columns = [];\n      /**\n       * @hidden\n       */\n\n      this._pinnedColumns = [];\n      /**\n       * @hidden\n       */\n\n      this._unpinnedColumns = [];\n      /**\n       * @hidden\n       */\n\n      this._filteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And);\n      /**\n       * @hidden\n       */\n\n      this._sortingExpressions = [];\n      /**\n       * @hidden\n       */\n\n      this._maxLevelHeaderDepth = null;\n      /**\n       * @hidden\n       */\n\n      this._columnHiding = false;\n      /**\n       * @hidden\n       */\n\n      this._columnPinning = false;\n      this._pinnedRecordIDs = [];\n      this._allowFiltering = false;\n      this._allowAdvancedFiltering = false;\n      this._filterMode = FilterMode.quickFilter;\n      this._defaultTargetRecordNumber = 10;\n      this._expansionStates = new Map();\n      this._defaultExpandState = false;\n      this._headerFeaturesWidth = NaN;\n      this._init = true;\n      this._cdrRequestRepaint = false;\n      this._batchEditing = false;\n      this._filterStrategy = new FilteringStrategy();\n      this._autoGeneratedCols = [];\n      this._dataView = [];\n      this._rowEditable = false;\n      this._filteredSortedData = null;\n      this._cdrRequests = false;\n      this._emptyGridMessage = null;\n      this._emptyFilteredGridMessage = null;\n      this._isLoading = false;\n      this.overlayIDs = [];\n      this._pinning = {\n        columns: ColumnPinningPosition.Start\n      };\n      this._advancedFilteringPositionSettings = {\n        verticalDirection: VerticalAlignment.Middle,\n        horizontalDirection: HorizontalAlignment.Center,\n        horizontalStartPoint: HorizontalAlignment.Center,\n        verticalStartPoint: VerticalAlignment.Middle\n      };\n      this._advancedFilteringOverlaySettings = {\n        closeOnOutsideClick: false,\n        modal: false,\n        positionStrategy: new ConnectedPositioningStrategy(this._advancedFilteringPositionSettings)\n      };\n      this._height = '100%';\n      this._width = '100%';\n      this._horizontalForOfs = [];\n      this._multiRowLayoutRowSize = 1; // Caches\n\n      this._totalWidth = NaN;\n      this._pinnedVisible = [];\n      this._unpinnedVisible = [];\n      this._pinnedWidth = NaN;\n      this._unpinnedWidth = NaN;\n      this._visibleColumns = [];\n      this._columnGroups = false;\n      this._summaryPosition = GridSummaryPosition.bottom;\n      this._summaryCalculationMode = GridSummaryCalculationMode.rootAndChildLevels;\n      this._showSummaryOnCollapse = false;\n      this._summaryRowHeight = 0;\n      this._cellSelectionMode = GridSelectionMode.multiple;\n      this._rowSelectionMode = GridSelectionMode.none;\n      this._selectRowOnClick = true;\n      this._columnSelectionMode = GridSelectionMode.none;\n      this.rowEditPositioningStrategy = new RowEditPositionStrategy({\n        horizontalDirection: HorizontalAlignment.Right,\n        verticalDirection: VerticalAlignment.Bottom,\n        horizontalStartPoint: HorizontalAlignment.Left,\n        verticalStartPoint: VerticalAlignment.Bottom,\n        closeAnimation: null\n      });\n      this.rowEditSettings = {\n        scrollStrategy: new AbsoluteScrollStrategy(),\n        modal: false,\n        closeOnOutsideClick: false,\n        outlet: this.rowOutletDirective,\n        positionStrategy: this.rowEditPositioningStrategy\n      };\n      this.transactionChange$ = new Subject();\n      this._rendered = false;\n      this.DRAG_SCROLL_DELTA = 10;\n      this._dataCloneStrategy = new DefaultDataCloneStrategy();\n      /**\n       * @hidden @internal\n       */\n\n      this.preventContainerScroll = evt => {\n        if (evt.target.scrollTop !== 0) {\n          this.verticalScrollContainer.addScrollTop(evt.target.scrollTop);\n          evt.target.scrollTop = 0;\n        }\n\n        if (evt.target.scrollLeft !== 0) {\n          this.headerContainer.scrollPosition += evt.target.scrollLeft;\n          evt.target.scrollLeft = 0;\n        }\n      };\n\n      this.locale = this.locale || this.localeId;\n      this._transactions = this.transactionFactory.create(\"None\"\n      /* None */\n      );\n      this._transactions.cloneStrategy = this.dataCloneStrategy;\n      this.cdr.detach();\n    }\n    /**\n     * Get/Set IgxSummaryRow height\n     */\n\n\n    set summaryRowHeight(value) {\n      this._summaryRowHeight = value | 0;\n      this.summaryService.summaryHeight = value;\n\n      if (!this._init) {\n        this.reflow();\n      }\n    }\n\n    get summaryRowHeight() {\n      if (this.hasSummarizedColumns && this.rootSummariesEnabled) {\n        return this._summaryRowHeight || this.summaryService.calcMaxSummaryHeight();\n      }\n\n      return 0;\n    }\n    /**\n     * Gets/Sets the data clone strategy of the grid when in edit mode.\n     *\n     * @example\n     * ```html\n     *  <igx-grid #grid [data]=\"localData\" [dataCloneStrategy]=\"customCloneStrategy\"></igx-grid>\n     * ```\n     */\n\n\n    get dataCloneStrategy() {\n      return this._dataCloneStrategy;\n    }\n\n    set dataCloneStrategy(strategy) {\n      if (strategy) {\n        this._dataCloneStrategy = strategy;\n        this._transactions.cloneStrategy = strategy;\n      }\n    }\n    /** @hidden @internal */\n\n\n    get excelStyleFilteringComponent() {\n      var _a;\n\n      return (_a = this.excelStyleFilteringComponents) === null || _a === void 0 ? void 0 : _a.first;\n    }\n\n    get headerGroups() {\n      return this.theadRow.groups;\n    }\n\n    get headerContainer() {\n      var _a;\n\n      return (_a = this.theadRow) === null || _a === void 0 ? void 0 : _a.headerForOf;\n    }\n\n    get headerSelectorContainer() {\n      var _a;\n\n      return (_a = this.theadRow) === null || _a === void 0 ? void 0 : _a.headerSelectorContainer;\n    }\n\n    get headerDragContainer() {\n      var _a;\n\n      return (_a = this.theadRow) === null || _a === void 0 ? void 0 : _a.headerDragContainer;\n    }\n\n    get headerGroupContainer() {\n      var _a;\n\n      return (_a = this.theadRow) === null || _a === void 0 ? void 0 : _a.headerGroupContainer;\n    }\n\n    get filteringRow() {\n      var _a;\n\n      return (_a = this.theadRow) === null || _a === void 0 ? void 0 : _a.filterRow;\n    }\n    /**\n     * Gets/Sets the resource strings.\n     *\n     * @remarks\n     * By default it uses EN resources.\n     */\n\n\n    set resourceStrings(value) {\n      this._resourceStrings = Object.assign({}, this._resourceStrings, value);\n    }\n\n    get resourceStrings() {\n      if (!this._resourceStrings) {\n        this._resourceStrings = CurrentResourceStrings.GridResStrings;\n      }\n\n      return this._resourceStrings;\n    }\n    /**\n     * Gets/Sets the filtering logic of the `IgxGridComponent`.\n     *\n     * @remarks\n     * The default is AND.\n     * @example\n     * ```html\n     * <igx-grid [data]=\"Data\" [autoGenerate]=\"true\" [filteringLogic]=\"filtering\"></igx-grid>\n     * ```\n     */\n\n\n    get filteringLogic() {\n      return this._filteringExpressionsTree.operator;\n    }\n\n    set filteringLogic(value) {\n      this._filteringExpressionsTree.operator = value;\n    }\n    /**\n     * Gets/Sets the filtering state.\n     *\n     * @example\n     * ```html\n     * <igx-grid #grid [data]=\"Data\" [autoGenerate]=\"true\" [(filteringExpressionsTree)]=\"model.filteringExpressions\"></igx-grid>\n     * ```\n     * @remarks\n     * Supports two-way binding.\n     */\n\n\n    get filteringExpressionsTree() {\n      return this._filteringExpressionsTree;\n    }\n\n    set filteringExpressionsTree(value) {\n      if (value && value instanceof FilteringExpressionsTree) {\n        const val = value;\n\n        for (let index = 0; index < val.filteringOperands.length; index++) {\n          if (!(val.filteringOperands[index] instanceof FilteringExpressionsTree)) {\n            const newExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And, val.filteringOperands[index].fieldName);\n            newExpressionsTree.filteringOperands.push(val.filteringOperands[index]);\n            val.filteringOperands[index] = newExpressionsTree;\n          }\n        }\n\n        value.type = FilteringExpressionsTreeType.Regular;\n        this._filteringExpressionsTree = value;\n        this.filteringPipeTrigger++;\n        this.filteringExpressionsTreeChange.emit(this._filteringExpressionsTree);\n\n        if (this.filteringService.isFilteringExpressionsTreeEmpty(this._filteringExpressionsTree) && this.filteringService.isFilteringExpressionsTreeEmpty(this._advancedFilteringExpressionsTree)) {\n          this.filteredData = null;\n        }\n\n        this.filteringService.refreshExpressions();\n        this.selectionService.clearHeaderCBState();\n        this.summaryService.clearSummaryCache();\n        this.notifyChanges();\n      }\n    }\n    /**\n     * Gets/Sets the advanced filtering state.\n     *\n     * @example\n     * ```typescript\n     * let advancedFilteringExpressionsTree = this.grid.advancedFilteringExpressionsTree;\n     * this.grid.advancedFilteringExpressionsTree = logic;\n     * ```\n     */\n\n\n    get advancedFilteringExpressionsTree() {\n      return this._advancedFilteringExpressionsTree;\n    }\n\n    set advancedFilteringExpressionsTree(value) {\n      if (value && value instanceof FilteringExpressionsTree) {\n        value.type = FilteringExpressionsTreeType.Advanced;\n        this._advancedFilteringExpressionsTree = value;\n        this.filteringPipeTrigger++;\n      } else {\n        this._advancedFilteringExpressionsTree = null;\n      }\n\n      this.advancedFilteringExpressionsTreeChange.emit(this._advancedFilteringExpressionsTree);\n\n      if (this.filteringService.isFilteringExpressionsTreeEmpty(this._filteringExpressionsTree) && this.filteringService.isFilteringExpressionsTreeEmpty(this._advancedFilteringExpressionsTree)) {\n        this.filteredData = null;\n      }\n\n      this.selectionService.clearHeaderCBState();\n      this.summaryService.clearSummaryCache();\n      this.notifyChanges(); // Wait for the change detection to update filtered data through the pipes and then emit the event.\n\n      requestAnimationFrame(() => this.filteringDone.emit(this._advancedFilteringExpressionsTree));\n    }\n    /**\n     * Gets/Sets the locale.\n     *\n     * @remarks\n     * If not set, returns browser's language.\n     */\n\n\n    get locale() {\n      return this._locale;\n    }\n\n    set locale(value) {\n      if (value !== this._locale) {\n        this._locale = value;\n        this._currencyPositionLeft = undefined;\n        this.summaryService.clearSummaryCache();\n        this.pipeTrigger++;\n        this.notifyChanges();\n        this.localeChange.next();\n      }\n    }\n\n    get pagingMode() {\n      return this._pagingMode;\n    }\n\n    set pagingMode(val) {\n      this._pagingMode = val;\n      this.pipeTrigger++;\n      this.notifyChanges(true);\n    }\n    /**\n     * @deprecated in version 12.1.0. Use the corresponding method exposed by the `igx-paginator`\n     *\n     * Gets/Sets whether the paging feature is enabled.\n     *\n     *\n     * @remarks\n     * The default state is disabled (false).\n     * @example\n     * ```html\n     * <igx-grid #grid [data]=\"Data\" [autoGenerate]=\"true\">\n     *  <igx-paginator></igx-paginator>\n     * </igx-grid>\n     * ```\n     */\n\n\n    get paging() {\n      return this._paging;\n    }\n\n    set paging(value) {\n      this._paging = value;\n      this.pipeTrigger++;\n    }\n    /**\n     * @deprecated in version 12.1.0. Use `page` property form `paginator` component instead\n     *\n     * Gets/Sets the current page index.\n     *\n     *\n     * @example\n     * ```html\n     * <igx-grid #grid [data]=\"Data\" [autoGenerate]=\"true\">\n     *  <igx-paginator [(page)]=\"model.page\"></igx-paginator>\n     * </igx-grid>\n     * ```\n     * @remarks\n     * Supports two-way binding.\n     */\n\n\n    get page() {\n      var _a;\n\n      return ((_a = this.paginator) === null || _a === void 0 ? void 0 : _a.page) || 0;\n    }\n\n    set page(val) {\n      if (this.paginator) {\n        this.paginator.page = val;\n      }\n    }\n    /**\n     * @deprecated in version 12.1.0. Use `perPage` property from `paginator` component instead\n     *\n     * Gets/Sets the number of visible items per page.\n     *\n     *\n     * @remarks\n     * The default is 15.\n     * @example\n     * ```html\n     * <igx-grid #grid [data]=\"Data\" [autoGenerate]=\"true\">\n     *  <igx-paginator [(perPage)]=\"model.perPage\"></igx-paginator>\n     * </igx-grid>\n     * ```\n     */\n\n\n    get perPage() {\n      var _a;\n\n      return ((_a = this.paginator) === null || _a === void 0 ? void 0 : _a.perPage) || DEFAULT_ITEMS_PER_PAGE;\n    }\n\n    set perPage(val) {\n      this._perPage = val;\n\n      if (this.paginator) {\n        this.paginator.perPage = val;\n      }\n    }\n    /**\n     * Gets/Sets if the row selectors are hidden.\n     *\n     * @remarks\n     *  By default row selectors are shown\n     */\n\n\n    get hideRowSelectors() {\n      return this._hideRowSelectors;\n    }\n\n    set hideRowSelectors(value) {\n      this._hideRowSelectors = value;\n      this.notifyChanges(true);\n    }\n    /**\n     * Gets/Sets whether rows can be moved.\n     *\n     * @example\n     * ```html\n     * <igx-grid #grid [rowDraggable]=\"true\"></igx-grid>\n     * ```\n     */\n\n\n    get rowDraggable() {\n      return this._rowDrag && this.hasVisibleColumns;\n    }\n\n    set rowDraggable(val) {\n      this._rowDrag = val;\n      this.notifyChanges(true);\n    }\n    /**\n     * Gets/Sets whether the rows are editable.\n     *\n     * @remarks\n     * By default it is set to false.\n     * @example\n     * ```html\n     * <igx-grid #grid [rowEditable]=\"true\" [primaryKey]=\"'ProductID'\" ></igx-grid>\n     * ```\n     */\n\n\n    get rowEditable() {\n      return this._rowEditable;\n    }\n\n    set rowEditable(val) {\n      if (!this._init) {\n        this.refreshGridState();\n      }\n\n      this._rowEditable = val;\n      this.notifyChanges();\n    }\n    /**\n     * Gets/Sets the height.\n     *\n     * @example\n     * ```html\n     * <igx-grid #grid [data]=\"Data\" [height]=\"'305px'\" [autoGenerate]=\"true\"></igx-grid>\n     * ```\n     */\n\n\n    get height() {\n      return this._height;\n    }\n\n    set height(value) {\n      if (this._height !== value) {\n        this._height = value;\n        this.nativeElement.style.height = value;\n        this.notifyChanges(true);\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get hostWidth() {\n      return this._width || this._hostWidth;\n    }\n    /**\n     * Gets/Sets the width of the grid.\n     *\n     * @example\n     * ```typescript\n     * let gridWidth = this.grid.width;\n     * ```\n     */\n\n\n    get width() {\n      return this._width;\n    }\n\n    set width(value) {\n      if (this._width !== value) {\n        this._width = value;\n        this.nativeElement.style.width = value;\n        this.notifyChanges(true);\n      }\n    }\n    /**\n     * Gets the width of the header.\n     *\n     * @example\n     * ```html\n     * let gridHeaderWidth = this.grid.headerWidth;\n     * ```\n     */\n\n\n    get headerWidth() {\n      return parseInt(this.width, 10) - 17;\n    }\n    /**\n     * Gets/Sets the row height.\n     *\n     * @example\n     * ```html\n     * <igx-grid #grid [data]=\"localData\" [rowHeight]=\"100\" [autoGenerate]=\"true\"></igx-grid>\n     * ```\n     */\n\n\n    get rowHeight() {\n      return this._rowHeight ? this._rowHeight : this.defaultRowHeight;\n    }\n\n    set rowHeight(value) {\n      this._rowHeight = parseInt(value, 10);\n    }\n    /**\n     * Gets/Sets the default width of the columns.\n     *\n     * @example\n     * ```html\n     * <igx-grid #grid [data]=\"localData\" [columnWidth]=\"100\" [autoGenerate]=\"true\"></igx-grid>\n     * ```\n     */\n\n\n    get columnWidth() {\n      return this._columnWidth;\n    }\n\n    set columnWidth(value) {\n      this._columnWidth = value;\n      this.columnWidthSetByUser = true;\n      this.notifyChanges(true);\n    }\n    /**\n     * Get/Sets the message displayed when there are no records.\n     *\n     * @example\n     * ```html\n     * <igx-grid #grid [data]=\"Data\" [emptyGridMessage]=\"'The grid is empty'\" [autoGenerate]=\"true\"></igx-grid>\n     * ```\n     */\n\n\n    set emptyGridMessage(value) {\n      this._emptyGridMessage = value;\n    }\n\n    get emptyGridMessage() {\n      return this._emptyGridMessage || this.resourceStrings.igx_grid_emptyGrid_message;\n    }\n    /**\n     * Gets/Sets whether the grid is going to show a loading indicator.\n     *\n     * @example\n     * ```html\n     * <igx-grid #grid [data]=\"Data\" [isLoading]=\"true\" [autoGenerate]=\"true\"></igx-grid>\n     * ```\n     */\n\n\n    set isLoading(value) {\n      if (this._isLoading !== value) {\n        this._isLoading = value;\n\n        if (!!this.data) {\n          this.evaluateLoadingState();\n        }\n      }\n\n      Promise.resolve().then(() => {\n        // wait for the current detection cycle to end before triggering a new one.\n        this.notifyChanges();\n      });\n    }\n\n    get isLoading() {\n      return this._isLoading;\n    }\n    /**\n     * Gets/Sets the message displayed when there are no records and the grid is filtered.\n     *\n     * @example\n     * ```html\n     * <igx-grid #grid [data]=\"Data\" [emptyGridMessage]=\"'The grid is empty'\" [autoGenerate]=\"true\"></igx-grid>\n     * ```\n     */\n\n\n    set emptyFilteredGridMessage(value) {\n      this._emptyFilteredGridMessage = value;\n    }\n\n    get emptyFilteredGridMessage() {\n      return this._emptyFilteredGridMessage || this.resourceStrings.igx_grid_emptyFilteredGrid_message;\n    }\n    /**\n     * Gets/Sets the initial pinning configuration.\n     *\n     * @remarks\n     * Allows to apply pinning the columns to the start or the end.\n     * Note that pinning to both sides at a time is not allowed.\n     * @example\n     * ```html\n     * <igx-grid [pinning]=\"pinningConfig\"></igx-grid>\n     * ```\n     */\n\n\n    get pinning() {\n      return this._pinning;\n    }\n\n    set pinning(value) {\n      if (value !== this._pinning) {\n        this.resetCaches();\n      }\n\n      this._pinning = value;\n    }\n    /**\n     * Gets/Sets if the filtering is enabled.\n     *\n     * @example\n     * ```html\n     * <igx-grid #grid [data]=\"localData\" [allowFiltering]=\"true\" [height]=\"'305px'\" [autoGenerate]=\"true\"></igx-grid>\n     * ```\n     */\n\n\n    get allowFiltering() {\n      return this._allowFiltering;\n    }\n\n    set allowFiltering(value) {\n      if (this._allowFiltering !== value) {\n        this._allowFiltering = value;\n        this.filteringService.registerSVGIcons();\n\n        if (!this._init) {\n          this.calcGridHeadRow();\n        }\n\n        this.filteringService.isFilterRowVisible = false;\n        this.filteringService.filteredColumn = null;\n        this.notifyChanges(true);\n      }\n    }\n    /**\n     * Gets/Sets a value indicating whether the advanced filtering is enabled.\n     *\n     * @example\n     * ```html\n     * <igx-grid #grid [data]=\"localData\" [allowAdvancedFiltering]=\"true\" [autoGenerate]=\"true\"></igx-grid>\n     * ```\n     */\n\n\n    get allowAdvancedFiltering() {\n      return this._allowAdvancedFiltering;\n    }\n\n    set allowAdvancedFiltering(value) {\n      if (this._allowAdvancedFiltering !== value) {\n        this._allowAdvancedFiltering = value;\n        this.filteringService.registerSVGIcons();\n\n        if (!this._init) {\n          this.notifyChanges(true);\n        }\n      }\n    }\n    /**\n     * Gets/Sets the filter mode.\n     *\n     * @example\n     * ```html\n     * <igx-grid #grid [data]=\"localData\" [filterMode]=\"'quickFilter'\" [height]=\"'305px'\" [autoGenerate]=\"true\"></igx-grid>\n     * ```\n     * @remarks\n     * By default it's set to FilterMode.quickFilter.\n     */\n\n\n    get filterMode() {\n      return this._filterMode;\n    }\n\n    set filterMode(value) {\n      this._filterMode = value;\n\n      if (this.filteringService.isFilterRowVisible) {\n        this.filteringRow.close();\n      }\n\n      this.notifyChanges(true);\n    }\n    /**\n     * Gets/Sets the summary position.\n     *\n     * @example\n     * ```html\n     * <igx-grid #grid [data]=\"localData\" summaryPosition=\"top\" [autoGenerate]=\"true\"></igx-grid>\n     * ```\n     * @remarks\n     * By default it is bottom.\n     */\n\n\n    get summaryPosition() {\n      return this._summaryPosition;\n    }\n\n    set summaryPosition(value) {\n      this._summaryPosition = value;\n      this.notifyChanges();\n    }\n    /**\n     * Gets/Sets the summary calculation mode.\n     *\n     * @example\n     * ```html\n     * <igx-grid #grid [data]=\"localData\" summaryCalculationMode=\"rootLevelOnly\" [autoGenerate]=\"true\"></igx-grid>\n     * ```\n     * @remarks\n     * By default it is rootAndChildLevels which means the summaries are calculated for the root level and each child level.\n     */\n\n\n    get summaryCalculationMode() {\n      return this._summaryCalculationMode;\n    }\n\n    set summaryCalculationMode(value) {\n      this._summaryCalculationMode = value;\n\n      if (!this._init) {\n        this.crudService.endEdit(false);\n        this.summaryService.resetSummaryHeight();\n        this.notifyChanges(true);\n      }\n    }\n    /**\n     * Controls whether the summary row is visible when groupBy/parent row is collapsed.\n     *\n     * @example\n     * ```html\n     * <igx-grid #grid [data]=\"localData\" [showSummaryOnCollapse]=\"true\" [autoGenerate]=\"true\"></igx-grid>\n     * ```\n     * @remarks\n     * By default showSummaryOnCollapse is set to 'false' which means that the summary row is not visible\n     * when the groupBy/parent row is collapsed.\n     */\n\n\n    get showSummaryOnCollapse() {\n      return this._showSummaryOnCollapse;\n    }\n\n    set showSummaryOnCollapse(value) {\n      this._showSummaryOnCollapse = value;\n      this.notifyChanges();\n    }\n    /**\n     * Gets/Sets the filtering strategy of the grid.\n     *\n     * @example\n     * ```html\n     *  <igx-grid #grid [data]=\"localData\" [filterStrategy]=\"filterStrategy\"></igx-grid>\n     * ```\n     */\n\n\n    get filterStrategy() {\n      return this._filterStrategy;\n    }\n\n    set filterStrategy(classRef) {\n      this._filterStrategy = classRef;\n    }\n    /**\n     * Gets/Sets the sorting strategy of the grid.\n     *\n     * @example\n     * ```html\n     *  <igx-grid #grid [data]=\"localData\" [sortStrategy]=\"sortStrategy\"></igx-grid>\n     * ```\n     */\n\n\n    get sortStrategy() {\n      return this._sortingStrategy;\n    }\n\n    set sortStrategy(value) {\n      this._sortingStrategy = value;\n    }\n    /**\n     * Gets/Sets the current selection state.\n     *\n     * @remarks\n     * Represents the selected rows' IDs (primary key or rowData)\n     * @example\n     * ```html\n     * <igx-grid [data]=\"localData\" primaryKey=\"ID\" rowSelection=\"multiple\" [selectedRows]=\"[0, 1, 2]\"><igx-grid>\n     * ```\n     */\n\n\n    set selectedRows(rowIDs) {\n      this.selectRows(rowIDs || [], true);\n    }\n\n    get selectedRows() {\n      return this.selectionService.getSelectedRows();\n    }\n    /**\n     * A list of all `IgxGridHeaderGroupComponent`.\n     *\n     * @example\n     * ```typescript\n     * const headerGroupsList = this.grid.headerGroupsList;\n     * ```\n     */\n\n\n    get headerGroupsList() {\n      return this.theadRow.groups;\n    }\n    /**\n     * A list of all `IgxGridHeaderComponent`.\n     *\n     * @example\n     * ```typescript\n     * const headers = this.grid.headerCellList;\n     * ```\n     */\n\n\n    get headerCellList() {\n      return this.headerGroupsList.map(headerGroup => headerGroup.header).filter(header => header);\n    }\n    /**\n     * A list of all `IgxGridFilteringCellComponent`.\n     *\n     * @example\n     * ```typescript\n     * const filterCells = this.grid.filterCellList;\n     * ```\n     */\n\n\n    get filterCellList() {\n      return this.headerGroupsList.map(group => group.filter).filter(cell => cell);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get summariesRowList() {\n      const res = new QueryList();\n\n      if (!this._summaryRowList) {\n        return res;\n      }\n\n      const sumList = this._summaryRowList.filter(item => item.element.nativeElement.parentElement !== null);\n\n      res.reset(sumList);\n      return res;\n    }\n    /**\n     * A list of `IgxGridRowComponent`.\n     *\n     * @example\n     * ```typescript\n     * const rowList = this.grid.rowList;\n     * ```\n     */\n\n\n    get rowList() {\n      const res = new QueryList();\n\n      if (!this._rowList) {\n        return res;\n      }\n\n      const rList = this._rowList.filter(item => item.element.nativeElement.parentElement !== null).sort((a, b) => a.index - b.index);\n\n      res.reset(rList);\n      return res;\n    }\n    /**\n     * A list of currently rendered `IgxGridRowComponent`'s.\n     *\n     * @example\n     * ```typescript\n     * const dataList = this.grid.dataRowList;\n     * ```\n     */\n\n\n    get dataRowList() {\n      const res = new QueryList();\n\n      if (!this._dataRowList) {\n        return res;\n      }\n\n      const rList = this._dataRowList.filter(item => item.element.nativeElement.parentElement !== null).sort((a, b) => a.index - b.index);\n\n      res.reset(rList);\n      return res;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get headSelectorTemplate() {\n      if (this.headSelectorsTemplates && this.headSelectorsTemplates.first) {\n        return this.headSelectorsTemplates.first.templateRef;\n      }\n\n      return null;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get isPinningToStart() {\n      return this.pinning.columns !== ColumnPinningPosition.End;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get isRowPinningToTop() {\n      return this.pinning.rows !== RowPinningPosition.Bottom;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get rowSelectorTemplate() {\n      if (this.rowSelectorsTemplates && this.rowSelectorsTemplates.first) {\n        return this.rowSelectorsTemplates.first.templateRef;\n      }\n\n      return null;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get rowOutletDirective() {\n      return this.rowEditingOutletDirective;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get parentRowOutletDirective() {\n      return this.outlet;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get rowEditCustom() {\n      if (this.rowEditCustomDirectives && this.rowEditCustomDirectives.first) {\n        return this.rowEditCustomDirectives.first;\n      }\n\n      return null;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get rowEditText() {\n      if (this.rowEditTextDirectives && this.rowEditTextDirectives.first) {\n        return this.rowEditTextDirectives.first;\n      }\n\n      return null;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get rowEditActions() {\n      if (this.rowEditActionsDirectives && this.rowEditActionsDirectives.first) {\n        return this.rowEditActionsDirectives.first;\n      }\n\n      return null;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get rowEditContainer() {\n      return this.rowEditCustom ? this.rowEditCustom : this.defaultRowEditTemplate;\n    }\n    /**\n     * The custom template, if any, that should be used when rendering the row drag indicator icon\n     */\n\n\n    get dragIndicatorIconTemplate() {\n      return this._customDragIndicatorIconTemplate || this.dragIndicatorIconTemplates.first;\n    }\n\n    set dragIndicatorIconTemplate(val) {\n      this._customDragIndicatorIconTemplate = val;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get firstEditableColumnIndex() {\n      const index = this.visibleColumns.filter(col => col.editable).map(c => c.visibleIndex).sort((a, b) => a - b);\n      return index.length ? index[0] : null;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get lastEditableColumnIndex() {\n      const index = this.visibleColumns.filter(col => col.editable).map(c => c.visibleIndex).sort((a, b) => a > b ? -1 : 1);\n      return index.length ? index[0] : null;\n    }\n    /**\n     * @hidden @internal\n     * TODO: Nav service logic doesn't handle 0 results from this querylist\n     */\n\n\n    get rowEditTabs() {\n      return this.rowEditTabsCUSTOM.length ? this.rowEditTabsCUSTOM : this.rowEditTabsDEFAULT;\n    }\n\n    get activeDescendant() {\n      const activeElem = this.navigation.activeNode;\n\n      if (!activeElem || !Object.keys(activeElem).length) {\n        return this.id;\n      }\n\n      return activeElem.row < 0 ? `${this.id}_${activeElem.row}_${activeElem.mchCache.level}_${activeElem.column}` : `${this.id}_${activeElem.row}_${activeElem.column}`;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get hostClass() {\n      const classes = [this.getComponentDensityClass('igx-grid')]; // The custom classes should be at the end.\n\n      classes.push(this.class);\n      return classes.join(' ');\n    }\n\n    get bannerClass() {\n      const position = this.rowEditPositioningStrategy.isTop ? 'igx-banner__border-top' : 'igx-banner__border-bottom';\n      return `${this.getComponentDensityClass('igx-banner')} ${position}`;\n    }\n    /**\n     * Gets/Sets the sorting state.\n     *\n     * @remarks\n     * Supports two-way data binding.\n     * @example\n     * ```html\n     * <igx-grid #grid [data]=\"Data\" [autoGenerate]=\"true\" [(sortingExpressions)]=\"model.sortingExpressions\"></igx-grid>\n     * ```\n     */\n\n\n    get sortingExpressions() {\n      return this._sortingExpressions;\n    }\n\n    set sortingExpressions(value) {\n      this._sortingExpressions = cloneArray(value);\n      this.sortingExpressionsChange.emit(this._sortingExpressions);\n      this.notifyChanges();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get maxLevelHeaderDepth() {\n      if (this._maxLevelHeaderDepth === null) {\n        this._maxLevelHeaderDepth = this.hasColumnLayouts ? this.columnList.reduce((acc, col) => Math.max(acc, col.rowStart), 0) : this.columnList.reduce((acc, col) => Math.max(acc, col.level), 0);\n      }\n\n      return this._maxLevelHeaderDepth;\n    }\n    /**\n     * Gets the number of hidden columns.\n     *\n     * @example\n     * ```typescript\n     * const hiddenCol = this.grid.hiddenColumnsCount;\n     * ``\n     */\n\n\n    get hiddenColumnsCount() {\n      return this.columnList.filter(col => col.columnGroup === false && col.hidden === true).length;\n    }\n    /**\n     * Gets the number of pinned columns.\n     */\n\n\n    get pinnedColumnsCount() {\n      return this.pinnedColumns.filter(col => !col.columnLayout).length;\n    }\n    /**\n     * Gets/Sets whether the grid has batch editing enabled.\n     * When batch editing is enabled, changes are not made directly to the underlying data.\n     * Instead, they are stored as transactions, which can later be committed w/ the `commit` method.\n     *\n     * @example\n     * ```html\n     * <igx-grid [batchEditing]=\"true\" [data]=\"someData\">\n     * </igx-grid>\n     * ```\n     */\n\n\n    get batchEditing() {\n      return this._batchEditing;\n    }\n\n    set batchEditing(val) {\n      if (val !== this._batchEditing) {\n        delete this._transactions;\n        this._batchEditing = val;\n        this.switchTransactionService(val);\n        this.subscribeToTransactions();\n      }\n    }\n    /**\n     * Get transactions service for the grid.\n     */\n\n\n    get transactions() {\n      if (this._diTransactions && !this.batchEditing) {\n        return this._diTransactions;\n      }\n\n      return this._transactions;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get currentRowState() {\n      return this._currentRowState;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get currencyPositionLeft() {\n      if (this._currencyPositionLeft !== undefined) {\n        return this._currencyPositionLeft;\n      }\n\n      const format = getLocaleNumberFormat(this.locale, NumberFormatStyle.Currency);\n      const formatParts = format.split(',');\n      const i = formatParts.indexOf(formatParts.find(c => c.includes('¤')));\n      return this._currencyPositionLeft = i < 1;\n    }\n    /**\n     * Gets/Sets cell selection mode.\n     *\n     * @remarks\n     * By default the cell selection mode is multiple\n     * @param selectionMode: GridSelectionMode\n     */\n\n\n    get cellSelection() {\n      return this._cellSelectionMode;\n    }\n\n    set cellSelection(selectionMode) {\n      this._cellSelectionMode = selectionMode; // if (this.gridAPI.grid) {\n\n      this.selectionService.clear(true);\n      this.notifyChanges(); // }\n    }\n    /**\n     * Gets/Sets row selection mode\n     *\n     * @remarks\n     * By default the row selection mode is 'none'\n     * Note that in IgxGrid and IgxHierarchicalGrid 'multipleCascade' behaves like 'multiple'\n     */\n\n\n    get rowSelection() {\n      return this._rowSelectionMode;\n    }\n\n    set rowSelection(selectionMode) {\n      this._rowSelectionMode = selectionMode;\n\n      if (!this._init) {\n        this.selectionService.clearAllSelectedRows();\n        this.notifyChanges(true);\n      }\n    }\n    /**\n     * Gets/Sets column selection mode\n     *\n     * @remarks\n     * By default the row selection mode is none\n     * @param selectionMode: GridSelectionMode\n     */\n\n\n    get columnSelection() {\n      return this._columnSelectionMode;\n    }\n\n    set columnSelection(selectionMode) {\n      this._columnSelectionMode = selectionMode; // if (this.gridAPI.grid) {\n\n      this.selectionService.clearAllSelectedColumns();\n      this.notifyChanges(true); // }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    set pagingState(value) {\n      this._pagingState = value;\n\n      if (this.paginator && !this._init) {\n        this.paginator.totalRecords = value.metadata.countRecords;\n      }\n    }\n\n    get pagingState() {\n      return this._pagingState;\n    }\n    /** @hidden @internal */\n\n\n    get paginator() {\n      var _a;\n\n      return (_a = this.paginationComponents) === null || _a === void 0 ? void 0 : _a.first;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get scrollSize() {\n      return this.verticalScrollContainer.getScrollNativeSize();\n    }\n    /**\n     * Returns an array containing the filtered sorted data.\n     *\n     * @example\n     * ```typescript\n     * const filteredSortedData = this.grid1.filteredSortedData;\n     * ```\n     */\n\n\n    get filteredSortedData() {\n      return this._filteredSortedData;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get rowChangesCount() {\n      if (!this.crudService.row) {\n        return 0;\n      }\n\n      const f = obj => {\n        let changes = 0;\n        Object.keys(obj).forEach(key => isObject(obj[key]) ? changes += f(obj[key]) : changes++);\n        return changes;\n      };\n\n      const rowChanges = this.transactions.getAggregatedValue(this.crudService.row.id, false);\n      return rowChanges ? f(rowChanges) : 0;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get dataWithAddedInTransactionRows() {\n      const result = cloneArray(this.gridAPI.get_all_data());\n\n      if (this.transactions.enabled) {\n        result.push(...this.transactions.getAggregatedChanges(true).filter(t => t.type === TransactionType.ADD).map(t => t.newValue));\n      }\n\n      if (this.crudService.row && this.crudService.row.getClassName() === IgxAddRow.name) {\n        result.splice(this.crudService.row.index, 0, this.crudService.row.data);\n      }\n\n      return result;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get dataLength() {\n      return this.transactions.enabled ? this.dataWithAddedInTransactionRows.length : this.gridAPI.get_all_data().length;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get template() {\n      if (this.isLoading && (this.hasZeroResultFilter || this.hasNoData)) {\n        return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;\n      }\n\n      if (this.hasZeroResultFilter) {\n        return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;\n      }\n\n      if (this.hasNoData) {\n        return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get hasZeroResultFilter() {\n      return this.filteredData && this.filteredData.length === 0;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get hasNoData() {\n      return !this.data || this.dataLength === 0;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get shouldOverlayLoading() {\n      return this.isLoading && !this.hasNoData && !this.hasZeroResultFilter;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get isMultiRowSelectionEnabled() {\n      return this.rowSelection === GridSelectionMode.multiple || this.rowSelection === GridSelectionMode.multipleCascade;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get isRowSelectable() {\n      return this.rowSelection !== GridSelectionMode.none;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get isCellSelectable() {\n      return this.cellSelection !== GridSelectionMode.none;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get columnInDrag() {\n      return this.gridAPI.cms.column;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    hideActionStrip() {\n      var _a;\n\n      (_a = this.actionStrip) === null || _a === void 0 ? void 0 : _a.hide();\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get headerFeaturesWidth() {\n      return this._headerFeaturesWidth;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    isDetailRecord(_rec) {\n      return false;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    isGroupByRecord(_rec) {\n      return false;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    isGhostRecord(record) {\n      return record.ghostRecord !== undefined;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    isAddRowRecord(record) {\n      return record.addRow !== undefined;\n    }\n    /**\n     * @hidden\n     * Returns the row index of a row that takes into account the full view data like pinning.\n     */\n\n\n    getDataViewIndex(rowIndex, pinned) {\n      if (pinned && !this.isRowPinningToTop) {\n        rowIndex = rowIndex + this.unpinnedDataView.length;\n      } else if (!pinned && this.isRowPinningToTop) {\n        rowIndex = rowIndex + this.pinnedDataView.length;\n      }\n\n      return rowIndex;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get hasDetails() {\n      return false;\n    }\n    /**\n     * Returns the state of the grid virtualization.\n     *\n     * @remarks\n     * Includes the start index and how many records are rendered.\n     * @example\n     * ```typescript\n     * const gridVirtState = this.grid1.virtualizationState;\n     * ```\n     */\n\n\n    get virtualizationState() {\n      return this.verticalScrollContainer.state;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set virtualizationState(state) {\n      this.verticalScrollContainer.state = state;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    hideOverlays() {\n      this.overlayIDs.forEach(overlayID => {\n        var _a;\n\n        const overlay = this.overlayService.getOverlayById(overlayID);\n\n        if ((overlay === null || overlay === void 0 ? void 0 : overlay.visible) && !((_a = overlay.closeAnimationPlayer) === null || _a === void 0 ? void 0 : _a.hasStarted())) {\n          this.overlayService.hide(overlayID);\n          this.nativeElement.focus();\n        }\n      });\n    }\n    /**\n     * Returns whether the record is pinned or not.\n     *\n     * @param rowIndex Index of the record in the `dataView` collection.\n     *\n     * @hidden\n     * @internal\n     */\n\n\n    isRecordPinnedByViewIndex(rowIndex) {\n      return this.hasPinnedRecords && this.isRowPinningToTop && rowIndex < this.pinnedDataView.length || !this.isRowPinningToTop && rowIndex >= this.unpinnedDataView.length;\n    }\n    /**\n     * Returns whether the record is pinned or not.\n     *\n     * @param rowIndex Index of the record in the `filteredSortedData` collection.\n     */\n\n\n    isRecordPinnedByIndex(rowIndex) {\n      return this.hasPinnedRecords && this.isRowPinningToTop && rowIndex < this._filteredSortedPinnedData.length || !this.isRowPinningToTop && rowIndex >= this._filteredSortedUnpinnedData.length;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    isRecordPinned(rec) {\n      return this.getInitialPinnedIndex(rec) !== -1;\n    }\n    /**\n     * @hidden\n     * @internal\n     * Returns the record index in order of pinning by the user. Does not consider sorting/filtering.\n     */\n\n\n    getInitialPinnedIndex(rec) {\n      const id = this.gridAPI.get_row_id(rec);\n      return this._pinnedRecordIDs.indexOf(id);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get hasPinnedRecords() {\n      return this._pinnedRecordIDs.length > 0;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get pinnedRecordsCount() {\n      return this._pinnedRecordIDs.length;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get crudService() {\n      return this.gridAPI.crudService;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    _setupServices() {\n      this.gridAPI.grid = this;\n      this.crudService.grid = this;\n      this.selectionService.grid = this;\n      this.navigation.grid = this;\n      this.filteringService.grid = this;\n      this.summaryService.grid = this;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    _setupListeners() {\n      const destructor = takeUntil(this.destroy$);\n      fromEvent(this.nativeElement, 'focusout').pipe(filter(() => !!this.navigation.activeNode), destructor).subscribe(event => {\n        if (!this.crudService.cell && !!this.navigation.activeNode && (event.target === this.tbody.nativeElement && this.navigation.activeNode.row >= 0 && this.navigation.activeNode.row < this.dataView.length || event.target === this.theadRow.nativeElement && this.navigation.activeNode.row === -1 || event.target === this.tfoot.nativeElement && this.navigation.activeNode.row === this.dataView.length) && !(this.rowEditable && this.crudService.rowEditingBlocked && this.crudService.rowInEditMode)) {\n          this.navigation.lastActiveNode = this.navigation.activeNode;\n          this.navigation.activeNode = {};\n          this.notifyChanges();\n        }\n      });\n      this.rowAddedNotifier.pipe(destructor).subscribe(args => this.refreshGridState(args));\n      this.rowDeletedNotifier.pipe(destructor).subscribe(args => {\n        this.summaryService.deleteOperation = true;\n        this.summaryService.clearSummaryCache(args);\n      });\n      this.subscribeToTransactions();\n      this.resizeNotify.pipe(filter(() => !this._init), throttleTime(0, animationFrameScheduler, {\n        leading: true,\n        trailing: true\n      }), destructor).subscribe(() => {\n        this.zone.run(() => {\n          // do not trigger reflow if element is detached.\n          if (this.document.contains(this.nativeElement)) {\n            this.notifyChanges(true);\n          }\n        });\n      });\n      this.pipeTriggerNotifier.pipe(takeUntil(this.destroy$)).subscribe(() => this.pipeTrigger++);\n      this.columnMovingEnd.pipe(destructor).subscribe(() => this.crudService.endEdit(false));\n      this.overlayService.opening.pipe(destructor).subscribe(event => {\n        if (this._advancedFilteringOverlayId === event.id) {\n          const instance = event.componentRef.instance;\n\n          if (instance) {\n            instance.initialize(this, this.overlayService, event.id);\n          }\n        }\n      });\n      this.overlayService.opened.pipe(destructor).subscribe(event => {\n        var _a, _b;\n\n        const overlaySettings = (_a = this.overlayService.getOverlayById(event.id)) === null || _a === void 0 ? void 0 : _a.settings; // do not hide the advanced filtering overlay on scroll\n\n        if (this._advancedFilteringOverlayId === event.id) {\n          const instance = event.componentRef.instance;\n\n          if (instance) {\n            instance.lastActiveNode = this.navigation.activeNode;\n            instance.setAddButtonFocus();\n          }\n\n          return;\n        } // do not hide the overlay if it's attached to a row\n\n\n        if (((_b = this.rowEditingOverlay) === null || _b === void 0 ? void 0 : _b.overlayId) === event.id) {\n          return;\n        }\n\n        if ((overlaySettings === null || overlaySettings === void 0 ? void 0 : overlaySettings.outlet) === this.outlet && this.overlayIDs.indexOf(event.id) === -1) {\n          this.overlayIDs.push(event.id);\n        }\n      });\n      this.overlayService.closed.pipe(filter(() => !this._init), destructor).subscribe(event => {\n        if (this._advancedFilteringOverlayId === event.id) {\n          this.overlayService.detach(this._advancedFilteringOverlayId);\n          this._advancedFilteringOverlayId = null;\n          return;\n        }\n\n        const ind = this.overlayIDs.indexOf(event.id);\n\n        if (ind !== -1) {\n          this.overlayIDs.splice(ind, 1);\n        }\n      });\n      this.verticalScrollContainer.dataChanging.pipe(filter(() => !this._init), destructor).subscribe($event => {\n        const shouldRecalcSize = this.isPercentHeight && (!this.calcHeight || this.calcHeight === this.getDataBasedBodyHeight() || this.calcHeight === this.renderedRowHeight * this._defaultTargetRecordNumber);\n\n        if (shouldRecalcSize) {\n          this.calculateGridHeight();\n          $event.containerSize = this.calcHeight;\n        }\n\n        this.evaluateLoadingState();\n      });\n      this.verticalScrollContainer.scrollbarVisibilityChanged.pipe(filter(() => !this._init), destructor).subscribe(() => {\n        // called to recalc all widths that may have changes as a result of\n        // the vert. scrollbar showing/hiding\n        this.notifyChanges(true);\n        this.cdr.detectChanges();\n      });\n      this.verticalScrollContainer.contentSizeChange.pipe(filter(() => !this._init), destructor).subscribe(() => {\n        this.notifyChanges();\n      });\n      this.onDensityChanged.pipe(destructor).subscribe(() => {\n        this.crudService.endEdit(false);\n\n        if (this._summaryRowHeight === 0) {\n          this.summaryService.summaryHeight = 0;\n        }\n\n        this.notifyChanges(true);\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      super.ngOnInit();\n\n      this._setupServices();\n\n      this._setupListeners();\n\n      this.rowListDiffer = this.differs.find([]).create(null); // compare based on field, not on object ref.\n\n      this.columnListDiffer = this.differs.find([]).create((index, col) => col.field);\n      this.calcWidth = this.width && this.width.indexOf('%') === -1 ? parseInt(this.width, 10) : 0;\n      this.shouldGenerate = this.autoGenerate;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    resetColumnsCaches() {\n      this.columnList.forEach(column => column.resetCaches());\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    generateRowID() {\n      const primaryColumn = this.columnList.find(col => col.field === this.primaryKey);\n      const idType = this.data.length ? this.resolveDataTypes(this.data[0][this.primaryKey]) : primaryColumn ? primaryColumn.dataType : 'string';\n      return idType === 'string' ? v4() : FAKE_ROW_ID--;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    resetForOfCache() {\n      const firstVirtRow = this.dataRowList.first;\n\n      if (firstVirtRow) {\n        if (this._cdrRequests) {\n          firstVirtRow.virtDirRow.cdr.detectChanges();\n        }\n\n        firstVirtRow.virtDirRow.assumeMaster();\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    setFilteredData(data, pinned) {\n      if (this.hasPinnedRecords && pinned) {\n        this._filteredPinnedData = data || [];\n        const filteredUnpinned = this._filteredUnpinnedData || [];\n        const filteredData = [...this._filteredPinnedData, ...filteredUnpinned];\n        this.filteredData = filteredData.length > 0 ? filteredData : this._filteredUnpinnedData;\n      } else if (this.hasPinnedRecords && !pinned) {\n        this._filteredUnpinnedData = data;\n      } else {\n        this.filteredData = data;\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    resetColumnCollections() {\n      this._visibleColumns.length = 0;\n      this._pinnedVisible.length = 0;\n      this._unpinnedVisible.length = 0;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    resetCachedWidths() {\n      this._unpinnedWidth = NaN;\n      this._pinnedWidth = NaN;\n      this._totalWidth = NaN;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    resetCaches(recalcFeatureWidth = true) {\n      if (recalcFeatureWidth) {\n        this._headerFeaturesWidth = NaN;\n      }\n\n      this.resetForOfCache();\n      this.resetColumnsCaches();\n      this.resetColumnCollections();\n      this.resetCachedWidths();\n      this.hasVisibleColumns = undefined;\n      this._columnGroups = this.columnList.some(col => col.columnGroup);\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterContentInit() {\n      this.setupColumns();\n      this.toolbar.changes.pipe(filter(() => !this._init), takeUntil(this.destroy$)).subscribe(() => this.notifyChanges(true));\n      this.setUpPaginator();\n      this.paginationComponents.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        this.setUpPaginator();\n      });\n\n      if (this.actionStrip) {\n        this.actionStrip.menuOverlaySettings.outlet = this.outlet;\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    dataRebinding(event) {\n      this.dataChanging.emit(event);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    dataRebound(event) {\n      this.dataChanged.emit(event);\n    }\n    /** @hidden @internal */\n\n\n    createFilterDropdown(column, options) {\n      options.outlet = this.outlet;\n\n      if (this.excelStyleFilteringComponent) {\n        this.excelStyleFilteringComponent.initialize(column, this.overlayService);\n        const id = this.overlayService.attach(this.excelStyleFilteringComponent.element, options);\n        this.excelStyleFilteringComponent.overlayComponentId = id;\n        return {\n          id,\n          ref: undefined\n        };\n      }\n\n      const ref = this.createComponentInstance(IgxGridExcelStyleFilteringComponent);\n      ref.instance.initialize(column, this.overlayService);\n      const id = this.overlayService.attach(ref.instance.element, options);\n      ref.instance.overlayComponentId = id;\n      return {\n        ref,\n        id\n      };\n    }\n\n    createComponentInstance(component) {\n      let dynamicFactory;\n      const factoryResolver = this.moduleRef ? this.moduleRef.componentFactoryResolver : this.resolver;\n\n      try {\n        dynamicFactory = factoryResolver.resolveComponentFactory(component);\n      } catch (error) {\n        console.error(error);\n        return null;\n      }\n\n      const injector = this.moduleRef ? this.moduleRef.injector : this.injector;\n      const dynamicComponent = dynamicFactory.create(injector);\n      this.appRef.attachView(dynamicComponent.hostView);\n      return dynamicComponent;\n    }\n    /** @hidden @internal */\n\n\n    setUpPaginator() {\n      if (this.paginator) {\n        this.paginator.pageChange.pipe(takeWhile(() => !!this.paginator), filter(() => !this._init)).subscribe(page => {\n          this.pageChange.emit(page);\n        });\n        this.paginator.pagingDone.pipe(takeWhile(() => !!this.paginator), filter(() => !this._init)).subscribe(args => {\n          this.selectionService.clear(true);\n          this.pagingDone.emit({\n            previous: args.previous,\n            current: args.current\n          });\n          this.crudService.endEdit(false);\n          this.pipeTrigger++;\n          this.navigateTo(0);\n          this.notifyChanges();\n        });\n        this.paginator.perPageChange.pipe(takeWhile(() => !!this.paginator), filter(() => !this._init)).subscribe(perPage => {\n          this.selectionService.clear(true);\n          this.perPageChange.emit(perPage);\n          this.paginator.page = 0;\n          this.crudService.endEdit(false);\n          this.notifyChanges();\n        });\n      } else {\n        this.markForCheck();\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    setFilteredSortedData(data, pinned) {\n      data = data || [];\n\n      if (this.pinnedRecordsCount > 0) {\n        if (pinned) {\n          this._filteredSortedPinnedData = data;\n          this.pinnedRecords = data;\n          this._filteredSortedData = this.isRowPinningToTop ? [...this._filteredSortedPinnedData, ...this._filteredSortedUnpinnedData] : [...this._filteredSortedUnpinnedData, ...this._filteredSortedPinnedData];\n          this.refreshSearch(true, false);\n        } else {\n          this._filteredSortedUnpinnedData = data;\n        }\n      } else {\n        this._filteredSortedData = data;\n        this.refreshSearch(true, false);\n      }\n\n      this.buildDataView(data);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    resetHorizontalVirtualization() {\n      const elementFilter = item => this.isDefined(item.nativeElement.parentElement);\n\n      this._horizontalForOfs = [...this._dataRowList.filter(elementFilter).map(item => item.virtDirRow), ...this._summaryRowList.filter(elementFilter).map(item => item.virtDirRow)];\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    _setupRowObservers() {\n      const elementFilter = item => this.isDefined(item.nativeElement.parentElement);\n\n      const extractForOfs = pipe(map(collection => collection.filter(elementFilter).map(item => item.virtDirRow)));\n      const rowListObserver = extractForOfs(this._dataRowList.changes);\n      const summaryRowObserver = extractForOfs(this._summaryRowList.changes);\n      rowListObserver.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        this.resetHorizontalVirtualization();\n      });\n      summaryRowObserver.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        this.resetHorizontalVirtualization();\n      });\n      this.resetHorizontalVirtualization();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    _zoneBegoneListeners() {\n      this.zone.runOutsideAngular(() => {\n        var _a;\n\n        this.verticalScrollContainer.getScroll().addEventListener('scroll', this.verticalScrollHandler.bind(this));\n        (_a = this.headerContainer) === null || _a === void 0 ? void 0 : _a.getScroll().addEventListener('scroll', this.horizontalScrollHandler.bind(this));\n        fromEvent(window, 'resize').pipe(takeUntil(this.destroy$)).subscribe(() => this.resizeNotify.next());\n        resizeObservable(this.nativeElement).pipe(takeUntil(this.destroy$)).subscribe(() => this.resizeNotify.next());\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterViewInit() {\n      var _a;\n\n      this.initPinning();\n      this.calculateGridSizes();\n      this._init = false;\n      this.cdr.reattach();\n\n      this._setupRowObservers();\n\n      this._zoneBegoneListeners();\n\n      const vertScrDC = this.verticalScrollContainer.displayContainer;\n      vertScrDC.addEventListener('scroll', this.preventContainerScroll.bind(this));\n\n      this._pinnedRowList.changes.pipe(takeUntil(this.destroy$)).subscribe(change => {\n        this.onPinnedRowsChanged(change);\n      });\n\n      (_a = this.addRowSnackbar) === null || _a === void 0 ? void 0 : _a.clicked.subscribe(() => {\n        const rec = this.filteredSortedData[this.lastAddedRowIndex];\n        this.scrollTo(rec, 0);\n        this.addRowSnackbar.close();\n      }); // Keep the stream open for future subscribers\n\n      this.rendered$.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        if (this.paginator) {\n          this.paginator.perPage = this._perPage !== DEFAULT_ITEMS_PER_PAGE ? this._perPage : this.paginator.perPage;\n          this.paginator.totalRecords = this.totalRecords ? this.totalRecords : this.paginator.totalRecords;\n          this.paginator.overlaySettings = {\n            outlet: this.outlet\n          };\n        }\n\n        this._rendered = true;\n      });\n      Promise.resolve().then(() => this.rendered.next(true));\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    notifyChanges(repaint = false) {\n      this._cdrRequests = true;\n      this._cdrRequestRepaint = repaint;\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    ngDoCheck() {\n      super.ngDoCheck();\n\n      if (this._init) {\n        return;\n      }\n\n      if (this._cdrRequestRepaint) {\n        this.resetNotifyChanges();\n        this.calculateGridSizes();\n        this.refreshSearch(true);\n        return;\n      }\n\n      if (this._cdrRequests) {\n        this.resetNotifyChanges();\n        this.cdr.detectChanges();\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    getDragGhostCustomTemplate() {\n      if (this.dragGhostCustomTemplates && this.dragGhostCustomTemplates.first) {\n        return this.dragGhostCustomTemplates.first;\n      }\n\n      return null;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    ngOnDestroy() {\n      this.tmpOutlets.forEach(tmplOutlet => {\n        tmplOutlet.cleanCache();\n      });\n      this.destroy$.next(true);\n      this.destroy$.complete();\n      this.transactionChange$.next();\n      this.transactionChange$.complete();\n      this._destroyed = true;\n\n      if (this._advancedFilteringOverlayId) {\n        this.overlayService.detach(this._advancedFilteringOverlayId);\n        delete this._advancedFilteringOverlayId;\n      }\n\n      this.overlayIDs.forEach(overlayID => {\n        const overlay = this.overlayService.getOverlayById(overlayID);\n\n        if (overlay && !overlay.detached) {\n          this.overlayService.detach(overlayID);\n        }\n      });\n      this.zone.runOutsideAngular(() => {\n        var _a, _b, _c, _d, _e;\n\n        (_b = (_a = this.verticalScrollContainer) === null || _a === void 0 ? void 0 : _a.getScroll()) === null || _b === void 0 ? void 0 : _b.removeEventListener('scroll', this.verticalScrollHandler);\n        (_d = (_c = this.headerContainer) === null || _c === void 0 ? void 0 : _c.getScroll()) === null || _d === void 0 ? void 0 : _d.removeEventListener('scroll', this.horizontalScrollHandler);\n        const vertScrDC = (_e = this.verticalScrollContainer) === null || _e === void 0 ? void 0 : _e.displayContainer;\n        vertScrDC === null || vertScrDC === void 0 ? void 0 : vertScrDC.removeEventListener('scroll', this.preventContainerScroll);\n      });\n    }\n    /**\n     * Toggles the specified column's visibility.\n     *\n     * @example\n     * ```typescript\n     * this.grid1.toggleColumnVisibility({\n     *       column: this.grid1.columns[0],\n     *       newValue: true\n     * });\n     * ```\n     */\n\n\n    toggleColumnVisibility(args) {\n      const col = args.column ? this.columnList.find(c => c === args.column) : undefined;\n\n      if (!col) {\n        return;\n      }\n\n      col.toggleVisibility(args.newValue);\n    }\n    /**\n     * Gets/Sets a list of key-value pairs [row ID, expansion state].\n     *\n     * @remarks\n     * Includes only states that differ from the default one.\n     * Supports two-way binding.\n     * @example\n     * ```html\n     * <igx-grid #grid [data]=\"data\" [(expansionStates)]=\"model.expansionStates\">\n     * </igx-grid>\n     * ```\n     */\n\n\n    get expansionStates() {\n      return this._expansionStates;\n    }\n\n    set expansionStates(value) {\n      this._expansionStates = new Map(value);\n      this.expansionStatesChange.emit(this._expansionStates);\n      this.notifyChanges(true);\n\n      if (this.gridAPI.grid) {\n        this.cdr.detectChanges();\n      }\n    }\n    /**\n     * Expands all rows.\n     *\n     * @example\n     * ```typescript\n     * this.grid.expandAll();\n     * ```\n     */\n\n\n    expandAll() {\n      this._defaultExpandState = true;\n      this.expansionStates = new Map();\n    }\n    /**\n     * Collapses all rows.\n     *\n     * @example\n     * ```typescript\n     * this.grid.collapseAll();\n     * ```\n     */\n\n\n    collapseAll() {\n      this._defaultExpandState = false;\n      this.expansionStates = new Map();\n    }\n    /**\n     * Expands the row by its id.\n     *\n     * @remarks\n     * ID is either the primaryKey value or the data record instance.\n     * @example\n     * ```typescript\n     * this.grid.expandRow(rowID);\n     * ```\n     * @param rowID The row id - primaryKey value or the data record instance.\n     */\n\n\n    expandRow(rowID) {\n      this.gridAPI.set_row_expansion_state(rowID, true);\n    }\n    /**\n     * Collapses the row by its id.\n     *\n     * @remarks\n     * ID is either the primaryKey value or the data record instance.\n     * @example\n     * ```typescript\n     * this.grid.collapseRow(rowID);\n     * ```\n     * @param rowID The row id - primaryKey value or the data record instance.\n     */\n\n\n    collapseRow(rowID) {\n      this.gridAPI.set_row_expansion_state(rowID, false);\n    }\n    /**\n     * Toggles the row by its id.\n     *\n     * @remarks\n     * ID is either the primaryKey value or the data record instance.\n     * @example\n     * ```typescript\n     * this.grid.toggleRow(rowID);\n     * ```\n     * @param rowID The row id - primaryKey value or the data record instance.\n     */\n\n\n    toggleRow(rowID) {\n      const rec = this.gridAPI.get_rec_by_id(rowID);\n      const state = this.gridAPI.get_row_expansion_state(rec);\n      this.gridAPI.set_row_expansion_state(rowID, !state);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    getDefaultExpandState(_rec) {\n      return this._defaultExpandState;\n    }\n    /**\n     * Gets the native element.\n     *\n     * @example\n     * ```typescript\n     * const nativeEl = this.grid.nativeElement.\n     * ```\n     */\n\n\n    get nativeElement() {\n      return this.elementRef.nativeElement;\n    }\n    /**\n     * Gets/Sets the outlet used to attach the grid's overlays to.\n     *\n     * @remark\n     * If set, returns the outlet defined outside the grid. Otherwise returns the grid's internal outlet directive.\n     */\n\n\n    get outlet() {\n      return this.resolveOutlet();\n    }\n\n    set outlet(val) {\n      this._userOutletDirective = val;\n    }\n    /**\n     * Gets the default row height.\n     *\n     * @example\n     * ```typescript\n     * const rowHeigh = this.grid.defaultRowHeight;\n     * ```\n     */\n\n\n    get defaultRowHeight() {\n      switch (this.displayDensity) {\n        case DisplayDensity.cosy:\n          return 40;\n\n        case DisplayDensity.compact:\n          return 32;\n\n        default:\n          return 50;\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get defaultSummaryHeight() {\n      switch (this.displayDensity) {\n        case DisplayDensity.cosy:\n          return 30;\n\n        case DisplayDensity.compact:\n          return 24;\n\n        default:\n          return 36;\n      }\n    }\n    /**\n     * Returns the `IgxGridHeaderGroupComponent`'s minimum allowed width.\n     *\n     * @remarks\n     * Used internally for restricting header group component width.\n     * The values below depend on the header cell default right/left padding values.\n     */\n\n\n    get defaultHeaderGroupMinWidth() {\n      switch (this.displayDensity) {\n        case DisplayDensity.cosy:\n          return 32;\n\n        case DisplayDensity.compact:\n          return 24;\n\n        default:\n          return 48;\n      }\n    }\n    /**\n     * Gets the current width of the container for the pinned `IgxColumnComponent`s.\n     *\n     * @example\n     * ```typescript\n     * const pinnedWidth = this.grid.getPinnedWidth;\n     * ```\n     */\n\n\n    get pinnedWidth() {\n      if (!isNaN(this._pinnedWidth)) {\n        return this._pinnedWidth;\n      }\n\n      this._pinnedWidth = this.getPinnedWidth();\n      return this._pinnedWidth;\n    }\n    /**\n     * Gets the current width of the container for the unpinned `IgxColumnComponent`s.\n     *\n     * @example\n     * ```typescript\n     * const unpinnedWidth = this.grid.getUnpinnedWidth;\n     * ```\n     */\n\n\n    get unpinnedWidth() {\n      if (!isNaN(this._unpinnedWidth)) {\n        return this._unpinnedWidth;\n      }\n\n      this._unpinnedWidth = this.getUnpinnedWidth();\n      return this._unpinnedWidth;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get isHorizontalScrollHidden() {\n      const diff = this.unpinnedWidth - this.totalWidth;\n      return this.width === null || diff >= 0;\n    }\n    /**\n     * @hidden @internal\n     * Gets the header cell inner width for auto-sizing.\n     */\n\n\n    getHeaderCellWidth(element) {\n      const range = this.document.createRange();\n      const headerWidth = this.platform.getNodeSizeViaRange(range, element, element.parentElement);\n      const headerStyle = this.document.defaultView.getComputedStyle(element);\n      const headerPadding = parseFloat(headerStyle.paddingLeft) + parseFloat(headerStyle.paddingRight) + parseFloat(headerStyle.borderRightWidth); // Take into consideration the header group element, since column pinning applies borders to it if its not a columnGroup.\n\n      const headerGroupStyle = this.document.defaultView.getComputedStyle(element.parentElement);\n      const borderSize = parseFloat(headerGroupStyle.borderRightWidth) + parseFloat(headerGroupStyle.borderLeftWidth);\n      return {\n        width: Math.ceil(headerWidth),\n        padding: Math.ceil(headerPadding + borderSize)\n      };\n    }\n    /**\n     * @hidden @internal\n     * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.\n     */\n\n\n    featureColumnsWidth(expander) {\n      var _a, _b, _c, _d, _e, _f, _g;\n\n      if (Number.isNaN(this._headerFeaturesWidth)) {\n        // TODO: platformUtil.isBrowser check\n        const rowSelectArea = ((_b = (_a = this.headerSelectorContainer) === null || _a === void 0 ? void 0 : _a.nativeElement) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect) ? this.headerSelectorContainer.nativeElement.getBoundingClientRect().width : 0;\n        const rowDragArea = this.rowDraggable && ((_d = (_c = this.headerDragContainer) === null || _c === void 0 ? void 0 : _c.nativeElement) === null || _d === void 0 ? void 0 : _d.getBoundingClientRect) ? this.headerDragContainer.nativeElement.getBoundingClientRect().width : 0;\n        const groupableArea = ((_f = (_e = this.headerGroupContainer) === null || _e === void 0 ? void 0 : _e.nativeElement) === null || _f === void 0 ? void 0 : _f.getBoundingClientRect) ? this.headerGroupContainer.nativeElement.getBoundingClientRect().width : 0;\n        const expanderWidth = ((_g = expander === null || expander === void 0 ? void 0 : expander.nativeElement) === null || _g === void 0 ? void 0 : _g.getBoundingClientRect) ? expander.nativeElement.getBoundingClientRect().width : 0;\n        this._headerFeaturesWidth = rowSelectArea + rowDragArea + groupableArea + expanderWidth;\n      }\n\n      return this._headerFeaturesWidth;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get summariesMargin() {\n      return this.featureColumnsWidth();\n    }\n    /**\n     * Gets an array of `IgxColumnComponent`s.\n     *\n     * @example\n     * ```typescript\n     * const colums = this.grid.columns.\n     * ```\n     */\n\n\n    get columns() {\n      return this._rendered ? this._columns : [];\n    }\n    /**\n     * Gets an array of the pinned `IgxColumnComponent`s.\n     *\n     * @example\n     * ```typescript\n     * const pinnedColumns = this.grid.pinnedColumns.\n     * ```\n     */\n\n\n    get pinnedColumns() {\n      if (this._pinnedVisible.length) {\n        return this._pinnedVisible;\n      }\n\n      this._pinnedVisible = this._pinnedColumns.filter(col => !col.hidden);\n      return this._pinnedVisible;\n    }\n    /**\n     * Gets an array of the pinned `IgxRowComponent`s.\n     *\n     * @example\n     * ```typescript\n     * const pinnedRow = this.grid.pinnedRows;\n     * ```\n     */\n\n\n    get pinnedRows() {\n      return this._pinnedRowList.toArray().sort((a, b) => a.index - b.index);\n    }\n    /**\n     * Gets an array of unpinned `IgxColumnComponent`s.\n     *\n     * @example\n     * ```typescript\n     * const unpinnedColumns = this.grid.unpinnedColumns.\n     * ```\n     */\n\n\n    get unpinnedColumns() {\n      if (this._unpinnedVisible.length) {\n        return this._unpinnedVisible;\n      }\n\n      this._unpinnedVisible = this._unpinnedColumns.filter(col => !col.hidden);\n      return this._unpinnedVisible;\n    }\n    /**\n     * Gets the `width` to be set on `IgxGridHeaderGroupComponent`.\n     */\n\n\n    getHeaderGroupWidth(column) {\n      return this.hasColumnLayouts ? '' : `${Math.max(parseFloat(column.calcWidth), this.defaultHeaderGroupMinWidth)}px`;\n    }\n    /**\n     * Returns the `IgxColumnComponent` by field name.\n     *\n     * @example\n     * ```typescript\n     * const myCol = this.grid1.getColumnByName(\"ID\");\n     * ```\n     * @param name\n     */\n\n\n    getColumnByName(name) {\n      return this.columnList.find(col => col.field === name);\n    }\n\n    getColumnByVisibleIndex(index) {\n      return this.visibleColumns.find(col => !col.columnGroup && !col.columnLayout && col.visibleIndex === index);\n    }\n    /**\n     * Returns an array of visible `IgxColumnComponent`s.\n     *\n     * @example\n     * ```typescript\n     * const visibleColumns = this.grid.visibleColumns.\n     * ```\n     */\n\n\n    get visibleColumns() {\n      if (this._visibleColumns.length) {\n        return this._visibleColumns;\n      }\n\n      this._visibleColumns = this.columnList.filter(c => !c.hidden);\n      return this._visibleColumns;\n    }\n    /**\n     * @deprecated in version 12.1.0. Use the corresponding property exposed by the `igx-paginator`\n     *\n     * Gets the total number of pages.\n     *\n     *\n     * @example\n     * ```typescript\n     * const totalPages = this.grid.totalPages;\n     * ```\n     */\n\n\n    get totalPages() {\n      var _a;\n\n      return (_a = this.paginator) === null || _a === void 0 ? void 0 : _a.totalPages;\n    }\n    /**\n     * @deprecated in version 12.1.0. Use the corresponding property exposed by the `igx-paginator`\n     *\n     * Gets if the current page is the first page.\n     *\n     *\n     * @example\n     * ```typescript\n     * const firstPage = this.grid.isFirstPage;\n     * ```\n     */\n\n\n    get isFirstPage() {\n      return this.paginator.isLastPage;\n    }\n    /**\n     * @deprecated in version 12.1.0. Use the corresponding method exposed by the `igx-paginator`\n     *\n     * Goes to the next page, if the grid is not already at the last page.\n     *\n     *\n     * @example\n     * ```typescript\n     * this.grid1.nextPage();\n     * ```\n     */\n    // eslint-disable-next-line @typescript-eslint/member-ordering\n\n\n    nextPage() {\n      var _a;\n\n      (_a = this.paginator) === null || _a === void 0 ? void 0 : _a.nextPage();\n    }\n    /**\n     * @deprecated in version 12.1.0. Use the corresponding method exposed by the `igx-paginator`\n     *\n     * Goes to the previous page, if the grid is not already at the first page.\n     *\n     * @example\n     * ```\n     */\n    // eslint-disable-next-line @typescript-eslint/member-ordering\n\n\n    previousPage() {\n      var _a;\n\n      (_a = this.paginator) === null || _a === void 0 ? void 0 : _a.previousPage();\n    }\n    /**\n     * Returns the total number of records.\n     *\n     * @remarks\n     * Only functions when paging is enabled.\n     * @example\n     * ```typescript\n     * const totalRecords = this.grid.totalRecords;\n     * ```\n     */\n\n\n    get totalRecords() {\n      var _a;\n\n      return this._totalRecords >= 0 ? this._totalRecords : (_a = this.pagingState) === null || _a === void 0 ? void 0 : _a.metadata.countRecords;\n    }\n\n    set totalRecords(total) {\n      if (total >= 0) {\n        if (this.paginator) {\n          this.paginator.totalRecords = total;\n        }\n\n        this._totalRecords = total;\n        this.pipeTrigger++;\n        this.notifyChanges();\n      }\n    }\n    /**\n     * @deprecated in version 12.1.0. Use the corresponding property exposed by the `igx-paginator`\n     *\n     * Returns if the current page is the last page.\n     *\n     *\n     * @example\n     * ```typescript\n     * const lastPage = this.grid.isLastPage;\n     * ```\n     */\n\n\n    get isLastPage() {\n      return this.paginator.isLastPage;\n    }\n    /**\n     * Returns the total width of the `IgxGridComponent`.\n     *\n     * @example\n     * ```typescript\n     * const gridWidth = this.grid.totalWidth;\n     * ```\n     */\n\n\n    get totalWidth() {\n      if (!isNaN(this._totalWidth)) {\n        return this._totalWidth;\n      } // Take only top level columns\n\n\n      const cols = this.visibleColumns.filter(col => col.level === 0 && !col.pinned);\n      let totalWidth = 0;\n      let i = 0;\n\n      for (i; i < cols.length; i++) {\n        totalWidth += parseInt(cols[i].calcWidth, 10) || 0;\n      }\n\n      this._totalWidth = totalWidth;\n      return totalWidth;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get showRowSelectors() {\n      return this.isRowSelectable && this.hasVisibleColumns && !this.hideRowSelectors;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get showAddButton() {\n      return this.rowEditable && this.dataView.length === 0 && this.columnList.length > 0;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get showDragIcons() {\n      return this.rowDraggable && this.columnList.length > this.hiddenColumnsCount;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    _getDataViewIndex(index) {\n      let newIndex = index;\n\n      if ((index < 0 || index >= this.dataView.length) && this.pagingMode === 1 && this.paginator.page !== 0) {\n        newIndex = index - this.paginator.perPage * this.paginator.page;\n      } else if (this.gridAPI.grid.verticalScrollContainer.isRemote) {\n        newIndex = index - this.gridAPI.grid.virtualizationState.startIndex;\n      }\n\n      return newIndex;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    getDataIndex(dataViewIndex) {\n      let newIndex = dataViewIndex;\n\n      if (this.gridAPI.grid.verticalScrollContainer.isRemote) {\n        newIndex = dataViewIndex + this.gridAPI.grid.virtualizationState.startIndex;\n      }\n\n      return newIndex;\n    }\n    /**\n     * Places a column before or after the specified target column.\n     *\n     * @example\n     * ```typescript\n     * grid.moveColumn(column, target);\n     * ```\n     */\n\n\n    moveColumn(column, target, pos = DropPosition.AfterDropTarget) {\n      // M.A. May 11th, 2021 #9508 Make the event cancelable\n      const eventArgs = {\n        source: column,\n        target,\n        cancel: false\n      };\n      this.columnMovingEnd.emit(eventArgs);\n\n      if (eventArgs.cancel) {\n        return;\n      }\n\n      if (column === target || column.level !== target.level || column.topLevelParent !== target.topLevelParent) {\n        return;\n      }\n\n      if (column.level) {\n        this._moveChildColumns(column.parent, column, target, pos);\n      }\n\n      let columnPinStateChanged; // pinning and unpinning will work correctly even without passing index\n      // but is easier to calclulate the index here, and later use it in the pinning event args\n\n      if (target.pinned && !column.pinned) {\n        const pinnedIndex = this._pinnedColumns.indexOf(target);\n\n        const index = pos === DropPosition.AfterDropTarget ? pinnedIndex + 1 : pinnedIndex;\n        columnPinStateChanged = column.pin(index);\n      }\n\n      if (!target.pinned && column.pinned) {\n        const unpinnedIndex = this._unpinnedColumns.indexOf(target);\n\n        const index = pos === DropPosition.AfterDropTarget ? unpinnedIndex + 1 : unpinnedIndex;\n        columnPinStateChanged = column.unpin(index);\n      }\n\n      if (target.pinned && column.pinned && !columnPinStateChanged) {\n        this._reorderColumns(column, target, pos, this._pinnedColumns);\n      }\n\n      if (!target.pinned && !column.pinned && !columnPinStateChanged) {\n        this._reorderColumns(column, target, pos, this._unpinnedColumns);\n      }\n\n      this._moveColumns(column, target, pos);\n\n      this._columnsReordered(column);\n    }\n    /**\n     * @deprecated in version 12.1.0. Use the corresponding method exposed by the `igx-paginator`\n     *\n     * Goes to the desired page index.\n     *\n     *\n     * @example\n     * ```typescript\n     * this.grid1.paginate(1);\n     * ```\n     * @param val\n     */\n    // eslint-disable-next-line @typescript-eslint/member-ordering\n\n\n    paginate(val) {\n      var _a;\n\n      (_a = this.paginator) === null || _a === void 0 ? void 0 : _a.paginate(val);\n    }\n    /**\n     * Triggers change detection for the `IgxGridComponent`.\n     * Calling markForCheck also triggers the grid pipes explicitly, resulting in all updates being processed.\n     * May degrade performance if used when not needed, or if misused:\n     * ```typescript\n     * // DON'Ts:\n     * // don't call markForCheck from inside a loop\n     * // don't call markForCheck when a primitive has changed\n     * grid.data.forEach(rec => {\n     *  rec = newValue;\n     *  grid.markForCheck();\n     * });\n     *\n     * // DOs\n     * // call markForCheck after updating a nested property\n     * grid.data.forEach(rec => {\n     *  rec.nestedProp1.nestedProp2 = newValue;\n     * });\n     * grid.markForCheck();\n     * ```\n     *\n     * @example\n     * ```typescript\n     * grid.markForCheck();\n     * ```\n     */\n\n\n    markForCheck() {\n      this.pipeTrigger++;\n      this.cdr.detectChanges();\n    }\n    /**\n     * Creates a new `IgxGridRowComponent` and adds the data record to the end of the data source.\n     *\n     * @example\n     * ```typescript\n     * this.grid1.addRow(record);\n     * ```\n     * @param data\n     */\n\n\n    addRow(data) {\n      // commit pending states prior to adding a row\n      this.crudService.endEdit(true);\n      this.gridAPI.addRowToData(data);\n      this.rowAddedNotifier.next({\n        data\n      });\n      this.pipeTrigger++;\n      this.notifyChanges();\n    }\n    /**\n     * Removes the `IgxGridRowComponent` and the corresponding data record by primary key.\n     *\n     * @remarks\n     * Requires that the `primaryKey` property is set.\n     * The method accept rowSelector as a parameter, which is the rowID.\n     * @example\n     * ```typescript\n     * this.grid1.deleteRow(0);\n     * ```\n     * @param rowSelector\n     */\n\n\n    deleteRow(rowSelector) {\n      if (this.primaryKey !== undefined && this.primaryKey !== null) {\n        return this.deleteRowById(rowSelector);\n      }\n    }\n    /** @hidden */\n\n\n    deleteRowById(rowId) {\n      const args = {\n        rowID: rowId,\n        cancel: false,\n        rowData: this.getRowData(rowId),\n        oldValue: null\n      };\n      this.rowDelete.emit(args);\n\n      if (args.cancel) {\n        return;\n      }\n\n      const record = this.gridAPI.deleteRowById(rowId);\n\n      if (record !== null && record !== undefined) {\n        //  TODO: should we emit this when cascadeOnDelete is true for each row?!?!\n        this.rowDeleted.emit({\n          data: record\n        });\n      }\n\n      return record;\n    }\n    /**\n     * Updates the `IgxGridRowComponent` and the corresponding data record by primary key.\n     *\n     * @remarks\n     * Requires that the `primaryKey` property is set.\n     * @example\n     * ```typescript\n     * this.gridWithPK.updateCell('Updated', 1, 'ProductName');\n     * ```\n     * @param value the new value which is to be set.\n     * @param rowSelector corresponds to rowID.\n     * @param column corresponds to column field.\n     */\n\n\n    updateCell(value, rowSelector, column) {\n      if (this.isDefined(this.primaryKey)) {\n        const col = this.columnList.toArray().find(c => c.field === column);\n\n        if (col) {\n          // Simplify\n          const rowData = this.gridAPI.getRowData(rowSelector);\n          const index = this.gridAPI.get_row_index_in_data(rowSelector); // If row passed is invalid\n\n          if (index < 0) {\n            return;\n          }\n\n          const id = {\n            rowID: rowSelector,\n            columnID: col.index,\n            rowIndex: index\n          };\n          const cell = new IgxCell(id, index, col, rowData[col.field], value, rowData, this);\n          this.gridAPI.update_cell(cell);\n          this.cdr.detectChanges();\n        }\n      }\n    }\n    /**\n     * Updates the `IgxGridRowComponent`\n     *\n     * @remarks\n     * The row is specified by\n     * rowSelector parameter and the data source record with the passed value.\n     * This method will apply requested update only if primary key is specified in the grid.\n     * @example\n     * ```typescript\n     * grid.updateRow({\n     *       ProductID: 1, ProductName: 'Spearmint', InStock: true, UnitsInStock: 1, OrderDate: new Date('2005-03-21')\n     *   }, 1);\n     * ```\n     * @param value–\n     * @param rowSelector correspond to rowID\n     */\n    // TODO: prevent event invocation\n\n\n    updateRow(value, rowSelector) {\n      if (this.isDefined(this.primaryKey)) {\n        const editableCell = this.crudService.cell;\n\n        if (editableCell && editableCell.id.rowID === rowSelector) {\n          this.crudService.endCellEdit();\n        }\n\n        const row = new IgxEditRow(rowSelector, -1, this.gridAPI.getRowData(rowSelector), this);\n        this.gridAPI.update_row(row, value); // TODO: fix for #5934 and probably break for #5763\n        // consider adding of third optional boolean parameter in updateRow.\n        // If developer set this parameter to true we should call notifyChanges(true), and\n        // vise-versa if developer set it to false we should call notifyChanges(false).\n        // The parameter should default to false\n\n        this.notifyChanges();\n      }\n    }\n    /**\n     * Returns the data that is contained in the row component.\n     *\n     * @remarks\n     * If the primary key is not specified the row selector match the row data.\n     * @example\n     * ```typescript\n     * const data = grid.getRowData(94741);\n     * ```\n     * @param rowSelector correspond to rowID\n     */\n\n\n    getRowData(rowSelector) {\n      if (!this.primaryKey) {\n        return rowSelector;\n      }\n\n      const data = this.gridAPI.get_all_data(this.transactions.enabled);\n      const index = this.gridAPI.get_row_index_in_data(rowSelector);\n      return index < 0 ? {} : data[index];\n    }\n    /**\n     * Sort a single `IgxColumnComponent`.\n     *\n     * @remarks\n     * Sort the `IgxGridComponent`'s `IgxColumnComponent` based on the provided array of sorting expressions.\n     * @example\n     * ```typescript\n     * this.grid.sort({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });\n     * ```\n     */\n\n\n    sort(expression) {\n      const sortingState = cloneArray(this.sortingExpressions);\n\n      if (expression instanceof Array) {\n        for (const each of expression) {\n          if (each.dir === SortingDirection.None) {\n            this.gridAPI.remove_grouping_expression(each.fieldName);\n          }\n\n          this.gridAPI.prepare_sorting_expression([sortingState], each);\n        }\n      } else {\n        if (expression.dir === SortingDirection.None) {\n          this.gridAPI.remove_grouping_expression(expression.fieldName);\n        }\n\n        this.gridAPI.prepare_sorting_expression([sortingState], expression);\n      }\n\n      const eventArgs = {\n        owner: this,\n        sortingExpressions: sortingState,\n        cancel: false\n      };\n      this.sorting.emit(eventArgs);\n\n      if (eventArgs.cancel) {\n        return;\n      }\n\n      this.crudService.endEdit(false);\n\n      if (expression instanceof Array) {\n        this.gridAPI.sort_multiple(expression);\n      } else {\n        this.gridAPI.sort(expression);\n      }\n\n      requestAnimationFrame(() => this.sortingDone.emit(expression));\n    }\n    /**\n     * Filters a single `IgxColumnComponent`.\n     *\n     * @example\n     * ```typescript\n     * public filter(term) {\n     *      this.grid.filter(\"ProductName\", term, IgxStringFilteringOperand.instance().condition(\"contains\"));\n     * }\n     * ```\n     * @param name\n     * @param value\n     * @param conditionOrExpressionTree\n     * @param ignoreCase\n     */\n\n\n    filter(name, value, conditionOrExpressionTree, ignoreCase) {\n      this.filteringService.filter(name, value, conditionOrExpressionTree, ignoreCase);\n    }\n    /**\n     * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.\n     *\n     * @example\n     * ```typescript\n     * grid.filterGlobal('some', IgxStringFilteringOperand.instance().condition('contains'));\n     * ```\n     * @param value\n     * @param condition\n     * @param ignoreCase\n     */\n\n\n    filterGlobal(value, condition, ignoreCase) {\n      this.filteringService.filterGlobal(value, condition, ignoreCase);\n    }\n    /**\n     * Enables summaries for the specified column and applies your customSummary.\n     *\n     * @remarks\n     * If you do not provide the customSummary, then the default summary for the column data type will be applied.\n     * @example\n     * ```typescript\n     * grid.enableSummaries([{ fieldName: 'ProductName' }, { fieldName: 'ID' }]);\n     * ```\n     * Enable summaries for the listed columns.\n     * @example\n     * ```typescript\n     * grid.enableSummaries('ProductName');\n     * ```\n     * @param rest\n     */\n\n\n    enableSummaries(...rest) {\n      if (rest.length === 1 && Array.isArray(rest[0])) {\n        this._multipleSummaries(rest[0], true);\n      } else {\n        this._summaries(rest[0], true, rest[1]);\n      }\n    }\n    /**\n     * Disable summaries for the specified column.\n     *\n     * @example\n     * ```typescript\n     * grid.disableSummaries('ProductName');\n     * ```\n     * @remarks\n     * Disable summaries for the listed columns.\n     * @example\n     * ```typescript\n     * grid.disableSummaries([{ fieldName: 'ProductName' }]);\n     * ```\n     */\n\n\n    disableSummaries(...rest) {\n      if (rest.length === 1 && Array.isArray(rest[0])) {\n        this._disableMultipleSummaries(rest[0]);\n      } else {\n        this._summaries(rest[0], false);\n      }\n    }\n    /**\n     * If name is provided, clears the filtering state of the corresponding `IgxColumnComponent`.\n     *\n     * @remarks\n     * Otherwise clears the filtering state of all `IgxColumnComponent`s.\n     * @example\n     * ```typescript\n     * this.grid.clearFilter();\n     * ```\n     * @param name\n     */\n\n\n    clearFilter(name) {\n      this.filteringService.clearFilter(name);\n    }\n    /**\n     * If name is provided, clears the sorting state of the corresponding `IgxColumnComponent`.\n     *\n     * @remarks\n     * otherwise clears the sorting state of all `IgxColumnComponent`.\n     * @example\n     * ```typescript\n     * this.grid.clearSort();\n     * ```\n     * @param name\n     */\n\n\n    clearSort(name) {\n      if (!name) {\n        this.sortingExpressions = [];\n        return;\n      }\n\n      if (!this.gridAPI.get_column_by_name(name)) {\n        return;\n      }\n\n      this.gridAPI.clear_sort(name);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    refreshGridState(_args) {\n      this.crudService.endEdit(true);\n      this.selectionService.clearHeaderCBState();\n      this.summaryService.clearSummaryCache();\n      this.cdr.detectChanges();\n    } // TODO: We have return values here. Move them to event args ??\n\n    /**\n     * Pins a column by field name.\n     *\n     * @remarks\n     * Returns whether the operation is successful.\n     * @example\n     * ```typescript\n     * this.grid.pinColumn(\"ID\");\n     * ```\n     * @param columnName\n     * @param index\n     */\n\n\n    pinColumn(columnName, index) {\n      const col = columnName instanceof IgxColumnComponent ? columnName : this.getColumnByName(columnName);\n      return col.pin(index);\n    }\n    /**\n     * Unpins a column by field name. Returns whether the operation is successful.\n     *\n     * @example\n     * ```typescript\n     * this.grid.pinColumn(\"ID\");\n     * ```\n     * @param columnName\n     * @param index\n     */\n\n\n    unpinColumn(columnName, index) {\n      const col = columnName instanceof IgxColumnComponent ? columnName : this.getColumnByName(columnName);\n      return col.unpin(index);\n    }\n    /**\n     * Pin the row by its id.\n     *\n     * @remarks\n     * ID is either the primaryKey value or the data record instance.\n     * @example\n     * ```typescript\n     * this.grid.pinRow(rowID);\n     * ```\n     * @param rowID The row id - primaryKey value or the data record instance.\n     * @param index The index at which to insert the row in the pinned collection.\n     */\n\n\n    pinRow(rowID, index, row) {\n      if (this._pinnedRecordIDs.indexOf(rowID) !== -1) {\n        return false;\n      }\n\n      const eventArgs = {\n        insertAtIndex: index,\n        isPinned: true,\n        rowID,\n        row,\n        cancel: false\n      };\n      this.rowPinning.emit(eventArgs);\n\n      if (eventArgs.cancel) {\n        return;\n      }\n\n      this.crudService.endEdit(false);\n      const insertIndex = typeof eventArgs.insertAtIndex === 'number' ? eventArgs.insertAtIndex : this._pinnedRecordIDs.length;\n\n      this._pinnedRecordIDs.splice(insertIndex, 0, rowID);\n\n      this.pipeTrigger++;\n\n      if (this.gridAPI.grid) {\n        this.cdr.detectChanges();\n        this.rowPinned.emit(eventArgs);\n      }\n\n      return true;\n    }\n    /**\n     * Unpin the row by its id.\n     *\n     * @remarks\n     * ID is either the primaryKey value or the data record instance.\n     * @example\n     * ```typescript\n     * this.grid.unpinRow(rowID);\n     * ```\n     * @param rowID The row id - primaryKey value or the data record instance.\n     */\n\n\n    unpinRow(rowID, row) {\n      const index = this._pinnedRecordIDs.indexOf(rowID);\n\n      if (index === -1) {\n        return false;\n      }\n\n      const eventArgs = {\n        isPinned: false,\n        rowID,\n        row,\n        cancel: false\n      };\n      this.rowPinning.emit(eventArgs);\n\n      if (eventArgs.cancel) {\n        return;\n      }\n\n      this.crudService.endEdit(false);\n\n      this._pinnedRecordIDs.splice(index, 1);\n\n      this.pipeTrigger++;\n\n      if (this.gridAPI.grid) {\n        this.cdr.detectChanges();\n        this.rowPinned.emit(eventArgs);\n      }\n\n      return true;\n    }\n\n    get pinnedRowHeight() {\n      const containerHeight = this.pinContainer ? this.pinContainer.nativeElement.offsetHeight : 0;\n      return this.hasPinnedRecords ? containerHeight : 0;\n    }\n\n    get totalHeight() {\n      return this.calcHeight ? this.calcHeight + this.pinnedRowHeight : this.calcHeight;\n    }\n    /**\n     * Recalculates grid width/height dimensions.\n     *\n     * @remarks\n     * Should be run when changing DOM elements dimentions manually that affect the grid's size.\n     * @example\n     * ```typescript\n     * this.grid.reflow();\n     * ```\n     */\n\n\n    reflow() {\n      this.calculateGridSizes();\n    }\n    /**\n     * Finds the next occurrence of a given string in the grid and scrolls to the cell if it isn't visible.\n     *\n     * @remarks\n     * Returns how many times the grid contains the string.\n     * @example\n     * ```typescript\n     * this.grid.findNext(\"financial\");\n     * ```\n     * @param text the string to search.\n     * @param caseSensitive optionally, if the search should be case sensitive (defaults to false).\n     * @param exactMatch optionally, if the text should match the entire value  (defaults to false).\n     */\n\n\n    findNext(text, caseSensitive, exactMatch) {\n      return this.find(text, 1, caseSensitive, exactMatch);\n    }\n    /**\n     * Finds the previous occurrence of a given string in the grid and scrolls to the cell if it isn't visible.\n     *\n     * @remarks\n     * Returns how many times the grid contains the string.\n     * @example\n     * ```typescript\n     * this.grid.findPrev(\"financial\");\n     * ```\n     * @param text the string to search.\n     * @param caseSensitive optionally, if the search should be case sensitive (defaults to false).\n     * @param exactMatch optionally, if the text should match the entire value (defaults to false).\n     */\n\n\n    findPrev(text, caseSensitive, exactMatch) {\n      return this.find(text, -1, caseSensitive, exactMatch);\n    }\n    /**\n     * Reapplies the existing search.\n     *\n     * @remarks\n     * Returns how many times the grid contains the last search.\n     * @example\n     * ```typescript\n     * this.grid.refreshSearch();\n     * ```\n     * @param updateActiveInfo\n     */\n\n\n    refreshSearch(updateActiveInfo, endEdit = true) {\n      if (this.lastSearchInfo.searchText) {\n        this.rebuildMatchCache();\n\n        if (updateActiveInfo) {\n          const activeInfo = IgxTextHighlightDirective.highlightGroupsMap.get(this.id);\n          this.lastSearchInfo.matchInfoCache.forEach((match, i) => {\n            if (match.column === activeInfo.column && match.row === activeInfo.row && match.index === activeInfo.index && compareMaps(match.metadata, activeInfo.metadata)) {\n              this.lastSearchInfo.activeMatchIndex = i;\n            }\n          });\n        }\n\n        return this.find(this.lastSearchInfo.searchText, 0, this.lastSearchInfo.caseSensitive, this.lastSearchInfo.exactMatch, false, endEdit);\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * Removes all the highlights in the cell.\n     *\n     * @example\n     * ```typescript\n     * this.grid.clearSearch();\n     * ```\n     */\n\n\n    clearSearch() {\n      this.lastSearchInfo = {\n        searchText: '',\n        caseSensitive: false,\n        exactMatch: false,\n        activeMatchIndex: 0,\n        matchInfoCache: []\n      };\n      this.rowList.forEach(row => {\n        if (row.cells) {\n          row.cells.forEach(c => {\n            c.clearHighlight();\n          });\n        }\n      });\n    }\n    /**\n     * Returns if the `IgxGridComponent` has sortable columns.\n     *\n     * @example\n     * ```typescript\n     * const sortableGrid = this.grid.hasSortableColumns;\n     * ```\n     */\n\n\n    get hasSortableColumns() {\n      return this.columnList.some(col => col.sortable);\n    }\n    /**\n     * Returns if the `IgxGridComponent` has editable columns.\n     *\n     * @example\n     * ```typescript\n     * const editableGrid = this.grid.hasEditableColumns;\n     * ```\n     */\n\n\n    get hasEditableColumns() {\n      return this.columnList.some(col => col.editable);\n    }\n    /**\n     * Returns if the `IgxGridComponent` has filterable columns.\n     *\n     * @example\n     * ```typescript\n     * const filterableGrid = this.grid.hasFilterableColumns;\n     * ```\n     */\n\n\n    get hasFilterableColumns() {\n      return this.columnList.some(col => col.filterable);\n    }\n    /**\n     * Returns if the `IgxGridComponent` has summarized columns.\n     *\n     * @example\n     * ```typescript\n     * const summarizedGrid = this.grid.hasSummarizedColumns;\n     * ```\n     */\n\n\n    get hasSummarizedColumns() {\n      const summarizedColumns = this.columnList.filter(col => col.hasSummary && !col.hidden);\n      return summarizedColumns.length > 0;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get rootSummariesEnabled() {\n      return this.summaryCalculationMode !== GridSummaryCalculationMode.childLevelsOnly;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get hasVisibleColumns() {\n      if (this._hasVisibleColumns === undefined) {\n        return this.columnList ? this.columnList.some(c => !c.hidden) : false;\n      }\n\n      return this._hasVisibleColumns;\n    }\n\n    set hasVisibleColumns(value) {\n      this._hasVisibleColumns = value;\n    }\n    /**\n     * Returns if the `IgxGridComponent` has moveable columns.\n     *\n     * @deprecated\n     * Use `IgxGridComponent.moving` instead.\n     *\n     * @example\n     * ```typescript\n     * const movableGrid = this.grid.hasMovableColumns;\n     * ```\n     */\n\n\n    get hasMovableColumns() {\n      return this.moving;\n    }\n    /**\n     * Returns if the `IgxGridComponent` has column groups.\n     *\n     * @example\n     * ```typescript\n     * const groupGrid = this.grid.hasColumnGroups;\n     * ```\n     */\n\n\n    get hasColumnGroups() {\n      return this._columnGroups;\n    }\n    /**\n     * Returns if the `IgxGridComponent` has column layouts for multi-row layout definition.\n     *\n     * @example\n     * ```typescript\n     * const layoutGrid = this.grid.hasColumnLayouts;\n     * ```\n     */\n\n\n    get hasColumnLayouts() {\n      return !!this.columnList.some(col => col.columnLayout);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get multiRowLayoutRowSize() {\n      return this._multiRowLayoutRowSize;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get rowBasedHeight() {\n      return this.dataLength * this.rowHeight;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isPercentWidth() {\n      return this.width && this.width.indexOf('%') !== -1;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get isPercentHeight() {\n      return this._height && this._height.indexOf('%') !== -1;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get defaultTargetBodyHeight() {\n      const allItems = this.dataLength;\n      return this.renderedRowHeight * Math.min(this._defaultTargetRecordNumber, this.paginator ? Math.min(allItems, this.paginator.perPage) : allItems);\n    }\n    /**\n     * @hidden @internal\n     * The rowHeight input is bound to min-height css prop of rows that adds a 1px border in all cases\n     */\n\n\n    get renderedRowHeight() {\n      return this.rowHeight + 1;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get outerWidth() {\n      return this.hasVerticalScroll() ? this.calcWidth + this.scrollSize : this.calcWidth;\n    }\n    /**\n     * @hidden @internal\n     * Gets the visible content height that includes header + tbody + footer.\n     */\n\n\n    getVisibleContentHeight() {\n      let height = this.theadRow.nativeElement.clientHeight + this.tbody.nativeElement.clientHeight;\n\n      if (this.hasSummarizedColumns) {\n        height += this.tfoot.nativeElement.clientHeight;\n      }\n\n      return height;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    getPossibleColumnWidth(baseWidth = null) {\n      let computedWidth;\n\n      if (baseWidth !== null) {\n        computedWidth = baseWidth;\n      } else {\n        computedWidth = this.calcWidth || parseInt(this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('width'), 10);\n      }\n\n      computedWidth -= this.featureColumnsWidth();\n      const visibleChildColumns = this.visibleColumns.filter(c => !c.columnGroup); // Column layouts related\n\n      let visibleCols = [];\n      const columnBlocks = this.visibleColumns.filter(c => c.columnGroup);\n      const colsPerBlock = columnBlocks.map(block => block.getInitialChildColumnSizes(block.children));\n      const combinedBlocksSize = colsPerBlock.reduce((acc, item) => acc + item.length, 0);\n      colsPerBlock.forEach(blockCols => visibleCols = visibleCols.concat(blockCols)); //\n\n      const columnsWithSetWidths = this.hasColumnLayouts ? visibleCols.filter(c => c.widthSetByUser) : visibleChildColumns.filter(c => c.widthSetByUser);\n      const columnsToSize = this.hasColumnLayouts ? combinedBlocksSize - columnsWithSetWidths.length : visibleChildColumns.length - columnsWithSetWidths.length;\n      const sumExistingWidths = columnsWithSetWidths.reduce((prev, curr) => {\n        const colWidth = curr.width;\n        const widthValue = parseInt(colWidth, 10);\n        const currWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1 ? widthValue / 100 * computedWidth : widthValue;\n        return prev + currWidth;\n      }, 0); // When all columns are hidden, return 0px width\n\n      if (!sumExistingWidths && !columnsToSize) {\n        return '0px';\n      }\n\n      const columnWidth = Math.floor(!Number.isFinite(sumExistingWidths) ? Math.max(computedWidth / columnsToSize, MINIMUM_COLUMN_WIDTH$2) : Math.max((computedWidth - sumExistingWidths) / columnsToSize, MINIMUM_COLUMN_WIDTH$2));\n      return columnWidth + 'px';\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    hasVerticalScroll() {\n      if (this._init) {\n        return false;\n      }\n\n      const isScrollable = this.verticalScrollContainer ? this.verticalScrollContainer.isScrollable() : false;\n      return !!(this.calcWidth && this.dataView && this.dataView.length > 0 && isScrollable);\n    }\n    /**\n     * Gets calculated width of the pinned area.\n     *\n     * @example\n     * ```typescript\n     * const pinnedWidth = this.grid.getPinnedWidth();\n     * ```\n     * @param takeHidden If we should take into account the hidden columns in the pinned area.\n     */\n\n\n    getPinnedWidth(takeHidden = false) {\n      const fc = takeHidden ? this._pinnedColumns : this.pinnedColumns;\n      let sum = 0;\n\n      for (const col of fc) {\n        if (col.level === 0) {\n          sum += parseInt(col.calcWidth, 10);\n        }\n      }\n\n      if (this.isPinningToStart) {\n        sum += this.featureColumnsWidth();\n      }\n\n      return sum;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    isColumnGrouped(_fieldName) {\n      return false;\n    }\n    /**\n     * @hidden @internal\n     * TODO: REMOVE\n     */\n\n\n    onHeaderSelectorClick(event) {\n      if (!this.isMultiRowSelectionEnabled) {\n        return;\n      }\n\n      if (this.selectionService.areAllRowSelected()) {\n        this.selectionService.clearRowSelection(event);\n      } else {\n        this.selectionService.selectAllRows(event);\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get headSelectorBaseAriaLabel() {\n      if (this._filteringExpressionsTree.filteringOperands.length > 0) {\n        return this.selectionService.areAllRowSelected() ? 'Deselect all filtered' : 'Select all filtered';\n      }\n\n      return this.selectionService.areAllRowSelected() ? 'Deselect all' : 'Select all';\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get totalRowsCountAfterFilter() {\n      if (this.data) {\n        return this.selectionService.allData.length;\n      }\n\n      return 0;\n    }\n    /**\n     * Returns the currently transformed paged/filtered/sorted/grouped pinned row data, displayed in the grid.\n     *\n     * @example\n     * ```typescript\n     *      const pinnedDataView = this.grid.pinnedDataView;\n     * ```\n     */\n\n\n    get pinnedDataView() {\n      return this.pinnedRecords ? this.pinnedRecords : [];\n    }\n    /**\n     * Returns currently transformed paged/filtered/sorted/grouped unpinned row data, displayed in the grid.\n     *\n     * @example\n     * ```typescript\n     *      const pinnedDataView = this.grid.pinnedDataView;\n     * ```\n     */\n\n\n    get unpinnedDataView() {\n      var _a;\n\n      return this.unpinnedRecords ? this.unpinnedRecords : ((_a = this.verticalScrollContainer) === null || _a === void 0 ? void 0 : _a.igxForOf) || [];\n    }\n    /**\n     * Returns the currently transformed paged/filtered/sorted/grouped/pinned/unpinned row data, displayed in the grid.\n     *\n     * @example\n     * ```typescript\n     *      const dataView = this.grid.dataView;\n     * ```\n     */\n\n\n    get dataView() {\n      return this._dataView;\n    }\n    /**\n     * Gets/Sets whether clicking over a row should select/deselect it\n     *\n     * @remarks\n     * By default it is set to true\n     * @param enabled: boolean\n     */\n\n\n    get selectRowOnClick() {\n      return this._selectRowOnClick;\n    }\n\n    set selectRowOnClick(enabled) {\n      this._selectRowOnClick = enabled;\n    }\n    /**\n     * Select specified rows by ID.\n     *\n     * @example\n     * ```typescript\n     * this.grid.selectRows([1,2,5], true);\n     * ```\n     * @param rowIDs\n     * @param clearCurrentSelection if true clears the current selection\n     */\n\n\n    selectRows(rowIDs, clearCurrentSelection) {\n      this.selectionService.selectRowsWithNoEvent(rowIDs, clearCurrentSelection);\n      this.notifyChanges();\n    }\n    /**\n     * Deselect specified rows by ID.\n     *\n     * @example\n     * ```typescript\n     * this.grid.deselectRows([1,2,5]);\n     * ```\n     * @param rowIDs\n     */\n\n\n    deselectRows(rowIDs) {\n      this.selectionService.deselectRowsWithNoEvent(rowIDs);\n      this.notifyChanges();\n    }\n    /**\n     * Selects all rows\n     *\n     * @remarks\n     * By default if filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.\n     * If you set the parameter onlyFilterData to false that will select all rows in the grid exept deleted rows.\n     * @example\n     * ```typescript\n     * this.grid.selectAllRows();\n     * this.grid.selectAllRows(false);\n     * ```\n     * @param onlyFilterData\n     */\n\n\n    selectAllRows(onlyFilterData = true) {\n      const data = onlyFilterData && this.filteredData ? this.filteredData : this.gridAPI.get_all_data(true);\n      const rowIDs = this.selectionService.getRowIDs(data).filter(rID => !this.gridAPI.row_deleted_transaction(rID));\n      this.selectRows(rowIDs);\n    }\n    /**\n     * Deselects all rows\n     *\n     * @remarks\n     * By default if filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.\n     * If you set the parameter onlyFilterData to false that will deselect all rows in the grid exept deleted rows.\n     * @example\n     * ```typescript\n     * this.grid.deselectAllRows();\n     * ```\n     * @param onlyFilterData\n     */\n\n\n    deselectAllRows(onlyFilterData = true) {\n      if (onlyFilterData && this.filteredData && this.filteredData.length > 0) {\n        this.deselectRows(this.selectionService.getRowIDs(this.filteredData));\n      } else {\n        this.selectionService.clearAllSelectedRows();\n        this.notifyChanges();\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    clearCellSelection() {\n      this.selectionService.clear(true);\n      this.notifyChanges();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    dragScroll(delta) {\n      const horizontal = this.headerContainer.getScroll();\n      const vertical = this.verticalScrollContainer.getScroll();\n      const {\n        left,\n        top\n      } = delta;\n      horizontal.scrollLeft += left * this.DRAG_SCROLL_DELTA;\n      vertical.scrollTop += top * this.DRAG_SCROLL_DELTA;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    isDefined(arg) {\n      return arg !== undefined && arg !== null;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    selectRange(arg) {\n      if (!this.isDefined(arg)) {\n        this.clearCellSelection();\n        return;\n      }\n\n      if (arg instanceof Array) {\n        arg.forEach(range => this.setSelection(range));\n      } else {\n        this.setSelection(arg);\n      }\n\n      this.notifyChanges();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    columnToVisibleIndex(field) {\n      const visibleColumns = this.visibleColumns;\n\n      if (typeof field === 'number') {\n        return field;\n      }\n\n      return visibleColumns.find(column => column.field === field).visibleIndex;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    setSelection(range) {\n      const startNode = {\n        row: range.rowStart,\n        column: this.columnToVisibleIndex(range.columnStart)\n      };\n      const endNode = {\n        row: range.rowEnd,\n        column: this.columnToVisibleIndex(range.columnEnd)\n      };\n      this.selectionService.pointerState.node = startNode;\n      this.selectionService.selectRange(endNode, this.selectionService.pointerState);\n      this.selectionService.addRangeMeta(endNode, this.selectionService.pointerState);\n      this.selectionService.initPointerState();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    getSelectedRanges() {\n      return this.selectionService.ranges;\n    }\n    /**\n     *\n     * Returns an array of the current cell selection in the form of `[{ column.field: cell.value }, ...]`.\n     *\n     * @remarks\n     * If `formatters` is enabled, the cell value will be formatted by its respective column formatter (if any).\n     * If `headers` is enabled, it will use the column header (if any) instead of the column field.\n     */\n\n\n    getSelectedData(formatters = false, headers = false) {\n      const source = this.filteredSortedData;\n      return this.extractDataFromSelection(source, formatters, headers);\n    }\n    /**\n     * Get current selected columns.\n     *\n     * @example\n     * Returns an array with selected columns\n     * ```typescript\n     * const selectedColumns = this.grid.selectedColumns();\n     * ```\n     */\n\n\n    selectedColumns() {\n      const fields = this.selectionService.getSelectedColumns();\n      return fields.map(field => this.getColumnByName(field)).filter(field => field);\n    }\n    /**\n     * Select specified columns.\n     *\n     * @example\n     * ```typescript\n     * this.grid.selectColumns(['ID','Name'], true);\n     * ```\n     * @param columns\n     * @param clearCurrentSelection if true clears the current selection\n     */\n\n\n    selectColumns(columns, clearCurrentSelection) {\n      let fieldToSelect = [];\n\n      if (columns.length === 0 || typeof columns[0] === 'string') {\n        fieldToSelect = columns;\n      } else {\n        columns.forEach(col => {\n          if (col.columnGroup) {\n            const children = col.allChildren.filter(c => !c.columnGroup).map(c => c.field);\n            fieldToSelect = [...fieldToSelect, ...children];\n          } else {\n            fieldToSelect.push(col.field);\n          }\n        });\n      }\n\n      this.selectionService.selectColumnsWithNoEvent(fieldToSelect, clearCurrentSelection);\n      this.notifyChanges();\n    }\n    /**\n     * Deselect specified columns by field.\n     *\n     * @example\n     * ```typescript\n     * this.grid.deselectColumns(['ID','Name']);\n     * ```\n     * @param columns\n     */\n\n\n    deselectColumns(columns) {\n      let fieldToDeselect = [];\n\n      if (columns.length === 0 || typeof columns[0] === 'string') {\n        fieldToDeselect = columns;\n      } else {\n        columns.forEach(col => {\n          if (col.columnGroup) {\n            const children = col.allChildren.filter(c => !c.columnGroup).map(c => c.field);\n            fieldToDeselect = [...fieldToDeselect, ...children];\n          } else {\n            fieldToDeselect.push(col.field);\n          }\n        });\n      }\n\n      this.selectionService.deselectColumnsWithNoEvent(fieldToDeselect);\n      this.notifyChanges();\n    }\n    /**\n     * Deselects all columns\n     *\n     * @example\n     * ```typescript\n     * this.grid.deselectAllColumns();\n     * ```\n     */\n\n\n    deselectAllColumns() {\n      this.selectionService.clearAllSelectedColumns();\n      this.notifyChanges();\n    }\n    /**\n     * Selects all columns\n     *\n     * @example\n     * ```typescript\n     * this.grid.deselectAllColumns();\n     * ```\n     */\n\n\n    selectAllColumns() {\n      this.selectColumns(this.columnList.filter(c => !c.columnGroup));\n    }\n    /**\n     *\n     * Returns an array of the current columns selection in the form of `[{ column.field: cell.value }, ...]`.\n     *\n     * @remarks\n     * If `formatters` is enabled, the cell value will be formatted by its respective column formatter (if any).\n     * If `headers` is enabled, it will use the column header (if any) instead of the column field.\n     */\n\n\n    getSelectedColumnsData(formatters = false, headers = false) {\n      const source = this.filteredSortedData ? this.filteredSortedData : this.data;\n      return this.extractDataFromColumnsSelection(source, formatters, headers);\n    }\n\n    combineSelectedCellAndColumnData(columnData, formatters = false, headers = false) {\n      const source = this.filteredSortedData;\n      return this.extractDataFromSelection(source, formatters, headers, columnData);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    copyHandler(event) {\n      const selectedColumns = this.gridAPI.grid.selectedColumns();\n      const columnData = this.getSelectedColumnsData(this.clipboardOptions.copyFormatters, this.clipboardOptions.copyHeaders);\n      let selectedData;\n\n      if (event.type === 'copy') {\n        selectedData = this.getSelectedData(this.clipboardOptions.copyFormatters, this.clipboardOptions.copyHeaders);\n      }\n\n      ;\n      let data = [];\n      let result;\n\n      if (event.code === 'KeyC' && (event.ctrlKey || event.metaKey) && event.currentTarget.className === 'igx-grid-thead__wrapper') {\n        if (selectedData.length) {\n          if (columnData.length === 0) {\n            result = this.prepareCopyData(event, selectedData);\n          } else {\n            data = this.combineSelectedCellAndColumnData(columnData, this.clipboardOptions.copyFormatters, this.clipboardOptions.copyHeaders);\n            result = this.prepareCopyData(event, data[0], data[1]);\n          }\n        } else {\n          data = columnData;\n          result = this.prepareCopyData(event, data);\n        }\n\n        navigator.clipboard.writeText(result).then().catch(e => console.error(e));\n      } else if (!this.clipboardOptions.enabled || this.crudService.cellInEditMode || event.type === 'keydown') {\n        return;\n      } else {\n        if (selectedColumns.length) {\n          data = this.combineSelectedCellAndColumnData(columnData, this.clipboardOptions.copyFormatters, this.clipboardOptions.copyHeaders);\n          result = this.prepareCopyData(event, data[0], data[1]);\n        } else {\n          data = selectedData;\n          result = this.prepareCopyData(event, data);\n        }\n\n        event.clipboardData.setData('text/plain', result);\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    prepareCopyData(event, data, keys) {\n      const ev = {\n        data,\n        cancel: false\n      };\n      this.gridCopy.emit(ev);\n\n      if (ev.cancel) {\n        return;\n      }\n\n      const transformer = new CharSeparatedValueData(ev.data, this.clipboardOptions.separator);\n      let result = keys ? transformer.prepareData(keys) : transformer.prepareData();\n\n      if (!this.clipboardOptions.copyHeaders) {\n        result = result.substring(result.indexOf('\\n') + 1);\n      }\n\n      if (data && data.length > 0 && Object.values(data[0]).length === 1) {\n        result = result.slice(0, -2);\n      }\n\n      event.preventDefault();\n      /* Necessary for the hiearachical case but will probably have to\n         change how getSelectedData is propagated in the hiearachical grid\n      */\n\n      event.stopPropagation();\n      return result;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    showSnackbarFor(index) {\n      this.addRowSnackbar.actionText = index === -1 ? '' : this.snackbarActionText;\n      this.lastAddedRowIndex = index;\n      this.addRowSnackbar.open();\n    }\n    /**\n     * Navigates to a position in the grid based on provided `rowindex` and `visibleColumnIndex`.\n     *\n     * @remarks\n     * Also can execute a custom logic over the target element,\n     * through a callback function that accepts { targetType: GridKeydownTargetType, target: Object }\n     * @example\n     * ```typescript\n     *  this.grid.navigateTo(10, 3, (args) => { args.target.nativeElement.focus(); });\n     * ```\n     */\n\n\n    navigateTo(rowIndex, visibleColIndex = -1, cb = null) {\n      var _a;\n\n      const totalItems = (_a = this.totalItemCount) !== null && _a !== void 0 ? _a : this.dataView.length - 1;\n\n      if (rowIndex < 0 || rowIndex > totalItems || visibleColIndex !== -1 && this.columnList.map(col => col.visibleIndex).indexOf(visibleColIndex) === -1) {\n        return;\n      }\n\n      if (this.dataView.slice(rowIndex, rowIndex + 1).find(rec => rec.expression || rec.childGridsData)) {\n        visibleColIndex = -1;\n      } // If the target row is pinned no need to scroll as well.\n\n\n      const shouldScrollVertically = this.navigation.shouldPerformVerticalScroll(rowIndex, visibleColIndex);\n      const shouldScrollHorizontally = this.navigation.shouldPerformHorizontalScroll(visibleColIndex, rowIndex);\n\n      if (shouldScrollVertically) {\n        this.navigation.performVerticalScrollToCell(rowIndex, visibleColIndex, () => {\n          if (shouldScrollHorizontally) {\n            this.navigation.performHorizontalScrollToCell(visibleColIndex, () => this.executeCallback(rowIndex, visibleColIndex, cb));\n          } else {\n            this.executeCallback(rowIndex, visibleColIndex, cb);\n          }\n        });\n      } else if (shouldScrollHorizontally) {\n        this.navigation.performHorizontalScrollToCell(visibleColIndex, () => {\n          if (shouldScrollVertically) {\n            this.navigation.performVerticalScrollToCell(rowIndex, visibleColIndex, () => this.executeCallback(rowIndex, visibleColIndex, cb));\n          } else {\n            this.executeCallback(rowIndex, visibleColIndex, cb);\n          }\n        });\n      } else {\n        this.executeCallback(rowIndex, visibleColIndex, cb);\n      }\n    }\n    /**\n     * Returns `ICellPosition` which defines the next cell,\n     * according to the current position, that match specific criteria.\n     *\n     * @remarks\n     * You can pass callback function as a third parameter of `getPreviousCell` method.\n     * The callback function accepts IgxColumnComponent as a param\n     * @example\n     * ```typescript\n     *  const nextEditableCellPosition = this.grid.getNextCell(0, 3, (column) => column.editable);\n     * ```\n     */\n\n\n    getNextCell(currRowIndex, curVisibleColIndex, callback = null) {\n      const columns = this.columnList.filter(col => !col.columnGroup && col.visibleIndex >= 0);\n\n      const dataViewIndex = this._getDataViewIndex(currRowIndex);\n\n      if (!this.isValidPosition(dataViewIndex, curVisibleColIndex)) {\n        return {\n          rowIndex: currRowIndex,\n          visibleColumnIndex: curVisibleColIndex\n        };\n      }\n\n      const colIndexes = callback ? columns.filter(col => callback(col)).map(editCol => editCol.visibleIndex).sort((a, b) => a - b) : columns.map(editCol => editCol.visibleIndex).sort((a, b) => a - b);\n      const nextCellIndex = colIndexes.find(index => index > curVisibleColIndex);\n\n      if (this.dataView.slice(dataViewIndex, dataViewIndex + 1).find(rec => !rec.expression && !rec.summaries && !rec.childGridsData && !rec.detailsData) && nextCellIndex !== undefined) {\n        return {\n          rowIndex: currRowIndex,\n          visibleColumnIndex: nextCellIndex\n        };\n      } else {\n        const nextIndex = this.getNextDataRowIndex(currRowIndex);\n\n        if (colIndexes.length === 0 || nextIndex === currRowIndex) {\n          return {\n            rowIndex: currRowIndex,\n            visibleColumnIndex: curVisibleColIndex\n          };\n        } else {\n          return {\n            rowIndex: nextIndex,\n            visibleColumnIndex: colIndexes[0]\n          };\n        }\n      }\n    }\n    /**\n     * Returns `ICellPosition` which defines the previous cell,\n     * according to the current position, that match specific criteria.\n     *\n     * @remarks\n     * You can pass callback function as a third parameter of `getPreviousCell` method.\n     * The callback function accepts IgxColumnComponent as a param\n     * @example\n     * ```typescript\n     *  const previousEditableCellPosition = this.grid.getPreviousCell(0, 3, (column) => column.editable);\n     * ```\n     */\n\n\n    getPreviousCell(currRowIndex, curVisibleColIndex, callback = null) {\n      const columns = this.columnList.filter(col => !col.columnGroup && col.visibleIndex >= 0);\n\n      const dataViewIndex = this._getDataViewIndex(currRowIndex);\n\n      if (!this.isValidPosition(dataViewIndex, curVisibleColIndex)) {\n        return {\n          rowIndex: currRowIndex,\n          visibleColumnIndex: curVisibleColIndex\n        };\n      }\n\n      const colIndexes = callback ? columns.filter(col => callback(col)).map(editCol => editCol.visibleIndex).sort((a, b) => b - a) : columns.map(editCol => editCol.visibleIndex).sort((a, b) => b - a);\n      const prevCellIndex = colIndexes.find(index => index < curVisibleColIndex);\n\n      if (this.dataView.slice(dataViewIndex, dataViewIndex + 1).find(rec => !rec.expression && !rec.summaries && !rec.childGridsData && !rec.detailsData) && prevCellIndex !== undefined) {\n        return {\n          rowIndex: currRowIndex,\n          visibleColumnIndex: prevCellIndex\n        };\n      } else {\n        const prevIndex = this.getNextDataRowIndex(currRowIndex, true);\n\n        if (colIndexes.length === 0 || prevIndex === currRowIndex) {\n          return {\n            rowIndex: currRowIndex,\n            visibleColumnIndex: curVisibleColIndex\n          };\n        } else {\n          return {\n            rowIndex: prevIndex,\n            visibleColumnIndex: colIndexes[0]\n          };\n        }\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    endRowEditTabStop(commit = true, event) {\n      const canceled = this.crudService.endEdit(commit, event);\n\n      if (canceled) {\n        return true;\n      }\n\n      const activeCell = this.gridAPI.grid.navigation.activeNode;\n\n      if (activeCell && activeCell.row !== -1) {\n        this.tbody.nativeElement.focus();\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    trackColumnChanges(index, col) {\n      return col.field + col._calcWidth;\n    }\n    /**\n     * @hidden\n     */\n\n\n    isExpandedGroup(_group) {\n      return undefined;\n    }\n    /**\n     * @hidden @internal\n     * TODO: MOVE to CRUD\n     */\n\n\n    openRowOverlay(id) {\n      this.configureRowEditingOverlay(id, this.rowList.length <= MIN_ROW_EDITING_COUNT_THRESHOLD);\n      this.rowEditingOverlay.open(this.rowEditSettings);\n      this.rowEditingOverlay.element.addEventListener('wheel', this.rowEditingWheelHandler.bind(this));\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    closeRowEditingOverlay() {\n      this.rowEditingOverlay.element.removeEventListener('wheel', this.rowEditingWheelHandler);\n      this.rowEditPositioningStrategy.isTopInitialPosition = null;\n      this.rowEditingOverlay.close();\n      this.rowEditingOverlay.element.parentElement.style.display = '';\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    toggleRowEditingOverlay(show) {\n      const rowStyle = this.rowEditingOverlay.element.style;\n\n      if (show) {\n        rowStyle.display = 'block';\n      } else {\n        rowStyle.display = 'none';\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    repositionRowEditingOverlay(row) {\n      if (row && !this.rowEditingOverlay.collapsed) {\n        const rowStyle = this.rowEditingOverlay.element.parentElement.style;\n\n        if (row) {\n          rowStyle.display = '';\n          this.configureRowEditingOverlay(row.key);\n          this.rowEditingOverlay.reposition();\n        } else {\n          rowStyle.display = 'none';\n        }\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    cachedViewLoaded(args) {\n      if (this.hasHorizontalScroll()) {\n        const tmplId = args.context.templateID.type;\n        const index = args.context.index;\n        args.view.detectChanges();\n        this.zone.onStable.pipe(first$1()).subscribe(() => {\n          const row = tmplId === 'dataRow' ? this.gridAPI.get_row_by_index(index) : null;\n          const summaryRow = tmplId === 'summaryRow' ? this.summariesRowList.find(sr => sr.dataRowIndex === index) : null;\n\n          if (row && row instanceof IgxRowDirective) {\n            this._restoreVirtState(row);\n          } else if (summaryRow) {\n            this._restoreVirtState(summaryRow);\n          }\n        });\n      }\n    }\n    /**\n     * Opens the advanced filtering dialog.\n     */\n\n\n    openAdvancedFilteringDialog(overlaySettings) {\n      const settings = overlaySettings ? overlaySettings : this._advancedFilteringOverlaySettings;\n\n      if (!this._advancedFilteringOverlayId) {\n        this._advancedFilteringOverlaySettings.target = this.rootGrid ? this.rootGrid.nativeElement : this.nativeElement;\n        this._advancedFilteringOverlaySettings.outlet = this.outlet;\n        this._advancedFilteringOverlayId = this.overlayService.attach(IgxAdvancedFilteringDialogComponent, settings, {\n          injector: this.viewRef.injector,\n          componentFactoryResolver: this.resolver\n        });\n        this.overlayService.show(this._advancedFilteringOverlayId);\n      }\n    }\n    /**\n     * Closes the advanced filtering dialog.\n     *\n     * @param applyChanges indicates whether the changes should be applied\n     */\n\n\n    closeAdvancedFilteringDialog(applyChanges) {\n      if (this._advancedFilteringOverlayId) {\n        const advancedFilteringOverlay = this.overlayService.getOverlayById(this._advancedFilteringOverlayId);\n        const advancedFilteringDialog = advancedFilteringOverlay.componentRef.instance;\n\n        if (applyChanges) {\n          advancedFilteringDialog.applyChanges();\n        }\n\n        advancedFilteringDialog.closeDialog();\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    getEmptyRecordObjectFor(inRow) {\n      const row = Object.assign({}, inRow === null || inRow === void 0 ? void 0 : inRow.data);\n      Object.keys(row).forEach(key => row[key] = undefined);\n      const id = this.generateRowID();\n      row[this.primaryKey] = id;\n      return {\n        rowID: id,\n        data: row,\n        recordRef: row\n      };\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    hasHorizontalScroll() {\n      return this.totalWidth - this.unpinnedWidth > 0;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    isSummaryRow(rowData) {\n      return rowData && rowData.summaries && rowData.summaries instanceof Map;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    triggerPipes() {\n      this.pipeTrigger++;\n      this.cdr.detectChanges();\n    }\n    /**\n     * @hidden\n     */\n\n\n    rowEditingWheelHandler(event) {\n      if (event.deltaY > 0) {\n        this.verticalScrollContainer.scrollNext();\n      } else {\n        this.verticalScrollContainer.scrollPrev();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    getUnpinnedIndexById(id) {\n      return this.unpinnedRecords.findIndex(x => x[this.primaryKey] === id);\n    }\n    /**\n     * Finishes the row transactions on the current row.\n     *\n     * @remarks\n     * If `commit === true`, passes them from the pending state to the data (or transaction service)\n     * @example\n     * ```html\n     * <button igxButton (click)=\"grid.endEdit(true)\">Commit Row</button>\n     * ```\n     * @param commit\n     */\n    // TODO: Facade for crud service refactoring. To be removed\n    // TODO: do not remove this, as it is used in rowEditTemplate, but mark is as internal and hidden\n\n\n    endEdit(commit = true, event) {\n      this.crudService.endEdit(commit, event);\n    }\n    /**\n     * Enters add mode by spawning the UI under the specified row by rowID.\n     *\n     * @remarks\n     * If null is passed as rowID, the row adding UI is spawned as the first record in the data view\n     * @remarks\n     * Spawning the UI to add a child for a record only works if you provide a rowID\n     * @example\n     * ```typescript\n     * this.grid.beginAddRowById('ALFKI');\n     * this.grid.beginAddRowById('ALFKI', true);\n     * this.grid.beginAddRowById(null);\n     * ```\n     * @param rowID - The rowID to spawn the add row UI for, or null to spawn it as the first record in the data view\n     * @param asChild - Whether the record should be added as a child. Only applicable to igxTreeGrid.\n     */\n\n\n    beginAddRowById(rowID, asChild) {\n      let index = rowID;\n\n      if (rowID == null) {\n        if (asChild) {\n          console.warn('The record cannot be added as a child to an unspecified record.');\n          return;\n        }\n\n        index = null;\n      } else {\n        // find the index of the record with that PK\n        index = this.gridAPI.get_rec_index_by_id(rowID, this.dataView);\n\n        if (index === -1) {\n          console.warn('No row with the specified ID was found.');\n          return;\n        }\n      }\n\n      this._addRowForIndex(index, asChild);\n    }\n\n    _addRowForIndex(index, asChild) {\n      if (!this.dataView.length) {\n        this.beginAddRowForIndex(index, asChild);\n        return;\n      } // check if the index is valid - won't support anything outside the data view\n\n\n      if (index >= 0 && index < this.dataView.length) {\n        // check if the index is in the view port\n        if ((index < this.virtualizationState.startIndex || index >= this.virtualizationState.startIndex + this.virtualizationState.chunkSize) && !this.isRecordPinnedByViewIndex(index)) {\n          this.verticalScrollContainer.chunkLoad.pipe(first$1(), takeUntil(this.destroy$)).subscribe(() => {\n            this.beginAddRowForIndex(index, asChild);\n          });\n          this.navigateTo(index);\n          this.notifyChanges(true);\n          return;\n        }\n\n        this.beginAddRowForIndex(index, asChild);\n      } else {\n        console.warn('The row with the specified PK or index is outside of the current data view.');\n      }\n    }\n    /**\n     * Enters add mode by spawning the UI at the specified index.\n     *\n     * @remarks\n     * Accepted values for index are integers from 0 to this.grid.dataView.length\n     * @example\n     * ```typescript\n     * this.grid.beginAddRowByIndex(0);\n     * ```\n     * @param index - The index to spawn the UI at. Accepts integers from 0 to this.grid.dataView.length\n     */\n\n\n    beginAddRowByIndex(index) {\n      if (index === 0) {\n        return this.beginAddRowById(null);\n      }\n\n      return this._addRowForIndex(index - 1);\n    }\n    /**\n     * @hidden\n     */\n\n\n    preventHeaderScroll(args) {\n      if (args.target.scrollLeft !== 0) {\n        this.navigation.forOfDir().getScroll().scrollLeft = args.target.scrollLeft;\n        args.target.scrollLeft = 0;\n      }\n    }\n\n    beginAddRowForIndex(index, asChild = false) {\n      // TODO is row from rowList suitable for enterAddRowMode\n      const row = index == null ? null : this.rowList.find(r => r.index === index);\n\n      if (row !== undefined) {\n        this.crudService.enterAddRowMode(row, asChild);\n      } else {\n        console.warn('No row with the specified PK or index was found.');\n      }\n    }\n\n    switchTransactionService(val) {\n      if (val) {\n        this._transactions = this.transactionFactory.create(\"Base\"\n        /* Base */\n        );\n      } else {\n        this._transactions = this.transactionFactory.create(\"None\"\n        /* None */\n        );\n      }\n\n      if (this.dataCloneStrategy) {\n        this._transactions.cloneStrategy = this.dataCloneStrategy;\n      }\n    }\n\n    subscribeToTransactions() {\n      this.transactionChange$.next();\n      this.transactions.onStateUpdate.pipe(takeUntil(merge(this.destroy$, this.transactionChange$))).subscribe(this.transactionStatusUpdate.bind(this));\n    }\n\n    transactionStatusUpdate(event) {\n      let actions = [];\n\n      if (event.origin === TransactionEventOrigin.REDO) {\n        actions = event.actions ? event.actions.filter(x => x.transaction.type === TransactionType.DELETE) : [];\n      } else if (event.origin === TransactionEventOrigin.UNDO) {\n        actions = event.actions ? event.actions.filter(x => x.transaction.type === TransactionType.ADD) : [];\n      }\n\n      if (actions.length > 0) {\n        for (const action of actions) {\n          if (this.selectionService.isRowSelected(action.transaction.id)) {\n            this.selectionService.deselectRow(action.transaction.id);\n          }\n        }\n      }\n\n      this.selectionService.clearHeaderCBState();\n      this.summaryService.clearSummaryCache();\n      this.pipeTrigger++;\n      this.notifyChanges();\n    }\n\n    writeToData(rowIndex, value) {\n      mergeObjects(this.gridAPI.get_all_data()[rowIndex], value);\n    }\n\n    _restoreVirtState(row) {\n      // check virtualization state of data record added from cache\n      // in case state is no longer valid - update it.\n      const rowForOf = row.virtDirRow;\n      const gridScrLeft = rowForOf.getScroll().scrollLeft;\n      const left = -parseInt(rowForOf.dc.instance._viewContainer.element.nativeElement.style.left, 10);\n      const actualScrollLeft = left + rowForOf.getColumnScrollLeft(rowForOf.state.startIndex);\n\n      if (gridScrLeft !== actualScrollLeft) {\n        rowForOf.onHScroll(gridScrLeft);\n        rowForOf.cdr.detectChanges();\n      }\n    }\n\n    changeRowEditingOverlayStateOnScroll(row) {\n      if (!this.rowEditable || !this.rowEditingOverlay || this.rowEditingOverlay.collapsed) {\n        return;\n      }\n\n      if (!row) {\n        this.toggleRowEditingOverlay(false);\n      } else {\n        this.repositionRowEditingOverlay(row);\n      }\n    }\n    /**\n     * Should be called when data and/or isLoading input changes so that the overlay can be\n     * hidden/shown based on the current value of shouldOverlayLoading\n     */\n\n\n    evaluateLoadingState() {\n      if (this.shouldOverlayLoading) {\n        // a new overlay should be shown\n        const overlaySettings = {\n          outlet: this.loadingOutlet,\n          closeOnOutsideClick: false,\n          positionStrategy: new ContainerPositionStrategy()\n        };\n        this.loadingOverlay.open(overlaySettings);\n      } else {\n        this.loadingOverlay.close();\n      }\n    }\n    /**\n     * @hidden\n     * Sets grid width i.e. this.calcWidth\n     */\n\n\n    calculateGridWidth() {\n      let width;\n\n      if (this.isPercentWidth) {\n        /* width in %*/\n        const computed = this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('width');\n        width = computed.indexOf('%') === -1 ? parseInt(computed, 10) : null;\n      } else {\n        width = parseInt(this.width, 10);\n      }\n\n      if (!width && this.nativeElement) {\n        width = this.nativeElement.offsetWidth;\n      }\n\n      if (this.width === null || !width) {\n        width = this.getColumnWidthSum();\n      }\n\n      if (this.hasVerticalScroll() && this.width !== null) {\n        width -= this.scrollSize;\n      }\n\n      if ((Number.isFinite(width) || width === null) && width !== this.calcWidth) {\n        this.calcWidth = width;\n      }\n\n      this._derivePossibleWidth();\n    }\n    /**\n     * @hidden\n     * Sets columns defaultWidth property\n     */\n\n\n    _derivePossibleWidth() {\n      if (!this.columnWidthSetByUser) {\n        this._columnWidth = this.width !== null ? this.getPossibleColumnWidth() : MINIMUM_COLUMN_WIDTH$2 + 'px';\n      }\n\n      this.columnList.forEach(column => {\n        if (this.hasColumnLayouts && parseInt(this._columnWidth, 10)) {\n          const columnWidthCombined = parseInt(this._columnWidth, 10) * (column.colEnd ? column.colEnd - column.colStart : 1);\n          column.defaultWidth = columnWidthCombined + 'px';\n        } else {\n          // D.K. March 29th, 2021 #9145 Consider min/max width when setting defaultWidth property\n          column.defaultWidth = this.getExtremumBasedColWidth(column);\n          column.resetCaches();\n        }\n      });\n      this.resetCachedWidths();\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    getExtremumBasedColWidth(column) {\n      let width = this._columnWidth;\n\n      if (width && typeof width !== 'string') {\n        width = String(width);\n      }\n\n      const minWidth = width.indexOf('%') === -1 ? column.minWidthPx : column.minWidthPercent;\n      const maxWidth = width.indexOf('%') === -1 ? column.maxWidthPx : column.maxWidthPercent;\n\n      if (column.hidden) {\n        return width;\n      }\n\n      if (minWidth > parseFloat(width)) {\n        width = String(column.minWidth);\n      } else if (maxWidth < parseFloat(width)) {\n        width = String(column.maxWidth);\n      } // if no px or % are defined in maxWidth/minWidth consider it px\n\n\n      if (width.indexOf('%') === -1 && width.indexOf('px') === -1) {\n        width += 'px';\n      }\n\n      return width;\n    }\n\n    resetNotifyChanges() {\n      this._cdrRequestRepaint = false;\n      this._cdrRequests = false;\n    }\n    /** @hidden @internal */\n\n\n    resolveOutlet() {\n      return this._userOutletDirective ? this._userOutletDirective : this._outletDirective;\n    }\n    /**\n     * Reorder columns in the main columnList and _columns collections.\n     *\n     * @hidden\n     */\n\n\n    _moveColumns(from, to, pos) {\n      const list = this.columnList.toArray();\n\n      this._reorderColumns(from, to, pos, list);\n\n      const newList = this._resetColumnList(list);\n\n      this.updateColumns(newList);\n    }\n    /**\n     * Update internal column's collection.\n     * @hidden\n     */\n\n\n    updateColumns(newColumns) {\n      // update internal collections to retain order.\n      this._pinnedColumns = newColumns.filter(c => c.pinned).sort((a, b) => this._pinnedColumns.indexOf(a) - this._pinnedColumns.indexOf(b));\n      this._unpinnedColumns = newColumns.filter(c => !c.pinned);\n      this.columnList.reset(newColumns);\n      this.columnList.notifyOnChanges();\n      this._columns = this.columnList.toArray();\n    }\n    /**\n     * @hidden\n     */\n\n\n    _resetColumnList(list) {\n      if (!list) {\n        list = this.columnList.toArray();\n      }\n\n      let newList = [];\n      list.filter(c => c.level === 0).forEach(p => {\n        newList.push(p);\n\n        if (p.columnGroup) {\n          newList = newList.concat(p.allChildren);\n        }\n      });\n      return newList;\n    }\n    /**\n     * Reorders columns inside the passed column collection.\n     * When reordering column group collection, the collection is not flattened.\n     * In all other cases, the columns collection is flattened, this is why adittional calculations on the dropIndex are done.\n     *\n     * @hidden\n     */\n\n\n    _reorderColumns(from, to, position, columnCollection, inGroup = false) {\n      const fromIndex = columnCollection.indexOf(from);\n      const childColumnsCount = inGroup ? 1 : from.allChildren.length + 1;\n      columnCollection.splice(fromIndex, childColumnsCount);\n      let dropIndex = columnCollection.indexOf(to);\n\n      if (position === DropPosition.AfterDropTarget) {\n        dropIndex++;\n\n        if (!inGroup && to.columnGroup) {\n          dropIndex += to.allChildren.length;\n        }\n      }\n\n      columnCollection.splice(dropIndex, 0, from);\n    }\n    /**\n     * Reorder column group collection.\n     *\n     * @hidden\n     */\n\n\n    _moveChildColumns(parent, from, to, pos) {\n      const buffer = parent.children.toArray();\n\n      this._reorderColumns(from, to, pos, buffer, true);\n\n      parent.children.reset(buffer);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    setupColumns() {\n      if (this.autoGenerate) {\n        this.autogenerateColumns();\n      }\n\n      this.initColumns(this.columnList, col => this.columnInit.emit(col));\n      this.columnListDiffer.diff(this.columnList);\n      this.columnList.changes.pipe(takeUntil(this.destroy$)).subscribe(change => {\n        this.onColumnsChanged(change);\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    deleteRowFromData(rowID, index) {\n      //  if there is a row (index !== 0) delete it\n      //  if there is a row in ADD or UPDATE state change it's state to DELETE\n      if (index !== -1) {\n        if (this.transactions.enabled) {\n          const transaction = {\n            id: rowID,\n            type: TransactionType.DELETE,\n            newValue: null\n          };\n          this.transactions.add(transaction, this.data[index]);\n        } else {\n          this.data.splice(index, 1);\n        }\n      } else {\n        const state = this.transactions.getState(rowID);\n        this.transactions.add({\n          id: rowID,\n          type: TransactionType.DELETE,\n          newValue: null\n        }, state && state.recordRef);\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    getDataBasedBodyHeight() {\n      return !this.data || this.data.length < this._defaultTargetRecordNumber ? 0 : this.defaultTargetBodyHeight;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onPinnedRowsChanged(change) {\n      const diff = this.rowListDiffer.diff(change);\n\n      if (diff) {\n        this.notifyChanges(true);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onColumnsChanged(change) {\n      const diff = this.columnListDiffer.diff(change);\n\n      if (this.autoGenerate && this.columnList.length === 0 && this._autoGeneratedCols.length > 0) {\n        // In Ivy if there are nested conditional templates the content children are re-evaluated\n        // hence autogenerated columns are cleared and need to be reset.\n        this.columnList.reset(this._autoGeneratedCols);\n        return;\n      }\n\n      if (diff) {\n        let added = false;\n        let removed = false;\n        diff.forEachAddedItem(record => {\n          added = true;\n\n          if (record.item.pinned) {\n            this._pinnedColumns.push(record.item);\n          } else {\n            this._unpinnedColumns.push(record.item);\n          }\n        });\n        this.initColumns(this.columnList, col => this.columnInit.emit(col));\n        diff.forEachRemovedItem(record => {\n          const isColumnGroup = record.item instanceof IgxColumnGroupComponent;\n\n          if (!isColumnGroup) {\n            // Clear Grouping\n            this.gridAPI.clear_groupby(record.item.field); // Clear Filtering\n\n            this.filteringService.clear_filter(record.item.field); // Close filter row\n\n            if (this.filteringService.isFilterRowVisible && this.filteringService.filteredColumn && this.filteringService.filteredColumn.field === record.item.field) {\n              this.filteringRow.close();\n            } // Clear Sorting\n\n\n            this.gridAPI.clear_sort(record.item.field); // Remove column selection\n\n            this.selectionService.deselectColumnsWithNoEvent([record.item.field]);\n          }\n\n          removed = true;\n        });\n        this.resetCaches();\n\n        if (added || removed) {\n          this.summaryService.clearSummaryCache();\n          Promise.resolve().then(() => {\n            // `onColumnsChanged` can be executed midway a current detectChange cycle and markForCheck will be ignored then.\n            // This ensures that we will wait for the current cycle to end so we can trigger a new one and ngDoCheck to fire.\n            this.notifyChanges(true);\n          });\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    calculateGridSizes(recalcFeatureWidth = true) {\n      /*\n          TODO: (R.K.) This layered lasagne should be refactored\n          ASAP. The reason I have to reset the caches so many times is because\n          after teach `detectChanges` call they are filled with invalid\n          state. Of course all of this happens midway through the grid\n          sizing process which of course, uses values from the caches, thus resulting\n          in a broken layout.\n      */\n      this.resetCaches(recalcFeatureWidth);\n      this.cdr.detectChanges();\n      const hasScroll = this.hasVerticalScroll();\n      this.calculateGridWidth();\n      this.resetCaches(recalcFeatureWidth);\n      this.cdr.detectChanges();\n      this.calculateGridHeight();\n\n      if (this.rowEditable) {\n        this.repositionRowEditingOverlay(this.crudService.rowInEditMode);\n      }\n\n      if (this.filteringService.isFilterRowVisible) {\n        this.filteringRow.resetChipsArea();\n      }\n\n      this.cdr.detectChanges(); // in case scrollbar has appeared recalc to size correctly.\n\n      if (hasScroll !== this.hasVerticalScroll()) {\n        this.calculateGridWidth();\n        this.cdr.detectChanges();\n      }\n\n      if (this.zone.isStable) {\n        this.zone.run(() => {\n          this._applyWidthHostBinding();\n\n          this.cdr.detectChanges();\n        });\n      } else {\n        this.zone.onStable.pipe(first$1()).subscribe(() => {\n          this.zone.run(() => {\n            this._applyWidthHostBinding();\n          });\n        });\n      }\n\n      this.resetCaches(recalcFeatureWidth);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    calcGridHeadRow() {\n      if (this.maxLevelHeaderDepth) {\n        this._baseFontSize = parseFloat(getComputedStyle(this.document.documentElement).getPropertyValue('font-size'));\n        let minSize = (this.maxLevelHeaderDepth + 1) * this.defaultRowHeight / this._baseFontSize;\n\n        if (this._allowFiltering && this._filterMode === FilterMode.quickFilter) {\n          minSize += (FILTER_ROW_HEIGHT + 1) / this._baseFontSize;\n        }\n\n        this.theadRow.nativeElement.style.minHeight = `${minSize}rem`;\n      }\n    }\n    /**\n     * @hidden\n     * Sets TBODY height i.e. this.calcHeight\n     */\n\n\n    calculateGridHeight() {\n      this.calcGridHeadRow();\n      this.calcHeight = this._calculateGridBodyHeight();\n\n      if (this.pinnedRowHeight && this.calcHeight) {\n        this.calcHeight -= this.pinnedRowHeight;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    getGroupAreaHeight() {\n      return 0;\n    }\n    /**\n     * @hidden\n     */\n\n\n    getComputedHeight(elem) {\n      return elem.offsetHeight ? parseFloat(this.document.defaultView.getComputedStyle(elem).getPropertyValue('height')) : 0;\n    }\n    /**\n     * @hidden\n     */\n\n\n    getFooterHeight() {\n      return this.summaryRowHeight || this.getComputedHeight(this.tfoot.nativeElement);\n    }\n    /**\n     * @hidden\n     */\n\n\n    getTheadRowHeight() {\n      const height = this.getComputedHeight(this.theadRow.nativeElement);\n      return !this.allowFiltering || this.allowFiltering && this.filterMode !== FilterMode.quickFilter ? height - this.getFilterCellHeight() : height;\n    }\n    /**\n     * @hidden\n     */\n\n\n    getToolbarHeight() {\n      let toolbarHeight = 0;\n\n      if (this.toolbar.first) {\n        toolbarHeight = this.getComputedHeight(this.toolbar.first.nativeElement);\n      }\n\n      return toolbarHeight;\n    }\n    /**\n     * @hidden\n     */\n\n\n    getPagingFooterHeight() {\n      let pagingHeight = 0;\n\n      if (this.footer) {\n        const height = this.getComputedHeight(this.footer.nativeElement);\n        pagingHeight = this.footer.nativeElement.firstElementChild ? height : 0;\n      }\n\n      return pagingHeight;\n    }\n    /**\n     * @hidden\n     */\n\n\n    getFilterCellHeight() {\n      const headerGroupNativeEl = this.headerGroupsList.length !== 0 ? this.headerGroupsList[0].nativeElement : null;\n      const filterCellNativeEl = headerGroupNativeEl ? headerGroupNativeEl.querySelector('igx-grid-filtering-cell') : null;\n      return filterCellNativeEl ? filterCellNativeEl.offsetHeight : 0;\n    }\n    /**\n     * @hidden\n     */\n\n\n    _calculateGridBodyHeight() {\n      if (!this._height) {\n        return null;\n      }\n\n      const actualTheadRow = this.getTheadRowHeight();\n      const footerHeight = this.getFooterHeight();\n      const toolbarHeight = this.getToolbarHeight();\n      const pagingHeight = this.getPagingFooterHeight();\n      const groupAreaHeight = this.getGroupAreaHeight();\n      const scrHeight = this.getComputedHeight(this.scr.nativeElement);\n      const renderedHeight = toolbarHeight + actualTheadRow + footerHeight + pagingHeight + groupAreaHeight + scrHeight;\n      let gridHeight = 0;\n\n      if (this.isPercentHeight) {\n        const computed = this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('height');\n\n        const autoSize = this._shouldAutoSize(renderedHeight);\n\n        if (autoSize || computed.indexOf('%') !== -1) {\n          const bodyHeight = this.getDataBasedBodyHeight();\n          return bodyHeight > 0 ? bodyHeight : null;\n        }\n\n        gridHeight = parseFloat(computed);\n      } else {\n        gridHeight = parseInt(this._height, 10);\n      }\n\n      const height = Math.abs(gridHeight - renderedHeight);\n\n      if (Math.round(height) === 0 || isNaN(gridHeight)) {\n        const bodyHeight = this.defaultTargetBodyHeight;\n        return bodyHeight > 0 ? bodyHeight : null;\n      }\n\n      return height;\n    }\n\n    checkContainerSizeChange() {\n      const origHeight = this.nativeElement.parentElement.offsetHeight;\n      this.nativeElement.style.display = 'none';\n      const height = this.nativeElement.parentElement.offsetHeight;\n      this.nativeElement.style.display = '';\n      return origHeight !== height;\n    }\n\n    _shouldAutoSize(renderedHeight) {\n      this.tbody.nativeElement.style.display = 'none';\n      let res = !this.nativeElement.parentElement || this.nativeElement.parentElement.clientHeight === 0 || this.nativeElement.parentElement.clientHeight === renderedHeight || // If grid causes the parent container to extend (for example when container is flex)\n      // we should always auto-size since the actual size of the container will continuously change as the grid renders elements.\n      this.checkContainerSizeChange();\n      this.tbody.nativeElement.style.display = '';\n      return res;\n    }\n    /**\n     * @hidden\n     * Gets calculated width of the unpinned area\n     * @param takeHidden If we should take into account the hidden columns in the pinned area.\n     */\n\n\n    getUnpinnedWidth(takeHidden = false) {\n      let width = this.isPercentWidth ? this.calcWidth : parseInt(this.width, 10) || parseInt(this.hostWidth, 10) || this.calcWidth;\n\n      if (this.hasVerticalScroll() && !this.isPercentWidth) {\n        width -= this.scrollSize;\n      }\n\n      if (!this.isPinningToStart) {\n        width -= this.featureColumnsWidth();\n      }\n\n      return width - this.getPinnedWidth(takeHidden);\n    }\n    /**\n     * @hidden\n     */\n\n\n    _summaries(fieldName, hasSummary, summaryOperand) {\n      const column = this.gridAPI.get_column_by_name(fieldName);\n\n      if (column) {\n        column.hasSummary = hasSummary;\n\n        if (summaryOperand) {\n          if (this.rootSummariesEnabled) {\n            this.summaryService.retriggerRootPipe++;\n          }\n\n          column.summaries = summaryOperand;\n        }\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    _multipleSummaries(expressions, hasSummary) {\n      expressions.forEach(element => {\n        this._summaries(element.fieldName, hasSummary, element.customSummary);\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    _disableMultipleSummaries(expressions) {\n      expressions.forEach(column => {\n        const columnName = column && column.fieldName ? column.fieldName : column;\n\n        this._summaries(columnName, false);\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    resolveDataTypes(rec) {\n      if (typeof rec === 'number') {\n        return GridColumnDataType.Number;\n      } else if (typeof rec === 'boolean') {\n        return GridColumnDataType.Boolean;\n      } else if (typeof rec === 'object' && rec instanceof Date) {\n        return GridColumnDataType.Date;\n      }\n\n      return GridColumnDataType.String;\n    }\n    /**\n     * @hidden\n     */\n\n\n    autogenerateColumns() {\n      const data = this.gridAPI.get_data();\n      const factory = this.resolver.resolveComponentFactory(IgxColumnComponent);\n      const fields = this.generateDataFields(data);\n      const columns = [];\n      fields.forEach(field => {\n        const ref = factory.create(this.viewRef.injector);\n        ref.instance.field = field;\n        ref.instance.dataType = this.resolveDataTypes(data[0][field]);\n        ref.changeDetectorRef.detectChanges();\n        columns.push(ref.instance);\n      });\n      this._autoGeneratedCols = columns;\n      this.columnList.reset(columns);\n\n      if (data && data.length > 0) {\n        this.shouldGenerate = false;\n      }\n    }\n\n    generateDataFields(data) {\n      return Object.keys(data && data.length !== 0 ? data[0] : []);\n    }\n    /**\n     * @hidden\n     */\n\n\n    initColumns(collection, cb = null) {\n      this._columnGroups = this.columnList.some(col => col.columnGroup);\n\n      if (this.hasColumnLayouts) {\n        // Set overall row layout size\n        this.columnList.forEach(col => {\n          if (col.columnLayout) {\n            const layoutSize = col.children ? col.children.reduce((acc, val) => Math.max(val.rowStart + val.gridRowSpan - 1, acc), 1) : 1;\n            this._multiRowLayoutRowSize = Math.max(layoutSize, this._multiRowLayoutRowSize);\n          }\n        });\n      }\n\n      if (this.hasColumnLayouts && this.hasColumnGroups) {\n        // invalid configuration - multi-row and column groups\n        // remove column groups\n        const columnLayoutColumns = this.columnList.filter(col => col.columnLayout || col.columnLayoutChild);\n        this.columnList.reset(columnLayoutColumns);\n      }\n\n      this._maxLevelHeaderDepth = null;\n      this._columns = this.columnList.toArray();\n      collection.forEach(column => {\n        column.defaultWidth = this.columnWidthSetByUser ? this._columnWidth : column.defaultWidth ? column.defaultWidth : '';\n\n        if (cb) {\n          cb(column);\n        }\n      });\n      this.reinitPinStates();\n\n      if (this.hasColumnLayouts) {\n        collection.forEach(column => {\n          column.populateVisibleIndexes();\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    reinitPinStates() {\n      this._pinnedColumns = this.columnList.filter(c => c.pinned).sort((a, b) => this._pinnedColumns.indexOf(a) - this._pinnedColumns.indexOf(b));\n      this._unpinnedColumns = this.hasColumnGroups ? this.columnList.filter(c => !c.pinned) : this.columnList.filter(c => !c.pinned).sort((a, b) => this._unpinnedColumns.findIndex(x => x.field === a.field) - this._unpinnedColumns.findIndex(x => x.field === b.field));\n    }\n\n    extractDataFromSelection(source, formatters = false, headers = false, columnData) {\n      var _a;\n\n      let columnsArray;\n      let record = {};\n      let selectedData = [];\n      let keys = [];\n      const selectionCollection = new Map();\n      const keysAndData = [];\n      const activeEl = this.selectionService.activeElement;\n\n      if (this.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid') {\n        const expansionRowIndexes = [];\n\n        for (const [key, value] of this.expansionStates.entries()) {\n          if (value) {\n            expansionRowIndexes.push(key);\n          }\n        }\n\n        if (this.selectionService.selection.size > 0) {\n          if (expansionRowIndexes.length > 0) {\n            for (const [key, value] of this.selectionService.selection.entries()) {\n              let updatedKey = key;\n              expansionRowIndexes.forEach(row => {\n                let rowIndex;\n\n                if (!isNaN(row.ID)) {\n                  rowIndex = Number(row.ID);\n                } else {\n                  rowIndex = Number(row);\n                }\n\n                if (updatedKey > Number(rowIndex)) {\n                  updatedKey--;\n                }\n              });\n              selectionCollection.set(updatedKey, value);\n            }\n          }\n        } else if (activeEl) {\n          if (expansionRowIndexes.length > 0) {\n            expansionRowIndexes.forEach(row => {\n              if (activeEl.row > Number(row)) {\n                activeEl.row--;\n              }\n            });\n          }\n        }\n      }\n\n      const totalItems = (_a = this.totalItemCount) !== null && _a !== void 0 ? _a : 0;\n      const isRemote = totalItems && totalItems > this.dataView.length;\n      let selectionMap;\n\n      if (this.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid' && selectionCollection.size > 0) {\n        selectionMap = isRemote ? Array.from(selectionCollection) : Array.from(selectionCollection).filter(tuple => tuple[0] < source.length);\n      } else {\n        selectionMap = isRemote ? Array.from(this.selectionService.selection) : Array.from(this.selectionService.selection).filter(tuple => tuple[0] < source.length);\n      }\n\n      if (this.cellSelection === GridSelectionMode.single && activeEl) {\n        selectionMap.push([activeEl.row, new Set().add(activeEl.column)]);\n      }\n\n      if (this.cellSelection === GridSelectionMode.none && activeEl) {\n        selectionMap.push([activeEl.row, new Set().add(activeEl.column)]);\n      }\n\n      if (columnData) {\n        selectedData = columnData;\n      } // eslint-disable-next-line prefer-const\n\n\n      for (let [row, set] of selectionMap) {\n        row = this.paginator && this.pagingMode === GridPagingMode.Local && source === this.filteredSortedData ? row + this.paginator.perPage * this.paginator.page : row;\n        row = isRemote ? row - this.virtualizationState.startIndex : row;\n\n        if (!source[row] || source[row].detailsData !== undefined) {\n          continue;\n        }\n\n        const temp = Array.from(set);\n\n        for (const each of temp) {\n          columnsArray = this.getSelectableColumnsAt(each);\n          columnsArray.forEach(col => {\n            if (col) {\n              const key = headers ? col.header || col.field : col.field;\n              const rowData = source[row].ghostRecord ? source[row].recordRef : source[row];\n              const value = resolveNestedPath(rowData, col.field);\n              record[key] = formatters && col.formatter ? col.formatter(value, rowData) : value;\n\n              if (columnData) {\n                if (!record[key]) {\n                  record[key] = '';\n                }\n\n                record[key] = record[key].toString().concat('recordRow-' + row);\n              }\n            }\n          });\n        }\n\n        if (Object.keys(record).length) {\n          if (columnData) {\n            if (!keys.length) {\n              keys = Object.keys(columnData[0]);\n            }\n\n            for (const [key, value] of Object.entries(record)) {\n              if (!keys.includes(key)) {\n                keys.push(key);\n              }\n\n              let c = value;\n              const rowNumber = +c.split('recordRow-')[1];\n              c = c.split('recordRow-')[0];\n              record[key] = c;\n              const mergedObj = Object.assign(selectedData[rowNumber], record);\n              selectedData[rowNumber] = mergedObj;\n            }\n          } else {\n            selectedData.push(record);\n          }\n        }\n\n        record = {};\n      }\n\n      if (keys.length) {\n        keysAndData.push(selectedData);\n        keysAndData.push(keys);\n        return keysAndData;\n      } else {\n        return selectedData;\n      }\n    }\n\n    getSelectableColumnsAt(index) {\n      if (this.hasColumnLayouts) {\n        const visibleLayoutColumns = this.visibleColumns.filter(col => col.columnLayout).sort((a, b) => a.visibleIndex - b.visibleIndex);\n        const colLayout = visibleLayoutColumns[index];\n        return colLayout ? colLayout.children.toArray() : [];\n      } else {\n        const visibleColumns = this.visibleColumns.filter(col => !col.columnGroup).sort((a, b) => a.visibleIndex - b.visibleIndex);\n        return [visibleColumns[index]];\n      }\n    }\n\n    extractDataFromColumnsSelection(source, formatters = false, headers = false) {\n      let record = {};\n      const selectedData = [];\n      const selectedColumns = this.selectedColumns();\n\n      if (selectedColumns.length === 0) {\n        return [];\n      }\n\n      for (const data of source) {\n        selectedColumns.forEach(col => {\n          const key = headers ? col.header || col.field : col.field;\n          record[key] = formatters && col.formatter ? col.formatter(data[col.field], data) : data[col.field];\n        });\n\n        if (Object.keys(record).length) {\n          selectedData.push(record);\n        }\n\n        record = {};\n      }\n\n      return selectedData;\n    }\n    /**\n     * @hidden\n     */\n\n\n    initPinning() {\n      const pinnedColumns = [];\n      const unpinnedColumns = [];\n      this.calculateGridWidth();\n      this.resetCaches(); // When a column is a group or is inside a group, pin all related.\n\n      this._pinnedColumns.forEach(col => {\n        if (col.parent) {\n          col.parent.pinned = true;\n        }\n\n        if (col.columnGroup) {\n          col.children.forEach(child => child.pinned = true);\n        }\n      }); // Make sure we don't exceed unpinned area min width and get pinned and unpinned col collections.\n      // We take into account top level columns (top level groups and non groups).\n      // If top level is unpinned the pinning handles all children to be unpinned as well.\n\n\n      for (const column of this.columnList) {\n        if (column.pinned && !column.parent) {\n          pinnedColumns.push(column);\n        } else if (column.pinned && column.parent) {\n          if (column.topLevelParent.pinned) {\n            pinnedColumns.push(column);\n          } else {\n            column.pinned = false;\n            unpinnedColumns.push(column);\n          }\n        } else {\n          unpinnedColumns.push(column);\n        }\n      } // Assign the applicable collections.\n\n\n      this._pinnedColumns = pinnedColumns;\n      this._unpinnedColumns = unpinnedColumns;\n      this.notifyChanges();\n    }\n    /**\n     * @hidden\n     */\n\n\n    scrollTo(row, column, inCollection = this._filteredSortedUnpinnedData) {\n      let delayScrolling = false;\n\n      if (this.paginator && typeof row !== 'number') {\n        const rowIndex = inCollection.indexOf(row);\n        const page = Math.floor(rowIndex / this.paginator.perPage);\n\n        if (this.paginator.page !== page) {\n          delayScrolling = true;\n          this.paginator.page = page;\n        }\n      }\n\n      if (delayScrolling) {\n        this.verticalScrollContainer.dataChanged.pipe(first$1()).subscribe(() => {\n          this.scrollDirective(this.verticalScrollContainer, typeof row === 'number' ? row : this.unpinnedDataView.indexOf(row));\n        });\n      } else {\n        this.scrollDirective(this.verticalScrollContainer, typeof row === 'number' ? row : this.unpinnedDataView.indexOf(row));\n      }\n\n      this.scrollToHorizontally(column);\n    }\n    /**\n     * @hidden\n     */\n\n\n    scrollToHorizontally(column) {\n      let columnIndex = typeof column === 'number' ? column : this.getColumnByName(column).visibleIndex;\n      const scrollRow = this.rowList.find(r => !!r.virtDirRow);\n      const virtDir = scrollRow ? scrollRow.virtDirRow : null;\n\n      if (this.isPinningToStart && this.pinnedColumns.length) {\n        if (columnIndex >= this.pinnedColumns.length) {\n          columnIndex -= this.pinnedColumns.length;\n          this.scrollDirective(virtDir, columnIndex);\n        }\n      } else {\n        this.scrollDirective(virtDir, columnIndex);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    scrollDirective(directive, goal) {\n      if (!directive) {\n        return;\n      }\n\n      directive.scrollTo(goal);\n    }\n\n    getColumnWidthSum() {\n      let colSum = 0;\n      const cols = this.hasColumnLayouts ? this.visibleColumns.filter(x => x.columnLayout) : this.visibleColumns.filter(x => !x.columnGroup);\n      cols.forEach(item => {\n        colSum += parseInt(item.calcWidth || item.defaultWidth, 10) || MINIMUM_COLUMN_WIDTH$2;\n      });\n\n      if (!colSum) {\n        return null;\n      }\n\n      this.cdr.detectChanges();\n      colSum += this.featureColumnsWidth();\n      return colSum;\n    }\n    /**\n     * Notify changes, reset cache and populateVisibleIndexes.\n     *\n     * @hidden\n     */\n\n\n    _columnsReordered(column) {\n      this.notifyChanges();\n\n      if (this.hasColumnLayouts) {\n        this.columnList.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());\n      } // after reordering is done reset cached column collections.\n\n\n      this.resetColumnCollections();\n      column.resetCaches();\n    }\n\n    buildDataView(data) {\n      this._dataView = this.isRowPinningToTop ? [...this.pinnedDataView, ...this.unpinnedDataView] : [...this.unpinnedDataView, ...this.pinnedDataView];\n    }\n\n    _applyWidthHostBinding() {\n      let width = this._width;\n\n      if (width === null) {\n        let currentWidth = this.calcWidth;\n\n        if (this.hasVerticalScroll()) {\n          currentWidth += this.scrollSize;\n        }\n\n        width = currentWidth + 'px';\n        this.resetCaches();\n      }\n\n      this._hostWidth = width;\n      this.cdr.markForCheck();\n    }\n\n    verticalScrollHandler(event) {\n      var _a;\n\n      this.verticalScrollContainer.onScroll(event);\n      this.disableTransitions = true;\n      this.zone.run(() => {\n        this.zone.onStable.pipe(first$1()).subscribe(() => {\n          this.verticalScrollContainer.chunkLoad.emit(this.verticalScrollContainer.state);\n\n          if (this.rowEditable) {\n            this.changeRowEditingOverlayStateOnScroll(this.crudService.rowInEditMode);\n          }\n        });\n      });\n      this.disableTransitions = false;\n      this.hideOverlays();\n      (_a = this.actionStrip) === null || _a === void 0 ? void 0 : _a.hide();\n\n      if (this.actionStrip) {\n        this.actionStrip.context = null;\n      }\n\n      const args = {\n        direction: 'vertical',\n        event,\n        scrollPosition: this.verticalScrollContainer.scrollPosition\n      };\n      this.gridScroll.emit(args);\n    }\n\n    horizontalScrollHandler(event) {\n      const scrollLeft = event.target.scrollLeft;\n      this.headerContainer.onHScroll(scrollLeft);\n\n      this._horizontalForOfs.forEach(vfor => vfor.onHScroll(scrollLeft));\n\n      this.cdr.markForCheck();\n      this.zone.run(() => {\n        this.zone.onStable.pipe(first$1()).subscribe(() => {\n          this.parentVirtDir.chunkLoad.emit(this.headerContainer.state);\n        });\n      });\n      this.hideOverlays();\n      const args = {\n        direction: 'horizontal',\n        event,\n        scrollPosition: this.headerContainer.scrollPosition\n      };\n      this.gridScroll.emit(args);\n    }\n\n    executeCallback(rowIndex, visibleColIndex = -1, cb = null) {\n      if (!cb) {\n        return;\n      }\n\n      let row = this.summariesRowList.filter(s => s.index !== 0).concat(this.rowList.toArray()).find(r => r.index === rowIndex);\n\n      if (!row) {\n        if (this.totalItemCount) {\n          this.verticalScrollContainer.dataChanged.pipe(first$1()).subscribe(() => {\n            this.cdr.detectChanges();\n            row = this.summariesRowList.filter(s => s.index !== 0).concat(this.rowList.toArray()).find(r => r.index === rowIndex);\n            const cbArgs = this.getNavigationArguments(row, visibleColIndex);\n            cb(cbArgs);\n          });\n        }\n\n        const dataViewIndex = this._getDataViewIndex(rowIndex);\n\n        if (this.dataView[dataViewIndex].detailsData) {\n          this.navigation.setActiveNode({\n            row: rowIndex\n          });\n          this.cdr.detectChanges();\n        }\n\n        return;\n      }\n\n      const args = this.getNavigationArguments(row, visibleColIndex);\n      cb(args);\n    }\n\n    getNavigationArguments(row, visibleColIndex) {\n      let targetType;\n      let target;\n\n      switch (row.nativeElement.tagName.toLowerCase()) {\n        case 'igx-grid-groupby-row':\n          targetType = 'groupRow';\n          target = row;\n          break;\n\n        case 'igx-grid-summary-row':\n          targetType = 'summaryCell';\n          target = visibleColIndex !== -1 ? row.summaryCells.find(c => c.visibleColumnIndex === visibleColIndex) : row.summaryCells.first;\n          break;\n\n        case 'igx-child-grid-row':\n          targetType = 'hierarchicalRow';\n          target = row;\n          break;\n\n        default:\n          targetType = 'dataCell';\n          target = visibleColIndex !== -1 ? row.cells.find(c => c.visibleColumnIndex === visibleColIndex) : row.cells.first;\n          break;\n      }\n\n      return {\n        targetType,\n        target\n      };\n    }\n\n    getNextDataRowIndex(currentRowIndex, previous = false) {\n      const resolvedIndex = this._getDataViewIndex(currentRowIndex);\n\n      if (currentRowIndex < 0 || currentRowIndex === 0 && previous || resolvedIndex >= this.dataView.length - 1 && !previous) {\n        return currentRowIndex;\n      } // find next/prev record that is editable.\n\n\n      const nextRowIndex = previous ? this.findPrevEditableDataRowIndex(currentRowIndex) : this.dataView.findIndex((rec, index) => index > resolvedIndex && this.isEditableDataRecordAtIndex(index));\n      const nextDataIndex = this.getDataIndex(nextRowIndex);\n      return nextDataIndex !== -1 ? nextDataIndex : currentRowIndex;\n    }\n    /**\n     * Returns the previous editable row index or -1 if no such row is found.\n     *\n     * @param currentIndex The index of the current editable record.\n     */\n\n\n    findPrevEditableDataRowIndex(currentIndex) {\n      let i = this.dataView.length;\n\n      const resolvedIndex = this._getDataViewIndex(currentIndex);\n\n      while (i--) {\n        if (i < resolvedIndex && this.isEditableDataRecordAtIndex(i)) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n    /**\n     * Returns if the record at the specified data view index is a an editable data record.\n     * If record is group rec, summary rec, child rec, ghost rec. etc. it is not editable.\n     *\n     * @param dataViewIndex The index of that record in the data view.\n     *\n     */\n    // TODO: Consider moving it into CRUD\n\n\n    isEditableDataRecordAtIndex(dataViewIndex) {\n      const rec = this.dataView[dataViewIndex];\n      return !rec.expression && !rec.summaries && !rec.childGridsData && !rec.detailsData && !this.isGhostRecordAtIndex(dataViewIndex);\n    }\n    /**\n     * Returns if the record at the specified data view index is a ghost.\n     * If record is pinned but is not in pinned area then it is a ghost record.\n     *\n     * @param dataViewIndex The index of that record in the data view.\n     */\n\n\n    isGhostRecordAtIndex(dataViewIndex) {\n      const isPinned = this.isRecordPinned(this.dataView[dataViewIndex]);\n      const isInPinnedArea = this.isRecordPinnedByViewIndex(dataViewIndex);\n      return isPinned && !isInPinnedArea;\n    }\n\n    isValidPosition(rowIndex, colIndex) {\n      const rows = this.summariesRowList.filter(s => s.index !== 0).concat(this.rowList.toArray()).length;\n      const cols = this.columnList.filter(col => !col.columnGroup && col.visibleIndex >= 0 && !col.hidden).length;\n\n      if (rows < 1 || cols < 1) {\n        return false;\n      }\n\n      if (rowIndex > -1 && rowIndex < this.dataView.length && colIndex > -1 && colIndex <= Math.max(...this.visibleColumns.map(c => c.visibleIndex))) {\n        return true;\n      }\n\n      return false;\n    }\n\n    find(text, increment, caseSensitive, exactMatch, scroll, endEdit = true) {\n      if (!this.rowList) {\n        return 0;\n      }\n\n      if (endEdit) {\n        this.crudService.endEdit(false);\n      }\n\n      if (!text) {\n        this.clearSearch();\n        return 0;\n      }\n\n      const caseSensitiveResolved = caseSensitive ? true : false;\n      const exactMatchResolved = exactMatch ? true : false;\n      let rebuildCache = false;\n\n      if (this.lastSearchInfo.searchText !== text || this.lastSearchInfo.caseSensitive !== caseSensitiveResolved || this.lastSearchInfo.exactMatch !== exactMatchResolved) {\n        this.lastSearchInfo = {\n          searchText: text,\n          activeMatchIndex: 0,\n          caseSensitive: caseSensitiveResolved,\n          exactMatch: exactMatchResolved,\n          matchInfoCache: []\n        };\n        rebuildCache = true;\n      } else {\n        this.lastSearchInfo.activeMatchIndex += increment;\n      }\n\n      if (rebuildCache) {\n        this.rowList.forEach(row => {\n          if (row.cells) {\n            row.cells.forEach(c => {\n              c.highlightText(text, caseSensitiveResolved, exactMatchResolved);\n            });\n          }\n        });\n        this.rebuildMatchCache();\n      }\n\n      if (this.lastSearchInfo.activeMatchIndex >= this.lastSearchInfo.matchInfoCache.length) {\n        this.lastSearchInfo.activeMatchIndex = 0;\n      } else if (this.lastSearchInfo.activeMatchIndex < 0) {\n        this.lastSearchInfo.activeMatchIndex = this.lastSearchInfo.matchInfoCache.length - 1;\n      }\n\n      if (this.lastSearchInfo.matchInfoCache.length) {\n        const matchInfo = this.lastSearchInfo.matchInfoCache[this.lastSearchInfo.activeMatchIndex];\n        this.lastSearchInfo = Object.assign({}, this.lastSearchInfo);\n\n        if (scroll !== false) {\n          this.scrollTo(matchInfo.row, matchInfo.column);\n        }\n\n        IgxTextHighlightDirective.setActiveHighlight(this.id, {\n          column: matchInfo.column,\n          row: matchInfo.row,\n          index: matchInfo.index,\n          metadata: matchInfo.metadata\n        });\n      } else {\n        IgxTextHighlightDirective.clearActiveHighlight(this.id);\n      }\n\n      return this.lastSearchInfo.matchInfoCache.length;\n    }\n\n    rebuildMatchCache() {\n      this.lastSearchInfo.matchInfoCache = [];\n      const caseSensitive = this.lastSearchInfo.caseSensitive;\n      const exactMatch = this.lastSearchInfo.exactMatch;\n      const searchText = caseSensitive ? this.lastSearchInfo.searchText : this.lastSearchInfo.searchText.toLowerCase();\n      const data = this.filteredSortedData;\n      const columnItems = this.visibleColumns.filter(c => !c.columnGroup).sort((c1, c2) => c1.visibleIndex - c2.visibleIndex);\n      data.forEach((dataRow, rowIndex) => {\n        columnItems.forEach(c => {\n          const pipeArgs = this.getColumnByName(c.field).pipeArgs;\n          const value = c.formatter ? c.formatter(resolveNestedPath(dataRow, c.field), dataRow) : c.dataType === 'number' ? formatNumber(resolveNestedPath(dataRow, c.field), this.locale, pipeArgs.digitsInfo) : c.dataType === 'date' ? formatDate(resolveNestedPath(dataRow, c.field), pipeArgs.format, this.locale, pipeArgs.timezone) : resolveNestedPath(dataRow, c.field);\n\n          if (value !== undefined && value !== null && c.searchable) {\n            let searchValue = caseSensitive ? String(value) : String(value).toLowerCase();\n\n            if (exactMatch) {\n              if (searchValue === searchText) {\n                const metadata = new Map();\n                metadata.set('pinned', this.isRecordPinnedByIndex(rowIndex));\n                this.lastSearchInfo.matchInfoCache.push({\n                  row: dataRow,\n                  column: c.field,\n                  index: 0,\n                  metadata\n                });\n              }\n            } else {\n              let occurenceIndex = 0;\n              let searchIndex = searchValue.indexOf(searchText);\n\n              while (searchIndex !== -1) {\n                const metadata = new Map();\n                metadata.set('pinned', this.isRecordPinnedByIndex(rowIndex));\n                this.lastSearchInfo.matchInfoCache.push({\n                  row: dataRow,\n                  column: c.field,\n                  index: occurenceIndex++,\n                  metadata\n                });\n                searchValue = searchValue.substring(searchIndex + searchText.length);\n                searchIndex = searchValue.indexOf(searchText);\n              }\n            }\n          }\n        });\n      });\n    } // TODO: About to Move to CRUD\n\n\n    configureRowEditingOverlay(rowID, useOuter = false) {\n      let settings = this.rowEditSettings;\n      const overlay = this.overlayService.getOverlayById(this.rowEditingOverlay.overlayId);\n\n      if (overlay) {\n        settings = overlay.settings;\n      }\n\n      settings.outlet = useOuter ? this.parentRowOutletDirective : this.rowOutletDirective;\n      this.rowEditPositioningStrategy.settings.container = this.tbody.nativeElement;\n      const pinned = this._pinnedRecordIDs.indexOf(rowID) !== -1;\n      const targetRow = !pinned ? this.gridAPI.get_row_by_key(rowID) : this.pinnedRows.find(x => x.key === rowID);\n\n      if (!targetRow) {\n        return;\n      }\n\n      settings.target = targetRow.element.nativeElement;\n      this.toggleRowEditingOverlay(true);\n    }\n\n  }\n\n  IgxGridBaseDirective.ɵfac = function IgxGridBaseDirective_Factory(t) {\n    return new (t || IgxGridBaseDirective)(i0.ɵɵdirectiveInject(IgxGridSelectionService), i0.ɵɵdirectiveInject(IgxColumnResizingService), i0.ɵɵdirectiveInject(IGX_GRID_SERVICE_BASE), i0.ɵɵdirectiveInject(IgxFlatTransactionFactory), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ApplicationRef), i0.ɵɵdirectiveInject(i0.NgModuleRef), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(IgxGridNavigationService), i0.ɵɵdirectiveInject(IgxFilteringService), i0.ɵɵdirectiveInject(IgxOverlayService), i0.ɵɵdirectiveInject(IgxGridSummaryService), i0.ɵɵdirectiveInject(DisplayDensityToken, 8), i0.ɵɵdirectiveInject(LOCALE_ID), i0.ɵɵdirectiveInject(PlatformUtil), i0.ɵɵdirectiveInject(IgxGridTransaction, 8));\n  };\n\n  IgxGridBaseDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxGridBaseDirective,\n    contentQueries: function IgxGridBaseDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxActionStripComponent, 5);\n        i0.ɵɵcontentQuery(dirIndex, IgxExcelStyleLoadingValuesTemplateDirective, 7, IgxExcelStyleLoadingValuesTemplateDirective);\n        i0.ɵɵcontentQuery(dirIndex, IgxRowAddTextDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxRowExpandedIndicatorDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxRowCollapsedIndicatorDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxHeaderExpandIndicatorDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxHeaderCollapseIndicatorDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxExcelStyleHeaderIconDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxSortAscendingHeaderIconDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxSortDescendingHeaderIconDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxSortHeaderIconDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxGridExcelStyleFilteringComponent, 4, IgxGridExcelStyleFilteringComponent);\n        i0.ɵɵcontentQuery(dirIndex, IgxColumnComponent, 5, IgxColumnComponent);\n        i0.ɵɵcontentQuery(dirIndex, IgxHeadSelectorDirective, 4, IgxHeadSelectorDirective);\n        i0.ɵɵcontentQuery(dirIndex, IgxRowSelectorDirective, 4, IgxRowSelectorDirective);\n        i0.ɵɵcontentQuery(dirIndex, IgxRowDragGhostDirective, 4, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxRowEditTemplateDirective, 4, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxRowEditTextDirective, 4, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxRowEditActionsDirective, 4, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxDragIndicatorIconDirective, 4, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxRowEditTabStopDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, IgxGridToolbarComponent, 4);\n        i0.ɵɵcontentQuery(dirIndex, IgxPaginatorComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.actionStrip = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.excelStyleLoadingValuesTemplateDirective = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.rowAddText = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.rowExpandedIndicatorTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.rowCollapsedIndicatorTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerExpandIndicatorTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerCollapseIndicatorTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.excelStyleHeaderIconTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.sortAscendingHeaderIconTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.sortDescendingHeaderIconTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.sortHeaderIconTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.excelStyleFilteringComponents = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.columnList = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headSelectorsTemplates = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.rowSelectorsTemplates = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dragGhostCustomTemplates = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.rowEditCustomDirectives = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.rowEditTextDirectives = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.rowEditActionsDirectives = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dragIndicatorIconTemplates = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.rowEditTabsCUSTOM = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbar = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.paginationComponents = _t);\n      }\n    },\n    viewQuery: function IgxGridBaseDirective_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxSnackbarComponent, 5);\n        i0.ɵɵviewQuery(IgxGridColumnResizerComponent, 5);\n        i0.ɵɵviewQuery(_c179, 7, IgxToggleDirective);\n        i0.ɵɵviewQuery(_c180, 7, IgxOverlayOutletDirective);\n        i0.ɵɵviewQuery(_c181, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c182, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c183, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c7, 7, IgxGridForOfDirective);\n        i0.ɵɵviewQuery(_c184, 7, IgxGridForOfDirective);\n        i0.ɵɵviewQuery(_c185, 7, IgxGridForOfDirective);\n        i0.ɵɵviewQuery(_c186, 7, ElementRef);\n        i0.ɵɵviewQuery(_c175, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c187, 5, ElementRef);\n        i0.ɵɵviewQuery(IgxGridHeaderRowComponent, 7);\n        i0.ɵɵviewQuery(IgxGridGroupByAreaComponent, 5);\n        i0.ɵɵviewQuery(_c188, 7);\n        i0.ɵɵviewQuery(_c189, 5, ElementRef);\n        i0.ɵɵviewQuery(_c190, 7);\n        i0.ɵɵviewQuery(_c191, 7, IgxOverlayOutletDirective);\n        i0.ɵɵviewQuery(_c192, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c193, 5, IgxToggleDirective);\n        i0.ɵɵviewQuery(_c194, 7, IgxOverlayOutletDirective);\n        i0.ɵɵviewQuery(_c195, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c196, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c197, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c198, 7, TemplateRef);\n        i0.ɵɵviewQuery(IgxTemplateOutletDirective, 5, IgxTemplateOutletDirective);\n        i0.ɵɵviewQuery(IgxRowEditTabStopDirective, 5);\n        i0.ɵɵviewQuery(_c199, 5, IgxSummaryRowComponent);\n        i0.ɵɵviewQuery(_c200, 5);\n        i0.ɵɵviewQuery(_c201, 5);\n        i0.ɵɵviewQuery(IgxRowDirective, 5, IgxRowDirective);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.addRowSnackbar = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.resizeLine = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.loadingOverlay = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.loadingOutlet = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.emptyFilteredGridTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.emptyGridDefaultTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.loadingGridDefaultTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.parentVirtDir = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.verticalScrollContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.verticalScroll = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.scr = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerSelectorBaseTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.footer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.theadRow = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupArea = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tbody = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.pinContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tfoot = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.rowEditingOutletDirective = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dragIndicatorIconBase = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.rowEditingOverlay = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._outletDirective = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultExpandedTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultCollapsedTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultESFHeaderIconTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultRowEditTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tmpOutlets = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.rowEditTabsDEFAULT = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._summaryRowList = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._rowList = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._pinnedRowList = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._dataRowList = _t);\n      }\n    },\n    hostVars: 7,\n    hostBindings: function IgxGridBaseDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"mouseleave\", function IgxGridBaseDirective_mouseleave_HostBindingHandler() {\n          return ctx.hideActionStrip();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabindex\", ctx.tabindex)(\"role\", ctx.hostRole)(\"class\", ctx.hostClass);\n        i0.ɵɵstyleProp(\"height\", ctx.height)(\"width\", ctx.hostWidth);\n      }\n    },\n    inputs: {\n      snackbarDisplayTime: \"snackbarDisplayTime\",\n      autoGenerate: \"autoGenerate\",\n      moving: \"moving\",\n      emptyGridTemplate: \"emptyGridTemplate\",\n      addRowEmptyTemplate: \"addRowEmptyTemplate\",\n      loadingGridTemplate: \"loadingGridTemplate\",\n      summaryRowHeight: \"summaryRowHeight\",\n      dataCloneStrategy: \"dataCloneStrategy\",\n      clipboardOptions: \"clipboardOptions\",\n      class: \"class\",\n      evenRowCSS: \"evenRowCSS\",\n      oddRowCSS: \"oddRowCSS\",\n      rowClasses: \"rowClasses\",\n      rowStyles: \"rowStyles\",\n      primaryKey: \"primaryKey\",\n      uniqueColumnValuesStrategy: \"uniqueColumnValuesStrategy\",\n      resourceStrings: \"resourceStrings\",\n      filteringLogic: \"filteringLogic\",\n      filteringExpressionsTree: \"filteringExpressionsTree\",\n      advancedFilteringExpressionsTree: \"advancedFilteringExpressionsTree\",\n      locale: \"locale\",\n      pagingMode: \"pagingMode\",\n      paging: \"paging\",\n      page: \"page\",\n      perPage: \"perPage\",\n      hideRowSelectors: \"hideRowSelectors\",\n      rowDraggable: \"rowDraggable\",\n      rowEditable: \"rowEditable\",\n      height: \"height\",\n      width: \"width\",\n      rowHeight: \"rowHeight\",\n      columnWidth: \"columnWidth\",\n      emptyGridMessage: \"emptyGridMessage\",\n      isLoading: \"isLoading\",\n      emptyFilteredGridMessage: \"emptyFilteredGridMessage\",\n      pinning: \"pinning\",\n      allowFiltering: \"allowFiltering\",\n      allowAdvancedFiltering: \"allowAdvancedFiltering\",\n      filterMode: \"filterMode\",\n      summaryPosition: \"summaryPosition\",\n      summaryCalculationMode: \"summaryCalculationMode\",\n      showSummaryOnCollapse: \"showSummaryOnCollapse\",\n      filterStrategy: \"filterStrategy\",\n      sortStrategy: \"sortStrategy\",\n      selectedRows: \"selectedRows\",\n      sortingExpressions: \"sortingExpressions\",\n      batchEditing: \"batchEditing\",\n      cellSelection: \"cellSelection\",\n      rowSelection: \"rowSelection\",\n      columnSelection: \"columnSelection\",\n      expansionStates: \"expansionStates\",\n      outlet: \"outlet\",\n      totalRecords: \"totalRecords\",\n      selectRowOnClick: \"selectRowOnClick\"\n    },\n    outputs: {\n      filteringExpressionsTreeChange: \"filteringExpressionsTreeChange\",\n      advancedFilteringExpressionsTreeChange: \"advancedFilteringExpressionsTreeChange\",\n      gridScroll: \"gridScroll\",\n      pageChange: \"pageChange\",\n      perPageChange: \"perPageChange\",\n      cellClick: \"cellClick\",\n      selected: \"selected\",\n      rowSelectionChanging: \"rowSelectionChanging\",\n      columnSelectionChanging: \"columnSelectionChanging\",\n      columnPin: \"columnPin\",\n      columnPinned: \"columnPinned\",\n      cellEditEnter: \"cellEditEnter\",\n      cellEditExit: \"cellEditExit\",\n      cellEdit: \"cellEdit\",\n      cellEditDone: \"cellEditDone\",\n      rowEditEnter: \"rowEditEnter\",\n      rowEdit: \"rowEdit\",\n      rowEditDone: \"rowEditDone\",\n      rowEditExit: \"rowEditExit\",\n      columnInit: \"columnInit\",\n      sorting: \"sorting\",\n      sortingDone: \"sortingDone\",\n      filtering: \"filtering\",\n      filteringDone: \"filteringDone\",\n      pagingDone: \"pagingDone\",\n      rowAdded: \"rowAdded\",\n      rowDeleted: \"rowDeleted\",\n      rowDelete: \"rowDelete\",\n      rowAdd: \"rowAdd\",\n      columnResized: \"columnResized\",\n      contextMenu: \"contextMenu\",\n      doubleClick: \"doubleClick\",\n      columnVisibilityChanging: \"columnVisibilityChanging\",\n      columnVisibilityChanged: \"columnVisibilityChanged\",\n      columnMovingStart: \"columnMovingStart\",\n      columnMoving: \"columnMoving\",\n      columnMovingEnd: \"columnMovingEnd\",\n      gridKeydown: \"gridKeydown\",\n      rowDragStart: \"rowDragStart\",\n      rowDragEnd: \"rowDragEnd\",\n      gridCopy: \"gridCopy\",\n      expansionStatesChange: \"expansionStatesChange\",\n      rowToggle: \"rowToggle\",\n      rowPinning: \"rowPinning\",\n      rowPinned: \"rowPinned\",\n      activeNodeChange: \"activeNodeChange\",\n      sortingExpressionsChange: \"sortingExpressionsChange\",\n      toolbarExporting: \"toolbarExporting\",\n      rangeSelected: \"rangeSelected\",\n      rendered: \"rendered\",\n      localeChange: \"localeChange\",\n      dataChanging: \"dataChanging\",\n      dataChanged: \"dataChanged\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n\n  __decorate([WatchChanges()], IgxGridBaseDirective.prototype, \"primaryKey\", void 0);\n\n  __decorate([WatchChanges()], IgxGridBaseDirective.prototype, \"filteringLogic\", null);\n\n  __decorate([WatchChanges()], IgxGridBaseDirective.prototype, \"filteringExpressionsTree\", null);\n\n  __decorate([WatchChanges()], IgxGridBaseDirective.prototype, \"advancedFilteringExpressionsTree\", null);\n\n  __decorate([WatchChanges()], IgxGridBaseDirective.prototype, \"hideRowSelectors\", null);\n\n  __decorate([WatchChanges()], IgxGridBaseDirective.prototype, \"rowEditable\", null);\n\n  __decorate([WatchChanges()], IgxGridBaseDirective.prototype, \"height\", null);\n\n  __decorate([WatchChanges()], IgxGridBaseDirective.prototype, \"width\", null);\n\n  __decorate([WatchChanges()], IgxGridBaseDirective.prototype, \"rowHeight\", null);\n\n  __decorate([WatchChanges()], IgxGridBaseDirective.prototype, \"columnWidth\", null);\n\n  __decorate([WatchChanges()], IgxGridBaseDirective.prototype, \"isLoading\", null);\n\n  __decorate([WatchChanges()], IgxGridBaseDirective.prototype, \"sortingExpressions\", null);\n\n  __decorate([WatchChanges()], IgxGridBaseDirective.prototype, \"cellSelection\", null);\n\n  __decorate([WatchChanges()], IgxGridBaseDirective.prototype, \"rowSelection\", null);\n\n  __decorate([WatchChanges()], IgxGridBaseDirective.prototype, \"columnSelection\", null);\n\n  __decorate([WatchChanges()], IgxGridBaseDirective.prototype, \"selectRowOnClick\", null);\n\n  return IgxGridBaseDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridAPIService = /*#__PURE__*/(() => {\n  class IgxGridAPIService extends GridBaseAPIService {\n    groupBy(expression) {\n      const groupingState = cloneArray(this.grid.groupingExpressions);\n      const sortingState = cloneArray(this.grid.sortingExpressions);\n      this.prepare_sorting_expression([sortingState, groupingState], expression);\n      this.grid.groupingExpressions = groupingState;\n      this.arrange_sorting_expressions();\n    }\n\n    groupBy_multiple(expressions) {\n      const groupingState = cloneArray(this.grid.groupingExpressions);\n      const sortingState = cloneArray(this.grid.sortingExpressions);\n\n      for (const each of expressions) {\n        this.prepare_sorting_expression([sortingState, groupingState], each);\n      }\n\n      this.grid.groupingExpressions = groupingState;\n      this.arrange_sorting_expressions();\n    }\n\n    clear_groupby(name) {\n      const groupingState = cloneArray(this.grid.groupingExpressions);\n      const sortingState = cloneArray(this.grid.sortingExpressions);\n\n      if (name) {\n        const names = typeof name === 'string' ? [name] : name;\n        const groupedCols = groupingState.filter(state => names.indexOf(state.fieldName) < 0);\n        const newSortingExpr = sortingState.filter(state => names.indexOf(state.fieldName) < 0);\n        this.grid.groupingExpressions = groupedCols;\n        this.grid.sortingExpressions = newSortingExpr;\n        names.forEach(colName => {\n          const grExprIndex = groupingState.findIndex(exp => exp.fieldName === colName);\n          const grpExpandState = this.grid.groupingExpansionState;\n          /* remove expansion states related to the cleared group\n             and all with deeper hierarchy than the cleared group */\n\n          const newExpandState = grpExpandState.filter(val => val.hierarchy && val.hierarchy.length <= grExprIndex);\n          /* Do not set the new instance produced by filter\n              when there are no differences between expansion states */\n\n          if (newExpandState.length !== grpExpandState.length) {\n            this.grid.groupingExpansionState = newExpandState;\n          }\n        });\n      } else {\n        // clear all\n        this.grid.groupingExpressions = [];\n        this.grid.groupingExpansionState = [];\n\n        for (const grExpr of groupingState) {\n          const sortExprIndex = sortingState.findIndex(exp => exp.fieldName === grExpr.fieldName);\n\n          if (sortExprIndex > -1) {\n            sortingState.splice(sortExprIndex, 1);\n          }\n        }\n\n        this.grid.sortingExpressions = sortingState;\n      }\n    }\n\n    groupBy_get_expanded_for_group(groupRow) {\n      const grState = this.grid.groupingExpansionState;\n      const hierarchy = DataUtil.getHierarchy(groupRow);\n      return grState.find(state => DataUtil.isHierarchyMatch(state.hierarchy || [{\n        fieldName: groupRow.expression.fieldName,\n        value: groupRow.value\n      }], hierarchy));\n    }\n\n    groupBy_is_row_in_group(groupRow, rowID) {\n      const grid = this.grid;\n      let rowInGroup = false;\n      groupRow.records.forEach(row => {\n        if (grid.primaryKey ? row[grid.primaryKey] === rowID : row === rowID) {\n          rowInGroup = true;\n        }\n      });\n      return rowInGroup;\n    }\n\n    groupBy_toggle_group(groupRow) {\n      const grid = this.grid;\n\n      if (grid.gridAPI.crudService.cellInEditMode) {\n        this.crudService.endEdit(false);\n      }\n\n      const expansionState = grid.groupingExpansionState;\n      const state = this.groupBy_get_expanded_for_group(groupRow);\n\n      if (state) {\n        state.expanded = !state.expanded;\n      } else {\n        expansionState.push({\n          expanded: !grid.groupsExpanded,\n          hierarchy: DataUtil.getHierarchy(groupRow)\n        });\n      }\n\n      this.grid.groupingExpansionState = [...expansionState];\n\n      if (grid.rowEditable) {\n        grid.repositionRowEditingOverlay(grid.gridAPI.crudService.rowInEditMode);\n      }\n    }\n\n    set_grouprow_expansion_state(groupRow, value) {\n      if (this.grid.isExpandedGroup(groupRow) !== value) {\n        this.groupBy_toggle_group(groupRow);\n      }\n    }\n\n    groupBy_fully_expand_group(groupRow) {\n      const state = this.groupBy_get_expanded_for_group(groupRow);\n      const expanded = state ? state.expanded : this.grid.groupsExpanded;\n\n      if (!expanded) {\n        this.groupBy_toggle_group(groupRow);\n      }\n\n      if (groupRow.groupParent) {\n        this.groupBy_fully_expand_group(groupRow.groupParent);\n      }\n    }\n\n    groupBy_select_all_rows_in_group(groupRow, clearPrevSelection) {\n      this.grid.selectionService.selectRowsWithNoEvent(this.grid.primaryKey ? groupRow.records.map(x => x[this.grid.primaryKey]) : groupRow.records, clearPrevSelection);\n    }\n\n    groupBy_deselect_all_rows_in_group(groupRow) {\n      this.grid.selectionService.deselectRowsWithNoEvent(this.grid.primaryKey ? groupRow.records.map(x => x[this.grid.primaryKey]) : groupRow.records);\n    }\n\n    arrange_sorting_expressions() {\n      const groupingState = this.grid.groupingExpressions;\n      this.grid.sortingExpressions.sort((a, b) => {\n        const groupExprA = groupingState.find(expr => expr.fieldName === a.fieldName);\n        const groupExprB = groupingState.find(expr => expr.fieldName === b.fieldName);\n\n        if (groupExprA && groupExprB) {\n          return groupingState.indexOf(groupExprA) > groupingState.indexOf(groupExprB) ? 1 : -1;\n        } else if (groupExprA) {\n          return -1;\n        } else if (groupExprB) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n    }\n\n    get_groupBy_record_id(gRow) {\n      let recordId = '{ ';\n      const hierrarchy = DataUtil.getHierarchy(gRow);\n\n      for (let i = 0; i < hierrarchy.length; i++) {\n        const groupByKey = hierrarchy[i];\n        recordId += `'${groupByKey.fieldName}': '${groupByKey.value}'`;\n\n        if (i < hierrarchy.length - 1) {\n          recordId += ', ';\n        }\n      }\n\n      recordId += ' }';\n      return recordId;\n    }\n\n    remove_grouping_expression(fieldName) {\n      const groupingExpressions = this.grid.groupingExpressions;\n      const index = groupingExpressions.findIndex(expr => expr.fieldName === fieldName);\n\n      if (index !== -1) {\n        groupingExpressions.splice(index, 1);\n      }\n    }\n\n  }\n\n  IgxGridAPIService.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxGridAPIService_BaseFactory;\n    return function IgxGridAPIService_Factory(t) {\n      return (ɵIgxGridAPIService_BaseFactory || (ɵIgxGridAPIService_BaseFactory = i0.ɵɵgetInheritedFactory(IgxGridAPIService)))(t || IgxGridAPIService);\n    };\n  }();\n\n  IgxGridAPIService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxGridAPIService,\n    factory: IgxGridAPIService.ɵfac\n  });\n  return IgxGridAPIService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridGroupByRowComponent = /*#__PURE__*/(() => {\n  class IgxGridGroupByRowComponent {\n    constructor(grid, gridSelection, element, cdr, filteringService) {\n      this.grid = grid;\n      this.gridSelection = gridSelection;\n      this.element = element;\n      this.cdr = cdr;\n      this.filteringService = filteringService;\n      /**\n       * @hidden\n       */\n\n      this.isFocused = false;\n      /**\n       * @hidden\n       */\n\n      this.destroy$ = new Subject();\n      /**\n       * @hidden\n       */\n\n      this.defaultCssClass = 'igx-grid__group-row';\n      /**\n       * @hidden\n       */\n\n      this.paddingIndentationCssClass = 'igx-grid__group-row--padding-level';\n      this.gridSelection.selectedRowsChange.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        this.cdr.markForCheck();\n      });\n    }\n    /**\n     * Returns whether the row is focused.\n     * ```\n     * let gridRowFocused = this.grid1.rowList.first.focused;\n     * ```\n     */\n\n\n    get focused() {\n      return this.isActive();\n    }\n\n    activate() {\n      this.grid.navigation.setActiveNode({\n        row: this.index\n      });\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n    /**\n     * Returns whether the group row is expanded.\n     * ```typescript\n     * const groupRowExpanded = this.grid1.rowList.first.expanded;\n     * ```\n     */\n\n\n    get expanded() {\n      return this.grid.isExpandedGroup(this.groupRow);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get describedBy() {\n      const grRowExpr = this.groupRow.expression !== undefined ? this.groupRow.expression.fieldName : '';\n      return this.gridID + '_' + grRowExpr;\n    }\n\n    get dataRowIndex() {\n      return this.index;\n    }\n    /**\n     * Returns a reference to the underlying HTML element.\n     * ```typescript\n     * const groupRowElement = this.nativeElement;\n     * ```\n     */\n\n\n    get nativeElement() {\n      return this.element.nativeElement;\n    }\n\n    get attrCellID() {\n      return `${this.gridID}_${this.index}`;\n    }\n    /**\n     * Returns the style classes applied to the group rows.\n     * ```typescript\n     * const groupCssStyles = this.grid1.rowList.first.styleClasses;\n     * ```\n     */\n\n\n    get styleClasses() {\n      return `${this.defaultCssClass} ` + `${this.paddingIndentationCssClass}-` + this.groupRow.level + (this.isActive() ? ` ${this.defaultCssClass}--active` : '');\n    }\n\n    isActive() {\n      return this.grid.navigation.activeNode ? this.grid.navigation.activeNode.row === this.index : false;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    getRowID(rowData) {\n      return this.grid.primaryKey ? rowData[this.grid.primaryKey] : rowData;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onGroupSelectorClick(event) {\n      if (!this.grid.isMultiRowSelectionEnabled) {\n        return;\n      }\n\n      event.stopPropagation();\n\n      if (this.areAllRowsInTheGroupSelected) {\n        this.gridSelection.deselectRows(this.groupRow.records.map(x => this.getRowID(x)));\n      } else {\n        this.gridSelection.selectRows(this.groupRow.records.map(x => this.getRowID(x)));\n      }\n    }\n    /**\n     * Toggles the group row.\n     * ```typescript\n     * this.grid1.rowList.first.toggle()\n     * ```\n     */\n\n\n    toggle() {\n      this.grid.toggleGroup(this.groupRow);\n    }\n\n    get iconTemplate() {\n      if (this.expanded) {\n        return this.grid.rowExpandedIndicatorTemplate || this.defaultGroupByExpandedTemplate;\n      } else {\n        return this.grid.rowCollapsedIndicatorTemplate || this.defaultGroupByCollapsedTemplate;\n      }\n    }\n\n    get selectionNode() {\n      return {\n        row: this.index,\n        column: this.gridSelection.activeElement ? this.gridSelection.activeElement.column : 0\n      };\n    }\n    /**\n     * @hidden\n     */\n\n\n    get dataType() {\n      const column = this.groupRow.column;\n      return column && column.dataType || GridColumnDataType.String;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get areAllRowsInTheGroupSelected() {\n      return this.groupRow.records.every(x => this.gridSelection.isRowSelected(this.getRowID(x)));\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get selectedRowsInTheGroup() {\n      const selectedIds = new Set(this.gridSelection.filteredSelectedRowIds);\n      return this.groupRow.records.filter(rowID => selectedIds.has(this.getRowID(rowID)));\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get groupByRowCheckboxIndeterminateState() {\n      if (this.selectedRowsInTheGroup.length > 0) {\n        return !this.areAllRowsInTheGroupSelected;\n      }\n\n      return false;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get groupByRowSelectorBaseAriaLabel() {\n      const ariaLabel = this.areAllRowsInTheGroupSelected ? this.grid.resourceStrings.igx_grid_groupByArea_deselect_message : this.grid.resourceStrings.igx_grid_groupByArea_select_message;\n      return ariaLabel.replace('{0}', this.groupRow.expression.fieldName).replace('{1}', this.groupRow.value);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get showRowSelectors() {\n      return this.grid.rowSelection !== GridSelectionMode.none && !this.hideGroupRowSelectors;\n    }\n\n  }\n\n  IgxGridGroupByRowComponent.ɵfac = function IgxGridGroupByRowComponent_Factory(t) {\n    return new (t || IgxGridGroupByRowComponent)(i0.ɵɵdirectiveInject(IGX_GRID_BASE), i0.ɵɵdirectiveInject(IgxGridSelectionService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(IgxFilteringService));\n  };\n\n  IgxGridGroupByRowComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxGridGroupByRowComponent,\n    selectors: [[\"igx-grid-groupby-row\"]],\n    viewQuery: function IgxGridGroupByRowComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c202, 7);\n        i0.ɵɵviewQuery(_c203, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c204, 7, TemplateRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupContent = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultGroupByExpandedTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultGroupByCollapsedTemplate = _t.first);\n      }\n    },\n    hostVars: 6,\n    hostBindings: function IgxGridGroupByRowComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"pointerdown\", function IgxGridGroupByRowComponent_pointerdown_HostBindingHandler() {\n          return ctx.activate();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-expanded\", ctx.expanded)(\"aria-describedby\", ctx.describedBy)(\"data-rowIndex\", ctx.dataRowIndex)(\"id\", ctx.attrCellID);\n        i0.ɵɵclassMap(ctx.styleClasses);\n      }\n    },\n    inputs: {\n      hideGroupRowSelectors: \"hideGroupRowSelectors\",\n      rowDraggable: \"rowDraggable\",\n      index: \"index\",\n      gridID: \"gridID\",\n      groupRow: \"groupRow\",\n      isFocused: \"isFocused\"\n    },\n    decls: 17,\n    vars: 10,\n    consts: [[\"defaultGroupRow\", \"\"], [4, \"ngIf\"], [1, \"igx-grid__grouping-indicator\", 3, \"click\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"igx-grid__group-content\"], [\"groupContent\", \"\"], [\"defaultGroupByExpandedTemplate\", \"\"], [\"defaultGroupByCollapsedTemplate\", \"\"], [\"defaultGroupByTemplate\", \"\"], [\"groupByRowSelectorBaseTemplate\", \"\"], [1, \"igx-grid__drag-indicator\", \"igx-grid__tr-action\"], [1, \"igx-grid__cbx-selection\", \"igx-grid__tr-action\", 2, \"background\", \"none\", 3, \"pointerdown\", \"click\"], [\"groupByRowSelector\", \"\"], [1, \"igx-group-label\"], [1, \"igx-group-label__icon\"], [1, \"igx-group-label__column-name\"], [4, \"ngIf\", \"ngIfElse\"], [\"default\", \"\"], [1, \"igx-group-label__count-badge\", 3, \"value\"], [1, \"igx-group-label__text\"], [1, \"igx-grid__cbx-padding\"], [3, \"tabindex\", \"readonly\", \"checked\", \"disableRipple\", \"indeterminate\", \"disabled\", \"aria-label\"], [\"groupByRowCheckbox\", \"\"]],\n    template: function IgxGridGroupByRowComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0, null, 0);\n        i0.ɵɵtemplate(2, IgxGridGroupByRowComponent_ng_container_2_Template, 4, 2, \"ng-container\", 1);\n        i0.ɵɵtemplate(3, IgxGridGroupByRowComponent_ng_container_3_Template, 3, 8, \"ng-container\", 1);\n        i0.ɵɵelementStart(4, \"div\", 2);\n        i0.ɵɵlistener(\"click\", function IgxGridGroupByRowComponent_Template_div_click_4_listener() {\n          return ctx.toggle();\n        });\n        i0.ɵɵtemplate(5, IgxGridGroupByRowComponent_ng_container_5_Template, 1, 0, \"ng-container\", 3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(6, \"div\", 4, 5);\n        i0.ɵɵtemplate(8, IgxGridGroupByRowComponent_ng_container_8_Template, 1, 0, \"ng-container\", 3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(9, IgxGridGroupByRowComponent_ng_template_9_Template, 2, 0, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(11, IgxGridGroupByRowComponent_ng_template_11_Template, 2, 0, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(13, IgxGridGroupByRowComponent_ng_template_13_Template, 9, 4, \"ng-template\", null, 8, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(15, IgxGridGroupByRowComponent_ng_template_15_Template, 3, 7, \"ng-template\", null, 9, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementContainerEnd();\n      }\n\n      if (rf & 2) {\n        const _r10 = i0.ɵɵreference(14);\n\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.rowDraggable);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showRowSelectors);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.iconTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(6, _c24, ctx));\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.grid.groupRowTemplate ? ctx.grid.groupRowTemplate : _r10)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(8, _c24, ctx.groupRow));\n      }\n    },\n    directives: [IgxIconComponent, IgxBadgeComponent, IgxCheckboxComponent, i4.NgIf, i4.NgTemplateOutlet],\n    pipes: [i4.DecimalPipe, i4.DatePipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxGridGroupByRowComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxGridMRLNavigationService = /*#__PURE__*/(() => {\n  class IgxGridMRLNavigationService extends IgxGridNavigationService {\n    isValidPosition(rowIndex, colIndex) {\n      if (rowIndex < 0 || colIndex < 0 || this.grid.dataView.length - 1 < rowIndex || Math.max(...this.grid.visibleColumns.map(col => col.visibleIndex)) < colIndex || this.activeNode.column !== colIndex && !this.isDataRow(rowIndex, true)) {\n        return false;\n      }\n\n      return true;\n    }\n\n    shouldPerformVerticalScroll(targetRowIndex, visibleColIndex) {\n      if (!super.shouldPerformVerticalScroll(targetRowIndex, visibleColIndex)) {\n        return false;\n      }\n\n      if (!this.isDataRow(targetRowIndex) || visibleColIndex < 0) {\n        return super.shouldPerformVerticalScroll(targetRowIndex, visibleColIndex);\n      }\n\n      const targetRow = super.getRowElementByIndex(targetRowIndex);\n      const containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;\n      const scrollPos = this.getVerticalScrollPositions(targetRowIndex, visibleColIndex);\n      return !targetRow || targetRow.offsetTop + scrollPos.topOffset < Math.abs(this.containerTopOffset) || containerHeight && containerHeight < scrollPos.rowBottom - Math.ceil(this.scrollTop);\n    }\n\n    isColumnFullyVisible(visibleColIndex) {\n      const targetCol = this.grid.getColumnByVisibleIndex(visibleColIndex);\n\n      if (this.isParentColumnFullyVisible(targetCol === null || targetCol === void 0 ? void 0 : targetCol.parent) || super.isColumnPinned(visibleColIndex, this.forOfDir())) {\n        return true;\n      }\n\n      const scrollPos = this.getChildColumnScrollPositions(visibleColIndex);\n      const colWidth = scrollPos.rightScroll - scrollPos.leftScroll;\n\n      if (this.displayContainerWidth < colWidth && this.displayContainerScrollLeft === scrollPos.leftScroll) {\n        return true;\n      }\n\n      return this.displayContainerWidth >= scrollPos.rightScroll - this.displayContainerScrollLeft && this.displayContainerScrollLeft <= scrollPos.leftScroll;\n    }\n\n    getVerticalScrollPositions(rowIndex, visibleIndex) {\n      const targetCol = this.grid.getColumnByVisibleIndex(visibleIndex);\n      const rowSpan = targetCol.rowEnd && targetCol.rowEnd - targetCol.rowStart ? targetCol.rowEnd - targetCol.rowStart : 1;\n      const topOffset = this.grid.defaultRowHeight * (targetCol.rowStart - 1);\n      const rowTop = this.grid.verticalScrollContainer.sizesCache[rowIndex] + topOffset;\n      return {\n        topOffset,\n        rowTop,\n        rowBottom: rowTop + this.grid.defaultRowHeight * rowSpan\n      };\n    }\n\n    performHorizontalScrollToCell(visibleColumnIndex, cb) {\n      if (!this.shouldPerformHorizontalScroll(visibleColumnIndex)) {\n        return;\n      }\n\n      const scrollPos = this.getChildColumnScrollPositions(visibleColumnIndex);\n      const startScroll = scrollPos.rightScroll - this.displayContainerScrollLeft;\n      const nextScroll = !(this.displayContainerScrollLeft <= scrollPos.leftScroll) && this.displayContainerWidth >= startScroll ? scrollPos.leftScroll : scrollPos.rightScroll - this.displayContainerWidth;\n      this.forOfDir().getScroll().scrollLeft = nextScroll;\n      this.grid.parentVirtDir.chunkLoad.pipe(first$1()).subscribe(() => {\n        if (cb) {\n          cb();\n        }\n      });\n    }\n\n    performVerticalScrollToCell(rowIndex, visibleColIndex, cb) {\n      var _a;\n\n      const children = (_a = this.parentByChildIndex(visibleColIndex || 0)) === null || _a === void 0 ? void 0 : _a.children;\n\n      if (!super.isDataRow(rowIndex) || children && children.length < 2 || visibleColIndex < 0) {\n        return super.performVerticalScrollToCell(rowIndex, visibleColIndex, cb);\n      }\n\n      const containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;\n      const pos = this.getVerticalScrollPositions(rowIndex, visibleColIndex);\n      const row = super.getRowElementByIndex(rowIndex);\n\n      if (this.scrollTop > pos.rowTop && (!row || row.offsetTop + pos.topOffset < Math.abs(this.containerTopOffset))) {\n        if (pos.topOffset === 0) {\n          this.grid.verticalScrollContainer.scrollTo(rowIndex);\n        } else {\n          this.grid.verticalScrollContainer.scrollPosition = pos.rowTop;\n        }\n      } else {\n        this.grid.verticalScrollContainer.addScrollTop(Math.abs(pos.rowBottom - this.scrollTop - containerHeight));\n      }\n\n      this.grid.verticalScrollContainer.chunkLoad.pipe(first$1()).subscribe(() => {\n        if (cb) {\n          cb();\n        }\n      });\n    }\n\n    getNextHorizontalCellPosition(previous = false) {\n      const parent = this.parentByChildIndex(this.activeNode.column);\n\n      if (!this.hasNextHorizontalPosition(previous, parent)) {\n        return {\n          row: this.activeNode.row,\n          column: this.activeNode.column\n        };\n      }\n\n      const columns = previous ? parent.children.filter(c => c.rowStart <= this.activeNode.layout.rowStart).sort((a, b) => b.visibleIndex - a.visibleIndex) : parent.children.filter(c => c.rowStart <= this.activeNode.layout.rowStart);\n      let column = columns.find(col => previous ? col.visibleIndex < this.activeNode.column && this.rowEnd(col) > this.activeNode.layout.rowStart : col.visibleIndex > this.activeNode.column && col.colStart > this.activeNode.layout.colStart);\n\n      if (!column || previous && this.activeNode.layout.colStart === 1) {\n        const index = previous ? parent.visibleIndex - 1 : parent.visibleIndex + 1;\n        const children = this.grid.columnList.find(cols => cols.columnLayout && cols.visibleIndex === index).children;\n        column = previous ? children.toArray().reverse().find(child => child.rowStart <= this.activeNode.layout.rowStart) : children.find(child => this.rowEnd(child) > this.activeNode.layout.rowStart && child.colStart === 1);\n      }\n\n      return {\n        row: this.activeNode.row,\n        column: column.visibleIndex\n      };\n    }\n\n    getNextVerticalPosition(previous = false) {\n      this.activeNode.column = this.activeNode.column || 0;\n\n      if (!this.hasNextVerticalPosition(previous)) {\n        return {\n          row: this.activeNode.row,\n          column: this.activeNode.column\n        };\n      }\n\n      const currentRowStart = this.grid.getColumnByVisibleIndex(this.activeNode.column).rowStart;\n      const nextBlock = !this.isDataRow(this.activeNode.row) || (previous ? currentRowStart === 1 : currentRowStart === this.lastRowStartPerBlock());\n      const nextRI = previous ? this.activeNode.row - 1 : this.activeNode.row + 1;\n\n      if (nextBlock && !this.isDataRow(nextRI)) {\n        return {\n          row: nextRI,\n          column: this.activeNode.column\n        };\n      }\n\n      const children = this.parentByChildIndex(this.activeNode.column).children;\n      const col = previous ? this.getPreviousRowIndex(children, nextBlock) : this.getNextRowIndex(children, nextBlock);\n      return {\n        row: nextBlock ? nextRI : this.activeNode.row,\n        column: col.visibleIndex\n      };\n    }\n\n    headerNavigation(event) {\n      const key = event.key.toLowerCase();\n\n      if (!HEADER_KEYS.has(key)) {\n        return;\n      }\n\n      event.preventDefault();\n\n      if (!this.activeNode.layout) {\n        this.activeNode.layout = this.layout(this.activeNode.column || 0);\n      }\n\n      const alt = event.altKey;\n      const ctrl = event.ctrlKey;\n      this.performHeaderKeyCombination(this.grid.getColumnByVisibleIndex(this.activeNode.column), key, event.shiftKey, ctrl, alt, event);\n\n      if (!ctrl && !alt && (key.includes('down') || key.includes('up'))) {\n        const children = this.parentByChildIndex(this.activeNode.column).children;\n        const col = key.includes('down') ? this.getNextRowIndex(children, false) : this.getPreviousRowIndex(children, false);\n\n        if (!col) {\n          return;\n        }\n\n        this.activeNode.column = col.visibleIndex;\n        const layout = this.layout(this.activeNode.column);\n        const nextLayout = Object.assign(Object.assign({}, this.activeNode.layout), {\n          rowStart: layout.rowStart,\n          rowEnd: layout.rowEnd\n        });\n        this.setActiveNode({\n          row: this.activeNode.row,\n          layout: nextLayout\n        });\n        return;\n      }\n\n      this.horizontalNav(event, key, -1, 'headerCell');\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    layout(visibleIndex) {\n      const column = this.grid.getColumnByVisibleIndex(visibleIndex);\n      return {\n        colStart: column.colStart,\n        rowStart: column.rowStart,\n        colEnd: column.colEnd,\n        rowEnd: column.rowEnd,\n        columnVisibleIndex: column.visibleIndex\n      };\n    }\n\n    getNextPosition(rowIndex, colIndex, key, shift, ctrl, event) {\n      if (!this.activeNode.layout) {\n        this.activeNode.layout = this.layout(this.activeNode.column || 0);\n      }\n\n      switch (key) {\n        case 'tab':\n        case ' ':\n        case 'spacebar':\n        case 'space':\n        case 'escape':\n        case 'esc':\n        case 'enter':\n        case 'f2':\n          super.getNextPosition(rowIndex, colIndex, key, shift, ctrl, event);\n          break;\n\n        case 'end':\n          rowIndex = ctrl ? this.findLastDataRowIndex() : this.activeNode.row;\n          colIndex = ctrl ? this.lastColIndexPerMRLBlock(this.lastIndexPerRow) : this.lastIndexPerRow;\n          break;\n\n        case 'home':\n          rowIndex = ctrl ? this.findFirstDataRowIndex() : this.activeNode.row;\n          colIndex = ctrl ? 0 : this.firstIndexPerRow;\n          break;\n\n        case 'arrowleft':\n        case 'left':\n          colIndex = ctrl ? this.firstIndexPerRow : this.getNextHorizontalCellPosition(true).column;\n          break;\n\n        case 'arrowright':\n        case 'right':\n          colIndex = ctrl ? this.lastIndexPerRow : this.getNextHorizontalCellPosition().column;\n          break;\n\n        case 'arrowup':\n        case 'up':\n          const prevPos = this.getNextVerticalPosition(true);\n          colIndex = ctrl ? this.activeNode.column : prevPos.column;\n          rowIndex = ctrl ? this.findFirstDataRowIndex() : prevPos.row;\n          break;\n\n        case 'arrowdown':\n        case 'down':\n          const nextPos = this.getNextVerticalPosition();\n          colIndex = ctrl ? this.activeNode.column : nextPos.column;\n          rowIndex = ctrl ? this.findLastDataRowIndex() : nextPos.row;\n          break;\n\n        default:\n          return;\n      }\n\n      const nextLayout = this.layout(colIndex);\n      const newLayout = key.includes('up') || key.includes('down') ? {\n        rowStart: nextLayout.rowStart\n      } : {\n        colStart: nextLayout.colStart\n      };\n      Object.assign(this.activeNode.layout, newLayout, {\n        rowEnd: nextLayout.rowEnd\n      });\n\n      if (ctrl && (key === 'home' || key === 'end')) {\n        this.activeNode.layout = nextLayout;\n      }\n\n      return {\n        rowIndex,\n        colIndex\n      };\n    }\n\n    horizontalNav(event, key, rowIndex, tag) {\n      const ctrl = event.ctrlKey;\n\n      if (!HORIZONTAL_NAV_KEYS.has(key) || event.altKey) {\n        return;\n      }\n\n      this.activeNode.row = rowIndex;\n      const newActiveNode = {\n        column: this.activeNode.column,\n        mchCache: {\n          level: this.activeNode.level,\n          visibleIndex: this.activeNode.column\n        }\n      };\n\n      if ((key.includes('left') || key === 'home') && this.activeNode.column > 0) {\n        newActiveNode.column = ctrl || key === 'home' ? this.firstIndexPerRow : this.getNextHorizontalCellPosition(true).column;\n      }\n\n      if ((key.includes('right') || key === 'end') && this.activeNode.column !== this.lastIndexPerRow) {\n        newActiveNode.column = ctrl || key === 'end' ? this.lastIndexPerRow : this.getNextHorizontalCellPosition().column;\n      }\n\n      if (tag === 'headerCell') {\n        const column = this.grid.getColumnByVisibleIndex(newActiveNode.column);\n        newActiveNode.mchCache.level = column.level;\n        newActiveNode.mchCache.visibleIndex = column.visibleIndex;\n      }\n\n      const layout = this.layout(newActiveNode.column);\n      const newLayout = Object.assign(Object.assign({}, this.activeNode.layout), {\n        colStart: layout.colStart,\n        rowEnd: layout.rowEnd\n      });\n      this.setActiveNode({\n        row: this.activeNode.row,\n        column: newActiveNode.column,\n        layout: newLayout,\n        mchCache: newActiveNode.mchCache\n      });\n      this.performHorizontalScrollToCell(newActiveNode.column);\n    }\n\n    isParentColumnFullyVisible(parent) {\n      if (!this.forOfDir().getScroll().clientWidth || (parent === null || parent === void 0 ? void 0 : parent.pinned)) {\n        return true;\n      }\n\n      const index = this.forOfDir().igxForOf.indexOf(parent);\n      return this.displayContainerWidth >= this.forOfDir().getColumnScrollLeft(index + 1) - this.displayContainerScrollLeft && this.displayContainerScrollLeft <= this.forOfDir().getColumnScrollLeft(index);\n    }\n\n    getChildColumnScrollPositions(visibleColIndex) {\n      const targetCol = this.grid.getColumnByVisibleIndex(visibleColIndex);\n      const parentVIndex = this.forOfDir().igxForOf.indexOf(targetCol.parent);\n      let leftScroll = this.forOfDir().getColumnScrollLeft(parentVIndex);\n      let rightScroll = this.forOfDir().getColumnScrollLeft(parentVIndex + 1);\n      targetCol.parent.children.forEach(c => {\n        if (c.rowStart >= targetCol.rowStart && c.visibleIndex < targetCol.visibleIndex) {\n          leftScroll += parseInt(c.width, 10);\n        }\n\n        if (c.rowStart <= targetCol.rowStart && c.visibleIndex > targetCol.visibleIndex) {\n          rightScroll -= parseInt(c.width, 10);\n        }\n      });\n      return {\n        leftScroll,\n        rightScroll\n      };\n    }\n\n    getNextRowIndex(children, next) {\n      const rowStart = next ? 1 : this.rowEnd(this.grid.getColumnByVisibleIndex(this.activeNode.column));\n      const col = children.filter(c => c.rowStart === rowStart);\n      return col.find(co => co.colStart === this.activeNode.layout.colStart) || col.sort((a, b) => b.visibleIndex - a.visibleIndex).find(co => co.colStart <= this.activeNode.layout.colStart);\n    }\n\n    getPreviousRowIndex(children, prev) {\n      const end = prev ? Math.max(...children.map(c => this.rowEnd(c))) : this.grid.getColumnByVisibleIndex(this.activeNode.column).rowStart;\n      const col = children.filter(c => this.rowEnd(c) === end);\n      return col.find(co => co.colStart === this.activeNode.layout.colStart) || col.sort((a, b) => b.visibleIndex - a.visibleIndex).find(co => co.colStart <= this.activeNode.layout.colStart);\n    }\n\n    get lastIndexPerRow() {\n      const children = this.grid.visibleColumns.find(c => c.visibleIndex === this.lastLayoutIndex && c.columnLayout).children.toArray().reverse();\n      const column = children.find(co => co.rowStart === this.activeNode.layout.rowStart) || children.find(co => co.rowStart <= this.activeNode.layout.rowStart);\n      return column.visibleIndex;\n    }\n\n    get firstIndexPerRow() {\n      const children = this.grid.visibleColumns.find(c => c.visibleIndex === 0 && c.columnLayout).children;\n      const column = children.find(co => co.rowStart === this.activeNode.layout.rowStart) || children.find(co => co.rowStart <= this.activeNode.layout.rowStart);\n      return column.visibleIndex;\n    }\n\n    get lastLayoutIndex() {\n      return Math.max(...this.grid.visibleColumns.filter(c => c.columnLayout).map(col => col.visibleIndex));\n    }\n\n    get scrollTop() {\n      return Math.abs(this.grid.verticalScrollContainer.getScroll().scrollTop);\n    }\n\n    lastColIndexPerMRLBlock(visibleIndex = this.activeNode.column) {\n      return this.parentByChildIndex(visibleIndex).children.last.visibleIndex;\n    }\n\n    lastRowStartPerBlock(visibleIndex = this.activeNode.column) {\n      return Math.max(...this.parentByChildIndex(visibleIndex).children.map(c => c.rowStart));\n    }\n\n    rowEnd(column) {\n      return column.rowEnd && column.rowEnd - column.rowStart ? column.rowStart + column.rowEnd - column.rowStart : column.rowStart + 1;\n    }\n\n    parentByChildIndex(visibleIndex) {\n      var _a;\n\n      return (_a = this.grid.getColumnByVisibleIndex(visibleIndex)) === null || _a === void 0 ? void 0 : _a.parent;\n    }\n\n    hasNextHorizontalPosition(previous = false, parent) {\n      if (previous && parent.visibleIndex === 0 && this.activeNode.layout.colStart === 1 || !previous && parent.visibleIndex === this.lastLayoutIndex && this.activeNode.column === this.lastIndexPerRow) {\n        return false;\n      }\n\n      return true;\n    }\n\n    hasNextVerticalPosition(prev = false) {\n      if (prev && this.activeNode.row === 0 && (!this.isDataRow(this.activeNode.row) || this.activeNode.layout.rowStart === 1) || !prev && this.activeNode.row >= this.grid.dataView.length - 1 && this.activeNode.column === this.lastColIndexPerMRLBlock()) {\n        return false;\n      }\n\n      return true;\n    }\n\n  }\n\n  IgxGridMRLNavigationService.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxGridMRLNavigationService_BaseFactory;\n    return function IgxGridMRLNavigationService_Factory(t) {\n      return (ɵIgxGridMRLNavigationService_BaseFactory || (ɵIgxGridMRLNavigationService_BaseFactory = i0.ɵɵgetInheritedFactory(IgxGridMRLNavigationService)))(t || IgxGridMRLNavigationService);\n    };\n  }();\n\n  IgxGridMRLNavigationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxGridMRLNavigationService,\n    factory: IgxGridMRLNavigationService.ɵfac\n  });\n  return IgxGridMRLNavigationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Providing reference to `IgxGridCellComponent`:\n * ```typescript\n * @ViewChild('grid', { read: IgxGridComponent })\n *  public grid: IgxGridComponent;\n * ```\n * ```typescript\n *  let column = this.grid.columnList.first;\n * ```\n * ```typescript\n *  let cell = column.cells[0];\n * ```\n */\n\n\nlet IgxGridCellComponent = /*#__PURE__*/(() => {\n  class IgxGridCellComponent {\n    constructor(selectionService, grid, cdr, element, zone, touchManager, platformUtil) {\n      this.selectionService = selectionService;\n      this.grid = grid;\n      this.cdr = cdr;\n      this.element = element;\n      this.zone = zone;\n      this.touchManager = touchManager;\n      this.platformUtil = platformUtil;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this.lastPinned = false;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this.firstPinned = false;\n      /**\n       * Returns whether the cell is in edit mode.\n       */\n\n      this.editMode = false;\n      /**\n       * Sets/get the `role` property of the cell.\n       * Default value is `\"gridcell\"`.\n       * ```typescript\n       * this.cell.role = 'grid-cell';\n       * ```\n       * ```typescript\n       * let cellRole = this.cell.role;\n       * ```\n       *\n       * @memberof IgxGridCellComponent\n       */\n\n      this.role = 'gridcell';\n      /**\n       * Gets the width of the cell.\n       * ```typescript\n       * let cellWidth = this.cell.width;\n       * ```\n       *\n       * @memberof IgxGridCellComponent\n       */\n\n      this.width = '';\n      /**\n       * @hidden\n       */\n\n      this.active = false;\n      /**\n       * @hidden\n       */\n\n      this.displayPinnedChip = false;\n      /**\n       * Sets/gets the highlight class of the cell.\n       * Default value is `\"igx-highlight\"`.\n       * ```typescript\n       * let highlightClass = this.cell.highlightClass;\n       * ```\n       * ```typescript\n       * this.cell.highlightClass = 'igx-cell-highlight';\n       * ```\n       *\n       * @memberof IgxGridCellComponent\n       */\n\n      this.highlightClass = 'igx-highlight';\n      /**\n       * Sets/gets the active highlight class class of the cell.\n       * Default value is `\"igx-highlight__active\"`.\n       * ```typescript\n       * let activeHighlightClass = this.cell.activeHighlightClass;\n       * ```\n       * ```typescript\n       * this.cell.activeHighlightClass = 'igx-cell-highlight_active';\n       * ```\n       *\n       * @memberof IgxGridCellComponent\n       */\n\n      this.activeHighlightClass = 'igx-highlight__active';\n      this._cellSelection = GridSelectionMode.multiple;\n      this._vIndex = -1;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this.onDoubleClick = event => {\n        if (event.type === 'doubletap') {\n          // prevent double-tap to zoom on iOS\n          event.preventDefault();\n        }\n\n        if (this.editable && !this.editMode && !this.intRow.deleted && !this.grid.crudService.rowEditingBlocked) {\n          this.grid.crudService.enterEditMode(this, event);\n        }\n\n        this.grid.doubleClick.emit({\n          cell: this.getCellType(),\n          event\n        });\n      };\n      /**\n       *\n       * @hidden\n       * @internal\n       */\n\n\n      this.pointerdown = event => {\n        if (this.cellSelectionMode !== GridSelectionMode.multiple) {\n          this.activate(event);\n          return;\n        }\n\n        if (!this.platformUtil.isLeftClick(event)) {\n          event.preventDefault();\n          this.grid.navigation.setActiveNode({\n            rowIndex: this.rowIndex,\n            colIndex: this.visibleColumnIndex\n          });\n          this.selectionService.addKeyboardRange();\n          this.selectionService.initKeyboardState();\n          this.selectionService.primaryButton = false; // Ensure RMB Click on edited cell does not end cell editing\n\n          if (!this.selected) {\n            this.grid.crudService.updateCell(true, event);\n          }\n\n          return;\n        }\n\n        this.selectionService.pointerDown(this.selectionNode, event.shiftKey, event.ctrlKey);\n        this.activate(event);\n      };\n      /**\n       *\n       * @hidden\n       * @internal\n       */\n\n\n      this.pointerenter = event => {\n        var _a, _b;\n\n        const isHierarchicalGrid = this.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';\n\n        if (isHierarchicalGrid && (!((_b = (_a = this.grid.navigation) === null || _a === void 0 ? void 0 : _a.activeNode) === null || _b === void 0 ? void 0 : _b.gridID) || this.grid.navigation.activeNode.gridID !== this.gridID)) {\n          return;\n        }\n\n        const dragMode = this.selectionService.pointerEnter(this.selectionNode, event);\n\n        if (dragMode) {\n          this.grid.cdr.detectChanges();\n        }\n      };\n      /**\n       * @hidden\n       * @internal\n       */\n\n\n      this.pointerup = event => {\n        var _a, _b;\n\n        const isHierarchicalGrid = this.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';\n\n        if (!this.platformUtil.isLeftClick(event) || isHierarchicalGrid && (!((_b = (_a = this.grid.navigation) === null || _a === void 0 ? void 0 : _a.activeNode) === null || _b === void 0 ? void 0 : _b.gridID) || this.grid.navigation.activeNode.gridID !== this.gridID)) {\n          return;\n        }\n\n        if (this.selectionService.pointerUp(this.selectionNode, this.grid.rangeSelected)) {\n          this.grid.cdr.detectChanges();\n        }\n      };\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get isEmptyAddRowCell() {\n      return this.intRow.addRowUI && (this.value === undefined || this.value === null);\n    }\n    /**\n     * Gets the row of the cell.\n     * ```typescript\n     * let cellRow = this.cell.row;\n     * ```\n     *\n     * @memberof IgxGridCellComponent\n     */\n\n\n    get row() {\n      return this.grid.createRow(this.intRow.index);\n    }\n    /**\n     * Gets the cell template context object.\n     * ```typescript\n     *  let context = this.cell.context();\n     * ```\n     *\n     * @memberof IgxGridCellComponent\n     */\n\n\n    get context() {\n      const ctx = {\n        $implicit: this.value,\n        additionalTemplateContext: this.column.additionalTemplateContext\n      };\n      /* Turns the `cell` property from the template context object into lazy-evaluated one.\n       * Otherwise on each detection cycle the cell template is recreating N cell instances where\n       * N = number of visible cells in the grid, leading to massive performance degradation in large grids.\n       */\n\n      Object.defineProperty(ctx, 'cell', {\n        get: () => this.getCellType(true)\n      });\n      return ctx;\n    }\n    /**\n     * Gets the cell template.\n     * ```typescript\n     * let template = this.cell.template;\n     * ```\n     *\n     * @memberof IgxGridCellComponent\n     */\n\n\n    get template() {\n      if (this.editMode) {\n        const inlineEditorTemplate = this.column.inlineEditorTemplate;\n        return inlineEditorTemplate ? inlineEditorTemplate : this.inlineEditorTemplate;\n      }\n\n      if (this.cellTemplate) {\n        return this.cellTemplate;\n      }\n\n      if (this.grid.rowEditable && this.intRow.addRowUI) {\n        return this.addRowCellTemplate;\n      }\n\n      return this.defaultCellTemplate;\n    }\n    /**\n     * Gets the pinned indicator template.\n     * ```typescript\n     * let template = this.cell.pinnedIndicatorTemplate;\n     * ```\n     *\n     * @memberof IgxGridCellComponent\n     */\n\n\n    get pinnedIndicatorTemplate() {\n      if (this.pinnedIndicator) {\n        return this.pinnedIndicator;\n      }\n\n      return this.defaultPinnedIndicator;\n    }\n    /**\n     * Gets the `id` of the grid in which the cell is stored.\n     * ```typescript\n     * let gridId = this.cell.gridID;\n     * ```\n     *\n     * @memberof IgxGridCellComponent\n     */\n\n\n    get gridID() {\n      return this.intRow.gridID;\n    }\n    /**\n     * Gets the `index` of the row where the cell is stored.\n     * ```typescript\n     * let rowIndex = this.cell.rowIndex;\n     * ```\n     *\n     * @memberof IgxGridCellComponent\n     */\n\n\n    get rowIndex() {\n      return this.intRow.index;\n    }\n    /**\n     * Gets the `index` of the cell column.\n     * ```typescript\n     * let columnIndex = this.cell.columnIndex;\n     * ```\n     *\n     * @memberof IgxGridCellComponent\n     */\n\n\n    get columnIndex() {\n      return this.column.index;\n    }\n    /**\n     * Returns the column visible index.\n     * ```typescript\n     * let visibleColumnIndex = this.cell.visibleColumnIndex;\n     * ```\n     *\n     * @memberof IgxGridCellComponent\n     */\n\n\n    get visibleColumnIndex() {\n      return this.column.columnLayoutChild ? this.column.visibleIndex : this._vIndex;\n    }\n\n    set visibleColumnIndex(val) {\n      this._vIndex = val;\n    }\n    /**\n     * Gets the ID of the cell.\n     * ```typescript\n     * let cellID = this.cell.cellID;\n     * ```\n     *\n     * @memberof IgxGridCellComponent\n     */\n\n\n    get cellID() {\n      const primaryKey = this.grid.primaryKey;\n      const rowID = primaryKey ? this.rowData[primaryKey] : this.rowData;\n      return {\n        rowID,\n        columnID: this.columnIndex,\n        rowIndex: this.rowIndex\n      };\n    }\n\n    get attrCellID() {\n      return `${this.intRow.gridID}_${this.rowIndex}_${this.visibleColumnIndex}`;\n    }\n\n    get title() {\n      if (this.editMode || this.cellTemplate) {\n        return '';\n      }\n\n      if (this.formatter) {\n        return this.formatter(this.value, this.rowData);\n      }\n\n      const args = this.column.pipeArgs;\n      const locale = this.grid.locale;\n\n      switch (this.column.dataType) {\n        case GridColumnDataType.Percent:\n          return formatPercent(this.value, locale, args.digitsInfo);\n\n        case GridColumnDataType.Currency:\n          return formatCurrency(this.value, this.currencyCode, args.display, args.digitsInfo, locale);\n\n        case GridColumnDataType.Date:\n        case GridColumnDataType.DateTime:\n        case GridColumnDataType.Time:\n          return formatDate(this.value, args.format, locale, args.timezone);\n      }\n\n      return this.value;\n    }\n\n    get booleanClass() {\n      return this.column.dataType === 'boolean' && this.value;\n    }\n    /**\n     * Returns a reference to the nativeElement of the cell.\n     * ```typescript\n     * let cellNativeElement = this.cell.nativeElement;\n     * ```\n     *\n     * @memberof IgxGridCellComponent\n     */\n\n\n    get nativeElement() {\n      return this.element.nativeElement;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get cellSelectionMode() {\n      return this._cellSelection;\n    }\n\n    set cellSelectionMode(value) {\n      if (this._cellSelection === value) {\n        return;\n      }\n\n      this.zone.runOutsideAngular(() => {\n        if (value === GridSelectionMode.multiple) {\n          this.addPointerListeners(value);\n        } else {\n          this.removePointerListeners(this._cellSelection);\n        }\n      });\n      this._cellSelection = value;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    set lastSearchInfo(value) {\n      this._lastSearchInfo = value;\n      this.highlightText(this._lastSearchInfo.searchText, this._lastSearchInfo.caseSensitive, this._lastSearchInfo.exactMatch);\n    }\n    /**\n     * Gets whether the cell is editable.\n     * ```typescript\n     * let isCellReadonly = this.cell.readonly;\n     * ```\n     *\n     * @memberof IgxGridCellComponent\n     */\n\n\n    get readonly() {\n      return !this.editable;\n    }\n\n    get gridRowSpan() {\n      return this.column.gridRowSpan;\n    }\n\n    get gridColumnSpan() {\n      return this.column.gridColumnSpan;\n    }\n\n    get rowEnd() {\n      return this.column.rowEnd;\n    }\n\n    get colEnd() {\n      return this.column.colEnd;\n    }\n\n    get rowStart() {\n      return this.column.rowStart;\n    }\n\n    get colStart() {\n      return this.column.colStart;\n    }\n\n    get ariaSelected() {\n      return this.selected || this.column.selected || this.intRow.selected;\n    }\n    /**\n     * Gets whether the cell is selected.\n     * ```typescript\n     * let isSelected = this.cell.selected;\n     * ```\n     *\n     * @memberof IgxGridCellComponent\n     */\n\n\n    get selected() {\n      return this.selectionService.selected(this.selectionNode);\n    }\n    /**\n     * Selects/deselects the cell.\n     * ```typescript\n     * this.cell.selected = true.\n     * ```\n     *\n     * @memberof IgxGridCellComponent\n     */\n\n\n    set selected(val) {\n      const node = this.selectionNode;\n\n      if (val) {\n        this.selectionService.add(node);\n      } else {\n        this.selectionService.remove(node);\n      }\n\n      this.grid.notifyChanges();\n    }\n    /**\n     * Gets whether the cell column is selected.\n     * ```typescript\n     * let isCellColumnSelected = this.cell.columnSelected;\n     * ```\n     *\n     * @memberof IgxGridCellComponent\n     */\n\n\n    get columnSelected() {\n      return this.selectionService.isColumnSelected(this.column.field);\n    }\n    /**\n     * Sets the current edit value while a cell is in edit mode.\n     * Only for cell editing mode.\n     * ```typescript\n     * this.cell.editValue = value;\n     * ```\n     *\n     * @memberof IgxGridCellComponent\n     */\n\n\n    set editValue(value) {\n      if (this.grid.crudService.cellInEditMode) {\n        this.grid.crudService.cell.editValue = value;\n      }\n    }\n    /**\n     * Gets the current edit value while a cell is in edit mode.\n     * Only for cell editing mode.\n     * ```typescript\n     * let editValue = this.cell.editValue;\n     * ```\n     *\n     * @memberof IgxGridCellComponent\n     */\n\n\n    get editValue() {\n      if (this.grid.crudService.cellInEditMode) {\n        return this.grid.crudService.cell.editValue;\n      }\n    }\n    /**\n     * Returns whether the cell is editable.\n     */\n\n\n    get editable() {\n      return this.column.editable && !this.intRow.disabled;\n    }\n\n    set highlight(value) {\n      this._highlight = value;\n\n      if (this._highlight && this.grid.lastSearchInfo.searchText) {\n        this._highlight.highlight(this.grid.lastSearchInfo.searchText, this.grid.lastSearchInfo.caseSensitive, this.grid.lastSearchInfo.exactMatch);\n\n        this._highlight.activateIfNecessary();\n      }\n    }\n\n    get highlight() {\n      return this._highlight;\n    }\n\n    get selectionNode() {\n      return {\n        row: this.rowIndex,\n        column: this.column.columnLayoutChild ? this.column.parent.visibleIndex : this.visibleColumnIndex,\n        layout: this.column.columnLayoutChild ? {\n          rowStart: this.column.rowStart,\n          colStart: this.column.colStart,\n          rowEnd: this.column.rowEnd,\n          colEnd: this.column.colEnd,\n          columnVisibleIndex: this.visibleColumnIndex\n        } : null\n      };\n    }\n    /** @hidden @internal */\n\n\n    get step() {\n      const digitsInfo = this.column.pipeArgs.digitsInfo;\n\n      if (!digitsInfo) {\n        return 1;\n      }\n\n      const step = +digitsInfo.substr(digitsInfo.indexOf('.') + 1, 1);\n      return 1 / Math.pow(10, step);\n    }\n    /** @hidden @internal */\n\n\n    get currencyCode() {\n      return this.column.pipeArgs.currencyCode ? this.column.pipeArgs.currencyCode : getLocaleCurrencyCode(this.grid.locale);\n    }\n    /** @hidden @internal */\n\n\n    get currencyCodeSymbol() {\n      return getCurrencySymbol(this.currencyCode, 'wide', this.grid.locale);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onClick(event) {\n      this.grid.cellClick.emit({\n        cell: this.getCellType(),\n        event\n      });\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onContextMenu(event) {\n      this.grid.contextMenu.emit({\n        cell: this.getCellType(),\n        event\n      });\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    ngOnInit() {\n      this.zone.runOutsideAngular(() => {\n        this.nativeElement.addEventListener('pointerdown', this.pointerdown);\n        this.addPointerListeners(this.cellSelectionMode);\n      });\n\n      if (this.platformUtil.isIOS) {\n        this.touchManager.addEventListener(this.nativeElement, 'doubletap', this.onDoubleClick, {\n          cssProps: {}\n          /* don't disable user-select, etc */\n\n        });\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    ngOnDestroy() {\n      this.zone.runOutsideAngular(() => {\n        this.nativeElement.removeEventListener('pointerdown', this.pointerdown);\n        this.removePointerListeners(this.cellSelectionMode);\n      });\n      this.touchManager.destroy();\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    ngOnChanges(changes) {\n      if (changes.value && !changes.value.firstChange) {\n        if (this.highlight) {\n          this.highlight.lastSearchInfo.searchedText = this.grid.lastSearchInfo.searchText;\n          this.highlight.lastSearchInfo.caseSensitive = this.grid.lastSearchInfo.caseSensitive;\n          this.highlight.lastSearchInfo.exactMatch = this.grid.lastSearchInfo.exactMatch;\n        }\n      }\n    }\n    /**\n     * Starts/ends edit mode for the cell.\n     *\n     * ```typescript\n     * cell.setEditMode(true);\n     * ```\n     */\n\n\n    setEditMode(value) {\n      if (this.intRow.deleted) {\n        return;\n      }\n\n      if (this.editable && value) {\n        if (this.grid.crudService.cellInEditMode) {\n          this.grid.gridAPI.update_cell(this.grid.crudService.cell);\n          this.grid.crudService.endCellEdit();\n        }\n\n        this.grid.crudService.enterEditMode(this);\n      } else {\n        this.grid.crudService.endCellEdit();\n      }\n\n      this.grid.notifyChanges();\n    }\n    /**\n     * Sets new value to the cell.\n     * ```typescript\n     * this.cell.update('New Value');\n     * ```\n     *\n     * @memberof IgxGridCellComponent\n     */\n    // TODO: Refactor\n\n\n    update(val) {\n      if (this.intRow.deleted) {\n        return;\n      }\n\n      let cell = this.grid.crudService.cell;\n\n      if (!cell) {\n        cell = this.grid.crudService.createCell(this);\n      }\n\n      cell.editValue = val;\n      this.grid.gridAPI.update_cell(cell);\n      this.grid.crudService.endCellEdit();\n      this.cdr.markForCheck();\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    activate(event) {\n      const node = this.selectionNode;\n      const shouldEmitSelection = !this.selectionService.isActiveNode(node);\n\n      if (this.selectionService.primaryButton) {\n        const currentActive = this.selectionService.activeElement;\n        this.selectionService.activeElement = node;\n\n        const cancel = this._updateCRUDStatus(event);\n\n        if (cancel) {\n          this.selectionService.activeElement = currentActive;\n          return;\n        }\n\n        const activeElement = this.selectionService.activeElement;\n        const row = activeElement ? this.grid.gridAPI.get_row_by_index(activeElement.row) : null;\n\n        if (this.grid.crudService.rowEditingBlocked && row && this.intRow.key !== row.key) {\n          return;\n        }\n      } else {\n        this.selectionService.activeElement = null;\n\n        if (this.grid.crudService.cellInEditMode && !this.editMode) {\n          this.grid.crudService.updateCell(true, event);\n        }\n      }\n\n      this.grid.navigation.setActiveNode({\n        row: this.rowIndex,\n        column: this.visibleColumnIndex\n      });\n      this.selectionService.primaryButton = true;\n\n      if (this.cellSelectionMode === GridSelectionMode.multiple && this.selectionService.activeElement) {\n        this.selectionService.add(this.selectionService.activeElement, false); // pointer events handle range generation\n\n        this.selectionService.keyboardStateOnFocus(node, this.grid.rangeSelected, this.nativeElement);\n      }\n\n      if (this.grid.isCellSelectable && shouldEmitSelection) {\n        this.grid.selected.emit({\n          cell: this.getCellType(),\n          event\n        });\n      }\n    }\n    /**\n     * If the provided string matches the text in the cell, the text gets highlighted.\n     * ```typescript\n     * this.cell.highlightText('Cell Value', true);\n     * ```\n     *\n     * @memberof IgxGridCellComponent\n     */\n\n\n    highlightText(text, caseSensitive, exactMatch) {\n      return this.highlight && this.column.searchable ? this.highlight.highlight(text, caseSensitive, exactMatch) : 0;\n    }\n    /**\n     * Clears the highlight of the text in the cell.\n     * ```typescript\n     * this.cell.clearHighLight();\n     * ```\n     *\n     * @memberof IgxGridCellComponent\n     */\n\n\n    clearHighlight() {\n      if (this.highlight && this.column.searchable) {\n        this.highlight.clearHighlight();\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    calculateSizeToFit(range) {\n      return this.platformUtil.getNodeSizeViaRange(range, this.nativeElement);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get searchMetadata() {\n      const meta = new Map();\n      meta.set('pinned', this.grid.isRecordPinnedByViewIndex(this.intRow.index));\n      return meta;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    _updateCRUDStatus(event) {\n      if (this.editMode) {\n        return;\n      }\n\n      let editableArgs;\n      const crud = this.grid.crudService;\n      const editableCell = this.grid.crudService.cell;\n      const editMode = !!(crud.row || crud.cell);\n\n      if (this.editable && editMode && !this.intRow.deleted) {\n        if (editableCell) {\n          editableArgs = this.grid.crudService.updateCell(false, event);\n          /* This check is related with the following issue #6517:\n           * when edit cell that belongs to a column which is sorted and press tab,\n           * the next cell in edit mode is with wrong value /its context is not updated/;\n           * So we reapply sorting before the next cell enters edit mode.\n           * Also we need to keep the notifyChanges below, because of the current\n           * change detection cycle when we have editing with enabled transactions\n           */\n\n          if (this.grid.sortingExpressions.length && this.grid.sortingExpressions.indexOf(editableCell.column.field)) {\n            this.grid.cdr.detectChanges();\n          }\n\n          if (editableArgs && editableArgs.cancel) {\n            return true;\n          }\n\n          crud.exitCellEdit(event);\n        }\n\n        this.grid.tbody.nativeElement.focus({\n          preventScroll: true\n        });\n        this.grid.notifyChanges();\n        crud.enterEditMode(this, event);\n        return false;\n      }\n\n      if (editableCell && crud.sameRow(this.cellID.rowID)) {\n        this.grid.crudService.updateCell(true, event);\n      } else if (editMode && !crud.sameRow(this.cellID.rowID)) {\n        this.grid.crudService.endEdit(true, event);\n      }\n    }\n\n    addPointerListeners(selection) {\n      if (selection !== GridSelectionMode.multiple) {\n        return;\n      }\n\n      this.nativeElement.addEventListener('pointerenter', this.pointerenter);\n      this.nativeElement.addEventListener('pointerup', this.pointerup);\n    }\n\n    removePointerListeners(selection) {\n      if (selection !== GridSelectionMode.multiple) {\n        return;\n      }\n\n      this.nativeElement.removeEventListener('pointerenter', this.pointerenter);\n      this.nativeElement.removeEventListener('pointerup', this.pointerup);\n    }\n\n    getCellType(useRow) {\n      const rowID = useRow ? this.grid.createRow(this.intRow.index, this.intRow.data) : this.intRow.index;\n      return new IgxGridCell(this.grid, rowID, this.column.field);\n    }\n\n  }\n\n  IgxGridCellComponent.ɵfac = function IgxGridCellComponent_Factory(t) {\n    return new (t || IgxGridCellComponent)(i0.ɵɵdirectiveInject(IgxGridSelectionService), i0.ɵɵdirectiveInject(IGX_GRID_BASE), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(HammerGesturesManager), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxGridCellComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxGridCellComponent,\n    selectors: [[\"igx-grid-cell\"]],\n    viewQuery: function IgxGridCellComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c206, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c207, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c208, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c209, 7, TemplateRef);\n        i0.ɵɵviewQuery(IgxTextHighlightDirective, 5, IgxTextHighlightDirective);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultCellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultPinnedIndicator = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inlineEditorTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.addRowCellTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.highlight = _t.first);\n      }\n    },\n    hostVars: 25,\n    hostBindings: function IgxGridCellComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"dblclick\", function IgxGridCellComponent_dblclick_HostBindingHandler($event) {\n          return ctx.onDoubleClick($event);\n        })(\"click\", function IgxGridCellComponent_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        })(\"contextmenu\", function IgxGridCellComponent_contextmenu_HostBindingHandler($event) {\n          return ctx.onContextMenu($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"data-rowIndex\", ctx.rowIndex)(\"data-visibleIndex\", ctx.visibleColumnIndex)(\"id\", ctx.attrCellID)(\"title\", ctx.title)(\"role\", ctx.role)(\"aria-readonly\", ctx.readonly)(\"aria-selected\", ctx.ariaSelected);\n        i0.ɵɵclassProp(\"igx-grid__td--new\", ctx.isEmptyAddRowCell)(\"igx-grid__td--bool-true\", ctx.booleanClass)(\"igx-grid__td--pinned-last\", ctx.lastPinned)(\"igx-grid__td--pinned-first\", ctx.firstPinned)(\"igx-grid__td--editing\", ctx.editMode)(\"igx-grid__td--active\", ctx.active)(\"igx-grid__td--selected\", ctx.selected)(\"igx-grid__td--column-selected\", ctx.columnSelected)(\"igx-grid__td--row-pinned-first\", ctx.displayPinnedChip);\n      }\n    },\n    inputs: {\n      column: \"column\",\n      intRow: \"intRow\",\n      row: \"row\",\n      rowData: \"rowData\",\n      cellTemplate: \"cellTemplate\",\n      pinnedIndicator: \"pinnedIndicator\",\n      value: \"value\",\n      formatter: \"formatter\",\n      visibleColumnIndex: \"visibleColumnIndex\",\n      cellSelectionMode: \"cellSelectionMode\",\n      lastSearchInfo: \"lastSearchInfo\",\n      lastPinned: \"lastPinned\",\n      firstPinned: \"firstPinned\",\n      editMode: \"editMode\",\n      width: \"width\",\n      active: \"active\",\n      displayPinnedChip: \"displayPinnedChip\"\n    },\n    features: [i0.ɵɵProvidersFeature([HammerGesturesManager]), i0.ɵɵNgOnChangesFeature],\n    decls: 10,\n    vars: 4,\n    consts: [[\"defaultPinnedIndicator\", \"\"], [\"defaultCell\", \"\"], [\"addRowCell\", \"\"], [\"inlineEditor\", \"\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"class\", \"igx-grid__td--pinned-chip\", 3, \"disabled\", \"displayDensity\", 4, \"ngIf\"], [1, \"igx-grid__td--pinned-chip\", 3, \"disabled\", \"displayDensity\"], [\"igxTextHighlight\", \"\", \"class\", \"igx-grid__td-text\", \"style\", \"pointer-events: none;\", 3, \"cssClass\", \"activeCssClass\", \"groupName\", \"value\", \"row\", \"column\", \"containerClass\", \"metadata\", 4, \"ngIf\"], [3, \"ngClass\", 4, \"ngIf\"], [\"igxTextHighlight\", \"\", 1, \"igx-grid__td-text\", 2, \"pointer-events\", \"none\", 3, \"cssClass\", \"activeCssClass\", \"groupName\", \"value\", \"row\", \"column\", \"containerClass\", \"metadata\"], [3, \"ngClass\"], [\"igxTextHighlight\", \"\", \"class\", \"igx-grid__td-text\", \"style\", \"pointer-events: none\", 3, \"cssClass\", \"activeCssClass\", \"groupName\", \"value\", \"row\", \"column\", \"containerClass\", \"metadata\", 4, \"ngIf\"], [4, \"ngIf\"], [\"displayDensity\", \"compact\"], [\"igxInput\", \"\", 3, \"ngModel\", \"igxFocus\", \"ngModelChange\"], [\"igxInput\", \"\", \"type\", \"number\", 3, \"ngModel\", \"igxFocus\", \"step\", \"ngModelChange\"], [3, \"checked\", \"igxFocus\", \"disableRipple\", \"change\"], [\"mode\", \"dropdown\", 3, \"outlet\", \"locale\", \"value\", \"igxFocus\", \"valueChange\"], [\"mode\", \"dropdown\", 3, \"outlet\", \"locale\", \"inputFormat\", \"value\", \"igxFocus\", \"valueChange\"], [\"type\", \"text\", \"igxInput\", \"\", 3, \"igxDateTimeEditor\", \"ngModel\", \"igxFocus\", \"ngModelChange\"]],\n    template: function IgxGridCellComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxGridCellComponent_ng_template_0_Template, 1, 1, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, IgxGridCellComponent_ng_template_2_Template, 2, 2, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(4, IgxGridCellComponent_ng_template_4_Template, 1, 1, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(6, IgxGridCellComponent_ng_template_6_Template, 8, 8, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(8, IgxGridCellComponent_ng_container_8_Template, 1, 0, \"ng-container\", 4);\n        i0.ɵɵtemplate(9, IgxGridCellComponent_ng_container_9_Template, 1, 0, \"ng-container\", 4);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(8);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.pinnedIndicatorTemplate)(\"ngTemplateOutletContext\", ctx.context);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template)(\"ngTemplateOutletContext\", ctx.context);\n      }\n    },\n    directives: [IgxChipComponent, IgxIconComponent, IgxInputGroupComponent, IgxCheckboxComponent, IgxDatePickerComponent, IgxTimePickerComponent, i4.NgIf, IgxTextHighlightDirective, i4.NgClass, i12.DefaultValueAccessor, IgxInputDirective, i12.NgControlStatus, i12.NgModel, IgxFocusDirective, i12.NumberValueAccessor, IgxDateTimeEditorDirective, IgxPrefixDirective, IgxSuffixDirective, i4.NgTemplateOutlet],\n    pipes: [IgxColumnFormatterPipe, i4.DecimalPipe, i4.DatePipe, i4.CurrencyPipe, i4.PercentPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxGridCellComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridExpandableCellComponent = /*#__PURE__*/(() => {\n  class IgxGridExpandableCellComponent extends IgxGridCellComponent {\n    constructor(selectionService, grid, cdr, element, zone, touchManager, document, platformUtil) {\n      super(selectionService, grid, cdr, element, zone, touchManager, platformUtil);\n      this.zone = zone;\n      this.document = document;\n      this.platformUtil = platformUtil;\n      /**\n       * @hidden\n       */\n\n      this.expanded = false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    toggle(event) {\n      event.stopPropagation();\n      const expansionState = this.grid.gridAPI.get_row_expansion_state(this.intRow.data);\n      this.grid.gridAPI.set_row_expansion_state(this.intRow.key, !expansionState, event);\n    }\n    /**\n     * @hidden\n     */\n\n\n    onIndicatorFocus() {\n      this.grid.gridAPI.update_cell(this.grid.crudService.cell);\n    }\n    /**\n     * @hidden\n     */\n\n\n    calculateSizeToFit(range) {\n      let leftPadding = 0;\n\n      if (this.indentationDiv) {\n        const indentationStyle = this.document.defaultView.getComputedStyle(this.indentationDiv.nativeElement);\n        leftPadding = parseFloat(indentationStyle.paddingLeft);\n      }\n\n      const contentWidth = this.platformUtil.getNodeSizeViaRange(range, this.nativeElement);\n      return contentWidth + leftPadding;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get iconTemplate() {\n      if (this.expanded) {\n        return this.grid.rowExpandedIndicatorTemplate || this.defaultExpandedTemplate;\n      } else {\n        return this.grid.rowCollapsedIndicatorTemplate || this.defaultCollapsedTemplate;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get showExpanderIndicator() {\n      const isGhost = this.intRow.pinned && this.intRow.disabled;\n      return !this.editMode && (!this.intRow.pinned || isGhost);\n    }\n\n  }\n\n  IgxGridExpandableCellComponent.ɵfac = function IgxGridExpandableCellComponent_Factory(t) {\n    return new (t || IgxGridExpandableCellComponent)(i0.ɵɵdirectiveInject(IgxGridSelectionService), i0.ɵɵdirectiveInject(IGX_GRID_BASE), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(HammerGesturesManager), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxGridExpandableCellComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxGridExpandableCellComponent,\n    selectors: [[\"igx-expandable-grid-cell\"]],\n    viewQuery: function IgxGridExpandableCellComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c108, 5, ElementRef);\n        i0.ɵɵviewQuery(_c211, 5, ElementRef);\n        i0.ɵɵviewQuery(_c195, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c196, 7, TemplateRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.indicator = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.indentationDiv = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultExpandedTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultCollapsedTemplate = _t.first);\n      }\n    },\n    inputs: {\n      expanded: \"expanded\"\n    },\n    features: [i0.ɵɵProvidersFeature([HammerGesturesManager]), i0.ɵɵInheritDefinitionFeature],\n    decls: 15,\n    vars: 5,\n    consts: [[\"defaultPinnedIndicator\", \"\"], [\"defaultCell\", \"\"], [\"addRowCell\", \"\"], [\"inlineEditor\", \"\"], [4, \"ngIf\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"defaultExpandedTemplate\", \"\"], [\"defaultCollapsedTemplate\", \"\"], [\"class\", \"igx-grid__td--pinned-chip\", 3, \"disabled\", \"displayDensity\", 4, \"ngIf\"], [1, \"igx-grid__td--pinned-chip\", 3, \"disabled\", \"displayDensity\"], [\"igxTextHighlight\", \"\", \"class\", \"igx-grid__td-text\", \"style\", \"pointer-events: none\", 3, \"cssClass\", \"activeCssClass\", \"groupName\", \"value\", \"row\", \"column\", \"containerClass\", \"metadata\", 4, \"ngIf\"], [3, \"ngClass\", 4, \"ngIf\"], [\"igxTextHighlight\", \"\", 1, \"igx-grid__td-text\", 2, \"pointer-events\", \"none\", 3, \"cssClass\", \"activeCssClass\", \"groupName\", \"value\", \"row\", \"column\", \"containerClass\", \"metadata\"], [3, \"ngClass\"], [\"displayDensity\", \"compact\"], [\"igxInput\", \"\", 3, \"ngModel\", \"igxFocus\", \"ngModelChange\"], [\"igxInput\", \"\", \"type\", \"number\", 3, \"ngModel\", \"igxFocus\", \"step\", \"ngModelChange\"], [3, \"value\", \"checked\", \"disableRipple\", \"change\"], [\"mode\", \"dropdown\", 3, \"outlet\", \"locale\", \"value\", \"igxFocus\", \"valueChange\"], [\"mode\", \"dropdown\", 3, \"outlet\", \"inputFormat\", \"ngModel\", \"igxFocus\", \"ngModelChange\"], [\"type\", \"text\", \"igxInput\", \"\", 3, \"igxDateTimeEditor\", \"ngModel\", \"igxFocus\", \"ngModelChange\"], [\"igxInput\", \"\", \"type\", \"number\", 3, \"ngModel\", \"step\", \"igxFocus\", \"ngModelChange\"], [1, \"igx-grid__tree-grouping-indicator\", 3, \"click\", \"focus\"], [\"indicator\", \"\"]],\n    template: function IgxGridExpandableCellComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxGridExpandableCellComponent_ng_template_0_Template, 1, 1, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, IgxGridExpandableCellComponent_ng_template_2_Template, 2, 2, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(4, IgxGridExpandableCellComponent_ng_template_4_Template, 1, 1, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(6, IgxGridExpandableCellComponent_ng_template_6_Template, 8, 8, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(8, IgxGridExpandableCellComponent_ng_container_8_Template, 4, 4, \"ng-container\", 4);\n        i0.ɵɵtemplate(9, IgxGridExpandableCellComponent_ng_container_9_Template, 1, 0, \"ng-container\", 5);\n        i0.ɵɵtemplate(10, IgxGridExpandableCellComponent_ng_container_10_Template, 1, 0, \"ng-container\", 5);\n        i0.ɵɵtemplate(11, IgxGridExpandableCellComponent_ng_template_11_Template, 2, 0, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(13, IgxGridExpandableCellComponent_ng_template_13_Template, 2, 0, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(8);\n        i0.ɵɵproperty(\"ngIf\", ctx.showExpanderIndicator);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.pinnedIndicatorTemplate)(\"ngTemplateOutletContext\", ctx.context);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template)(\"ngTemplateOutletContext\", ctx.context);\n      }\n    },\n    directives: [IgxChipComponent, IgxIconComponent, IgxInputGroupComponent, IgxCheckboxComponent, IgxDatePickerComponent, IgxTimePickerComponent, i4.NgIf, IgxTextHighlightDirective, i4.NgClass, i12.DefaultValueAccessor, IgxInputDirective, i12.NgControlStatus, i12.NgModel, IgxFocusDirective, i12.NumberValueAccessor, IgxDateTimeEditorDirective, IgxPrefixDirective, IgxSuffixDirective, i4.NgTemplateOutlet],\n    pipes: [IgxColumnFormatterPipe, i4.DecimalPipe, i4.DatePipe, i4.CurrencyPipe, i4.PercentPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxGridExpandableCellComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridRowComponent = /*#__PURE__*/(() => {\n  class IgxGridRowComponent extends IgxRowDirective {\n    getContext(col, row) {\n      return {\n        $implicit: col,\n        row\n      };\n    }\n\n    get mrlRightPinnedOffset() {\n      return !this.grid.isPinningToStart ? -this.grid.pinnedWidth - this.grid.headerFeaturesWidth + 'px' : null;\n    }\n\n    getContextMRL(pinnedCols, row) {\n      return {\n        $implicit: pinnedCols,\n        row\n      };\n    }\n\n  }\n\n  IgxGridRowComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxGridRowComponent_BaseFactory;\n    return function IgxGridRowComponent_Factory(t) {\n      return (ɵIgxGridRowComponent_BaseFactory || (ɵIgxGridRowComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxGridRowComponent)))(t || IgxGridRowComponent);\n    };\n  }();\n\n  IgxGridRowComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxGridRowComponent,\n    selectors: [[\"igx-grid-row\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxRowDirective,\n      useExisting: forwardRef(() => IgxGridRowComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 17,\n    vars: 1,\n    consts: [[4, \"ngTemplateOutlet\"], [\"addTemp\", \"\"], [\"defaultTemp\", \"\"], [\"mrlPinnedTemplate\", \"\"], [\"rowSelectorBaseTemplate\", \"\"], [\"cellTemplate\", \"\"], [\"expandableCellTemplate\", \"\"], [\"mrlCellTemplate\", \"\"], [\"mrlExpandableCellTemplate\", \"\"], [1, \"igx-grid__tr--inner\", 3, \"animationend\"], [4, \"ngIf\"], [3, \"igxRowDrag\", \"ghostTemplate\", \"click\"], [1, \"igx-grid__cbx-selection\", \"igx-grid__tr-action\", 3, \"pointerdown\", \"click\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [3, \"pointerdown\", \"click\"], [\"igxGridFor\", \"\", 3, \"igxGridForOf\", \"igxForScrollContainer\", \"igxForScrollOrientation\", \"igxForContainerSize\", \"igxForSizePropName\", \"igxForTrackBy\"], [\"igxDirRef\", \"\"], [\"ngFor\", \"\", 3, \"ngForOf\"], [1, \"igx-grid__mrl-block\", 3, \"ngStyle\"], [\"class\", \"igx-grid__mrl-block\", 3, \"igx-grid__td--pinned-last\", \"igx-grid__td--pinned-first\", \"left\", \"ngStyle\", 4, \"ngFor\", \"ngForOf\"], [1, \"igx-grid__cbx-padding\"], [3, \"tabindex\", \"checked\", \"readonly\", \"disabled\", \"disableRipple\", \"disableTransitions\", \"aria-label\"], [1, \"igx-grid__td\", \"igx-grid__td--fw\", 3, \"ngClass\", \"ngStyle\", \"editMode\", \"column\", \"formatter\", \"intRow\", \"lastPinned\", \"firstPinned\", \"rowData\", \"width\", \"visibleColumnIndex\", \"value\", \"cellTemplate\", \"lastSearchInfo\", \"active\", \"cellSelectionMode\", \"displayPinnedChip\"], [\"cell\", \"\"], [1, \"igx-grid__td\", \"igx-grid__td--fw\", \"igx-grid__td--tree-cell\", 3, \"ngClass\", \"ngStyle\", \"expanded\", \"editMode\", \"column\", \"formatter\", \"intRow\", \"lastPinned\", \"rowData\", \"width\", \"visibleColumnIndex\", \"value\", \"cellTemplate\", \"lastSearchInfo\", \"active\", \"cellSelectionMode\", \"displayPinnedChip\"], [1, \"igx-grid__td\", \"igx-grid__td--fw\", 3, \"ngClass\", \"ngStyle\", \"editMode\", \"column\", \"lastPinned\", \"firstPinned\", \"formatter\", \"intRow\", \"rowData\", \"visibleColumnIndex\", \"value\", \"cellTemplate\", \"lastSearchInfo\", \"active\", \"cellSelectionMode\", \"displayPinnedChip\"], [1, \"igx-grid__td\", \"igx-grid__td--fw\", \"igx-grid__td--tree-cell\", 3, \"ngClass\", \"ngStyle\", \"expanded\", \"editMode\", \"column\", \"lastPinned\", \"formatter\", \"intRow\", \"rowData\", \"visibleColumnIndex\", \"value\", \"cellTemplate\", \"lastSearchInfo\", \"active\", \"cellSelectionMode\", \"displayPinnedChip\"]],\n    template: function IgxGridRowComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxGridRowComponent_ng_container_0_Template, 1, 0, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_1_Template, 2, 3, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(3, IgxGridRowComponent_ng_template_3_Template, 5, 5, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(5, IgxGridRowComponent_ng_template_5_Template, 2, 3, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(7, IgxGridRowComponent_ng_template_7_Template, 2, 7, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(9, IgxGridRowComponent_ng_template_9_Template, 7, 96, \"ng-template\", null, 5, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(11, IgxGridRowComponent_ng_template_11_Template, 7, 92, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(13, IgxGridRowComponent_ng_template_13_Template, 7, 93, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(15, IgxGridRowComponent_ng_template_15_Template, 7, 93, \"ng-template\", null, 8, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        const _r1 = i0.ɵɵreference(2);\n\n        const _r3 = i0.ɵɵreference(4);\n\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.addRowUI ? _r1 : _r3);\n      }\n    },\n    directives: [IgxCheckboxComponent, IgxGridCellComponent, IgxGridExpandableCellComponent, i4.NgTemplateOutlet, i4.NgIf, IgxRowDragDirective, i4.NgForOf, IgxGridForOfDirective, i4.NgStyle, i4.NgClass],\n    pipes: [IgxGridNotGroupedPipe, IgxGridTopLevelColumns, IgxGridTransactionStatePipe, IgxStringReplacePipe, IgxGridCellStyleClassesPipe, IgxGridCellStylesPipe, IgxGridDataMapperPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxGridRowComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar DragScrollDirection = /*#__PURE__*/(() => {\n  (function (DragScrollDirection) {\n    DragScrollDirection[DragScrollDirection[\"NONE\"] = 0] = \"NONE\";\n    DragScrollDirection[DragScrollDirection[\"LEFT\"] = 1] = \"LEFT\";\n    DragScrollDirection[DragScrollDirection[\"TOP\"] = 2] = \"TOP\";\n    DragScrollDirection[DragScrollDirection[\"RIGHT\"] = 3] = \"RIGHT\";\n    DragScrollDirection[DragScrollDirection[\"BOTTOM\"] = 4] = \"BOTTOM\";\n    DragScrollDirection[DragScrollDirection[\"TOPLEFT\"] = 5] = \"TOPLEFT\";\n    DragScrollDirection[DragScrollDirection[\"TOPRIGHT\"] = 6] = \"TOPRIGHT\";\n    DragScrollDirection[DragScrollDirection[\"BOTTOMLEFT\"] = 7] = \"BOTTOMLEFT\";\n    DragScrollDirection[DragScrollDirection[\"BOTTOMRIGHT\"] = 8] = \"BOTTOMRIGHT\";\n  })(DragScrollDirection || (DragScrollDirection = {}));\n\n  return DragScrollDirection;\n})();\n\n/**\n * An internal directive encapsulating the drag scroll behavior in the grid.\n *\n * @hidden @internal\n */\nlet IgxGridDragSelectDirective = /*#__PURE__*/(() => {\n  class IgxGridDragSelectDirective {\n    constructor(ref, zone) {\n      this.ref = ref;\n      this.zone = zone;\n      this.dragStop = new EventEmitter();\n      this.dragScroll = new EventEmitter();\n      this.end$ = new Subject();\n      this.lastDirection = DragScrollDirection.NONE;\n\n      this.startDragSelection = ev => {\n        if (!this.activeDrag) {\n          return;\n        }\n\n        const x = ev.clientX;\n        const y = ev.clientY;\n\n        const {\n          direction,\n          delta\n        } = this._measureDimensions(x, y);\n\n        if (direction === this.lastDirection) {\n          return;\n        }\n\n        this.unsubscribe();\n        this._sub = this._interval$.subscribe(() => this.dragScroll.emit(delta));\n        this.lastDirection = direction;\n      };\n\n      this.stopDragSelection = () => {\n        if (!this.activeDrag) {\n          return;\n        }\n\n        this.dragStop.emit(false);\n        this.unsubscribe();\n        this.lastDirection = DragScrollDirection.NONE;\n      };\n\n      this._interval$ = interval(0, animationFrameScheduler).pipe(takeUntil(this.end$), filter(() => this.activeDrag));\n    }\n\n    get activeDrag() {\n      return this._activeDrag;\n    }\n\n    set activeDrag(val) {\n      if (val !== this._activeDrag) {\n        this.unsubscribe();\n        this._activeDrag = val;\n      }\n    }\n\n    get nativeElement() {\n      return this.ref.nativeElement;\n    }\n\n    ngOnInit() {\n      this.zone.runOutsideAngular(() => {\n        this.nativeElement.addEventListener('pointerover', this.startDragSelection);\n        this.nativeElement.addEventListener('pointerleave', this.stopDragSelection);\n      });\n    }\n\n    ngOnDestroy() {\n      this.zone.runOutsideAngular(() => {\n        this.nativeElement.removeEventListener('pointerover', this.startDragSelection);\n        this.nativeElement.removeEventListener('pointerleave', this.stopDragSelection);\n      });\n      this.unsubscribe();\n      this.end$.complete();\n    }\n\n    _measureDimensions(x, y) {\n      let direction;\n      let delta = {\n        left: 0,\n        top: 0\n      };\n      const {\n        left,\n        top,\n        width,\n        height\n      } = this.nativeElement.getBoundingClientRect();\n      const RATIO = 0.15;\n      const offsetX = Math.trunc(x - left);\n      const offsetY = Math.trunc(y - top);\n      const leftDirection = offsetX <= width * RATIO;\n      const rightDirection = offsetX >= width * (1 - RATIO);\n      const topDirection = offsetY <= height * RATIO;\n      const bottomDirection = offsetY >= height * (1 - RATIO);\n\n      if (topDirection && leftDirection) {\n        direction = DragScrollDirection.TOPLEFT;\n        delta = {\n          left: -1,\n          top: -1\n        };\n      } else if (topDirection && rightDirection) {\n        direction = DragScrollDirection.TOPRIGHT;\n        delta = {\n          left: 1,\n          top: -1\n        };\n      } else if (bottomDirection && leftDirection) {\n        direction = DragScrollDirection.BOTTOMLEFT;\n        delta = {\n          left: -1,\n          top: 1\n        };\n      } else if (bottomDirection && rightDirection) {\n        direction = DragScrollDirection.BOTTOMRIGHT;\n        delta = {\n          top: 1,\n          left: 1\n        };\n      } else if (topDirection) {\n        direction = DragScrollDirection.TOP;\n        delta.top = -1;\n      } else if (bottomDirection) {\n        direction = DragScrollDirection.BOTTOM;\n        delta.top = 1;\n      } else if (leftDirection) {\n        direction = DragScrollDirection.LEFT;\n        delta.left = -1;\n      } else if (rightDirection) {\n        direction = DragScrollDirection.RIGHT;\n        delta.left = 1;\n      } else {\n        direction = DragScrollDirection.NONE;\n      }\n\n      return {\n        direction,\n        delta\n      };\n    }\n\n    unsubscribe() {\n      if (this._sub) {\n        this._sub.unsubscribe();\n      }\n    }\n\n  }\n\n  IgxGridDragSelectDirective.ɵfac = function IgxGridDragSelectDirective_Factory(t) {\n    return new (t || IgxGridDragSelectDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  IgxGridDragSelectDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxGridDragSelectDirective,\n    selectors: [[\"\", \"igxGridDragSelect\", \"\"]],\n    inputs: {\n      activeDrag: [\"igxGridDragSelect\", \"activeDrag\"]\n    },\n    outputs: {\n      dragStop: \"dragStop\",\n      dragScroll: \"dragScroll\"\n    }\n  });\n  return IgxGridDragSelectDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxGridSortingPipe = /*#__PURE__*/(() => {\n  class IgxGridSortingPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(collection, expressions, sorting, id, pipeTrigger, pinned) {\n      let result;\n\n      if (!expressions.length) {\n        result = collection;\n      } else {\n        result = DataUtil.sort(cloneArray(collection), expressions, sorting, this.grid);\n      }\n\n      this.grid.setFilteredSortedData(result, pinned);\n      return result;\n    }\n\n  }\n\n  IgxGridSortingPipe.ɵfac = function IgxGridSortingPipe_Factory(t) {\n    return new (t || IgxGridSortingPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxGridSortingPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"gridSort\",\n    type: IgxGridSortingPipe,\n    pure: true\n  });\n  return IgxGridSortingPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxGridGroupingPipe = /*#__PURE__*/(() => {\n  class IgxGridGroupingPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(collection, expression, expansion, groupingStrategy, defaultExpanded, id, groupsRecords, _pipeTrigger) {\n      const state = {\n        expressions: [],\n        expansion: [],\n        defaultExpanded\n      };\n      state.expressions = this.grid.groupingExpressions;\n      let result;\n      const fullResult = {\n        data: [],\n        metadata: []\n      };\n\n      if (!state.expressions.length) {\n        // empty the array without changing reference\n        groupsRecords.splice(0, groupsRecords.length);\n        result = {\n          data: collection,\n          metadata: collection\n        };\n      } else {\n        state.expansion = this.grid.groupingExpansionState;\n        state.defaultExpanded = this.grid.groupsExpanded;\n        result = DataUtil.group(cloneArray(collection), state, groupingStrategy, this.grid, groupsRecords, fullResult);\n      }\n\n      this.grid.groupingFlatResult = result.data;\n      this.grid.groupingResult = fullResult.data;\n      this.grid.groupingMetadata = fullResult.metadata;\n      return result;\n    }\n\n  }\n\n  IgxGridGroupingPipe.ɵfac = function IgxGridGroupingPipe_Factory(t) {\n    return new (t || IgxGridGroupingPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxGridGroupingPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"gridGroupBy\",\n    type: IgxGridGroupingPipe,\n    pure: true\n  });\n  return IgxGridGroupingPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxGridPagingPipe = /*#__PURE__*/(() => {\n  class IgxGridPagingPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(collection, page = 0, perPage = 15, _id, _) {\n      if (!this.grid.paginator || this.grid.pagingMode !== GridPagingMode.Local) {\n        return collection;\n      }\n\n      const state = {\n        index: page,\n        recordsPerPage: perPage\n      };\n      const total = this.grid._totalRecords >= 0 ? this.grid._totalRecords : collection.data.length;\n      DataUtil.correctPagingState(state, total);\n      const result = {\n        data: DataUtil.page(cloneArray(collection.data), state, total),\n        metadata: DataUtil.page(cloneArray(collection.metadata), state, total)\n      };\n\n      if (this.grid.paginator && this.grid.paginator.page !== state.index) {\n        this.grid.paginator.page = state.index;\n      }\n\n      this.grid.pagingState = state;\n      return result;\n    }\n\n  }\n\n  IgxGridPagingPipe.ɵfac = function IgxGridPagingPipe_Factory(t) {\n    return new (t || IgxGridPagingPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxGridPagingPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"gridPaging\",\n    type: IgxGridPagingPipe,\n    pure: true\n  });\n  return IgxGridPagingPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxGridFilteringPipe = /*#__PURE__*/(() => {\n  class IgxGridFilteringPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(collection, expressionsTree, filterStrategy, advancedExpressionsTree, id, pipeTrigger, filteringPipeTrigger, pinned) {\n      const state = {\n        expressionsTree,\n        strategy: filterStrategy,\n        advancedExpressionsTree\n      };\n\n      if (FilteringExpressionsTree.empty(state.expressionsTree) && FilteringExpressionsTree.empty(state.advancedExpressionsTree)) {\n        return collection;\n      }\n\n      const result = FilterUtil.filter(cloneArray(collection), state, this.grid);\n      this.grid.setFilteredData(result, pinned);\n      return result;\n    }\n\n  }\n\n  IgxGridFilteringPipe.ɵfac = function IgxGridFilteringPipe_Factory(t) {\n    return new (t || IgxGridFilteringPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxGridFilteringPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"gridFiltering\",\n    type: IgxGridFilteringPipe,\n    pure: true\n  });\n  return IgxGridFilteringPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxGridDetailsPipe = /*#__PURE__*/(() => {\n  class IgxGridDetailsPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(collection, hasDetails, expansionStates, _pipeTrigger) {\n      if (!hasDetails) {\n        return collection;\n      }\n\n      const res = this.addDetailRows(collection, expansionStates);\n      return res;\n    }\n\n    addDetailRows(collection, _expansionStates) {\n      const result = [];\n      collection.forEach(v => {\n        result.push(v);\n\n        if (!this.grid.isGroupByRecord(v) && !this.grid.isSummaryRow(v) && this.grid.gridAPI.get_row_expansion_state(v)) {\n          const detailsObj = {\n            detailsData: v\n          };\n          result.push(detailsObj);\n        }\n      });\n      return result;\n    }\n\n  }\n\n  IgxGridDetailsPipe.ɵfac = function IgxGridDetailsPipe_Factory(t) {\n    return new (t || IgxGridDetailsPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxGridDetailsPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"gridDetails\",\n    type: IgxGridDetailsPipe,\n    pure: true\n  });\n  return IgxGridDetailsPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxGridSummaryPipe = /*#__PURE__*/(() => {\n  class IgxGridSummaryPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(collection, hasSummary, summaryCalculationMode, summaryPosition, id, showSummary, _, __) {\n      if (!collection.data || !hasSummary || summaryCalculationMode === GridSummaryCalculationMode.rootLevelOnly) {\n        return collection.data;\n      }\n\n      return this.addSummaryRows(id, collection, summaryPosition, showSummary);\n    }\n\n    addSummaryRows(gridId, collection, summaryPosition, showSummary) {\n      const recordsWithSummary = [];\n      const lastChildMap = new Map();\n      const maxSummaryHeight = this.grid.summaryService.calcMaxSummaryHeight();\n\n      if (collection.metadata.length && !this.grid.isGroupByRecord(collection.data[0]) && this.grid.isGroupByRecord(collection.metadata[0]) && summaryPosition === GridSummaryPosition.bottom) {\n        const groups = [];\n        groups.push(collection.metadata[0]);\n\n        while (groups[groups.length - 1].groupParent) {\n          groups.push(groups[groups.length - 1].groupParent);\n        }\n\n        groups.reverse();\n        groups.forEach(g => g.skip = true);\n        collection.data.splice(0, 0, ...groups);\n      }\n\n      for (const record of collection.data) {\n        let skipAdd = false;\n        let recordId;\n        let groupByRecord = null;\n\n        if (this.grid.isGroupByRecord(record)) {\n          skipAdd = !!record.skip;\n          record.skip = null;\n          groupByRecord = record;\n          recordId = this.grid.gridAPI.get_groupBy_record_id(groupByRecord);\n        } else {\n          recordId = this.grid.gridAPI.get_row_id(record);\n        }\n\n        if (!skipAdd) {\n          recordsWithSummary.push(record);\n        }\n\n        if (summaryPosition === GridSummaryPosition.bottom && showSummary && groupByRecord && !this.grid.isExpandedGroup(groupByRecord)) {\n          const records = this.removeDeletedRecord(this.grid, groupByRecord.records.slice());\n          const summaries = this.grid.summaryService.calculateSummaries(recordId, records);\n          const summaryRecord = {\n            summaries,\n            max: maxSummaryHeight\n          };\n          recordsWithSummary.push(summaryRecord);\n        }\n\n        if (summaryPosition === GridSummaryPosition.bottom && lastChildMap.has(recordId)) {\n          const groupRecords = lastChildMap.get(recordId);\n\n          for (const groupRecord of groupRecords) {\n            const groupRecordId = this.grid.gridAPI.get_groupBy_record_id(groupRecord);\n            const records = this.removeDeletedRecord(this.grid, groupRecord.records.slice());\n            const summaries = this.grid.summaryService.calculateSummaries(groupRecordId, records);\n            const summaryRecord = {\n              summaries,\n              max: maxSummaryHeight\n            };\n            recordsWithSummary.push(summaryRecord);\n          }\n        }\n\n        const showSummaries = showSummary ? false : groupByRecord && !this.grid.isExpandedGroup(groupByRecord);\n\n        if (groupByRecord === null || showSummaries) {\n          continue;\n        }\n\n        if (summaryPosition === GridSummaryPosition.top) {\n          const records = this.removeDeletedRecord(this.grid, groupByRecord.records.slice());\n          const summaries = this.grid.summaryService.calculateSummaries(recordId, records);\n          const summaryRecord = {\n            summaries,\n            max: maxSummaryHeight\n          };\n          recordsWithSummary.push(summaryRecord);\n        } else if (summaryPosition === GridSummaryPosition.bottom) {\n          let lastChild = groupByRecord;\n\n          while (lastChild.groups && lastChild.groups.length > 0 && this.grid.isExpandedGroup(lastChild)) {\n            lastChild = lastChild.groups[lastChild.groups.length - 1];\n          }\n\n          let lastChildId;\n\n          if (this.grid.isExpandedGroup(lastChild)) {\n            lastChildId = this.grid.gridAPI.get_row_id(lastChild.records[lastChild.records.length - 1]);\n          } else {\n            lastChildId = this.grid.gridAPI.get_groupBy_record_id(lastChild);\n          }\n\n          let groupRecords = lastChildMap.get(lastChildId);\n\n          if (!groupRecords) {\n            groupRecords = [];\n            lastChildMap.set(lastChildId, groupRecords);\n          }\n\n          groupRecords.unshift(groupByRecord);\n        }\n      }\n\n      return recordsWithSummary;\n    }\n\n    removeDeletedRecord(grid, data) {\n      if (!grid.transactions.enabled) {\n        return data;\n      }\n\n      const deletedRows = grid.transactions.getTransactionLog().filter(t => t.type === 'delete').map(t => t.id);\n      deletedRows.forEach(rowID => {\n        const tempData = grid.primaryKey ? data.map(rec => rec[grid.primaryKey]) : data;\n        const index = tempData.indexOf(rowID);\n\n        if (index !== -1) {\n          data.splice(index, 1);\n        }\n      });\n      return data;\n    }\n\n  }\n\n  IgxGridSummaryPipe.ɵfac = function IgxGridSummaryPipe_Factory(t) {\n    return new (t || IgxGridSummaryPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxGridSummaryPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"gridSummary\",\n    type: IgxGridSummaryPipe,\n    pure: true\n  });\n  return IgxGridSummaryPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxSummaryDataPipe = /*#__PURE__*/(() => {\n  class IgxSummaryDataPipe {\n    constructor(grid) {\n      this.grid = grid;\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    transform(id, trigger = 0) {\n      const summaryService = this.grid.summaryService;\n      return summaryService.calculateSummaries(summaryService.rootSummaryID, this.grid.gridAPI.get_summary_data());\n    }\n\n  }\n\n  IgxSummaryDataPipe.ɵfac = function IgxSummaryDataPipe_Factory(t) {\n    return new (t || IgxSummaryDataPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxSummaryDataPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"igxGridSummaryDataPipe\",\n    type: IgxSummaryDataPipe,\n    pure: true\n  });\n  return IgxSummaryDataPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$9 = 0;\n/**\n * Grid provides a way to present and manipulate tabular data.\n *\n * @igxModule IgxGridModule\n * @igxGroup Grids & Lists\n * @igxKeywords grid, table\n * @igxTheme igx-grid-theme\n * @remarks\n * The Ignite UI Grid is used for presenting and manipulating tabular data in the simplest way possible.  Once data\n * has been bound, it can be manipulated through filtering, sorting & editing operations.\n * @example\n * ```html\n * <igx-grid [data]=\"employeeData\" [autoGenerate]=\"false\">\n *   <igx-column field=\"first\" header=\"First Name\"></igx-column>\n *   <igx-column field=\"last\" header=\"Last Name\"></igx-column>\n *   <igx-column field=\"role\" header=\"Role\"></igx-column>\n * </igx-grid>\n * ```\n */\n\nlet IgxGridComponent = /*#__PURE__*/(() => {\n  class IgxGridComponent extends IgxGridBaseDirective {\n    constructor() {\n      super(...arguments);\n      /**\n       * Emitted when a new chunk of data is loaded from virtualization.\n       *\n       * @example\n       * ```typescript\n       *  <igx-grid #grid [data]=\"localData\" [autoGenerate]=\"true\" (dataPreLoad)='handleDataPreloadEvent()'></igx-grid>\n       * ```\n       */\n\n      this.dataPreLoad = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.groupingExpressionsChange = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.groupingExpansionStateChange = new EventEmitter();\n      /**\n       * Emitted when columns are grouped/ungrouped.\n       *\n       * @remarks\n       * The `onGroupingDone` event would be raised only once if several columns get grouped at once by calling\n       * the `groupBy()` or `clearGrouping()` API methods and passing an array as an argument.\n       * The event arguments provide the `expressions`, `groupedColumns` and `ungroupedColumns` properties, which contain\n       * the `ISortingExpression` and the `IgxColumnComponent` related to the grouping/ungrouping operation.\n       * Please note that `groupedColumns` and `ungroupedColumns` show only the **newly** changed columns (affected by the **last**\n       * grouping/ungrouping operation), not all columns which are currently grouped/ungrouped.\n       * columns.\n       * @example\n       * ```html\n       * <igx-grid #grid [data]=\"localData\" (onGroupingDone)=\"groupingDone($event)\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       */\n\n      this.onGroupingDone = new EventEmitter();\n      /**\n       * Gets/Sets whether created groups are rendered expanded or collapsed.\n       *\n       * @remarks\n       * The default rendered state is expanded.\n       * @example\n       * ```html\n       * <igx-grid #grid [data]=\"Data\" [groupsExpanded]=\"false\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       */\n\n      this.groupsExpanded = true;\n      /**\n       * @hidden @internal\n       */\n\n      this.detailTemplate = new QueryList();\n      /**\n       * @hidden @internal\n       */\n\n      this.role = 'grid';\n      /**\n       * Gets/Sets the value of the `id` attribute.\n       *\n       * @remarks\n       * If not provided it will be automatically generated.\n       * @example\n       * ```html\n       * <igx-grid [id]=\"'igx-grid-1'\" [data]=\"Data\" [autoGenerate]=\"true\"></igx-grid>\n       * ```\n       */\n\n      this.id = `igx-grid-${NEXT_ID$9++}`;\n      /**\n       * Gets the hierarchical representation of the group by records.\n       *\n       * @example\n       * ```typescript\n       * let groupRecords = this.grid.groupsRecords;\n       * ```\n       */\n\n      this.groupsRecords = [];\n      /**\n       * @hidden\n       */\n\n      this._groupingExpressions = [];\n      /**\n       * @hidden\n       */\n\n      this._groupingExpandState = [];\n      this._hideGroupedColumns = false;\n      this._dropAreaMessage = null;\n      this._showGroupArea = true;\n      this._filteredData = null;\n      this.childDetailTemplates = new Map();\n    }\n    /**\n     * Gets/Sets the array of data that populates the `IgxGridComponent`.\n     *\n     * @example\n     * ```html\n     * <igx-grid [data]=\"Data\" [autoGenerate]=\"true\"></igx-grid>\n     * ```\n     */\n\n\n    get data() {\n      return this._data;\n    }\n\n    set data(value) {\n      this._data = value || [];\n      this.summaryService.clearSummaryCache();\n\n      if (this.shouldGenerate) {\n        this.setupColumns();\n      }\n\n      this.cdr.markForCheck();\n\n      if (this.isPercentHeight) {\n        this.notifyChanges(true);\n      }\n    }\n    /**\n     * Gets/Sets an array of objects containing the filtered data.\n     *\n     * @example\n     * ```typescript\n     * let filteredData = this.grid.filteredData;\n     * this.grid.filteredData = [...];\n     * ```\n     */\n\n\n    get filteredData() {\n      return this._filteredData;\n    }\n\n    set filteredData(value) {\n      this._filteredData = value;\n    }\n    /**\n     * Gets/Sets the total number of records in the data source.\n     *\n     * @remarks\n     * This property is required for remote grid virtualization to function when it is bound to remote data.\n     * @example\n     * ```typescript\n     * const itemCount = this.grid1.totalItemCount;\n     * this.grid1.totalItemCount = 55;\n     * ```\n     */\n\n\n    set totalItemCount(count) {\n      this.verticalScrollContainer.totalItemCount = count;\n      this.cdr.detectChanges();\n    }\n\n    get totalItemCount() {\n      return this.verticalScrollContainer.totalItemCount;\n    }\n\n    get _gridAPI() {\n      return this.gridAPI;\n    }\n    /**\n     * Gets/Sets the group by state.\n     *\n     * @example\n     * ```typescript\n     * let groupByState = this.grid.groupingExpressions;\n     * this.grid.groupingExpressions = [...];\n     * ```\n     * @remarks\n     * Supports two-way data binding.\n     * @example\n     * ```html\n     * <igx-grid #grid [data]=\"Data\" [autoGenerate]=\"true\" [(groupingExpressions)]=\"model.groupingExpressions\"></igx-grid>\n     * ```\n     */\n\n\n    get groupingExpressions() {\n      return this._groupingExpressions;\n    }\n\n    set groupingExpressions(value) {\n      if (this.groupingExpressions === value) {\n        return;\n      }\n\n      if (value && value.length > 10) {\n        throw Error('Maximum amount of grouped columns is 10.');\n      }\n\n      const oldExpressions = this.groupingExpressions;\n      const newExpressions = value;\n      this._groupingExpressions = cloneArray(value);\n      this.groupingExpressionsChange.emit(this._groupingExpressions);\n\n      if (this._gridAPI.grid) {\n        /* grouping should work in conjunction with sorting\n        and without overriding separate sorting expressions */\n        this._applyGrouping();\n\n        this._gridAPI.arrange_sorting_expressions();\n\n        this.notifyChanges();\n      } else {\n        // setter called before grid is registered in grid API service\n        this.sortingExpressions.unshift.apply(this.sortingExpressions, this._groupingExpressions);\n      }\n\n      if (!this._init && JSON.stringify(oldExpressions) !== JSON.stringify(newExpressions) && this.columnList) {\n        const groupedCols = [];\n        const ungroupedCols = [];\n        const groupedColsArr = newExpressions.filter(obj => !oldExpressions.some(obj2 => obj.fieldName === obj2.fieldName));\n        groupedColsArr.forEach(elem => {\n          groupedCols.push(this.getColumnByName(elem.fieldName));\n        }, this);\n        const ungroupedColsArr = oldExpressions.filter(obj => !newExpressions.some(obj2 => obj.fieldName === obj2.fieldName));\n        ungroupedColsArr.forEach(elem => {\n          ungroupedCols.push(this.getColumnByName(elem.fieldName));\n        }, this);\n        this.notifyChanges();\n        const groupingDoneArgs = {\n          expressions: newExpressions,\n          groupedColumns: groupedCols,\n          ungroupedColumns: ungroupedCols\n        };\n        this.onGroupingDone.emit(groupingDoneArgs);\n      }\n    }\n    /**\n     * Gets/Sets a list of expansion states for group rows.\n     *\n     * @remarks\n     * Includes only states that differ from the default one (controlled through groupsExpanded and states that the user has changed.\n     * Contains the expansion state (expanded: boolean) and the unique identifier for the group row (Array).\n     * Supports two-way data binding.\n     * @example\n     * ```html\n     * <igx-grid #grid [data]=\"Data\" [autoGenerate]=\"true\" [(groupingExpansionState)]=\"model.groupingExpansionState\"></igx-grid>\n     * ```\n     */\n\n\n    get groupingExpansionState() {\n      return this._groupingExpandState;\n    }\n\n    set groupingExpansionState(value) {\n      if (value !== this._groupingExpandState) {\n        this.groupingExpansionStateChange.emit(value);\n      }\n\n      this._groupingExpandState = value;\n\n      if (this.gridAPI.grid) {\n        this.cdr.detectChanges();\n      }\n    }\n    /**\n     * Gets/Sets whether the grouped columns should be hidden.\n     *\n     * @remarks\n     * The default value is \"false\"\n     * @example\n     * ```html\n     * <igx-grid #grid [data]=\"localData\" [hideGroupedColumns]=\"true\" [autoGenerate]=\"true\"></igx-grid>\n     * ```\n     */\n\n\n    get hideGroupedColumns() {\n      return this._hideGroupedColumns;\n    }\n\n    set hideGroupedColumns(value) {\n      if (value) {\n        this.groupingDiffer = this.differs.find(this.groupingExpressions).create();\n      } else {\n        this.groupingDiffer = null;\n      }\n\n      if (this.columnList && this.groupingExpressions) {\n        this._setGroupColsVisibility(value);\n      }\n\n      this._hideGroupedColumns = value;\n    }\n    /**\n     * Gets/Sets the grouping strategy of the grid.\n     *\n     * @remarks The default IgxGrouping extends from IgxSorting and a custom one can be used as a `sortStrategy` as well.\n     *\n     * @example\n     * ```html\n     *  <igx-grid #grid [data]=\"localData\" [groupStrategy]=\"groupStrategy\"></igx-grid>\n     * ```\n     */\n\n\n    get groupStrategy() {\n      return this._groupStrategy;\n    }\n\n    set groupStrategy(value) {\n      this._groupStrategy = value;\n    }\n    /**\n     * Gets/Sets the message displayed inside the GroupBy drop area where columns can be dragged on.\n     *\n     * @remarks\n     * The grid needs to have at least one groupable column in order the GroupBy area to be displayed.\n     * @example\n     * ```html\n     * <igx-grid dropAreaMessage=\"Drop here to group!\">\n     *      <igx-column [groupable]=\"true\" field=\"ID\"></igx-column>\n     * </igx-grid>\n     * ```\n     */\n\n\n    set dropAreaMessage(value) {\n      this._dropAreaMessage = value;\n      this.notifyChanges();\n    }\n\n    get dropAreaMessage() {\n      return this._dropAreaMessage || this.resourceStrings.igx_grid_groupByArea_message;\n    }\n    /**\n     * @deprecated in version 12.1.0. Use `getCellByColumn` or `getCellByKey` instead\n     *\n     * Returns a `CellType` object that matches the conditions.\n     *\n     * @example\n     * ```typescript\n     * const myCell = this.grid1.getCellByColumnVisibleIndex(2,\"UnitPrice\");\n     * ```\n     * @param rowIndex\n     * @param index\n     */\n\n\n    getCellByColumnVisibleIndex(rowIndex, index) {\n      var _a;\n\n      const row = this.getRowByIndex(rowIndex);\n      const column = this.columnList.find(col => col.visibleIndex === index);\n\n      if (row && row instanceof IgxGridRow && !((_a = row.data) === null || _a === void 0 ? void 0 : _a.detailsData) && column) {\n        return new IgxGridCell(this, rowIndex, column.field);\n      }\n    }\n    /**\n     * Gets the list of group rows.\n     *\n     * @example\n     * ```typescript\n     * const groupList = this.grid.groupsRowList;\n     * ```\n     */\n\n\n    get groupsRowList() {\n      const res = new QueryList();\n\n      if (!this._groupsRowList) {\n        return res;\n      }\n\n      const rList = this._groupsRowList.filter(item => item.element.nativeElement.parentElement !== null).sort((item1, item2) => item1.index - item2.index);\n\n      res.reset(rList);\n      return res;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get groupByRowSelectorTemplate() {\n      if (this.groupByRowSelectorsTemplates && this.groupByRowSelectorsTemplates.first) {\n        return this.groupByRowSelectorsTemplates.first.templateRef;\n      }\n\n      return null;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    getDetailsContext(rowData, index) {\n      return {\n        $implicit: rowData,\n        index\n      };\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    detailsViewFocused(container, rowIndex) {\n      this.navigation.setActiveNode({\n        row: rowIndex\n      });\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get hasDetails() {\n      return !!this.detailTemplate.length;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    getRowTemplate(rowData) {\n      if (this.isGroupByRecord(rowData)) {\n        return this.defaultGroupTemplate;\n      } else if (this.isSummaryRow(rowData)) {\n        return this.summaryTemplate;\n      } else if (this.hasDetails && this.isDetailRecord(rowData)) {\n        return this.detailTemplateContainer;\n      } else {\n        return this.recordTemplate;\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    isDetailRecord(record) {\n      return record && record.detailsData !== undefined;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    isDetailActive(rowIndex) {\n      return this.navigation.activeNode ? this.navigation.activeNode.row === rowIndex : false;\n    }\n    /**\n     * Gets/Sets the template reference for the group row.\n     *\n     * @example\n     * ```\n     * const groupRowTemplate = this.grid.groupRowTemplate;\n     * this.grid.groupRowTemplate = myRowTemplate;\n     * ```\n     */\n\n\n    get groupRowTemplate() {\n      return this._groupRowTemplate;\n    }\n\n    set groupRowTemplate(template) {\n      this._groupRowTemplate = template;\n      this.notifyChanges();\n    }\n    /**\n     * Gets/Sets the template reference of the `IgxGridComponent`'s group area.\n     *\n     * @example\n     * ```typescript\n     * const groupAreaTemplate = this.grid.groupAreaTemplate;\n     * this.grid.groupAreaTemplate = myAreaTemplate.\n     * ```\n     */\n\n\n    get groupAreaTemplate() {\n      return this._groupAreaTemplate;\n    }\n\n    set groupAreaTemplate(template) {\n      this._groupAreaTemplate = template;\n      this.notifyChanges();\n    }\n    /**\n     * Groups by a new `IgxColumnComponent` based on the provided expression, or modifies an existing one.\n     *\n     * @remarks\n     * Also allows for multiple columns to be grouped at once if an array of `ISortingExpression` is passed.\n     * The onGroupingDone event would get raised only **once** if this method gets called multiple times with the same arguments.\n     * @example\n     * ```typescript\n     * this.grid.groupBy({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });\n     * this.grid.groupBy([\n     *     { fieldName: name1, dir: SortingDirection.Asc, ignoreCase: false },\n     *     { fieldName: name2, dir: SortingDirection.Desc, ignoreCase: true },\n     *     { fieldName: name3, dir: SortingDirection.Desc, ignoreCase: false }\n     * ]);\n     * ```\n     */\n\n\n    groupBy(expression) {\n      if (this.checkIfNoColumnField(expression)) {\n        return;\n      }\n\n      this.crudService.endEdit(false);\n\n      if (expression instanceof Array) {\n        this._gridAPI.groupBy_multiple(expression);\n      } else {\n        this._gridAPI.groupBy(expression);\n      }\n\n      this.notifyChanges(true);\n    }\n    /**\n     * Clears grouping for particular column, array of columns or all columns.\n     *\n     * @remarks\n     * Clears all grouping in the grid, if no parameter is passed.\n     * If a parameter is provided, clears grouping for a particular column or an array of columns.\n     * @example\n     * ```typescript\n     * this.grid.clearGrouping(); //clears all grouping\n     * this.grid.clearGrouping(\"ID\"); //ungroups a single column\n     * this.grid.clearGrouping([\"ID\", \"Column1\", \"Column2\"]); //ungroups multiple columns\n     * ```\n     * @param name Name of column or array of column names to be ungrouped.\n     */\n\n\n    clearGrouping(name) {\n      this._gridAPI.clear_groupby(name);\n\n      this.calculateGridSizes();\n      this.notifyChanges(true);\n    }\n    /**\n     * Returns if a group is expanded or not.\n     *\n     * @param group The group record.\n     * @example\n     * ```typescript\n     * public groupRow: IGroupByRecord;\n     * const expandedGroup = this.grid.isExpandedGroup(this.groupRow);\n     * ```\n     */\n\n\n    isExpandedGroup(group) {\n      const state = this._getStateForGroupRow(group);\n\n      return state ? state.expanded : this.groupsExpanded;\n    }\n    /**\n     * Toggles the expansion state of a group.\n     *\n     * @param groupRow The group record to toggle.\n     * @example\n     * ```typescript\n     * public groupRow: IGroupByRecord;\n     * const toggleExpGroup = this.grid.toggleGroup(this.groupRow);\n     * ```\n     */\n\n\n    toggleGroup(groupRow) {\n      this._toggleGroup(groupRow);\n\n      this.notifyChanges();\n    }\n    /**\n     * Select all rows within a group.\n     *\n     * @param groupRow: The group record which rows would be selected.\n     * @param clearCurrentSelection if true clears the current selection\n     * @example\n     * ```typescript\n     * this.grid.selectRowsInGroup(this.groupRow, true);\n     * ```\n     */\n\n\n    selectRowsInGroup(groupRow, clearPrevSelection) {\n      this._gridAPI.groupBy_select_all_rows_in_group(groupRow, clearPrevSelection);\n\n      this.notifyChanges();\n    }\n    /**\n     * Deselect all rows within a group.\n     *\n     * @param groupRow The group record which rows would be deselected.\n     * @example\n     * ```typescript\n     * public groupRow: IGroupByRecord;\n     * this.grid.deselectRowsInGroup(this.groupRow);\n     * ```\n     */\n\n\n    deselectRowsInGroup(groupRow) {\n      this._gridAPI.groupBy_deselect_all_rows_in_group(groupRow);\n\n      this.notifyChanges();\n    }\n    /**\n     * Expands the specified group and all of its parent groups.\n     *\n     * @param groupRow The group record to fully expand.\n     * @example\n     * ```typescript\n     * public groupRow: IGroupByRecord;\n     * this.grid.fullyExpandGroup(this.groupRow);\n     * ```\n     */\n\n\n    fullyExpandGroup(groupRow) {\n      this._fullyExpandGroup(groupRow);\n\n      this.notifyChanges();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    isGroupByRecord(record) {\n      var _a, _b; // return record.records instance of GroupedRecords fails under Webpack\n\n\n      return record && (record === null || record === void 0 ? void 0 : record.records) && ((_a = record.records) === null || _a === void 0 ? void 0 : _a.length) && record.expression && ((_b = record.expression) === null || _b === void 0 ? void 0 : _b.fieldName);\n    }\n    /**\n     * Toggles the expansion state of all group rows recursively.\n     *\n     * @example\n     * ```typescript\n     * this.grid.toggleAllGroupRows;\n     * ```\n     */\n\n\n    toggleAllGroupRows() {\n      this.groupingExpansionState = [];\n      this.groupsExpanded = !this.groupsExpanded;\n      this.notifyChanges();\n    }\n    /**\n     * Returns if the `IgxGridComponent` has groupable columns.\n     *\n     * @example\n     * ```typescript\n     * const groupableGrid = this.grid.hasGroupableColumns;\n     * ```\n     */\n\n\n    get hasGroupableColumns() {\n      return this.columnList.some(col => col.groupable && !col.columnGroup);\n    }\n    /**\n     * Returns whether the `IgxGridComponent` has group area.\n     *\n     * @example\n     * ```typescript\n     * let isGroupAreaVisible = this.grid.showGroupArea;\n     * ```\n     *\n     * @example\n     * ```html\n     * <igx-grid #grid [data]=\"Data\" [showGroupArea]=\"false\"></igx-grid>\n     * ```\n     */\n\n\n    get showGroupArea() {\n      return this._showGroupArea;\n    }\n\n    set showGroupArea(value) {\n      this._showGroupArea = value;\n      this.notifyChanges(true);\n    }\n    /**\n     * Gets if the grid's group by drop area is visible.\n     *\n     * @example\n     * ```typescript\n     * const dropVisible = this.grid.dropAreaVisible;\n     * ```\n     */\n\n\n    get dropAreaVisible() {\n      var _a;\n\n      return ((_a = this.columnInDrag) === null || _a === void 0 ? void 0 : _a.groupable) || !this.groupingExpressions.length;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    isColumnGrouped(fieldName) {\n      return this.groupingExpressions.find(exp => exp.fieldName === fieldName) ? true : false;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    getContext(rowData, rowIndex, pinned) {\n      if (this.isDetailRecord(rowData)) {\n        const cachedData = this.childDetailTemplates.get(rowData.detailsData);\n        const rowID = this.primaryKey ? rowData.detailsData[this.primaryKey] : rowData.detailsData;\n\n        if (cachedData) {\n          const view = cachedData.view;\n          const tmlpOutlet = cachedData.owner;\n          return {\n            $implicit: rowData.detailsData,\n            moveView: view,\n            owner: tmlpOutlet,\n            index: this.dataView.indexOf(rowData),\n            templateID: {\n              type: 'detailRow',\n              id: rowID\n            }\n          };\n        } else {\n          // child rows contain unique grids, hence should have unique templates\n          return {\n            $implicit: rowData.detailsData,\n            templateID: {\n              type: 'detailRow',\n              id: rowID\n            },\n            index: this.dataView.indexOf(rowData)\n          };\n        }\n      }\n\n      return {\n        $implicit: this.isGhostRecord(rowData) ? rowData.recordRef : rowData,\n        index: this.getDataViewIndex(rowIndex, pinned),\n        templateID: {\n          type: this.isGroupByRecord(rowData) ? 'groupRow' : this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow',\n          id: null\n        },\n        disabled: this.isGhostRecord(rowData)\n      };\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    viewCreatedHandler(args) {\n      if (args.context.templateID.type === 'detailRow') {\n        this.childDetailTemplates.set(args.context.$implicit, args);\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    viewMovedHandler(args) {\n      if (args.context.templateID.type === 'detailRow') {\n        // view was moved, update owner in cache\n        const key = args.context.$implicit;\n        const cachedData = this.childDetailTemplates.get(key);\n        cachedData.owner = args.owner;\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get iconTemplate() {\n      if (this.groupsExpanded) {\n        return this.headerExpandIndicatorTemplate || this.defaultExpandedTemplate;\n      } else {\n        return this.headerCollapseIndicatorTemplate || this.defaultCollapsedTemplate;\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    ngAfterContentInit() {\n      super.ngAfterContentInit();\n\n      if (this.allowFiltering && this.hasColumnLayouts) {\n        this.filterMode = FilterMode.excelStyleFilter;\n      }\n\n      if (this.groupTemplate) {\n        this._groupRowTemplate = this.groupTemplate.template;\n      }\n\n      this.detailTemplate.changes.subscribe(() => this.trackChanges = (_, rec) => (rec === null || rec === void 0 ? void 0 : rec.detailsData) !== undefined ? rec.detailsData : rec);\n\n      if (this.hideGroupedColumns && this.columnList && this.groupingExpressions) {\n        this._setGroupColsVisibility(this.hideGroupedColumns);\n      }\n\n      this._setupNavigationService();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    ngAfterViewInit() {\n      super.ngAfterViewInit();\n      this.verticalScrollContainer.beforeViewDestroyed.pipe(takeUntil(this.destroy$)).subscribe(view => {\n        const rowData = view.context.$implicit;\n\n        if (this.isDetailRecord(rowData)) {\n          const cachedData = this.childDetailTemplates.get(rowData.detailsData);\n\n          if (cachedData) {\n            const tmlpOutlet = cachedData.owner;\n\n            tmlpOutlet._viewContainerRef.detach(0);\n          }\n        }\n      });\n      this.sortingExpressionsChange.pipe(takeUntil(this.destroy$)).subscribe(sortingExpressions => {\n        if (!this.groupingExpressions || !this.groupingExpressions.length) {\n          return;\n        }\n\n        sortingExpressions.forEach(sortExpr => {\n          const fieldName = sortExpr.fieldName;\n          const groupingExpr = this.groupingExpressions.find(ex => ex.fieldName === fieldName);\n\n          if (groupingExpr) {\n            groupingExpr.dir = sortExpr.dir;\n          }\n        });\n      });\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    ngOnInit() {\n      super.ngOnInit();\n      this.onGroupingDone.pipe(takeUntil(this.destroy$)).subscribe(args => {\n        this.crudService.endEdit(false);\n        this.summaryService.updateSummaryCache(args);\n        this._headerFeaturesWidth = NaN;\n      });\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    ngDoCheck() {\n      if (this.groupingDiffer && this.columnList && !this.hasColumnLayouts) {\n        const changes = this.groupingDiffer.diff(this.groupingExpressions);\n\n        if (changes && this.columnList.length > 0) {\n          changes.forEachAddedItem(rec => {\n            const col = this.getColumnByName(rec.item.fieldName);\n\n            if (col) {\n              col.hidden = true;\n            }\n          });\n          changes.forEachRemovedItem(rec => {\n            const col = this.getColumnByName(rec.item.fieldName);\n            col.hidden = false;\n          });\n        }\n      }\n\n      super.ngDoCheck();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    dataLoading(event) {\n      this.dataPreLoad.emit(event);\n    }\n    /**\n     * @inheritdoc\n     */\n\n\n    getSelectedData(formatters = false, headers = false) {\n      if (this.groupingExpressions.length || this.hasDetails) {\n        const source = [];\n\n        const process = record => {\n          if (record.expression || record.summaries || this.isDetailRecord(record)) {\n            source.push(null);\n            return;\n          }\n\n          source.push(record);\n        };\n\n        this.dataView.forEach(process);\n        return this.extractDataFromSelection(source, formatters, headers);\n      } else {\n        return super.getSelectedData(formatters, headers);\n      }\n    }\n    /**\n     * Returns the `IgxGridRow` by index.\n     *\n     * @example\n     * ```typescript\n     * const myRow = grid.getRowByIndex(1);\n     * ```\n     * @param index\n     */\n\n\n    getRowByIndex(index) {\n      let row;\n\n      if (index < 0) {\n        return undefined;\n      }\n\n      if (this.dataView.length >= this.virtualizationState.startIndex + this.virtualizationState.chunkSize) {\n        row = this.createRow(index);\n      } else {\n        if (!(index < this.virtualizationState.startIndex) && !(index > this.virtualizationState.startIndex + this.virtualizationState.chunkSize)) {\n          row = this.createRow(index);\n        }\n      }\n\n      if (this.gridAPI.grid.pagingMode === 1 && this.gridAPI.grid.page !== 0) {\n        row.index = index + this.paginator.perPage * this.paginator.page;\n      }\n\n      return row;\n    }\n    /**\n     * Returns `IgxGridRow` object by the specified primary key.\n     *\n     * @remarks\n     * Requires that the `primaryKey` property is set.\n     * @example\n     * ```typescript\n     * const myRow = this.grid1.getRowByKey(\"cell5\");\n     * ```\n     * @param keyValue\n     */\n\n\n    getRowByKey(key) {\n      const rec = this.filteredSortedData ? this.primaryKey ? this.filteredSortedData.find(record => record[this.primaryKey] === key) : this.filteredSortedData.find(record => record === key) : undefined;\n      const index = this.dataView.indexOf(rec);\n\n      if (index < 0 || index > this.dataView.length) {\n        return undefined;\n      }\n\n      return new IgxGridRow(this, index, rec);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    allRows() {\n      return this.dataView.map((rec, index) => {\n        this.pagingMode === 1 && this.paginator.page !== 0 ? index = index + this.paginator.perPage * this.paginator.page : index = this.dataRowList.first.index + index;\n        return this.createRow(index);\n      });\n    }\n    /**\n     * Returns the collection of `IgxGridRow`s for current page.\n     *\n     * @hidden @internal\n     */\n\n\n    dataRows() {\n      return this.allRows().filter(row => row instanceof IgxGridRow);\n    }\n    /**\n     * Returns an array of the selected `IgxGridCell`s.\n     *\n     * @example\n     * ```typescript\n     * const selectedCells = this.grid.selectedCells;\n     * ```\n     */\n\n\n    get selectedCells() {\n      return this.dataRows().map(row => row.cells.filter(cell => cell.selected)).reduce((a, b) => a.concat(b), []);\n    }\n    /**\n     * Returns a `CellType` object that matches the conditions.\n     *\n     * @example\n     * ```typescript\n     * const myCell = this.grid1.getCellByColumn(2, \"UnitPrice\");\n     * ```\n     * @param rowIndex\n     * @param columnField\n     */\n\n\n    getCellByColumn(rowIndex, columnField) {\n      var _a;\n\n      const row = this.getRowByIndex(rowIndex);\n      const column = this.columnList.find(col => col.field === columnField);\n\n      if (row && row instanceof IgxGridRow && !((_a = row.data) === null || _a === void 0 ? void 0 : _a.detailsData) && column) {\n        if (this.pagingMode === 1 && this.gridAPI.grid.page !== 0) {\n          row.index = rowIndex + this.paginator.perPage * this.paginator.page;\n        }\n\n        return new IgxGridCell(this, row.index, columnField);\n      }\n    }\n    /**\n     * Returns a `CellType` object that matches the conditions.\n     *\n     * @remarks\n     * Requires that the primaryKey property is set.\n     * @example\n     * ```typescript\n     * grid.getCellByKey(1, 'index');\n     * ```\n     * @param rowSelector match any rowID\n     * @param columnField\n     */\n\n\n    getCellByKey(rowSelector, columnField) {\n      const row = this.getRowByKey(rowSelector);\n      const column = this.columnList.find(col => col.field === columnField);\n\n      if (row && column) {\n        return new IgxGridCell(this, row.index, columnField);\n      }\n    }\n\n    pinRow(rowID, index) {\n      const row = this.getRowByKey(rowID);\n      return super.pinRow(rowID, index, row);\n    }\n\n    unpinRow(rowID) {\n      const row = this.getRowByKey(rowID);\n      return super.unpinRow(rowID, row);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    createRow(index, data) {\n      let row;\n      let rec;\n\n      const dataIndex = this._getDataViewIndex(index);\n\n      rec = data !== null && data !== void 0 ? data : this.dataView[dataIndex];\n\n      if (rec && this.isGroupByRecord(rec)) {\n        row = new IgxGroupByRow(this, index, rec);\n      }\n\n      if (rec && this.isSummaryRow(rec)) {\n        row = new IgxSummaryRow(this, index, rec.summaries, GridInstanceType.Grid);\n      } // if found record is a no a groupby or summary row, return IgxGridRow instance\n\n\n      if (!row && rec) {\n        row = new IgxGridRow(this, index, rec);\n      }\n\n      return row;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get defaultTargetBodyHeight() {\n      const allItems = this.totalItemCount || this.dataLength;\n      return this.renderedRowHeight * Math.min(this._defaultTargetRecordNumber, this.paginator ? Math.min(allItems, this.paginator.perPage) : allItems);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    getGroupAreaHeight() {\n      return this.groupArea ? this.getComputedHeight(this.groupArea.nativeElement) : 0;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    scrollTo(row, column) {\n      if (this.groupingExpressions && this.groupingExpressions.length && typeof row !== 'number') {\n        const rowIndex = this.groupingResult.indexOf(row);\n        const groupByRecord = this.groupingMetadata[rowIndex];\n\n        if (groupByRecord) {\n          this._fullyExpandGroup(groupByRecord);\n        }\n      }\n\n      super.scrollTo(row, column, this.groupingFlatResult);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    _getStateForGroupRow(groupRow) {\n      return this._gridAPI.groupBy_get_expanded_for_group(groupRow);\n    }\n    /**\n     * @hidden\n     */\n\n\n    _toggleGroup(groupRow) {\n      this._gridAPI.groupBy_toggle_group(groupRow);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    _fullyExpandGroup(groupRow) {\n      this._gridAPI.groupBy_fully_expand_group(groupRow);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    _applyGrouping() {\n      this._gridAPI.sort_multiple(this._groupingExpressions);\n    }\n\n    _setupNavigationService() {\n      if (this.hasColumnLayouts) {\n        this.navigation = new IgxGridMRLNavigationService(this.platform);\n        this.navigation.grid = this;\n      }\n    }\n\n    checkIfNoColumnField(expression) {\n      if (expression instanceof Array) {\n        for (const singleExpression of expression) {\n          if (!singleExpression.fieldName) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      return !expression.fieldName;\n    }\n\n    _setGroupColsVisibility(value) {\n      if (this.columnList.length > 0 && !this.hasColumnLayouts) {\n        this.groupingExpressions.forEach(expr => {\n          const col = this.getColumnByName(expr.fieldName);\n          col.hidden = value;\n        });\n      }\n    }\n\n  }\n\n  IgxGridComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxGridComponent_BaseFactory;\n    return function IgxGridComponent_Factory(t) {\n      return (ɵIgxGridComponent_BaseFactory || (ɵIgxGridComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxGridComponent)))(t || IgxGridComponent);\n    };\n  }();\n\n  IgxGridComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxGridComponent,\n    selectors: [[\"igx-grid\"]],\n    contentQueries: function IgxGridComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxGroupByRowTemplateDirective, 5, IgxGroupByRowTemplateDirective);\n        i0.ɵɵcontentQuery(dirIndex, IgxGridDetailTemplateDirective, 4, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxGroupByRowSelectorDirective, 4, IgxGroupByRowSelectorDirective);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.detailTemplate = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupByRowSelectorsTemplates = _t);\n      }\n    },\n    viewQuery: function IgxGridComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxGridGroupByAreaComponent, 5);\n        i0.ɵɵviewQuery(_c216, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c217, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c218, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c219, 7, TemplateRef);\n        i0.ɵɵviewQuery(IgxGridGroupByRowComponent, 5, IgxGridGroupByRowComponent);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupArea = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.recordTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.detailTemplateContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultGroupTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.summaryTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._groupsRowList = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function IgxGridComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"id\", ctx.id);\n      }\n    },\n    inputs: {\n      groupsExpanded: \"groupsExpanded\",\n      dropAreaTemplate: \"dropAreaTemplate\",\n      id: \"id\",\n      data: \"data\",\n      groupingExpressions: \"groupingExpressions\",\n      groupingExpansionState: \"groupingExpansionState\",\n      hideGroupedColumns: \"hideGroupedColumns\",\n      groupStrategy: \"groupStrategy\",\n      dropAreaMessage: \"dropAreaMessage\",\n      showGroupArea: \"showGroupArea\"\n    },\n    outputs: {\n      dataPreLoad: \"dataPreLoad\",\n      groupingExpressionsChange: \"groupingExpressionsChange\",\n      groupingExpansionStateChange: \"groupingExpansionStateChange\",\n      onGroupingDone: \"onGroupingDone\"\n    },\n    features: [i0.ɵɵProvidersFeature([IgxGridCRUDService, IgxGridNavigationService, IgxGridSummaryService, IgxGridSelectionService, {\n      provide: IGX_GRID_SERVICE_BASE,\n      useClass: IgxGridAPIService\n    }, {\n      provide: IGX_GRID_BASE,\n      useExisting: IgxGridComponent\n    }, IgxFilteringService, IgxColumnResizingService, IgxForOfSyncService, IgxForOfScrollSyncService]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c229,\n    decls: 96,\n    vars: 169,\n    consts: [[4, \"ngIf\"], [\"tabindex\", \"0\", 1, \"igx-grid-thead\", 3, \"grid\", \"hasMRL\", \"density\", \"activeDescendant\", \"width\", \"pinnedColumnCollection\", \"unpinnedColumnCollection\", \"keydown.meta.c\", \"keydown.control.c\", \"copy\", \"keydown\", \"scroll\", \"focus\"], [\"igxGridBody\", \"\", \"role\", \"rowgroup\", 1, \"igx-grid__tbody\", 3, \"keydown.control.c\", \"copy\"], [\"tabindex\", \"0\", 1, \"igx-grid__tbody-content\", 3, \"igxGridDragSelect\", \"keydown\", \"focus\", \"dragStop\", \"scroll\", \"dragScroll\"], [\"tbody\", \"\"], [\"id\", \"left\", \"class\", \"igx-grid__scroll-on-drag-left\", 3, \"igxColumnMovingDrop\", 4, \"ngIf\"], [\"id\", \"left\", \"class\", \"igx-grid__scroll-on-drag-pinned\", 3, \"igxColumnMovingDrop\", \"left\", 4, \"ngIf\"], [4, \"ngTemplateOutlet\"], [\"pinnedRecordsTemplate\", \"\"], [\"igxGridFor\", \"\", 3, \"igxGridForOf\", \"igxForScrollOrientation\", \"igxForScrollContainer\", \"igxForContainerSize\", \"igxForItemSize\", \"igxForTrackBy\", \"chunkPreload\", \"dataChanging\", \"dataChanged\"], [\"verticalScrollContainer\", \"\"], [\"record_template\", \"\"], [\"pinned_record_template\", \"\"], [\"group_template\", \"\"], [\"summary_template\", \"\"], [\"detail_template_container\", \"\"], [\"igxOverlayOutlet\", \"\", 1, \"igx-grid__row-editing-outlet\"], [\"igxRowEditingOverlayOutlet\", \"\"], [\"igxToggle\", \"\"], [\"loadingOverlay\", \"\"], [3, \"indeterminate\", 4, \"ngIf\"], [\"id\", \"right\", \"class\", \"igx-grid__scroll-on-drag-right\", 3, \"igxColumnMovingDrop\", 4, \"ngIf\"], [1, \"igx-grid__tbody-scrollbar\", 3, \"hidden\", \"pointerdown\"], [1, \"igx-grid__tbody-scrollbar-start\"], [1, \"igx-grid__tbody-scrollbar-main\"], [\"igxGridFor\", \"\", 3, \"igxGridForOf\"], [\"verticalScrollHolder\", \"\"], [1, \"igx-grid__tbody-scrollbar-end\"], [1, \"igx-grid__addrow-snackbar\"], [3, \"outlet\", \"actionText\", \"displayTime\"], [\"addRowSnackbar\", \"\"], [\"igxOverlayOutlet\", \"\"], [\"igxBodyOverlayOutlet\", \"overlay-outlet\"], [\"role\", \"rowgroup\", 1, \"igx-grid__tfoot\"], [\"tfoot\", \"\"], [\"tabindex\", \"0\", 3, \"focus\", \"keydown\"], [\"role\", \"row\", \"class\", \"igx-grid__summaries\", 3, \"width\", \"height\", \"gridID\", \"summaries\", \"index\", 4, \"ngIf\"], [1, \"igx-grid__tfoot-thumb\", 3, \"hidden\"], [1, \"igx-grid__scroll\", 3, \"hidden\", \"pointerdown\"], [\"scr\", \"\"], [1, \"igx-grid__scroll-start\"], [1, \"igx-grid__scroll-main\"], [\"scrollContainer\", \"\"], [1, \"igx-grid__scroll-end\", 3, \"hidden\"], [1, \"igx-grid__footer\"], [\"footer\", \"\"], [\"emptyFilteredGrid\", \"\"], [\"defaultEmptyGrid\", \"\"], [\"defaultAddRowEmptyTemplate\", \"\"], [\"defaultLoadingGrid\", \"\"], [\"defaultExpandedTemplate\", \"\"], [\"defaultCollapsedTemplate\", \"\"], [\"igxToggle\", \"\", 4, \"ngIf\"], [\"defaultRowEditText\", \"\"], [\"defaultRowEditActions\", \"\"], [\"defaultRowEditTemplate\", \"\"], [\"dragIndicatorIconBase\", \"\"], [\"igxOverlayOutlet\", \"\", 1, \"igx-grid__loading-outlet\"], [\"igxLoadingOverlayOutlet\", \"\"], [\"igxOverlayOutlet\", \"\", 1, \"igx-grid__outlet\"], [\"igxFilteringOverlayOutlet\", \"\"], [3, \"grid\", \"expressions\", \"sortingExpressions\", \"density\", \"dropAreaTemplate\", \"dropAreaMessage\"], [\"groupArea\", \"\"], [\"id\", \"left\", 1, \"igx-grid__scroll-on-drag-left\", 3, \"igxColumnMovingDrop\"], [\"id\", \"left\", 1, \"igx-grid__scroll-on-drag-pinned\", 3, \"igxColumnMovingDrop\"], [\"class\", \"igx-grid__tr--pinned\", 3, \"ngClass\", \"width\", 4, \"ngIf\"], [1, \"igx-grid__tr--pinned\", 3, \"ngClass\"], [\"pinContainer\", \"\"], [4, \"ngFor\", \"ngForOf\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [3, \"igxTemplateOutlet\", \"igxTemplateOutletContext\", \"cachedViewLoaded\", \"viewCreated\", \"viewMoved\"], [3, \"gridID\", \"index\", \"data\", \"disabled\", \"ngClass\", \"ngStyle\"], [\"row\", \"\"], [3, \"gridID\", \"index\", \"data\", \"ngClass\", \"ngStyle\"], [\"row\", \"\", \"pinnedRow\", \"\"], [3, \"gridID\", \"index\", \"groupRow\", \"hideGroupRowSelectors\", \"rowDraggable\"], [\"role\", \"row\", 1, \"igx-grid__summaries--body\", 3, \"gridID\", \"summaries\", \"index\"], [\"summaryRow\", \"\"], [\"detail\", \"true\", 2, \"overflow\", \"auto\", \"width\", \"100%\", 3, \"id\", \"ngClass\", \"pointerdown\"], [\"detailsContainer\", \"\"], [1, \"igx-grid__hierarchical-indent\", 2, \"display\", \"flex\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [3, \"indeterminate\"], [\"id\", \"right\", 1, \"igx-grid__scroll-on-drag-right\", 3, \"igxColumnMovingDrop\"], [\"role\", \"row\", 1, \"igx-grid__summaries\", 3, \"gridID\", \"summaries\", \"index\"], [\"role\", \"cell\", 1, \"igx-grid__tbody-message\"], [\"igxButton\", \"raised\", \"igxRipple\", \"\", 3, \"click\"], [1, \"igx-grid__loading\"], [\"role\", \"button\", 1, \"igx-grid__group-expand-btn\", 3, \"ngClass\"], [\"rowEditingOverlay\", \"\"], [3, \"className\"], [\"igxButton\", \"\", \"igxRowEditTabStop\", \"\", \"type\", \"button\", 3, \"click\"], [1, \"igx-banner__message\"], [1, \"igx-banner__text\"], [1, \"igx-banner__actions\"], [1, \"igx-banner__row\"]],\n    template: function IgxGridComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c227);\n        i0.ɵɵprojection(0);\n        i0.ɵɵtemplate(1, IgxGridComponent_ng_container_1_Template, 3, 8, \"ng-container\", 0);\n        i0.ɵɵelementStart(2, \"igx-grid-header-row\", 1);\n        i0.ɵɵlistener(\"keydown.meta.c\", function IgxGridComponent_Template_igx_grid_header_row_keydown_meta_c_2_listener($event) {\n          return ctx.copyHandler($event);\n        })(\"keydown.control.c\", function IgxGridComponent_Template_igx_grid_header_row_keydown_control_c_2_listener($event) {\n          return ctx.copyHandler($event);\n        })(\"copy\", function IgxGridComponent_Template_igx_grid_header_row_copy_2_listener($event) {\n          return ctx.copyHandler($event);\n        })(\"keydown\", function IgxGridComponent_Template_igx_grid_header_row_keydown_2_listener($event) {\n          return ctx.navigation.headerNavigation($event);\n        })(\"scroll\", function IgxGridComponent_Template_igx_grid_header_row_scroll_2_listener($event) {\n          return ctx.preventHeaderScroll($event);\n        })(\"focus\", function IgxGridComponent_Template_igx_grid_header_row_focus_2_listener() {\n          return ctx.navigation.focusFirstCell();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"div\", 2);\n        i0.ɵɵlistener(\"keydown.control.c\", function IgxGridComponent_Template_div_keydown_control_c_3_listener($event) {\n          return ctx.copyHandler($event);\n        })(\"copy\", function IgxGridComponent_Template_div_copy_3_listener($event) {\n          return ctx.copyHandler($event);\n        });\n        i0.ɵɵelementStart(4, \"div\", 3, 4);\n        i0.ɵɵlistener(\"keydown\", function IgxGridComponent_Template_div_keydown_4_listener($event) {\n          return ctx.navigation.handleNavigation($event);\n        })(\"focus\", function IgxGridComponent_Template_div_focus_4_listener($event) {\n          return ctx.navigation.focusTbody($event);\n        })(\"dragStop\", function IgxGridComponent_Template_div_dragStop_4_listener($event) {\n          return ctx.selectionService.dragMode = $event;\n        })(\"scroll\", function IgxGridComponent_Template_div_scroll_4_listener($event) {\n          return ctx.preventContainerScroll($event);\n        })(\"dragScroll\", function IgxGridComponent_Template_div_dragScroll_4_listener($event) {\n          return ctx.dragScroll($event);\n        });\n        i0.ɵɵtemplate(6, IgxGridComponent_span_6_Template, 1, 2, \"span\", 5);\n        i0.ɵɵtemplate(7, IgxGridComponent_span_7_Template, 1, 4, \"span\", 6);\n        i0.ɵɵtemplate(8, IgxGridComponent_ng_container_8_Template, 1, 0, \"ng-container\", 7);\n        i0.ɵɵtemplate(9, IgxGridComponent_ng_template_9_Template, 7, 47, \"ng-template\", null, 8, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(11, IgxGridComponent_ng_template_11_Template, 1, 2, \"ng-template\", 9, 10, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵpipe(13, \"gridRowPinning\");\n        i0.ɵɵpipe(14, \"gridAddRow\");\n        i0.ɵɵpipe(15, \"gridDetails\");\n        i0.ɵɵpipe(16, \"gridSummary\");\n        i0.ɵɵpipe(17, \"gridPaging\");\n        i0.ɵɵpipe(18, \"gridGroupBy\");\n        i0.ɵɵpipe(19, \"gridSort\");\n        i0.ɵɵpipe(20, \"gridFiltering\");\n        i0.ɵɵpipe(21, \"visibleColumns\");\n        i0.ɵɵpipe(22, \"gridTransaction\");\n        i0.ɵɵlistener(\"chunkPreload\", function IgxGridComponent_Template_ng_template_chunkPreload_11_listener($event) {\n          return ctx.dataLoading($event);\n        })(\"dataChanging\", function IgxGridComponent_Template_ng_template_dataChanging_11_listener($event) {\n          return ctx.dataRebinding($event);\n        })(\"dataChanged\", function IgxGridComponent_Template_ng_template_dataChanged_11_listener($event) {\n          return ctx.dataRebound($event);\n        });\n        i0.ɵɵtemplate(23, IgxGridComponent_ng_container_23_Template, 1, 0, \"ng-container\", 7);\n        i0.ɵɵtemplate(24, IgxGridComponent_ng_template_24_Template, 4, 36, \"ng-template\", null, 11, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(26, IgxGridComponent_ng_template_26_Template, 5, 35, \"ng-template\", null, 12, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(28, IgxGridComponent_ng_template_28_Template, 2, 5, \"ng-template\", null, 13, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(30, IgxGridComponent_ng_template_30_Template, 2, 3, \"ng-template\", null, 14, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(32, IgxGridComponent_ng_template_32_Template, 5, 9, \"ng-template\", null, 15, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(34, IgxGridComponent_ng_container_34_Template, 1, 0, \"ng-container\", 7);\n        i0.ɵɵelement(35, \"div\", 16, 17)(37, \"igc-trial-watermark\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(38, \"div\", 18, 19);\n        i0.ɵɵtemplate(40, IgxGridComponent_igx_circular_bar_40_Template, 1, 1, \"igx-circular-bar\", 20);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(41, IgxGridComponent_span_41_Template, 1, 2, \"span\", 21);\n        i0.ɵɵelementStart(42, \"div\", 22);\n        i0.ɵɵlistener(\"pointerdown\", function IgxGridComponent_Template_div_pointerdown_42_listener($event) {\n          return $event.preventDefault();\n        });\n        i0.ɵɵelement(43, \"div\", 23);\n        i0.ɵɵelementStart(44, \"div\", 24);\n        i0.ɵɵtemplate(45, IgxGridComponent_ng_template_45_Template, 0, 0, \"ng-template\", 25, 26, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(47, \"div\", 27);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(48, \"div\", 28)(49, \"igx-snackbar\", 29, 30);\n        i0.ɵɵtext(51);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelement(52, \"div\", 31, 32);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(54, \"div\", 33, 34)(56, \"div\", 35);\n        i0.ɵɵlistener(\"focus\", function IgxGridComponent_Template_div_focus_56_listener() {\n          return ctx.navigation.focusFirstCell(false);\n        })(\"keydown\", function IgxGridComponent_Template_div_keydown_56_listener($event) {\n          return ctx.navigation.summaryNav($event);\n        });\n        i0.ɵɵtemplate(57, IgxGridComponent_igx_grid_summary_row_57_Template, 3, 10, \"igx-grid-summary-row\", 36);\n        i0.ɵɵelement(58, \"div\", 37);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(59, \"div\", 38, 39);\n        i0.ɵɵlistener(\"pointerdown\", function IgxGridComponent_Template_div_pointerdown_59_listener($event) {\n          return $event.preventDefault();\n        });\n        i0.ɵɵelement(61, \"div\", 40);\n        i0.ɵɵelementStart(62, \"div\", 41);\n        i0.ɵɵtemplate(63, IgxGridComponent_ng_template_63_Template, 0, 0, \"ng-template\", 25, 42, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(65, \"div\", 43);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(66, \"div\", 44, 45);\n        i0.ɵɵprojection(68, 1);\n        i0.ɵɵtemplate(69, IgxGridComponent_ng_container_69_Template, 2, 0, \"ng-container\", 0);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(70, IgxGridComponent_ng_template_70_Template, 4, 2, \"ng-template\", null, 46, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(72, IgxGridComponent_ng_template_72_Template, 4, 2, \"ng-template\", null, 47, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(74, IgxGridComponent_ng_template_74_Template, 2, 1, \"ng-template\", null, 48, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(76, IgxGridComponent_ng_template_76_Template, 2, 1, \"ng-template\", null, 49, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(78, IgxGridComponent_ng_template_78_Template, 2, 3, \"ng-template\", null, 50, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(80, IgxGridComponent_ng_template_80_Template, 2, 3, \"ng-template\", null, 51, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(82, IgxGridComponent_div_82_Template, 4, 6, \"div\", 52);\n        i0.ɵɵtemplate(83, IgxGridComponent_ng_template_83_Template, 1, 1, \"ng-template\", null, 53, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(85, IgxGridComponent_ng_template_85_Template, 4, 2, \"ng-template\", null, 54, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(87, IgxGridComponent_ng_template_87_Template, 6, 8, \"ng-template\", null, 55, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(89, IgxGridComponent_ng_template_89_Template, 2, 0, \"ng-template\", null, 56, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(91, IgxGridComponent_igx_grid_column_resizer_91_Template, 1, 0, \"igx-grid-column-resizer\", 0);\n        i0.ɵɵelement(92, \"div\", 57, 58)(94, \"div\", 59, 60);\n      }\n\n      if (rf & 2) {\n        const _r5 = i0.ɵɵreference(10);\n\n        const _r28 = i0.ɵɵreference(53);\n\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showGroupArea && (ctx.groupingExpressions.length > 0 || ctx.hasGroupableColumns));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"grid\", ctx)(\"hasMRL\", ctx.hasColumnLayouts)(\"density\", ctx.displayDensity)(\"activeDescendant\", ctx.activeDescendant)(\"width\", ctx.calcWidth)(\"pinnedColumnCollection\", ctx.pinnedColumns)(\"unpinnedColumnCollection\", ctx.unpinnedColumns);\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"height\", ctx.totalHeight, \"px\")(\"width\", ctx.calcWidth || null, \"px\");\n        i0.ɵɵproperty(\"igxGridDragSelect\", ctx.selectionService.dragMode);\n        i0.ɵɵattribute(\"role\", ctx.dataView.length ? null : \"row\")(\"aria-activedescendant\", ctx.activeDescendant);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.moving && ctx.columnInDrag && ctx.pinnedColumns.length <= 0);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.moving && ctx.columnInDrag && ctx.pinnedColumns.length > 0);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.hasPinnedRecords && ctx.isRowPinningToTop ? _r5 : null);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"igxGridForOf\", i0.ɵɵpipeBind4(13, 71, i0.ɵɵpipeBind3(14, 76, i0.ɵɵpipeBind4(15, 80, i0.ɵɵpipeBindV(16, 85, i0.ɵɵpureFunction8(159, _c228, i0.ɵɵpipeBindV(17, 94, i0.ɵɵpureFunction5(153, _c71, i0.ɵɵpipeBindV(18, 100, i0.ɵɵpureFunction8(144, _c228, i0.ɵɵpipeBindV(19, 109, i0.ɵɵpureFunction5(138, _c71, i0.ɵɵpipeBindV(20, 115, i0.ɵɵpureFunction7(130, _c214, i0.ɵɵpipeBind2(21, 123, i0.ɵɵpipeBind3(22, 126, ctx.data, ctx.id, ctx.pipeTrigger), ctx.hasVisibleColumns), ctx.filteringExpressionsTree, ctx.filterStrategy, ctx.advancedFilteringExpressionsTree, ctx.id, ctx.pipeTrigger, ctx.filteringPipeTrigger)), ctx.sortingExpressions, ctx.sortStrategy, ctx.id, ctx.pipeTrigger)), ctx.groupingExpressions, ctx.groupingExpansionState, ctx.groupStrategy, ctx.groupsExpanded, ctx.id, ctx.groupsRecords, ctx.pipeTrigger)), ctx.paginator == null ? null : ctx.paginator.page, ctx.paginator == null ? null : ctx.paginator.perPage, ctx.id, ctx.pipeTrigger)), ctx.hasSummarizedColumns, ctx.summaryCalculationMode, ctx.summaryPosition, ctx.id, ctx.showSummaryOnCollapse, ctx.pipeTrigger, ctx.summaryPipeTrigger)), ctx.hasDetails, ctx.expansionStates, ctx.pipeTrigger), false, ctx.pipeTrigger), ctx.id, false, ctx.pipeTrigger))(\"igxForScrollOrientation\", \"vertical\")(\"igxForScrollContainer\", ctx.verticalScroll)(\"igxForContainerSize\", ctx.calcHeight)(\"igxForItemSize\", ctx.hasColumnLayouts ? ctx.rowHeight * ctx.multiRowLayoutRowSize + 1 : ctx.renderedRowHeight)(\"igxForTrackBy\", ctx.trackChanges);\n        i0.ɵɵadvance(12);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.hasPinnedRecords && !ctx.isRowPinningToTop ? _r5 : null);\n        i0.ɵɵadvance(11);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template);\n        i0.ɵɵadvance(6);\n        i0.ɵɵproperty(\"ngIf\", ctx.shouldOverlayLoading);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.moving && ctx.columnInDrag);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.scrollSize, \"px\");\n        i0.ɵɵproperty(\"hidden\", !ctx.hasVerticalScroll());\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"height\", ctx.isRowPinningToTop ? ctx.pinnedRowHeight : 0, \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"height\", ctx.calcHeight, \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"igxGridForOf\", i0.ɵɵpureFunction0(168, _c115));\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"height\", !ctx.isRowPinningToTop ? ctx.pinnedRowHeight : 0, \"px\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"outlet\", _r28)(\"actionText\", ctx.resourceStrings.igx_grid_snackbar_addrow_actiontext)(\"displayTime\", ctx.snackbarDisplayTime);\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate(ctx.resourceStrings.igx_grid_snackbar_addrow_label);\n        i0.ɵɵadvance(3);\n        i0.ɵɵstyleProp(\"height\", ctx.summaryRowHeight, \"px\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵattribute(\"aria-activedescendant\", ctx.activeDescendant);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasSummarizedColumns && ctx.rootSummariesEnabled);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"height\", ctx.summaryRowHeight, \"px\")(\"width\", ctx.scrollSize, \"px\");\n        i0.ɵɵproperty(\"hidden\", !ctx.hasVerticalScroll());\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"height\", ctx.scrollSize, \"px\");\n        i0.ɵɵproperty(\"hidden\", ctx.isHorizontalScrollHidden);\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"width\", ctx.isPinningToStart ? ctx.pinnedWidth : ctx.headerFeaturesWidth, \"px\")(\"min-width\", ctx.isPinningToStart ? ctx.pinnedWidth : ctx.headerFeaturesWidth, \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.unpinnedWidth, \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"igxGridForOf\", ctx.EMPTY_DATA);\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"float\", \"right\")(\"width\", ctx.pinnedWidth, \"px\")(\"min-width\", ctx.pinnedWidth, \"px\");\n        i0.ɵɵproperty(\"hidden\", ctx.pinnedWidth === 0 || ctx.isPinningToStart);\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"ngIf\", ctx.totalRecords || ctx.pagingMode === 1);\n        i0.ɵɵadvance(13);\n        i0.ɵɵproperty(\"ngIf\", ctx.rowEditable);\n        i0.ɵɵadvance(9);\n        i0.ɵɵproperty(\"ngIf\", ctx.colResizingService.showResizer);\n      }\n    },\n    directives: [IgxGridGroupByAreaComponent, IgxGridHeaderRowComponent, IgxGridRowComponent, IgxGridGroupByRowComponent, IgxSummaryRowComponent, IgxCircularProgressBarComponent, IgxSnackbarComponent, IgxIconComponent, IgxGridColumnResizerComponent, i4.NgIf, IgxGridBodyDirective, IgxGridDragSelectDirective, IgxColumnMovingDropDirective, i4.NgTemplateOutlet, i4.NgClass, i4.NgForOf, IgxGridForOfDirective, IgxTemplateOutletDirective, i4.NgStyle, IgxOverlayOutletDirective, IgxToggleDirective, IgxButtonDirective, IgxRippleDirective, IgxRowEditTabStopDirective],\n    pipes: [IgxGridSortingPipe, IgxGridFilteringPipe, IgxGridRowPinningPipe, IgxGridAddRowPipe, IgxHasVisibleColumnsPipe, IgxGridTransactionPipe, IgxGridDetailsPipe, IgxGridSummaryPipe, IgxGridPagingPipe, IgxGridGroupingPipe, IgxGridRowClassesPipe, IgxGridRowStylesPipe, IgxSummaryDataPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxGridComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridStateDirective = /*#__PURE__*/(() => {\n  class IgxGridStateDirective {\n    /**\n     * @hidden\n     */\n    constructor(grid, resolver, viewRef) {\n      this.grid = grid;\n      this.resolver = resolver;\n      this.viewRef = viewRef;\n      this.featureKeys = [];\n      this._options = {\n        columns: true,\n        filtering: true,\n        advancedFiltering: true,\n        sorting: true,\n        groupBy: true,\n        paging: true,\n        cellSelection: true,\n        rowSelection: true,\n        columnSelection: true,\n        rowPinning: true,\n        expansion: true,\n        moving: true,\n        rowIslands: true\n      };\n      this.FEATURES = {\n        sorting: {\n          getFeatureState: context => {\n            const sortingState = context.currGrid.sortingExpressions;\n            sortingState.forEach(s => {\n              delete s.strategy;\n              delete s.owner;\n            });\n            return {\n              sorting: sortingState\n            };\n          },\n          restoreFeatureState: (context, state) => {\n            context.currGrid.sortingExpressions = state;\n          }\n        },\n        filtering: {\n          getFeatureState: context => {\n            const filteringState = context.currGrid.filteringExpressionsTree;\n\n            if (filteringState) {\n              delete filteringState.owner;\n\n              for (const item of filteringState.filteringOperands) {\n                delete item.owner;\n              }\n            }\n\n            return {\n              filtering: filteringState\n            };\n          },\n          restoreFeatureState: (context, state) => {\n            const filterTree = context.createExpressionsTreeFromObject(state);\n            context.currGrid.filteringExpressionsTree = filterTree;\n          }\n        },\n        advancedFiltering: {\n          getFeatureState: context => {\n            const filteringState = context.currGrid.advancedFilteringExpressionsTree;\n            let advancedFiltering;\n\n            if (filteringState) {\n              delete filteringState.owner;\n\n              for (const item of filteringState.filteringOperands) {\n                delete item.owner;\n              }\n\n              advancedFiltering = filteringState;\n            } else {\n              advancedFiltering = {};\n            }\n\n            return {\n              advancedFiltering\n            };\n          },\n          restoreFeatureState: (context, state) => {\n            const filterTree = context.createExpressionsTreeFromObject(state);\n            context.currGrid.advancedFilteringExpressionsTree = filterTree;\n          }\n        },\n        columns: {\n          getFeatureState: context => {\n            const gridColumns = context.currGrid.columnList.map(c => ({\n              pinned: c.pinned,\n              sortable: c.sortable,\n              filterable: c.filterable,\n              editable: c.editable,\n              sortingIgnoreCase: c.sortingIgnoreCase,\n              filteringIgnoreCase: c.filteringIgnoreCase,\n              headerClasses: c.headerClasses,\n              headerGroupClasses: c.headerGroupClasses,\n              maxWidth: c.maxWidth,\n              groupable: c.groupable,\n              movable: c.movable,\n              hidden: c.hidden,\n              dataType: c.dataType,\n              hasSummary: c.hasSummary,\n              field: c.field,\n              width: c.width,\n              header: c.header,\n              resizable: c.resizable,\n              searchable: c.searchable,\n              selectable: c.selectable,\n              parent: c.parent ? c.parent.header : null,\n              columnGroup: c.columnGroup,\n              disableHiding: c.disableHiding\n            }));\n            return {\n              columns: gridColumns\n            };\n          },\n          restoreFeatureState: (context, state) => {\n            const newColumns = [];\n            const factory = context.resolver.resolveComponentFactory(IgxColumnComponent);\n            const groupFactory = context.resolver.resolveComponentFactory(IgxColumnGroupComponent);\n            state.forEach(colState => {\n              const hasColumnGroup = colState.columnGroup;\n              delete colState.columnGroup;\n\n              if (hasColumnGroup) {\n                const ref1 = groupFactory.create(context.viewRef.injector);\n                Object.assign(ref1.instance, colState);\n\n                if (ref1.instance.parent) {\n                  const columnGroup = newColumns.find(e => e.header === ref1.instance.parent);\n                  columnGroup.children.reset([...columnGroup.children.toArray(), ref1.instance]);\n                  ref1.instance.parent = columnGroup;\n                }\n\n                ref1.changeDetectorRef.detectChanges();\n                newColumns.push(ref1.instance);\n              } else {\n                const ref = factory.create(context.viewRef.injector);\n                Object.assign(ref.instance, colState);\n\n                if (ref.instance.parent) {\n                  const columnGroup = newColumns.find(e => e.header === ref.instance.parent);\n\n                  if (columnGroup) {\n                    ref.instance.parent = columnGroup;\n                    columnGroup.children.reset([...columnGroup.children.toArray(), ref.instance]);\n                  }\n                }\n\n                ref.changeDetectorRef.detectChanges();\n                newColumns.push(ref.instance);\n              }\n            });\n            context.grid.updateColumns(newColumns);\n          }\n        },\n        groupBy: {\n          getFeatureState: context => {\n            const grid = context.currGrid;\n            const groupingExpressions = grid.groupingExpressions;\n            groupingExpressions.forEach(expr => {\n              delete expr.strategy;\n            });\n            const expansionState = grid.groupingExpansionState;\n            const groupsExpanded = grid.groupsExpanded;\n            return {\n              groupBy: {\n                expressions: groupingExpressions,\n                expansion: expansionState,\n                defaultExpanded: groupsExpanded\n              }\n            };\n          },\n          restoreFeatureState: (context, state) => {\n            const grid = context.currGrid;\n            grid.groupingExpressions = state.expressions;\n\n            if (grid.groupsExpanded !== state.defaultExpanded) {\n              grid.toggleAllGroupRows();\n            } else {\n              grid.groupingExpansionState = state.expansion;\n            }\n          }\n        },\n        paging: {\n          getFeatureState: context => {\n            const pagingState = context.currGrid.pagingState;\n            return {\n              paging: pagingState\n            };\n          },\n          restoreFeatureState: (context, state) => {\n            if (!context.currGrid.paginator) {\n              return;\n            }\n\n            if (context.currGrid.paginator.perPage !== state.recordsPerPage) {\n              context.currGrid.paginator.perPage = state.recordsPerPage;\n              context.currGrid.cdr.detectChanges();\n            }\n\n            context.currGrid.paginator.page = state.index;\n          }\n        },\n        moving: {\n          getFeatureState: context => {\n            return {\n              moving: context.currGrid.moving\n            };\n          },\n          restoreFeatureState: (context, state) => {\n            context.currGrid.moving = state;\n          }\n        },\n        rowSelection: {\n          getFeatureState: context => {\n            const selection = context.currGrid.selectedRows;\n            return {\n              rowSelection: selection\n            };\n          },\n          restoreFeatureState: (context, state) => {\n            context.currGrid.selectRows(state, true);\n          }\n        },\n        cellSelection: {\n          getFeatureState: context => {\n            const selection = context.currGrid.getSelectedRanges().map(range => ({\n              rowStart: range.rowStart,\n              rowEnd: range.rowEnd,\n              columnStart: range.columnStart,\n              columnEnd: range.columnEnd\n            }));\n            return {\n              cellSelection: selection\n            };\n          },\n          restoreFeatureState: (context, state) => {\n            state.forEach(r => {\n              const range = {\n                rowStart: r.rowStart,\n                rowEnd: r.rowEnd,\n                columnStart: r.columnStart,\n                columnEnd: r.columnEnd\n              };\n              context.currGrid.selectRange(range);\n            });\n          }\n        },\n        columnSelection: {\n          getFeatureState: context => {\n            const selection = context.currGrid.selectedColumns().map(c => c.field);\n            return {\n              columnSelection: selection\n            };\n          },\n          restoreFeatureState: (context, state) => {\n            context.currGrid.deselectAllColumns();\n            context.currGrid.selectColumns(state);\n          }\n        },\n        rowPinning: {\n          getFeatureState: context => {\n            const pinned = context.currGrid.pinnedRows.map(x => x.key);\n            return {\n              rowPinning: pinned\n            };\n          },\n          restoreFeatureState: (context, state) => {\n            // clear current state.\n            context.currGrid.pinnedRows.forEach(row => row.unpin());\n            state.forEach(rowID => context.currGrid.pinRow(rowID));\n          }\n        },\n        pinningConfig: {\n          getFeatureState: context => ({\n            pinningConfig: context.currGrid.pinning\n          }),\n          restoreFeatureState: (context, state) => {\n            context.currGrid.pinning = state;\n          }\n        },\n        expansion: {\n          getFeatureState: context => {\n            const expansionStates = Array.from(context.currGrid.expansionStates);\n            return {\n              expansion: expansionStates\n            };\n          },\n          restoreFeatureState: (context, state) => {\n            const expansionStates = new Map(state);\n            context.currGrid.expansionStates = expansionStates;\n          }\n        },\n        rowIslands: {\n          getFeatureState(context) {\n            const childGridStates = [];\n            const rowIslands = context.currGrid.allLayoutList;\n\n            if (rowIslands) {\n              rowIslands.forEach(rowIsland => {\n                const childGrids = rowIsland.rowIslandAPI.getChildGrids();\n                childGrids.forEach(chGrid => {\n                  const parentRowID = this.getParentRowID(chGrid);\n                  context.currGrid = chGrid;\n\n                  if (context.currGrid) {\n                    const childGridState = context.buildState(context.featureKeys);\n                    childGridStates.push({\n                      id: `${rowIsland.id}`,\n                      parentRowID,\n                      state: childGridState\n                    });\n                  }\n                });\n              });\n            }\n\n            context.currGrid = context.grid;\n            return {\n              rowIslands: childGridStates\n            };\n          },\n\n          restoreFeatureState(context, state) {\n            const rowIslands = context.currGrid.allLayoutList;\n\n            if (rowIslands) {\n              rowIslands.forEach(rowIsland => {\n                const childGrids = rowIsland.rowIslandAPI.getChildGrids();\n                childGrids.forEach(chGrid => {\n                  const parentRowID = this.getParentRowID(chGrid);\n                  context.currGrid = chGrid;\n                  const childGridState = state.find(st => st.id === rowIsland.id && st.parentRowID === parentRowID);\n\n                  if (childGridState && context.currGrid) {\n                    context.restoreGridState(childGridState.state, context.featureKeys);\n                  }\n                });\n              });\n            }\n\n            context.currGrid = context.grid;\n          },\n\n          /**\n           * Traverses the hierarchy up to the root grid to return the ID of the expanded row.\n           */\n          getParentRowID: grid => {\n            let childGrid;\n\n            while (grid.parent) {\n              childGrid = grid;\n              grid = grid.parent;\n            }\n\n            return grid.gridAPI.getParentRowId(childGrid);\n          }\n        }\n      };\n    }\n    /**\n     *  An object with options determining if a certain feature state should be saved.\n     * ```html\n     * <igx-grid [igxGridState]=\"options\"></igx-grid>\n     * ```\n     * ```typescript\n     * public options = {selection: false, advancedFiltering: false};\n     * ```\n     */\n\n\n    get options() {\n      return this._options;\n    }\n\n    set options(value) {\n      Object.assign(this._options, value);\n\n      if (!(this.grid instanceof IgxGridComponent)) {\n        delete this._options.groupBy;\n      } else {\n        delete this._options.rowIslands;\n      }\n    }\n    /**\n     * Gets the state of a feature or states of all grid features, unless a certain feature is disabled through the `options` property.\n     *\n     * @param `serialize` determines whether the returned object will be serialized to JSON string. Default value is true.\n     * @param `feature` string or array of strings determining the features to be added in the state. If skipped, all features are added.\n     * @returns Returns the serialized to JSON string IGridState object, or the non-serialized IGridState object.\n     * ```html\n     * <igx-grid [igxGridState]=\"options\"></igx-grid>\n     * ```\n     * ```typescript\n     * @ViewChild(IgxGridStateDirective, { static: true }) public state;\n     * let state = this.state.getState(); // returns string\n     * let state = this.state(false) // returns `IGridState` object\n     * ```\n     */\n\n\n    getState(serialize = true, features) {\n      let state;\n      this.currGrid = this.grid;\n      this.state = state = this.buildState(features);\n\n      if (serialize) {\n        state = JSON.stringify(state, this.stringifyCallback);\n      }\n\n      return state;\n    }\n    /**\n     * Restores grid features' state based on the IGridState object passed as an argument.\n     *\n     * @param IGridState object to restore state from.\n     * @returns\n     * ```html\n     * <igx-grid [igxGridState]=\"options\"></igx-grid>\n     * ```\n     * ```typescript\n     * @ViewChild(IgxGridStateDirective, { static: true }) public state;\n     * this.state.setState(gridState);\n     * ```\n     */\n\n\n    setState(state, features) {\n      if (typeof state === 'string') {\n        state = JSON.parse(state);\n      }\n\n      this.state = state;\n      this.currGrid = this.grid;\n      this.restoreGridState(state, features);\n      this.grid.cdr.detectChanges(); // TODO\n    }\n    /**\n     * Builds an IGridState object.\n     */\n\n\n    buildState(keys) {\n      this.applyFeatures(keys);\n      let gridState = {};\n      this.featureKeys.forEach(f => {\n        if (this.options[f]) {\n          if (!(this.grid instanceof IgxGridComponent) && f === 'groupBy') {\n            return;\n          }\n\n          const feature = this.getFeature(f);\n          const featureState = feature.getFeatureState(this);\n          gridState = Object.assign(gridState, featureState);\n        }\n      });\n      return gridState;\n    }\n    /**\n     * The method that calls corresponding methods to restore features from the passed IGridState object.\n     */\n\n\n    restoreGridState(state, features) {\n      // TODO Notify the grid that columnList.changes is triggered by the state directive\n      // instead of piping it like below\n      const columns = 'columns';\n      this.grid.columnList.changes.pipe(delay(0), take(1)).subscribe(() => {\n        this.featureKeys = this.featureKeys.filter(f => f !== columns);\n        this.restoreFeatures(state);\n      });\n      this.applyFeatures(features);\n\n      if (this.featureKeys.includes(columns) && this.options[columns] && state[columns]) {\n        this.getFeature(columns).restoreFeatureState(this, state[columns]);\n      } else {\n        this.restoreFeatures(state);\n      }\n    }\n\n    restoreFeatures(state) {\n      this.featureKeys.forEach(f => {\n        if (this.options[f]) {\n          const featureState = state[f];\n\n          if (f === 'moving' || featureState) {\n            const feature = this.getFeature(f);\n            feature.restoreFeatureState(this, featureState);\n          }\n        }\n      });\n    }\n    /**\n     * Returns a collection of all grid features.\n     */\n\n\n    applyFeatures(keys) {\n      this.featureKeys = [];\n\n      if (!keys) {\n        for (const key of Object.keys(this.options)) {\n          this.featureKeys.push(key);\n        }\n      } else if (Array.isArray(keys)) {\n        this.featureKeys = [...keys];\n      } else {\n        this.featureKeys.push(keys);\n      }\n    }\n    /**\n     * This method builds a FilteringExpressionsTree from a provided object.\n     */\n\n\n    createExpressionsTreeFromObject(exprTreeObject) {\n      if (!exprTreeObject || !exprTreeObject.filteringOperands) {\n        return null;\n      }\n\n      const expressionsTree = new FilteringExpressionsTree(exprTreeObject.operator, exprTreeObject.fieldName);\n\n      for (const item of exprTreeObject.filteringOperands) {\n        // Check if item is an expressions tree or a single expression.\n        if (item.filteringOperands) {\n          const subTree = this.createExpressionsTreeFromObject(item);\n          expressionsTree.filteringOperands.push(subTree);\n        } else {\n          const expr = item;\n          let dataType;\n\n          if (this.currGrid.columnList.length > 0) {\n            dataType = this.currGrid.columnList.find(c => c.field === expr.fieldName).dataType;\n          } else if (this.state.columns) {\n            dataType = this.state.columns.find(c => c.field === expr.fieldName).dataType;\n          } else {\n            return null;\n          } // when ESF, values are stored in Set.\n          // First those values are converted to an array before returning string in the stringifyCallback\n          // now we need to convert those back to Set\n\n\n          if (Array.isArray(expr.searchVal)) {\n            expr.searchVal = new Set(expr.searchVal);\n          } else {\n            expr.searchVal = expr.searchVal && (dataType === 'date' || dataType === 'dateTime') ? new Date(Date.parse(expr.searchVal)) : expr.searchVal;\n          }\n\n          expr.condition = this.generateFilteringCondition(dataType, expr.condition.name);\n          expressionsTree.filteringOperands.push(expr);\n        }\n      }\n\n      return expressionsTree;\n    }\n    /**\n     * Returns the filtering logic function for a given dataType and condition (contains, greaterThan, etc.)\n     */\n\n\n    generateFilteringCondition(dataType, name) {\n      let filters;\n\n      switch (dataType) {\n        case GridColumnDataType.Boolean:\n          filters = IgxBooleanFilteringOperand.instance();\n          break;\n\n        case GridColumnDataType.Number:\n          filters = IgxNumberFilteringOperand.instance();\n          break;\n\n        case GridColumnDataType.Date:\n          filters = IgxDateFilteringOperand.instance();\n          break;\n\n        case GridColumnDataType.DateTime:\n          filters = IgxDateTimeFilteringOperand.instance();\n          break;\n\n        case GridColumnDataType.String:\n        default:\n          filters = IgxStringFilteringOperand.instance();\n          break;\n      }\n\n      return filters.condition(name);\n    }\n\n    stringifyCallback(key, val) {\n      if (key === 'searchVal' && val instanceof Set) {\n        return Array.from(val);\n      }\n\n      return val;\n    }\n\n    getFeature(key) {\n      const feature = this.FEATURES[key];\n      return feature;\n    }\n\n  }\n\n  IgxGridStateDirective.ɵfac = function IgxGridStateDirective_Factory(t) {\n    return new (t || IgxGridStateDirective)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 9), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  };\n\n  IgxGridStateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxGridStateDirective,\n    selectors: [[\"\", \"igxGridState\", \"\"]],\n    inputs: {\n      options: [\"igxGridState\", \"options\"]\n    }\n  });\n  return IgxGridStateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxGridStateModule = /*#__PURE__*/(() => {\n  class IgxGridStateModule {}\n\n  IgxGridStateModule.ɵfac = function IgxGridStateModule_Factory(t) {\n    return new (t || IgxGridStateModule)();\n  };\n\n  IgxGridStateModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxGridStateModule\n  });\n  IgxGridStateModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return IgxGridStateModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridSharedModules = /*#__PURE__*/(() => {\n  class IgxGridSharedModules {}\n\n  IgxGridSharedModules.ɵfac = function IgxGridSharedModules_Factory(t) {\n    return new (t || IgxGridSharedModules)();\n  };\n\n  IgxGridSharedModules.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxGridSharedModules\n  });\n  IgxGridSharedModules.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, FormsModule, IgxButtonModule, IgxDatePickerModule, IgxIconModule, IgxRippleModule, IgxInputGroupModule, IgxFocusModule, IgxToggleModule, IgxForOfModule, IgxTemplateOutletModule, IgxTextHighlightModule, IgxTextSelectionModule, IgxCheckboxModule, IgxBadgeModule, IgxChipsModule, IgxDragDropModule, IgxDropDownModule, IgxButtonGroupModule, IgxProgressBarModule, IgxSelectModule, IgxGridStateModule, IgxSnackbarModule, IgxTimePickerModule, IgxDateTimeEditorModule], CommonModule, FormsModule, IgxButtonModule, IgxDatePickerModule, IgxIconModule, IgxRippleModule, IgxInputGroupModule, IgxFocusModule, IgxToggleModule, IgxForOfModule, IgxTemplateOutletModule, IgxTextHighlightModule, IgxGridStateModule, IgxTextSelectionModule, IgxCheckboxModule, IgxBadgeModule, IgxChipsModule, IgxDragDropModule, IgxDropDownModule, IgxButtonGroupModule, IgxProgressBarModule, IgxSelectModule, IgxSnackbarModule, IgxTimePickerModule, IgxDateTimeEditorModule]\n  });\n  return IgxGridSharedModules;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxColumnLayoutComponent = /*#__PURE__*/(() => {\n  class IgxColumnLayoutComponent extends IgxColumnGroupComponent {\n    constructor() {\n      super(...arguments);\n      this.childrenVisibleIndexes = [];\n    }\n    /**\n     * Gets the width of the column layout.\n     * ```typescript\n     * let columnGroupWidth = this.columnGroup.width;\n     * ```\n     *\n     * @memberof IgxColumnGroupComponent\n     */\n\n\n    get width() {\n      const width = this.getFilledChildColumnSizes(this.children).reduce((acc, val) => acc + parseInt(val, 10), 0);\n      return width;\n    }\n\n    set width(val) {}\n\n    get columnLayout() {\n      return true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    getCalcWidth() {\n      let borderWidth = 0;\n\n      if (this.headerGroup && this.headerGroup.hasLastPinnedChildColumn) {\n        const headerStyles = this.grid.document.defaultView.getComputedStyle(this.headerGroup.nativeElement.children[0]);\n        borderWidth = parseInt(headerStyles.borderRightWidth, 10);\n      }\n\n      return super.getCalcWidth() + borderWidth;\n    }\n    /**\n     * Gets the column visible index.\n     * If the column is not visible, returns `-1`.\n     * ```typescript\n     * let visibleColumnIndex =  this.column.visibleIndex;\n     * ```\n     *\n     * @memberof IgxColumnComponent\n     */\n\n\n    get visibleIndex() {\n      if (!isNaN(this._vIndex)) {\n        return this._vIndex;\n      }\n\n      const unpinnedColumns = this.grid.unpinnedColumns.filter(c => c.columnLayout && !c.hidden);\n      const pinnedColumns = this.grid.pinnedColumns.filter(c => c.columnLayout && !c.hidden);\n      let vIndex = -1;\n\n      if (!this.pinned) {\n        const indexInCollection = unpinnedColumns.indexOf(this);\n        vIndex = indexInCollection === -1 ? -1 : pinnedColumns.length + indexInCollection;\n      } else {\n        vIndex = pinnedColumns.indexOf(this);\n      }\n\n      this._vIndex = vIndex;\n      return vIndex;\n    }\n    /*\n     * Gets whether the column layout is hidden.\n     * ```typescript\n     * let isHidden = this.columnGroup.hidden;\n     * ```\n     * @memberof IgxColumnGroupComponent\n     */\n\n\n    get hidden() {\n      return this._hidden;\n    }\n    /**\n     * Sets the column layout hidden property.\n     * ```typescript\n     * <igx-column-layout [hidden] = \"true\"></igx-column->\n     * ```\n     *\n     * @memberof IgxColumnGroupComponent\n     */\n\n\n    set hidden(value) {\n      this._hidden = value;\n      this.children.forEach(child => child.hidden = value);\n\n      if (this.grid && this.grid.columnList && this.grid.columnList.length > 0) {\n        // reset indexes in case columns are hidden/shown runtime\n        const columns = this.grid && this.grid.pinnedColumns && this.grid.unpinnedColumns ? this.grid.pinnedColumns.concat(this.grid.unpinnedColumns) : [];\n\n        if (!this._hidden && !columns.find(c => c.field === this.field)) {\n          this.grid.resetColumnCollections();\n        }\n\n        this.grid.columnList.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterContentInit() {\n      super.ngAfterContentInit();\n\n      if (!this.hidden) {\n        this.hidden = this.allChildren.some(x => x.hidden);\n      } else {\n        this.children.forEach(child => child.hidden = this.hidden);\n      }\n    }\n    /*\n     * Gets whether the group contains the last pinned child column of the column layout.\n     * ```typescript\n     * let columsHasLastPinned = this.columnLayout.hasLastPinnedChildColumn;\n     * ```\n     * @memberof IgxColumnLayoutComponent\n     */\n\n\n    get hasLastPinnedChildColumn() {\n      return this.children.some(child => child.isLastPinned);\n    }\n    /*\n     * Gets whether the group contains the first pinned child column of the column layout.\n     * ```typescript\n     * let hasFirstPinnedChildColumn = this.columnLayout.hasFirstPinnedChildColumn;\n     * ```\n     * @memberof IgxColumnLayoutComponent\n     */\n\n\n    get hasFirstPinnedChildColumn() {\n      return this.children.some(child => child.isFirstPinned);\n    }\n    /**\n     * @hidden\n     */\n\n\n    populateVisibleIndexes() {\n      var _a, _b;\n\n      this.childrenVisibleIndexes = [];\n      const columns = ((_a = this.grid) === null || _a === void 0 ? void 0 : _a.pinnedColumns) && ((_b = this.grid) === null || _b === void 0 ? void 0 : _b.unpinnedColumns) ? this.grid.pinnedColumns.concat(this.grid.unpinnedColumns) : [];\n      const orderedCols = columns.filter(x => !x.columnGroup && !x.hidden).sort((a, b) => a.rowStart - b.rowStart || columns.indexOf(a.parent) - columns.indexOf(b.parent) || a.colStart - b.colStart);\n      this.children.forEach(child => {\n        const rs = child.rowStart || 1;\n        let vIndex = 0; // filter out all cols with larger rowStart\n\n        const cols = orderedCols.filter(c => !c.columnGroup && (c.rowStart || 1) <= rs);\n        vIndex = cols.indexOf(child);\n        this.childrenVisibleIndexes.push({\n          column: child,\n          index: vIndex\n        });\n      });\n    }\n\n  }\n\n  IgxColumnLayoutComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxColumnLayoutComponent_BaseFactory;\n    return function IgxColumnLayoutComponent_Factory(t) {\n      return (ɵIgxColumnLayoutComponent_BaseFactory || (ɵIgxColumnLayoutComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxColumnLayoutComponent)))(t || IgxColumnLayoutComponent);\n    };\n  }();\n\n  IgxColumnLayoutComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxColumnLayoutComponent,\n    selectors: [[\"igx-column-layout\"]],\n    inputs: {\n      hidden: \"hidden\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxColumnComponent,\n      useExisting: forwardRef(() => IgxColumnLayoutComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function IgxColumnLayoutComponent_Template(rf, ctx) {},\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxColumnLayoutComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridColumnModule = /*#__PURE__*/(() => {\n  class IgxGridColumnModule {}\n\n  IgxGridColumnModule.ɵfac = function IgxGridColumnModule_Factory(t) {\n    return new (t || IgxGridColumnModule)();\n  };\n\n  IgxGridColumnModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxGridColumnModule\n  });\n  IgxGridColumnModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return IgxGridColumnModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxColumnMovingModule = /*#__PURE__*/(() => {\n  class IgxColumnMovingModule {}\n\n  IgxColumnMovingModule.ɵfac = function IgxColumnMovingModule_Factory(t) {\n    return new (t || IgxColumnMovingModule)();\n  };\n\n  IgxColumnMovingModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxColumnMovingModule\n  });\n  IgxColumnMovingModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return IgxColumnMovingModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridPipesModule = /*#__PURE__*/(() => {\n  class IgxGridPipesModule {}\n\n  IgxGridPipesModule.ɵfac = function IgxGridPipesModule_Factory(t) {\n    return new (t || IgxGridPipesModule)();\n  };\n\n  IgxGridPipesModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxGridPipesModule\n  });\n  IgxGridPipesModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return IgxGridPipesModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridFilteringModule = /*#__PURE__*/(() => {\n  class IgxGridFilteringModule {}\n\n  IgxGridFilteringModule.ɵfac = function IgxGridFilteringModule_Factory(t) {\n    return new (t || IgxGridFilteringModule)();\n  };\n\n  IgxGridFilteringModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxGridFilteringModule\n  });\n  IgxGridFilteringModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[IgxGridSharedModules, IgxGridPipesModule]]\n  });\n  return IgxGridFilteringModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n * @internal\n */\n\n\nlet IgxPivotColumnResizingService = /*#__PURE__*/(() => {\n  class IgxPivotColumnResizingService extends IgxColumnResizingService {\n    /**\n     * @hidden\n     */\n    getColumnHeaderRenderedWidth() {\n      return this.rowHeaderGroup.header.nativeElement.getBoundingClientRect().width;\n    }\n\n    _handlePixelResize(diff, column) {\n      const rowDim = this.rowHeaderGroup.parent.rootDimension;\n      if (!rowDim) return;\n      const currentColWidth = parseFloat(column.width);\n      const colMinWidth = column.minWidthPx;\n      const colMaxWidth = column.maxWidthPx;\n      let newWidth = currentColWidth;\n\n      if (currentColWidth + diff < colMinWidth) {\n        newWidth = colMinWidth;\n      } else if (colMaxWidth && currentColWidth + diff > colMaxWidth) {\n        newWidth = colMaxWidth;\n      } else {\n        newWidth = currentColWidth + diff;\n      }\n\n      this.rowHeaderGroup.grid.resizeRowDimensionPixels(rowDim, newWidth);\n    }\n\n    _handlePercentageResize(diff, column) {}\n\n  }\n\n  IgxPivotColumnResizingService.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxPivotColumnResizingService_BaseFactory;\n    return function IgxPivotColumnResizingService_Factory(t) {\n      return (ɵIgxPivotColumnResizingService_BaseFactory || (ɵIgxPivotColumnResizingService_BaseFactory = i0.ɵɵgetInheritedFactory(IgxPivotColumnResizingService)))(t || IgxPivotColumnResizingService);\n    };\n  }();\n\n  IgxPivotColumnResizingService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxPivotColumnResizingService,\n    factory: IgxPivotColumnResizingService.ɵfac\n  });\n  return IgxPivotColumnResizingService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n * @internal\n */\n\n\nlet IgxPivotResizeHandleDirective = /*#__PURE__*/(() => {\n  class IgxPivotResizeHandleDirective extends IgxResizeHandleDirective {\n    constructor(zone, element, colResizingService) {\n      super(zone, element, colResizingService);\n      this.zone = zone;\n      this.element = element;\n      this.colResizingService = colResizingService;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set pivotColumn(value) {\n      this.column = value;\n    }\n\n    get pivotColumn() {\n      return this.column;\n    }\n    /**\n     * @hidden\n     */\n\n\n    onDoubleClick() {\n      this._dblClick = true;\n      this.initResizeService();\n      this.rowHeaderGroup.grid.autoSizeRowDimension(this.rowHeaderGroup.parent.rootDimension);\n    }\n    /**\n     * @hidden\n     */\n\n\n    initResizeService(event = null) {\n      super.initResizeService(event);\n      this.colResizingService.rowHeaderGroup = this.rowHeaderGroup;\n    }\n\n  }\n\n  IgxPivotResizeHandleDirective.ɵfac = function IgxPivotResizeHandleDirective_Factory(t) {\n    return new (t || IgxPivotResizeHandleDirective)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(IgxPivotColumnResizingService));\n  };\n\n  IgxPivotResizeHandleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxPivotResizeHandleDirective,\n    selectors: [[\"\", \"igxPivotResizeHandle\", \"\"]],\n    inputs: {\n      pivotColumn: [\"igxPivotResizeHandle\", \"pivotColumn\"],\n      rowHeaderGroup: [\"igxPivotResizeHandleHeader\", \"rowHeaderGroup\"]\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return IgxPivotResizeHandleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxPivotGridColumnResizerComponent = /*#__PURE__*/(() => {\n  class IgxPivotGridColumnResizerComponent extends IgxGridColumnResizerComponent {\n    constructor(colResizingService) {\n      super(colResizingService);\n      this.colResizingService = colResizingService;\n    }\n\n  }\n\n  IgxPivotGridColumnResizerComponent.ɵfac = function IgxPivotGridColumnResizerComponent_Factory(t) {\n    return new (t || IgxPivotGridColumnResizerComponent)(i0.ɵɵdirectiveInject(IgxPivotColumnResizingService));\n  };\n\n  IgxPivotGridColumnResizerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxPivotGridColumnResizerComponent,\n    selectors: [[\"igx-pivot-grid-column-resizer\"]],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 1,\n    vars: 7,\n    consts: [[\"igxResizer\", \"\", 1, \"igx-grid-th__resize-line\", 3, \"restrictHResizeMax\", \"restrictHResizeMin\", \"restrictResizerTop\", \"resizeEnd\"]],\n    template: function IgxPivotGridColumnResizerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵlistener(\"resizeEnd\", function IgxPivotGridColumnResizerComponent_Template_div_resizeEnd_0_listener($event) {\n          return ctx.colResizingService.resizeColumn($event);\n        });\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"left\", -99999, \"px\")(\"height\", ctx.colResizingService.resizerHeight, \"px\");\n        i0.ɵɵproperty(\"restrictHResizeMax\", ctx.colResizingService.restrictResizeMax)(\"restrictHResizeMin\", ctx.colResizingService.restrictResizeMin)(\"restrictResizerTop\", ctx.restrictResizerTop);\n      }\n    },\n    directives: [IgxColumnResizerDirective],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxPivotGridColumnResizerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridResizingModule = /*#__PURE__*/(() => {\n  class IgxGridResizingModule {}\n\n  IgxGridResizingModule.ɵfac = function IgxGridResizingModule_Factory(t) {\n    return new (t || IgxGridResizingModule)();\n  };\n\n  IgxGridResizingModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxGridResizingModule\n  });\n  IgxGridResizingModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IgxColumnResizingService, IgxPivotColumnResizingService],\n    imports: [[CommonModule]]\n  });\n  return IgxGridResizingModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridHeadersModule = /*#__PURE__*/(() => {\n  class IgxGridHeadersModule {}\n\n  IgxGridHeadersModule.ɵfac = function IgxGridHeadersModule_Factory(t) {\n    return new (t || IgxGridHeadersModule)();\n  };\n\n  IgxGridHeadersModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxGridHeadersModule\n  });\n  IgxGridHeadersModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[IgxGridSharedModules, IgxGridFilteringModule, IgxColumnMovingModule, IgxGridResizingModule, IgxGridPipesModule]]\n  });\n  return IgxGridHeadersModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxGridExcelStyleFilteringModule = /*#__PURE__*/(() => {\n  class IgxGridExcelStyleFilteringModule {}\n\n  IgxGridExcelStyleFilteringModule.ɵfac = function IgxGridExcelStyleFilteringModule_Factory(t) {\n    return new (t || IgxGridExcelStyleFilteringModule)();\n  };\n\n  IgxGridExcelStyleFilteringModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxGridExcelStyleFilteringModule\n  });\n  IgxGridExcelStyleFilteringModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [IgxSelectionAPIService],\n    imports: [[CommonModule, FormsModule, IgxGridPipesModule, IgxButtonModule, IgxButtonGroupModule, IgxDatePickerModule, IgxTimePickerModule, IgxIconModule, IgxRippleModule, IgxInputGroupModule, IgxDropDownModule, IgxForOfModule, IgxCheckboxModule, IgxFilterModule, IgxToggleModule, IgxListModule, IgxProgressBarModule, IgxSelectModule, IgxFocusModule, IgxDateTimeEditorModule, IgxTreeModule]]\n  });\n  return IgxGridExcelStyleFilteringModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridFooterComponent = /*#__PURE__*/(() => {\n  class IgxGridFooterComponent {}\n\n  IgxGridFooterComponent.ɵfac = function IgxGridFooterComponent_Factory(t) {\n    return new (t || IgxGridFooterComponent)();\n  };\n\n  IgxGridFooterComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxGridFooterComponent,\n    selectors: [[\"igx-grid-footer\"]],\n    ngContentSelectors: _c8,\n    decls: 1,\n    vars: 0,\n    template: function IgxGridFooterComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxGridFooterComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxPaginatorDirective = /*#__PURE__*/(() => {\n  class IgxPaginatorDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxPaginatorDirective.ɵfac = function IgxPaginatorDirective_Factory(t) {\n    return new (t || IgxPaginatorDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxPaginatorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxPaginatorDirective,\n    selectors: [[\"\", \"igxPaginator\", \"\"]]\n  });\n  return IgxPaginatorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxPaginatorModule = /*#__PURE__*/(() => {\n  class IgxPaginatorModule {}\n\n  IgxPaginatorModule.ɵfac = function IgxPaginatorModule_Factory(t) {\n    return new (t || IgxPaginatorModule)();\n  };\n\n  IgxPaginatorModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxPaginatorModule\n  });\n  IgxPaginatorModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, FormsModule, IgxButtonModule, IgxIconModule, IgxInputGroupModule, IgxRippleModule, IgxSelectModule]]\n  });\n  return IgxPaginatorModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridSelectionModule = /*#__PURE__*/(() => {\n  class IgxGridSelectionModule {}\n\n  IgxGridSelectionModule.ɵfac = function IgxGridSelectionModule_Factory(t) {\n    return new (t || IgxGridSelectionModule)();\n  };\n\n  IgxGridSelectionModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxGridSelectionModule\n  });\n  IgxGridSelectionModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return IgxGridSelectionModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridSummaryModule = /*#__PURE__*/(() => {\n  class IgxGridSummaryModule {}\n\n  IgxGridSummaryModule.ɵfac = function IgxGridSummaryModule_Factory(t) {\n    return new (t || IgxGridSummaryModule)();\n  };\n\n  IgxGridSummaryModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxGridSummaryModule\n  });\n  IgxGridSummaryModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[IgxGridPipesModule, IgxGridSharedModules]]\n  });\n  return IgxGridSummaryModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxColumnActionsBaseDirective = /*#__PURE__*/(() => {\n  class IgxColumnActionsBaseDirective {}\n\n  IgxColumnActionsBaseDirective.ɵfac = function IgxColumnActionsBaseDirective_Factory(t) {\n    return new (t || IgxColumnActionsBaseDirective)();\n  };\n\n  IgxColumnActionsBaseDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxColumnActionsBaseDirective\n  });\n  return IgxColumnActionsBaseDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$8 = 0;\n/**\n * Providing reference to `IgxColumnActionsComponent`:\n * ```typescript\n *  @ViewChild('columnActions', { read: IgxColumnActionsComponent })\n *  public columnActions: IgxColumnActionsComponent;\n */\n\nlet IgxColumnActionsComponent = /*#__PURE__*/(() => {\n  class IgxColumnActionsComponent {\n    constructor(differs) {\n      this.differs = differs;\n      /**\n       * Gets/sets the indentation of columns in the column list based on their hierarchy level.\n       *\n       * @example\n       * ```\n       * <igx-column-actions [indentation]=\"15\"></igx-column-actions>\n       * ```\n       */\n\n      this.indentation = 30;\n      /**\n       * Sets/Gets the css class selector.\n       * By default the value of the `class` attribute is `\"igx-column-actions\"`.\n       * ```typescript\n       * let cssCLass =  this.columnHidingUI.cssClass;\n       * ```\n       * ```typescript\n       * this.columnHidingUI.cssClass = 'column-chooser';\n       * ```\n       */\n\n      this.cssClass = 'igx-column-actions';\n      /**\n       * Gets/sets the max height of the columns area.\n       *\n       * @remarks\n       * The default max height is 100%.\n       * @example\n       * ```html\n       * <igx-column-actions [columnsAreaMaxHeight]=\"200px\"></igx-column-actions>\n       * ```\n       */\n\n      this.columnsAreaMaxHeight = '100%';\n      /**\n       * Shows/hides the columns filtering input from the UI.\n       *\n       * @example\n       * ```html\n       *  <igx-column-actions [hideFilter]=\"true\"></igx-column-actions>\n       * ```\n       */\n\n      this.hideFilter = false;\n      /**\n       * Gets/sets the title of the column actions component.\n       *\n       * @example\n       * ```html\n       * <igx-column-actions [title]=\"'Pin Columns'\"></igx-column-actions>\n       * ```\n       */\n\n      this.title = '';\n      /**\n       * An event that is emitted after a column's checked state is changed.\n       * Provides references to the `column` and the `checked` properties as event arguments.\n       * ```html\n       *  <igx-column-actions (columnToggled)=\"columnToggled($event)\"></igx-column-actions>\n       * ```\n       */\n\n      this.columnToggled = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.actionableColumns = [];\n      /**\n       * @hidden @internal\n       */\n\n      this.filteredColumns = [];\n      /**\n       * @hidden @internal\n       */\n\n      this.pipeTrigger = 0;\n      this._differ = null;\n      /**\n       * @hidden @internal\n       */\n\n      this._filterColumnsPrompt = '';\n      /**\n       * @hidden @internal\n       */\n\n      this._filterCriteria = '';\n      /**\n       * @hidden @internal\n       */\n\n      this._columnDisplayOrder = ColumnDisplayOrder.DisplayOrder;\n      /**\n       * @hidden @internal\n       */\n\n      this._id = `igx-column-actions-${NEXT_ID$8++}`;\n      /**\n       * @hidden @internal\n       */\n\n      this.trackChanges = (index, col) => col.field + '_' + this.actionsDirective.actionEnabledColumnsFilter(col, index, []);\n\n      this._differ = this.differs.find([]).create(this.trackChanges);\n    }\n    /**\n     * Gets the prompt that is displayed in the filter input.\n     *\n     * @example\n     * ```typescript\n     * let filterColumnsPrompt = this.columnActions.filterColumnsPrompt;\n     * ```\n     */\n\n\n    get filterColumnsPrompt() {\n      return this._filterColumnsPrompt;\n    }\n    /**\n     * Sets the prompt that is displayed in the filter input.\n     *\n     * @example\n     * ```html\n     * <igx-column-actions [filterColumnsPrompt]=\"'Type here to search'\"></igx-column-actions>\n     * ```\n     */\n\n\n    set filterColumnsPrompt(value) {\n      this._filterColumnsPrompt = value || '';\n    }\n    /**\n     * Gets the value which filters the columns list.\n     *\n     * @example\n     * ```typescript\n     * let filterCriteria =  this.columnActions.filterCriteria;\n     * ```\n     */\n\n\n    get filterCriteria() {\n      return this._filterCriteria;\n    }\n    /**\n     * Sets the value which filters the columns list.\n     *\n     * @example\n     * ```html\n     *  <igx-column-actions [filterCriteria]=\"'ID'\"></igx-column-actions>\n     * ```\n     */\n\n\n    set filterCriteria(value) {\n      value = value || '';\n\n      if (value !== this._filterCriteria) {\n        this._filterCriteria = value;\n        this.pipeTrigger++;\n      }\n    }\n    /**\n     * Gets the display order of the columns.\n     *\n     * @example\n     * ```typescript\n     * let columnDisplayOrder = this.columnActions.columnDisplayOrder;\n     * ```\n     */\n\n\n    get columnDisplayOrder() {\n      return this._columnDisplayOrder;\n    }\n    /**\n     * Sets the display order of the columns.\n     *\n     * @example\n     * ```typescript\n     * this.columnActions.columnDisplayOrder = ColumnDisplayOrder.Alphabetical;\n     * ```\n     */\n\n\n    set columnDisplayOrder(value) {\n      if (value && value !== this._columnDisplayOrder) {\n        this._columnDisplayOrder = value;\n        this.pipeTrigger++;\n      }\n    }\n    /**\n     * Gets the text of the button that unchecks all columns.\n     *\n     * @remarks\n     * If unset it is obtained from the IgxColumnActionsBased derived directive applied.\n     * @example\n     * ```typescript\n     * let uncheckAllText = this.columnActions.uncheckAllText;\n     * ```\n     */\n\n\n    get uncheckAllText() {\n      return this._uncheckAllText || this.actionsDirective.uncheckAllLabel;\n    }\n    /**\n     * Sets the text of the button that unchecks all columns.\n     *\n     * @example\n     * ```html\n     * <igx-column-actions [uncheckAllText]=\"'Show All'\"></igx-column-actions>\n     * ```\n     */\n\n\n    set uncheckAllText(value) {\n      this._uncheckAllText = value;\n    }\n    /**\n     * Gets the text of the button that checks all columns.\n     *\n     * @remarks\n     * If unset it is obtained from the IgxColumnActionsBased derived directive applied.\n     * @example\n     * ```typescript\n     * let uncheckAllText = this.columnActions.uncheckAllText;\n     * ```\n     */\n\n\n    get checkAllText() {\n      return this._checkAllText || this.actionsDirective.checkAllLabel;\n    }\n    /**\n     * Sets the text of the button that checks all columns.\n     *\n     * @remarks\n     * If unset it is obtained from the IgxColumnActionsBased derived directive applied.\n     * @example\n     * ```html\n     * <igx-column-actions [checkAllText]=\"'Hide All'\"></igx-column-actions>\n     * ```\n     */\n\n\n    set checkAllText(value) {\n      this._checkAllText = value;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get checkAllDisabled() {\n      return this.actionsDirective.allUnchecked;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get uncheckAllDisabled() {\n      return this.actionsDirective.allChecked;\n    }\n    /**\n     * Gets/Sets the value of the `id` attribute.\n     *\n     * @remarks\n     * If not provided it will be automatically generated.\n     * @example\n     * ```html\n     * <igx-column-actions [id]=\"'igx-actions-1'\"></igx-column-actions>\n     * ```\n     */\n\n\n    get id() {\n      return this._id;\n    }\n\n    set id(value) {\n      this._id = value;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get titleID() {\n      return this.id + '_title';\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    ngDoCheck() {\n      var _a;\n\n      if (this._differ) {\n        const changes = this._differ.diff((_a = this.grid) === null || _a === void 0 ? void 0 : _a.columnList);\n\n        if (changes) {\n          this.pipeTrigger++;\n        }\n      }\n    }\n    /**\n     * Unchecks all columns and performs the appropriate action.\n     *\n     * @example\n     * ```typescript\n     * this.columnActions.uncheckAllColumns();\n     * ```\n     */\n\n\n    uncheckAllColumns() {\n      this.actionsDirective.uncheckAll();\n    }\n    /**\n     * Checks all columns and performs the appropriate action.\n     *\n     * @example\n     * ```typescript\n     * this.columnActions.checkAllColumns();\n     * ```\n     */\n\n\n    checkAllColumns() {\n      this.actionsDirective.checkAll();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    toggleColumn(column) {\n      this.actionsDirective.toggleColumn(column);\n      this.columnToggled.emit({\n        column: column,\n        checked: this.actionsDirective.columnChecked(column)\n      });\n    }\n\n  }\n\n  IgxColumnActionsComponent.ɵfac = function IgxColumnActionsComponent_Factory(t) {\n    return new (t || IgxColumnActionsComponent)(i0.ɵɵdirectiveInject(i0.IterableDiffers));\n  };\n\n  IgxColumnActionsComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxColumnActionsComponent,\n    selectors: [[\"igx-column-actions\"]],\n    viewQuery: function IgxColumnActionsComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxCheckboxComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.columnItems = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function IgxColumnActionsComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"class\", ctx.cssClass)(\"id\", ctx.id);\n      }\n    },\n    inputs: {\n      grid: \"grid\",\n      indentation: \"indentation\",\n      columnsAreaMaxHeight: \"columnsAreaMaxHeight\",\n      hideFilter: \"hideFilter\",\n      title: \"title\",\n      filterColumnsPrompt: \"filterColumnsPrompt\",\n      filterCriteria: \"filterCriteria\",\n      columnDisplayOrder: \"columnDisplayOrder\",\n      uncheckAllText: \"uncheckAllText\",\n      checkAllText: \"checkAllText\",\n      id: \"id\"\n    },\n    outputs: {\n      columnToggled: \"columnToggled\"\n    },\n    decls: 13,\n    vars: 21,\n    consts: [[1, \"igx-column-actions__header\"], [\"class\", \"igx-column-actions__header-title\", 4, \"ngIf\"], [\"class\", \"igx-column-actions__header-input\", 4, \"ngIf\"], [\"tabindex\", \"0\", 1, \"igx-column-actions__columns\"], [\"class\", \"igx-column-actions__columns-item\", 3, \"readonly\", \"checked\", \"margin-left\", \"click\", 4, \"ngFor\", \"ngForOf\"], [1, \"igx-column-actions__buttons\"], [\"igxButton\", \"\", \"igxRipple\", \"\", 3, \"disabled\", \"click\"], [1, \"igx-column-actions__header-title\"], [1, \"igx-column-actions__header-input\"], [\"igxInput\", \"\", \"type\", \"text\", \"autocomplete\", \"off\", 3, \"ngModel\", \"placeholder\", \"ngModelChange\"], [1, \"igx-column-actions__columns-item\", 3, \"readonly\", \"checked\", \"click\"]],\n    template: function IgxColumnActionsComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵtemplate(1, IgxColumnActionsComponent_h4_1_Template, 2, 2, \"h4\", 1);\n        i0.ɵɵtemplate(2, IgxColumnActionsComponent_igx_input_group_2_Template, 2, 3, \"igx-input-group\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"div\", 3);\n        i0.ɵɵtemplate(4, IgxColumnActionsComponent_igx_checkbox_4_Template, 2, 5, \"igx-checkbox\", 4);\n        i0.ɵɵpipe(5, \"sortActionColumns\");\n        i0.ɵɵpipe(6, \"filterActionColumns\");\n        i0.ɵɵpipe(7, \"columnActionEnabled\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(8, \"div\", 5)(9, \"button\", 6);\n        i0.ɵɵlistener(\"click\", function IgxColumnActionsComponent_Template_button_click_9_listener() {\n          return ctx.uncheckAllColumns();\n        });\n        i0.ɵɵtext(10);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(11, \"button\", 6);\n        i0.ɵɵlistener(\"click\", function IgxColumnActionsComponent_Template_button_click_11_listener() {\n          return ctx.checkAllColumns();\n        });\n        i0.ɵɵtext(12);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        let tmp_3_0;\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.title);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.hideFilter);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"max-height\", ctx.columnsAreaMaxHeight);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBind3(5, 9, i0.ɵɵpipeBind3(6, 13, i0.ɵɵpipeBind3(7, 17, (tmp_3_0 = ctx.grid) == null ? null : tmp_3_0._columns, ctx.actionsDirective.actionEnabledColumnsFilter, ctx.pipeTrigger), ctx.filterCriteria, ctx.pipeTrigger), ctx.columnDisplayOrder, ctx.pipeTrigger));\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"disabled\", ctx.uncheckAllDisabled);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx.uncheckAllText);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"disabled\", ctx.checkAllDisabled);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx.checkAllText);\n      }\n    },\n    directives: function () {\n      return [IgxInputGroupComponent, IgxCheckboxComponent, i4.NgIf, i12.DefaultValueAccessor, IgxInputDirective, i12.NgControlStatus, i12.NgModel, i4.NgForOf, IgxButtonDirective, IgxRippleDirective];\n    },\n    pipes: function () {\n      return [IgxSortActionColumnsPipe, IgxFilterActionColumnsPipe, IgxColumnActionEnabledPipe];\n    },\n    encapsulation: 2\n  });\n  return IgxColumnActionsComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxColumnActionEnabledPipe = /*#__PURE__*/(() => {\n  class IgxColumnActionEnabledPipe {\n    constructor(columnActions) {\n      this.columnActions = columnActions;\n    }\n\n    transform(collection, actionFilter, _pipeTrigger) {\n      if (!collection) {\n        return collection;\n      }\n\n      let copy = collection.slice(0);\n\n      if (copy.length && copy[0].grid.hasColumnLayouts) {\n        copy = copy.filter(c => c.columnLayout);\n      }\n\n      if (actionFilter) {\n        copy = copy.filter(actionFilter);\n      } // Preserve the actionable collection for use in the component\n\n\n      this.columnActions.actionableColumns = copy;\n      return copy;\n    }\n\n  }\n\n  IgxColumnActionEnabledPipe.ɵfac = function IgxColumnActionEnabledPipe_Factory(t) {\n    return new (t || IgxColumnActionEnabledPipe)(i0.ɵɵdirectiveInject(IgxColumnActionsComponent, 16));\n  };\n\n  IgxColumnActionEnabledPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"columnActionEnabled\",\n    type: IgxColumnActionEnabledPipe,\n    pure: true\n  });\n  return IgxColumnActionEnabledPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxFilterActionColumnsPipe = /*#__PURE__*/(() => {\n  class IgxFilterActionColumnsPipe {\n    constructor(columnActions) {\n      this.columnActions = columnActions;\n    }\n\n    transform(collection, filterCriteria, _pipeTrigger) {\n      if (!collection) {\n        return collection;\n      }\n\n      let copy = collection.slice(0);\n\n      if (filterCriteria && filterCriteria.length > 0) {\n        const filterFunc = c => {\n          var _a, _b;\n\n          const filterText = c.header || c.field;\n\n          if (!filterText) {\n            return false;\n          }\n\n          return filterText.toLocaleLowerCase().indexOf(filterCriteria.toLocaleLowerCase()) >= 0 || ((_b = (_a = c.children) === null || _a === void 0 ? void 0 : _a.some(filterFunc)) !== null && _b !== void 0 ? _b : false);\n        };\n\n        copy = collection.filter(filterFunc);\n      } // Preserve the filtered collection for use in the component\n\n\n      this.columnActions.filteredColumns = copy;\n      return copy;\n    }\n\n  }\n\n  IgxFilterActionColumnsPipe.ɵfac = function IgxFilterActionColumnsPipe_Factory(t) {\n    return new (t || IgxFilterActionColumnsPipe)(i0.ɵɵdirectiveInject(IgxColumnActionsComponent, 16));\n  };\n\n  IgxFilterActionColumnsPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"filterActionColumns\",\n    type: IgxFilterActionColumnsPipe,\n    pure: true\n  });\n  return IgxFilterActionColumnsPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxSortActionColumnsPipe = /*#__PURE__*/(() => {\n  class IgxSortActionColumnsPipe {\n    transform(collection, displayOrder, _pipeTrigger) {\n      if (displayOrder === ColumnDisplayOrder.Alphabetical) {\n        return collection.sort((a, b) => (a.header || a.field).localeCompare(b.header || b.field));\n      }\n\n      return collection;\n    }\n\n  }\n\n  IgxSortActionColumnsPipe.ɵfac = function IgxSortActionColumnsPipe_Factory(t) {\n    return new (t || IgxSortActionColumnsPipe)();\n  };\n\n  IgxSortActionColumnsPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"sortActionColumns\",\n    type: IgxSortActionColumnsPipe,\n    pure: true\n  });\n  return IgxSortActionColumnsPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxColumnHidingDirective = /*#__PURE__*/(() => {\n  class IgxColumnHidingDirective extends IgxColumnActionsBaseDirective {\n    constructor(columnActions) {\n      super();\n      this.columnActions = columnActions;\n      /**\n       * @hidden @internal\n       */\n\n      this.actionEnabledColumnsFilter = c => !c.disableHiding;\n\n      columnActions.actionsDirective = this;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get checkAllLabel() {\n      var _a, _b;\n\n      return (_b = (_a = this.columnActions.grid) === null || _a === void 0 ? void 0 : _a.resourceStrings.igx_grid_hiding_check_all_label) !== null && _b !== void 0 ? _b : 'Show All';\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get uncheckAllLabel() {\n      var _a, _b;\n\n      return (_b = (_a = this.columnActions.grid) === null || _a === void 0 ? void 0 : _a.resourceStrings.igx_grid_hiding_uncheck_all_label) !== null && _b !== void 0 ? _b : 'Hide All';\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    checkAll() {\n      this.columnActions.filteredColumns.forEach(c => c.toggleVisibility(false));\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    uncheckAll() {\n      this.columnActions.filteredColumns.forEach(c => c.toggleVisibility(true));\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    columnChecked(column) {\n      return !column.hidden;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    toggleColumn(column) {\n      column.toggleVisibility();\n    }\n\n    get allChecked() {\n      return this.columnActions.filteredColumns.every(col => !this.columnChecked(col));\n    }\n\n    get allUnchecked() {\n      return this.columnActions.filteredColumns.every(col => this.columnChecked(col));\n    }\n\n  }\n\n  IgxColumnHidingDirective.ɵfac = function IgxColumnHidingDirective_Factory(t) {\n    return new (t || IgxColumnHidingDirective)(i0.ɵɵdirectiveInject(IgxColumnActionsComponent));\n  };\n\n  IgxColumnHidingDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxColumnHidingDirective,\n    selectors: [[\"\", \"igxColumnHiding\", \"\"]],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return IgxColumnHidingDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxColumnPinningDirective = /*#__PURE__*/(() => {\n  class IgxColumnPinningDirective extends IgxColumnActionsBaseDirective {\n    constructor(columnActions) {\n      super();\n      this.columnActions = columnActions;\n      /**\n       * @hidden @internal\n       */\n\n      this.actionEnabledColumnsFilter = c => !c.disablePinning && !c.level;\n\n      columnActions.actionsDirective = this;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get checkAllLabel() {\n      var _a, _b;\n\n      return (_b = (_a = this.columnActions.grid) === null || _a === void 0 ? void 0 : _a.resourceStrings.igx_grid_pinning_check_all_label) !== null && _b !== void 0 ? _b : 'Pin All';\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get uncheckAllLabel() {\n      var _a, _b;\n\n      return (_b = (_a = this.columnActions.grid) === null || _a === void 0 ? void 0 : _a.resourceStrings.igx_grid_pinning_uncheck_all_label) !== null && _b !== void 0 ? _b : 'Unpin All';\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    checkAll() {\n      this.columnActions.filteredColumns.forEach(c => c.pinned = true);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    uncheckAll() {\n      this.columnActions.filteredColumns.forEach(c => c.pinned = false);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    columnChecked(column) {\n      return column.pinned;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    toggleColumn(column) {\n      column.pinned = !column.pinned;\n    }\n\n    get allUnchecked() {\n      return !this.columnActions.filteredColumns.some(col => !this.columnChecked(col));\n    }\n\n    get allChecked() {\n      return !this.columnActions.filteredColumns.some(col => this.columnChecked(col));\n    }\n\n  }\n\n  IgxColumnPinningDirective.ɵfac = function IgxColumnPinningDirective_Factory(t) {\n    return new (t || IgxColumnPinningDirective)(i0.ɵɵdirectiveInject(IgxColumnActionsComponent));\n  };\n\n  IgxColumnPinningDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxColumnPinningDirective,\n    selectors: [[\"\", \"igxColumnPinning\", \"\"]],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return IgxColumnPinningDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxColumnActionsModule = /*#__PURE__*/(() => {\n  class IgxColumnActionsModule {}\n\n  IgxColumnActionsModule.ɵfac = function IgxColumnActionsModule_Factory(t) {\n    return new (t || IgxColumnActionsModule)();\n  };\n\n  IgxColumnActionsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxColumnActionsModule\n  });\n  IgxColumnActionsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[IgxGridSharedModules, IgxGridPipesModule]]\n  });\n  return IgxColumnActionsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Base class for the pinning/hiding column and exporter actions.\n *\n * @hidden @internal\n */\n\n\nlet BaseToolbarDirective = /*#__PURE__*/(() => {\n  class BaseToolbarDirective {\n    constructor(toolbar) {\n      this.toolbar = toolbar;\n      /**\n       * Emits an event before the toggle container is opened.\n       */\n\n      this.opening = new EventEmitter();\n      /**\n       * Emits an event after the toggle container is opened.\n       */\n\n      this.opened = new EventEmitter();\n      /**\n       * Emits an event before the toggle container is closed.\n       */\n\n      this.closing = new EventEmitter();\n      /**\n       * Emits an event after the toggle container is closed.\n       */\n\n      this.closed = new EventEmitter();\n      /**\n       * Emits when after a column's checked state is changed\n       */\n\n      this.columnToggle = new EventEmitter();\n      this.$destroy = new Subject();\n      this._overlaySettings = {\n        positionStrategy: new ConnectedPositioningStrategy({\n          horizontalDirection: HorizontalAlignment.Left,\n          horizontalStartPoint: HorizontalAlignment.Right,\n          verticalDirection: VerticalAlignment.Bottom,\n          verticalStartPoint: VerticalAlignment.Bottom\n        }),\n        scrollStrategy: new AbsoluteScrollStrategy(),\n        modal: false,\n        closeOnEscape: true,\n        closeOnOutsideClick: true\n      };\n    }\n    /**\n     * Sets overlay settings\n     */\n\n\n    set overlaySettings(overlaySettings) {\n      this._overlaySettings = overlaySettings;\n    }\n    /**\n     * Returns overlay settings\n     */\n\n\n    get overlaySettings() {\n      return this._overlaySettings;\n    }\n    /**\n     * Returns the grid containing this component.\n     */\n\n\n    get grid() {\n      return this.toolbar.grid;\n    }\n\n    ngOnDestroy() {\n      this.$destroy.next();\n      this.$destroy.complete();\n    }\n    /** @hidden @internal */\n\n\n    toggle(anchorElement, toggleRef, actions) {\n      if (actions) {\n        this._setupListeners(toggleRef, actions);\n\n        const setHeight = () => {\n          var _a;\n\n          return actions.columnsAreaMaxHeight = actions.columnsAreaMaxHeight !== '100%' ? actions.columnsAreaMaxHeight : (_a = this.columnListHeight) !== null && _a !== void 0 ? _a : `${Math.max(this.grid.calcHeight * 0.5, 200)}px`;\n        };\n\n        toggleRef.opening.pipe(first$1()).subscribe(setHeight);\n      }\n\n      toggleRef.toggle(Object.assign(Object.assign({}, this.overlaySettings), {\n        target: anchorElement,\n        outlet: this.grid.outlet,\n        excludeFromOutsideClick: [anchorElement]\n      }));\n    }\n    /** @hidden @internal */\n\n\n    focusSearch(columnActions) {\n      var _a;\n\n      (_a = columnActions.querySelector('input')) === null || _a === void 0 ? void 0 : _a.focus();\n    }\n\n    _setupListeners(toggleRef, actions) {\n      if (actions) {\n        if (!this.$sub || this.$sub.closed) {\n          this.$sub = actions.columnToggled.subscribe(event => this.columnToggle.emit(event));\n        } else {\n          this.$sub.unsubscribe();\n        }\n      }\n      /** The if statement prevents emitting open and close events twice  */\n\n\n      if (toggleRef.collapsed) {\n        toggleRef.opening.pipe(first$1(), takeUntil(this.$destroy)).subscribe(event => this.opening.emit(event));\n        toggleRef.opened.pipe(first$1(), takeUntil(this.$destroy)).subscribe(event => this.opened.emit(event));\n      } else {\n        toggleRef.closing.pipe(first$1(), takeUntil(this.$destroy)).subscribe(event => this.closing.emit(event));\n        toggleRef.closed.pipe(first$1(), takeUntil(this.$destroy)).subscribe(event => this.closed.emit(event));\n      }\n    }\n\n  }\n\n  BaseToolbarDirective.ɵfac = function BaseToolbarDirective_Factory(t) {\n    return new (t || BaseToolbarDirective)(i0.ɵɵdirectiveInject(IgxToolbarToken));\n  };\n\n  BaseToolbarDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: BaseToolbarDirective,\n    inputs: {\n      columnListHeight: \"columnListHeight\",\n      title: \"title\",\n      prompt: \"prompt\",\n      overlaySettings: \"overlaySettings\"\n    },\n    outputs: {\n      opening: \"opening\",\n      opened: \"opened\",\n      closing: \"closing\",\n      closed: \"closed\",\n      columnToggle: \"columnToggle\"\n    }\n  });\n  return BaseToolbarDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden @internal\n * Base class for pinning/hiding column actions\n */\n\n\nlet BaseToolbarColumnActionsDirective = /*#__PURE__*/(() => {\n  class BaseToolbarColumnActionsDirective extends BaseToolbarDirective {\n    constructor() {\n      super(...arguments);\n      this.hideFilter = false;\n      this.filterCriteria = '';\n      this.columnDisplayOrder = ColumnDisplayOrder.DisplayOrder;\n      this.columnsAreaMaxHeight = '100%';\n      this.indentetion = 30;\n    }\n\n    checkAll() {\n      this.columnActionsUI.checkAllColumns();\n    }\n\n    uncheckAll() {\n      this.columnActionsUI.uncheckAllColumns();\n    }\n\n  }\n\n  BaseToolbarColumnActionsDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵBaseToolbarColumnActionsDirective_BaseFactory;\n    return function BaseToolbarColumnActionsDirective_Factory(t) {\n      return (ɵBaseToolbarColumnActionsDirective_BaseFactory || (ɵBaseToolbarColumnActionsDirective_BaseFactory = i0.ɵɵgetInheritedFactory(BaseToolbarColumnActionsDirective)))(t || BaseToolbarColumnActionsDirective);\n    };\n  }();\n\n  BaseToolbarColumnActionsDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: BaseToolbarColumnActionsDirective,\n    inputs: {\n      hideFilter: \"hideFilter\",\n      filterCriteria: \"filterCriteria\",\n      columnDisplayOrder: \"columnDisplayOrder\",\n      columnsAreaMaxHeight: \"columnsAreaMaxHeight\",\n      uncheckAllText: \"uncheckAllText\",\n      checkAllText: \"checkAllText\",\n      indentetion: \"indentetion\",\n      buttonText: \"buttonText\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return BaseToolbarColumnActionsDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Provides a pre-configured exporter component for the grid.\n *\n * @remarks\n * This component still needs the actual exporter service(s) provided in the DI chain\n * in order to export something.\n *\n * @igxModule IgxGridToolbarModule\n * @igxParent IgxGridToolbarComponent\n *\n */\n\n\nlet IgxGridToolbarExporterComponent = /*#__PURE__*/(() => {\n  class IgxGridToolbarExporterComponent extends BaseToolbarDirective {\n    constructor(toolbar, excelExporter, csvExporter) {\n      super(toolbar);\n      this.toolbar = toolbar;\n      this.excelExporter = excelExporter;\n      this.csvExporter = csvExporter;\n      /**\n       * Show entry for CSV export.\n       */\n\n      this.exportCSV = true;\n      /**\n       * Show entry for Excel export.\n       */\n\n      this.exportExcel = true;\n      /**\n       * The name for the exported file.\n       */\n\n      this.filename = 'ExportedData';\n      /**\n       * Emitted when starting an export operation. Re-emitted additionally\n       * by the grid itself.\n       */\n\n      this.exportStarted = new EventEmitter();\n      /**\n       * Emitted on successful ending of an export operation.\n       */\n\n      this.exportEnded = new EventEmitter();\n      /**\n       * Indicates whether there is an export in progress.\n       */\n\n      this.isExporting = false;\n    }\n\n    export(type, toggleRef) {\n      let options;\n      let exporter;\n      toggleRef === null || toggleRef === void 0 ? void 0 : toggleRef.close();\n\n      switch (type) {\n        case 'csv':\n          options = new IgxCsvExporterOptions(this.filename, CsvFileTypes.CSV);\n          exporter = this.csvExporter;\n          break;\n\n        case 'excel':\n          options = new IgxExcelExporterOptions(this.filename);\n          exporter = this.excelExporter;\n      }\n\n      const args = {\n        exporter,\n        options,\n        grid: this.grid,\n        cancel: false\n      };\n      this.exportStarted.emit(args);\n      this.grid.toolbarExporting.emit(args);\n      this.isExporting = true;\n      this.toolbar.showProgress = true;\n\n      if (args.cancel) {\n        return;\n      }\n\n      exporter.exportEnded.pipe(first$1()).subscribe(() => {\n        this.exportEnded.emit();\n        this.isExporting = false;\n        this.toolbar.showProgress = false;\n      });\n      exporter.export(this.grid, options);\n    }\n\n  }\n\n  IgxGridToolbarExporterComponent.ɵfac = function IgxGridToolbarExporterComponent_Factory(t) {\n    return new (t || IgxGridToolbarExporterComponent)(i0.ɵɵdirectiveInject(IgxToolbarToken), i0.ɵɵdirectiveInject(IgxExcelExporterService), i0.ɵɵdirectiveInject(IgxCsvExporterService));\n  };\n\n  IgxGridToolbarExporterComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxGridToolbarExporterComponent,\n    selectors: [[\"igx-grid-toolbar-exporter\"]],\n    contentQueries: function IgxGridToolbarExporterComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxExcelTextDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, IgxCSVTextDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.hasExcelAttr = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.hasCSVAttr = _t.first);\n      }\n    },\n    inputs: {\n      exportCSV: \"exportCSV\",\n      exportExcel: \"exportExcel\",\n      filename: \"filename\"\n    },\n    outputs: {\n      exportStarted: \"exportStarted\",\n      exportEnded: \"exportEnded\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c231,\n    decls: 15,\n    vars: 6,\n    consts: [[\"igxButton\", \"outlined\", \"type\", \"button\", \"igxRipple\", \"\", 3, \"title\", \"disabled\", \"displayDensity\", \"click\"], [\"btn\", \"\"], [\"ref\", \"\"], [4, \"ngIf\"], [\"id\", \"btnExport\", 1, \"igx-grid-toolbar__dropdown\"], [\"igxToggle\", \"\", 1, \"igx-grid-toolbar__dd-list\"], [\"toggleRef\", \"toggle\"], [\"id\", \"btnExportExcel\", \"class\", \"igx-grid-toolbar__dd-list-items\", \"igxRipple\", \"\", 3, \"click\", 4, \"ngIf\"], [\"id\", \"btnExportCsv\", \"class\", \"igx-grid-toolbar__dd-list-items\", \"igxRipple\", \"\", 3, \"click\", 4, \"ngIf\"], [\"id\", \"btnExportExcel\", \"igxRipple\", \"\", 1, \"igx-grid-toolbar__dd-list-items\", 3, \"click\"], [\"btnExportExcel\", \"\"], [\"excel\", \"\"], [4, \"ngTemplateOutlet\"], [\"id\", \"btnExportCsv\", \"igxRipple\", \"\", 1, \"igx-grid-toolbar__dd-list-items\", 3, \"click\"], [\"btnExportCsv\", \"\"], [\"csv\", \"\"]],\n    template: function IgxGridToolbarExporterComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        const _r20 = i0.ɵɵgetCurrentView();\n\n        i0.ɵɵprojectionDef(_c230);\n        i0.ɵɵelementStart(0, \"button\", 0, 1);\n        i0.ɵɵlistener(\"click\", function IgxGridToolbarExporterComponent_Template_button_click_0_listener() {\n          i0.ɵɵrestoreView(_r20);\n\n          const _r0 = i0.ɵɵreference(1);\n\n          const _r3 = i0.ɵɵreference(12);\n\n          return ctx.toggle(_r0, _r3);\n        });\n        i0.ɵɵelementStart(2, \"igx-icon\");\n        i0.ɵɵtext(3, \"import_export\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(4, \"span\", null, 2);\n        i0.ɵɵprojection(6);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(7, IgxGridToolbarExporterComponent_span_7_Template, 2, 1, \"span\", 3);\n        i0.ɵɵelementStart(8, \"igx-icon\");\n        i0.ɵɵtext(9, \"arrow_drop_down\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(10, \"div\", 4)(11, \"ul\", 5, 6);\n        i0.ɵɵtemplate(13, IgxGridToolbarExporterComponent_li_13_Template, 6, 2, \"li\", 7);\n        i0.ɵɵtemplate(14, IgxGridToolbarExporterComponent_li_14_Template, 6, 2, \"li\", 8);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        const _r1 = i0.ɵɵreference(5);\n\n        i0.ɵɵproperty(\"title\", ctx.grid == null ? null : ctx.grid.resourceStrings.igx_grid_toolbar_exporter_button_tooltip)(\"disabled\", ctx.isExporting)(\"displayDensity\", ctx.grid.displayDensity);\n        i0.ɵɵadvance(7);\n        i0.ɵɵproperty(\"ngIf\", !_r1.childNodes.length);\n        i0.ɵɵadvance(6);\n        i0.ɵɵproperty(\"ngIf\", ctx.exportExcel);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.exportCSV);\n      }\n    },\n    directives: [IgxIconComponent, IgxButtonDirective, IgxRippleDirective, i4.NgIf, IgxToggleDirective, IgxExcelTextDirective, i4.NgTemplateOutlet, IgxCSVTextDirective],\n    encapsulation: 2\n  });\n  return IgxGridToolbarExporterComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Provides a pre-configured column hiding component for the grid.\n *\n *\n * @igxModule IgxGridToolbarModule\n * @igxParent IgxGridToolbarComponent\n *\n * @example\n * ```html\n *  <igx-grid-toolbar-hiding></igx-grid-toolbar-hiding>\n * ```\n */\n\n\nlet IgxGridToolbarHidingComponent = /*#__PURE__*/(() => {\n  class IgxGridToolbarHidingComponent extends BaseToolbarColumnActionsDirective {\n    set content(content) {\n      this.columnActionsUI = content;\n    }\n\n  }\n\n  IgxGridToolbarHidingComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxGridToolbarHidingComponent_BaseFactory;\n    return function IgxGridToolbarHidingComponent_Factory(t) {\n      return (ɵIgxGridToolbarHidingComponent_BaseFactory || (ɵIgxGridToolbarHidingComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxGridToolbarHidingComponent)))(t || IgxGridToolbarHidingComponent);\n    };\n  }();\n\n  IgxGridToolbarHidingComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxGridToolbarHidingComponent,\n    selectors: [[\"igx-grid-toolbar-hiding\"]],\n    viewQuery: function IgxGridToolbarHidingComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxColumnHidingDirective, 5, IgxColumnActionsComponent);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.content = _t.first);\n      }\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 2,\n    vars: 3,\n    consts: [[4, \"ngIf\"], [\"igxButton\", \"outlined\", \"type\", \"button\", \"name\", \"btnColumnHiding\", 3, \"title\", \"displayDensity\", \"click\"], [\"btn\", \"\"], [\"igxColumnHiding\", \"\", \"igxToggle\", \"\", 3, \"grid\", \"title\", \"filterColumnsPrompt\", \"hideFilter\", \"filterCriteria\", \"columnDisplayOrder\", \"columnsAreaMaxHeight\", \"uncheckAllText\", \"checkAllText\", \"indentation\", \"opened\"], [\"actions\", \"\", \"ref\", \"toggle\"]],\n    template: function IgxGridToolbarHidingComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxGridToolbarHidingComponent_ng_container_0_Template, 12, 15, \"ng-container\", 0);\n        i0.ɵɵpipe(1, \"async\");\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", i0.ɵɵpipeBind1(1, 1, ctx.grid.rendered$));\n      }\n    },\n    directives: [IgxIconComponent, IgxColumnActionsComponent, i4.NgIf, IgxButtonDirective, IgxColumnHidingDirective, IgxToggleDirective],\n    pipes: [i4.AsyncPipe],\n    encapsulation: 2\n  });\n  return IgxGridToolbarHidingComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Provides a pre-configured column pinning component for the grid.\n *\n *\n * @igxModule IgxGridToolbarModule\n * @igxParent IgxGridToolbarComponent\n *\n * @example\n * ```html\n *  <igx-grid-toolbar-pinning></igx-grid-toolbar-pinning>\n * ```\n */\n\n\nlet IgxGridToolbarPinningComponent = /*#__PURE__*/(() => {\n  class IgxGridToolbarPinningComponent extends BaseToolbarColumnActionsDirective {\n    set content(content) {\n      this.columnActionsUI = content;\n    }\n\n  }\n\n  IgxGridToolbarPinningComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxGridToolbarPinningComponent_BaseFactory;\n    return function IgxGridToolbarPinningComponent_Factory(t) {\n      return (ɵIgxGridToolbarPinningComponent_BaseFactory || (ɵIgxGridToolbarPinningComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxGridToolbarPinningComponent)))(t || IgxGridToolbarPinningComponent);\n    };\n  }();\n\n  IgxGridToolbarPinningComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxGridToolbarPinningComponent,\n    selectors: [[\"igx-grid-toolbar-pinning\"]],\n    viewQuery: function IgxGridToolbarPinningComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxColumnPinningDirective, 5, IgxColumnActionsComponent);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.content = _t.first);\n      }\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 2,\n    vars: 3,\n    consts: [[4, \"ngIf\"], [\"igxButton\", \"outlined\", \"type\", \"button\", \"name\", \"btnColumnPinning\", 3, \"title\", \"displayDensity\", \"click\"], [\"btn\", \"\"], [\"family\", \"imx-icons\", 3, \"name\"], [\"igxColumnPinning\", \"\", \"igxToggle\", \"\", 3, \"grid\", \"title\", \"filterColumnsPrompt\", \"hideFilter\", \"filterCriteria\", \"columnDisplayOrder\", \"columnsAreaMaxHeight\", \"uncheckAllText\", \"checkAllText\", \"indentation\", \"opened\"], [\"actions\", \"\", \"ref\", \"toggle\"]],\n    template: function IgxGridToolbarPinningComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxGridToolbarPinningComponent_ng_container_0_Template, 11, 15, \"ng-container\", 0);\n        i0.ɵɵpipe(1, \"async\");\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", i0.ɵɵpipeBind1(1, 1, ctx.grid.rendered$));\n      }\n    },\n    directives: [IgxIconComponent, IgxColumnActionsComponent, i4.NgIf, IgxButtonDirective, IgxColumnPinningDirective, IgxToggleDirective],\n    pipes: [i4.AsyncPipe],\n    encapsulation: 2\n  });\n  return IgxGridToolbarPinningComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxGridToolbarModule = /*#__PURE__*/(() => {\n  class IgxGridToolbarModule {}\n\n  IgxGridToolbarModule.ɵfac = function IgxGridToolbarModule_Factory(t) {\n    return new (t || IgxGridToolbarModule)();\n  };\n\n  IgxGridToolbarModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxGridToolbarModule\n  });\n  IgxGridToolbarModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[IgxColumnActionsModule, IgxGridSharedModules]]\n  });\n  return IgxGridToolbarModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxGridCommonModule = /*#__PURE__*/(() => {\n  class IgxGridCommonModule {}\n\n  IgxGridCommonModule.ɵfac = function IgxGridCommonModule_Factory(t) {\n    return new (t || IgxGridCommonModule)();\n  };\n\n  IgxGridCommonModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxGridCommonModule\n  });\n  IgxGridCommonModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[IgxGridColumnModule, IgxGridHeadersModule, IgxColumnMovingModule, IgxGridResizingModule, IgxGridSelectionModule, IgxGridSummaryModule, IgxGridToolbarModule, IgxColumnActionsModule, IgxGridPipesModule, IgxGridFilteringModule, IgxGridExcelStyleFilteringModule, IgxRowDragModule, IgxPaginatorModule, IgxGridSharedModules, IgxChipsModule], IgxColumnActionsModule, IgxGridColumnModule, IgxGridHeadersModule, IgxGridPipesModule, IgxGridFilteringModule, IgxGridExcelStyleFilteringModule, IgxRowDragModule, IgxPaginatorModule, IgxGridResizingModule, IgxColumnMovingModule, IgxGridSelectionModule, IgxGridSummaryModule, IgxGridToolbarModule, IgxGridSharedModules]\n  });\n  return IgxGridCommonModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * An internal component representing the group-by drop area for the igx-grid component.\n *\n * @hidden @internal\n */\n\n\nlet IgxTreeGridGroupByAreaComponent = /*#__PURE__*/(() => {\n  class IgxTreeGridGroupByAreaComponent extends IgxGroupByAreaDirective {\n    constructor(differs, ref, platform) {\n      super(ref, platform);\n      this.differs = differs;\n      this._hideGroupedColumns = false;\n      this.destroy$ = new Subject();\n    }\n\n    get hideGroupedColumns() {\n      return this._hideGroupedColumns;\n    }\n\n    set hideGroupedColumns(value) {\n      if (this.grid.columnList && this.expressions) {\n        this.setColumnsVisibility(value);\n      }\n\n      this._hideGroupedColumns = value;\n    }\n\n    ngAfterContentInit() {\n      if (this.grid.columnList && this.expressions) {\n        this.groupingDiffer = this.differs.find(this.expressions).create();\n        this.updateColumnsVisibility();\n      }\n\n      this.grid.sortingExpressionsChange.pipe(takeUntil(this.destroy$)).subscribe(sortingExpressions => {\n        if (!this.expressions || !this.expressions.length) {\n          return;\n        }\n\n        let changed = false;\n        sortingExpressions.forEach(sortExpr => {\n          const fieldName = sortExpr.fieldName;\n          const groupingExpr = this.expressions.find(ex => ex.fieldName === fieldName);\n\n          if (groupingExpr && groupingExpr.dir !== sortExpr.dir) {\n            groupingExpr.dir = sortExpr.dir;\n            changed = true;\n          }\n        });\n\n        if (changed) {\n          this.expressions = [...this.expressions];\n        }\n      });\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next(true);\n      this.destroy$.complete();\n    }\n\n    handleReorder(event) {\n      const {\n        chipsArray,\n        originalEvent\n      } = event;\n      const newExpressions = this.getReorderedExpressions(chipsArray);\n      this.chipExpressions = newExpressions; // When reordered using keyboard navigation, we don't have `onMoveEnd` event.\n\n      if (originalEvent instanceof KeyboardEvent) {\n        this.expressions = newExpressions;\n      }\n    }\n\n    handleMoveEnd() {\n      this.expressions = this.chipExpressions;\n    }\n\n    groupBy(expression) {\n      this.expressions.push(expression);\n      this.expressions = [...this.expressions];\n    }\n\n    clearGrouping(name) {\n      this.expressions = this.expressions.filter(item => item.fieldName !== name);\n      this.grid.sortingExpressions = this.grid.sortingExpressions.filter(item => item.fieldName !== name);\n      this.grid.notifyChanges(true);\n    }\n\n    expressionsChanged() {\n      this.updateSortingExpressions();\n      this.updateColumnsVisibility();\n    }\n\n    updateSortingExpressions() {\n      const sortingExpressions = this.grid.sortingExpressions;\n      let changed = false;\n      this.expressions.forEach((expr, index) => {\n        const sortingIndex = sortingExpressions.findIndex(s => s.fieldName === expr.fieldName);\n\n        if (sortingIndex > -1) {\n          if (sortingIndex !== index) {\n            const sortExpr = sortingExpressions.splice(sortingIndex, 1)[0];\n            sortExpr.dir = expr.dir;\n            sortingExpressions.splice(index, 0, sortExpr);\n            changed = true;\n          } else if (sortingExpressions[sortingIndex].dir !== expr.dir) {\n            sortingExpressions[sortingIndex].dir = expr.dir;\n            changed = true;\n          }\n        } else {\n          const exprCopy = Object.assign({}, expr);\n          sortingExpressions.splice(index, 0, exprCopy);\n          changed = true;\n        }\n      });\n\n      if (changed) {\n        this.grid.sortingExpressions = [...sortingExpressions];\n      }\n    }\n\n    updateColumnsVisibility() {\n      if (this.groupingDiffer && this.grid.columnList && !this.grid.hasColumnLayouts) {\n        const changes = this.groupingDiffer.diff(this.expressions);\n\n        if (changes && this.grid.columnList.length > 0) {\n          changes.forEachAddedItem(rec => {\n            const col = this.grid.getColumnByName(rec.item.fieldName);\n            col.hidden = this.hideGroupedColumns;\n          });\n          changes.forEachRemovedItem(rec => {\n            const col = this.grid.getColumnByName(rec.item.fieldName);\n            col.hidden = false;\n          });\n        }\n      }\n    }\n\n    setColumnsVisibility(value) {\n      if (this.grid.columnList.length > 0 && !this.grid.hasColumnLayouts) {\n        this.expressions.forEach(expr => {\n          const col = this.grid.getColumnByName(expr.fieldName);\n          col.hidden = value;\n        });\n      }\n    }\n\n  }\n\n  IgxTreeGridGroupByAreaComponent.ɵfac = function IgxTreeGridGroupByAreaComponent_Factory(t) {\n    return new (t || IgxTreeGridGroupByAreaComponent)(i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxTreeGridGroupByAreaComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxTreeGridGroupByAreaComponent,\n    selectors: [[\"igx-tree-grid-group-by-area\"]],\n    inputs: {\n      hideGroupedColumns: \"hideGroupedColumns\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxGroupByAreaDirective,\n      useExisting: IgxTreeGridGroupByAreaComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 6,\n    vars: 7,\n    consts: [[3, \"reorder\", \"moveEnd\"], [4, \"ngFor\", \"ngForOf\"], [\"igxGroupAreaDrop\", \"\", 3, \"hidden\", \"igxDrop\"], [4, \"ngTemplateOutlet\"], [\"default\", \"\"], [3, \"id\", \"title\", \"displayDensity\", \"removable\", \"draggable\", \"disabled\", \"keyDown\", \"remove\", \"chipClick\"], [\"igxSuffix\", \"\"], [1, \"igx-grid-grouparea__connector\"], [3, \"hidden\"], [1, \"igx-drop-area__icon\"], [1, \"igx-drop-area__text\"]],\n    template: function IgxTreeGridGroupByAreaComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"igx-chips-area\", 0);\n        i0.ɵɵlistener(\"reorder\", function IgxTreeGridGroupByAreaComponent_Template_igx_chips_area_reorder_0_listener($event) {\n          return ctx.handleReorder($event);\n        })(\"moveEnd\", function IgxTreeGridGroupByAreaComponent_Template_igx_chips_area_moveEnd_0_listener() {\n          return ctx.handleMoveEnd();\n        });\n        i0.ɵɵtemplate(1, IgxTreeGridGroupByAreaComponent_ng_container_1_Template, 14, 24, \"ng-container\", 1);\n        i0.ɵɵelementStart(2, \"div\", 2);\n        i0.ɵɵlistener(\"igxDrop\", function IgxTreeGridGroupByAreaComponent_Template_div_igxDrop_2_listener($event) {\n          return ctx.onDragDrop($event);\n        });\n        i0.ɵɵtemplate(3, IgxTreeGridGroupByAreaComponent_ng_container_3_Template, 1, 0, \"ng-container\", 3);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵtemplate(4, IgxTreeGridGroupByAreaComponent_ng_template_4_Template, 4, 1, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        const _r2 = i0.ɵɵreference(5);\n\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.chipExpressions);\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassMapInterpolate1(\"igx-drop-area\", ctx.density !== \"comfortable\" ? \"--\" + ctx.density : \"\", \"\");\n        i0.ɵɵproperty(\"hidden\", !ctx.dropAreaVisible);\n        i0.ɵɵattribute(\"gridId\", ctx.grid.id);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.dropAreaTemplate || _r2);\n      }\n    },\n    directives: [IgxChipsAreaComponent, IgxChipComponent, IgxIconComponent, i4.NgForOf, IgxSuffixDirective, IgxGroupAreaDropDirective, IgxDropDirective, i4.NgTemplateOutlet],\n    pipes: [IgxGroupByMetaPipe],\n    encapsulation: 2\n  });\n  return IgxTreeGridGroupByAreaComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxGridModule = /*#__PURE__*/(() => {\n  class IgxGridModule {}\n\n  IgxGridModule.ɵfac = function IgxGridModule_Factory(t) {\n    return new (t || IgxGridModule)();\n  };\n\n  IgxGridModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxGridModule\n  });\n  IgxGridModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[IgxGridCommonModule], IgxGridCommonModule]\n  });\n  return IgxGridModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxTreeGridAPIService = /*#__PURE__*/(() => {\n  class IgxTreeGridAPIService extends GridBaseAPIService {\n    get_all_data(transactions) {\n      const grid = this.grid;\n      let data = grid && grid.flatData ? grid.flatData : [];\n      data = transactions ? grid.dataWithAddedInTransactionRows : data;\n      return data;\n    }\n\n    get_summary_data() {\n      const grid = this.grid;\n      const data = grid.processedRootRecords.filter(row => row.isFilteredOutParent === undefined || row.isFilteredOutParent === false).map(rec => rec.data);\n\n      if (grid.transactions.enabled) {\n        const deletedRows = grid.transactions.getTransactionLog().filter(t => t.type === TransactionType.DELETE).map(t => t.id);\n        deletedRows.forEach(rowID => {\n          const tempData = grid.primaryKey ? data.map(rec => rec[grid.primaryKey]) : data;\n          const index = tempData.indexOf(rowID);\n\n          if (index !== -1) {\n            data.splice(index, 1);\n          }\n        });\n      }\n\n      return data;\n    }\n\n    allow_expansion_state_change(rowID, expanded) {\n      const grid = this.grid;\n      const row = grid.records.get(rowID);\n\n      if (row.expanded === expanded || (!row.children || !row.children.length) && (!grid.loadChildrenOnDemand || grid.hasChildrenKey && !row.data[grid.hasChildrenKey])) {\n        return false;\n      }\n\n      return true;\n    }\n\n    expand_path_to_record(record) {\n      const grid = this.grid;\n      const expandedStates = grid.expansionStates;\n\n      while (record.parent) {\n        record = record.parent;\n        const expanded = this.get_row_expansion_state(record);\n\n        if (!expanded) {\n          expandedStates.set(record.key, true);\n        }\n      }\n\n      grid.expansionStates = expandedStates;\n\n      if (grid.rowEditable) {\n        grid.gridAPI.crudService.endEdit(false);\n      }\n    }\n\n    get_row_expansion_state(record) {\n      const grid = this.grid;\n      const states = grid.expansionStates;\n      const expanded = states.get(record.key);\n\n      if (expanded !== undefined) {\n        return expanded;\n      } else {\n        return record.children && record.children.length && record.level < grid.expansionDepth;\n      }\n    }\n\n    should_apply_number_style(column) {\n      return column.dataType === GridColumnDataType.Number && column.visibleIndex !== 0;\n    }\n\n    deleteRowById(rowID) {\n      const treeGrid = this.grid;\n      const flatDataWithCascadeOnDeleteAndTransactions = treeGrid.primaryKey && treeGrid.foreignKey && treeGrid.cascadeOnDelete && treeGrid.transactions.enabled;\n\n      if (flatDataWithCascadeOnDeleteAndTransactions) {\n        treeGrid.transactions.startPending();\n      }\n\n      const record = super.deleteRowById(rowID);\n\n      if (flatDataWithCascadeOnDeleteAndTransactions) {\n        treeGrid.transactions.endPending(true);\n      }\n\n      return record;\n    }\n\n    deleteRowFromData(rowID, index) {\n      const treeGrid = this.grid;\n      const record = treeGrid.records.get(rowID);\n\n      if (treeGrid.primaryKey && treeGrid.foreignKey) {\n        index = treeGrid.primaryKey ? treeGrid.data.map(c => c[treeGrid.primaryKey]).indexOf(rowID) : treeGrid.data.indexOf(rowID);\n        super.deleteRowFromData(rowID, index);\n\n        if (treeGrid.cascadeOnDelete) {\n          if (record && record.children) {\n            for (const child of record.children) {\n              super.deleteRowById(child.key);\n            }\n          }\n        }\n      } else {\n        const collection = record.parent ? record.parent.data[treeGrid.childDataKey] : treeGrid.data;\n        index = treeGrid.primaryKey ? collection.map(c => c[treeGrid.primaryKey]).indexOf(rowID) : collection.indexOf(rowID);\n        const selectedChildren = [];\n        this.get_selected_children(record, selectedChildren);\n\n        if (selectedChildren.length > 0) {\n          treeGrid.deselectRows(selectedChildren);\n        }\n\n        if (treeGrid.transactions.enabled) {\n          const path = treeGrid.generateRowPath(rowID);\n          treeGrid.transactions.add({\n            id: rowID,\n            type: TransactionType.DELETE,\n            newValue: null,\n            path\n          }, collection[index]);\n        } else {\n          collection.splice(index, 1);\n        }\n      }\n    }\n\n    get_selected_children(record, selectedRowIDs) {\n      const grid = this.grid;\n\n      if (!record.children || record.children.length === 0) {\n        return;\n      }\n\n      for (const child of record.children) {\n        if (grid.selectionService.isRowSelected(child.key)) {\n          selectedRowIDs.push(child.key);\n        }\n\n        this.get_selected_children(child, selectedRowIDs);\n      }\n    }\n\n    row_deleted_transaction(rowID) {\n      return this.row_deleted_parent(rowID) || super.row_deleted_transaction(rowID);\n    }\n\n    get_rec_by_id(rowID) {\n      return this.grid.records.get(rowID);\n    }\n    /**\n     * Returns the index of the record in the data view by pk or -1 if not found or primaryKey is not set.\n     *\n     * @param pk\n     * @param dataCollection\n     */\n\n\n    get_rec_index_by_id(pk, dataCollection) {\n      dataCollection = dataCollection || this.grid.data;\n      return this.grid.primaryKey ? dataCollection.findIndex(rec => rec.data[this.grid.primaryKey] === pk) : -1;\n    }\n\n    addRowToData(data, parentRowID) {\n      if (parentRowID !== undefined && parentRowID !== null) {\n        const state = this.grid.transactions.getState(parentRowID); // we should not allow adding of rows as child of deleted row\n\n        if (state && state.type === TransactionType.DELETE) {\n          throw Error(`Cannot add child row to deleted parent row`);\n        }\n\n        const parentRecord = this.grid.records.get(parentRowID);\n\n        if (!parentRecord) {\n          throw Error('Invalid parent row ID!');\n        }\n\n        this.grid.summaryService.clearSummaryCache({\n          rowID: parentRecord.key\n        });\n\n        if (this.grid.primaryKey && this.grid.foreignKey) {\n          data[this.grid.foreignKey] = parentRowID;\n          super.addRowToData(data);\n        } else {\n          const parentData = parentRecord.data;\n          const childKey = this.grid.childDataKey;\n\n          if (this.grid.transactions.enabled) {\n            const rowId = this.grid.primaryKey ? data[this.grid.primaryKey] : data;\n            const path = [];\n            path.push(...this.grid.generateRowPath(parentRowID));\n            path.push(parentRowID);\n            this.grid.transactions.add({\n              id: rowId,\n              path,\n              newValue: data,\n              type: TransactionType.ADD\n            }, null);\n          } else {\n            if (!parentData[childKey]) {\n              parentData[childKey] = [];\n            }\n\n            parentData[childKey].push(data);\n          }\n        }\n      } else {\n        super.addRowToData(data);\n      }\n    }\n\n    filterDataByExpressions(expressionsTree) {\n      let records = this.filterTreeDataByExpressions(expressionsTree);\n      const data = [];\n      this.getFlatDataFromFilteredRecords(records, data);\n      return data;\n    }\n\n    sortDataByExpressions(data, expressions) {\n      var _a;\n\n      const records = DataUtil.sort(cloneArray(data), expressions, (_a = this.grid.sortStrategy) !== null && _a !== void 0 ? _a : new IgxDataRecordSorting(), this.grid);\n      return records.map(r => r.data);\n    }\n\n    filterTreeDataByExpressions(expressionsTree) {\n      var _a;\n\n      let records = this.grid.rootRecords;\n\n      if (expressionsTree.filteringOperands.length) {\n        const state = {\n          expressionsTree,\n          strategy: (_a = this.grid.filterStrategy) !== null && _a !== void 0 ? _a : new TreeGridFilteringStrategy()\n        };\n        records = FilterUtil.filter(cloneArray(records), state, this.grid);\n      }\n\n      return records;\n    }\n\n    update_row_in_array(value, rowID, index) {\n      const grid = this.grid;\n\n      if (grid.primaryKey && grid.foreignKey) {\n        super.update_row_in_array(value, rowID, index);\n      } else {\n        const record = grid.records.get(rowID);\n        const childData = record.parent ? record.parent.data[grid.childDataKey] : grid.data;\n        index = grid.primaryKey ? childData.map(c => c[grid.primaryKey]).indexOf(rowID) : childData.indexOf(rowID);\n        childData[index] = value;\n      }\n    }\n    /**\n     * Updates related row of provided grid's data source with provided new row value\n     *\n     * @param grid Grid to update data for\n     * @param rowID ID of the row to update\n     * @param rowValueInDataSource Initial value of the row as it is in data source\n     * @param rowCurrentValue Current value of the row as it is with applied previous transactions\n     * @param rowNewValue New value of the row\n     */\n\n\n    updateData(grid, rowID, rowValueInDataSource, rowCurrentValue, rowNewValue) {\n      if (grid.transactions.enabled) {\n        const path = grid.generateRowPath(rowID);\n        const transaction = {\n          id: rowID,\n          type: TransactionType.UPDATE,\n          newValue: rowNewValue,\n          path\n        };\n        grid.transactions.add(transaction, rowCurrentValue);\n      } else {\n        mergeObjects(rowValueInDataSource, rowNewValue);\n      }\n    }\n\n    row_deleted_parent(rowID) {\n      const grid = this.grid;\n\n      if (!grid) {\n        return false;\n      }\n\n      if (grid.cascadeOnDelete && grid.foreignKey || grid.childDataKey) {\n        let node = grid.records.get(rowID);\n\n        while (node) {\n          const state = grid.transactions.getState(node.key);\n\n          if (state && state.type === TransactionType.DELETE) {\n            return true;\n          }\n\n          node = node.parent;\n        }\n      }\n\n      return false;\n    }\n\n    getFlatDataFromFilteredRecords(records, data) {\n      if (!records || records.length === 0) {\n        return;\n      }\n\n      for (const record of records) {\n        if (!record.isFilteredOutParent) {\n          data.push(record);\n        }\n\n        this.getFlatDataFromFilteredRecords(record.children, data);\n      }\n    }\n\n  }\n\n  IgxTreeGridAPIService.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxTreeGridAPIService_BaseFactory;\n    return function IgxTreeGridAPIService_Factory(t) {\n      return (ɵIgxTreeGridAPIService_BaseFactory || (ɵIgxTreeGridAPIService_BaseFactory = i0.ɵɵgetInheritedFactory(IgxTreeGridAPIService)))(t || IgxTreeGridAPIService);\n    };\n  }();\n\n  IgxTreeGridAPIService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxTreeGridAPIService,\n    factory: IgxTreeGridAPIService.ɵfac\n  });\n  return IgxTreeGridAPIService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxRowLoadingIndicatorTemplateDirective = /*#__PURE__*/(() => {\n  class IgxRowLoadingIndicatorTemplateDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxRowLoadingIndicatorTemplateDirective.ɵfac = function IgxRowLoadingIndicatorTemplateDirective_Factory(t) {\n    return new (t || IgxRowLoadingIndicatorTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxRowLoadingIndicatorTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxRowLoadingIndicatorTemplateDirective,\n    selectors: [[\"\", \"igxRowLoadingIndicator\", \"\"]]\n  });\n  return IgxRowLoadingIndicatorTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxTreeGridSelectionService = /*#__PURE__*/(() => {\n  class IgxTreeGridSelectionService extends IgxGridSelectionService {\n    /** Select specified rows. No event is emitted. */\n    selectRowsWithNoEvent(rowIDs, clearPrevSelection) {\n      if (this.grid && this.grid.rowSelection === GridSelectionMode.multipleCascade) {\n        this.cascadeSelectRowsWithNoEvent(rowIDs, clearPrevSelection);\n        return;\n      }\n\n      super.selectRowsWithNoEvent(rowIDs, clearPrevSelection);\n    }\n    /** Deselect specified rows. No event is emitted. */\n\n\n    deselectRowsWithNoEvent(rowIDs) {\n      if (this.grid.rowSelection === GridSelectionMode.multipleCascade) {\n        this.cascadeDeselectRowsWithNoEvent(rowIDs);\n        return;\n      }\n\n      super.deselectRowsWithNoEvent(rowIDs);\n    }\n\n    emitRowSelectionEvent(newSelection, added, removed, event) {\n      if (this.grid.rowSelection === GridSelectionMode.multipleCascade) {\n        this.emitCascadeRowSelectionEvent(newSelection, added, removed, event);\n        return;\n      }\n\n      super.emitRowSelectionEvent(newSelection, added, removed, event);\n    }\n\n    updateCascadeSelectionOnFilterAndCRUD(parents, crudRowID, visibleRowIDs = null) {\n      if (visibleRowIDs === null) {\n        // if the tree grid has flat structure\n        // do not explicitly handle the selection state of the rows\n        if (!parents.size) {\n          return;\n        }\n\n        visibleRowIDs = new Set(this.getRowIDs(this.allData));\n        this.rowsToBeSelected = new Set(this.rowSelection);\n        this.rowsToBeIndeterminate = new Set(this.indeterminateRows);\n\n        if (crudRowID) {\n          this.rowSelection.delete(crudRowID);\n        }\n      }\n\n      if (!parents.size) {\n        this.rowSelection = new Set(this.rowsToBeSelected);\n        this.indeterminateRows = new Set(this.rowsToBeIndeterminate); // TODO: emit selectionChangeD event, calculate its args through the handleAddedAndRemovedArgs method\n\n        this.clearHeaderCBState();\n        this.selectedRowsChange.next();\n        return;\n      }\n\n      const newParents = new Set();\n      parents.forEach(parent => {\n        this.handleRowSelectionState(parent, visibleRowIDs);\n\n        if (parent && parent.parent) {\n          newParents.add(parent.parent);\n        }\n      });\n      this.updateCascadeSelectionOnFilterAndCRUD(newParents, null, visibleRowIDs);\n    }\n\n    cascadeSelectRowsWithNoEvent(rowIDs, clearPrevSelection) {\n      if (clearPrevSelection) {\n        this.indeterminateRows.clear();\n        this.rowSelection.clear();\n        this.calculateRowsNewSelectionState({\n          added: rowIDs,\n          removed: []\n        });\n      } else {\n        const oldSelection = this.getSelectedRows();\n        const newSelection = [...oldSelection, ...rowIDs];\n        const args = {\n          oldSelection,\n          newSelection\n        }; // retrieve only the rows without their parents/children which has to be added to the selection\n\n        this.handleAddedAndRemovedArgs(args);\n        this.calculateRowsNewSelectionState(args);\n      }\n\n      this.rowSelection = new Set(this.rowsToBeSelected);\n      this.indeterminateRows = new Set(this.rowsToBeIndeterminate);\n      this.clearHeaderCBState();\n      this.selectedRowsChange.next();\n    }\n\n    cascadeDeselectRowsWithNoEvent(rowIDs) {\n      const args = {\n        added: [],\n        removed: rowIDs\n      };\n      this.calculateRowsNewSelectionState(args);\n      this.rowSelection = new Set(this.rowsToBeSelected);\n      this.indeterminateRows = new Set(this.rowsToBeIndeterminate);\n      this.clearHeaderCBState();\n      this.selectedRowsChange.next();\n    }\n\n    get selectionService() {\n      return this.grid.selectionService;\n    }\n\n    emitCascadeRowSelectionEvent(newSelection, added, removed, event) {\n      const currSelection = this.getSelectedRows();\n\n      if (this.areEqualCollections(currSelection, newSelection)) {\n        return;\n      }\n\n      const args = {\n        oldSelection: currSelection,\n        newSelection,\n        added,\n        removed,\n        event,\n        cancel: false\n      };\n      this.calculateRowsNewSelectionState(args);\n      args.newSelection = Array.from(this.rowsToBeSelected); // retrieve rows/parents/children which has been added/removed from the selection\n\n      this.handleAddedAndRemovedArgs(args);\n      this.grid.rowSelectionChanging.emit(args);\n\n      if (args.cancel) {\n        return;\n      } // if args.newSelection hasn't been modified\n\n\n      if (this.areEqualCollections(Array.from(this.rowsToBeSelected), args.newSelection)) {\n        this.rowSelection = new Set(this.rowsToBeSelected);\n        this.indeterminateRows = new Set(this.rowsToBeIndeterminate);\n        this.clearHeaderCBState();\n        this.selectedRowsChange.next();\n      } else {\n        // select the rows within the modified args.newSelection with no event\n        this.cascadeSelectRowsWithNoEvent(args.newSelection, true);\n      }\n    }\n    /**\n     * retrieve the rows which should be added/removed to/from the old selection\n     */\n\n\n    handleAddedAndRemovedArgs(args) {\n      const newSelectionSet = new Set(args.newSelection);\n      const oldSelectionSet = new Set(args.oldSelection);\n      args.removed = args.oldSelection.filter(x => !newSelectionSet.has(x));\n      args.added = args.newSelection.filter(x => !oldSelectionSet.has(x));\n    }\n    /**\n     * adds to rowsToBeProcessed set all visible children of the rows which was initially within the rowsToBeProcessed set\n     *\n     * @param rowsToBeProcessed set of the rows (without their parents/children) to be selected/deselected\n     * @param visibleRowIDs list of all visible rowIds\n     * @returns a new set with all direct parents of the rows within rowsToBeProcessed set\n     */\n\n\n    collectRowsChildrenAndDirectParents(rowsToBeProcessed, visibleRowIDs, adding) {\n      const processedRowsParents = new Set();\n      Array.from(rowsToBeProcessed).forEach(rowID => {\n        this.selectDeselectRow(rowID, adding);\n        const rowTreeRecord = this.grid.gridAPI.get_rec_by_id(rowID);\n        const rowAndAllChildren = this.get_all_children(rowTreeRecord);\n        rowAndAllChildren.forEach(row => {\n          if (visibleRowIDs.has(row.key)) {\n            this.selectDeselectRow(row.key, adding);\n          }\n        });\n\n        if (rowTreeRecord && rowTreeRecord.parent) {\n          processedRowsParents.add(rowTreeRecord.parent);\n        }\n      });\n      return processedRowsParents;\n    }\n    /**\n     * populates the rowsToBeSelected and rowsToBeIndeterminate sets\n     * with the rows which will be eventually in selected/indeterminate state\n     */\n\n\n    calculateRowsNewSelectionState(args) {\n      this.rowsToBeSelected = new Set(args.oldSelection ? args.oldSelection : this.getSelectedRows());\n      this.rowsToBeIndeterminate = new Set(this.getIndeterminateRows());\n      const visibleRowIDs = new Set(this.getRowIDs(this.allData));\n      const removed = new Set(args.removed);\n      const added = new Set(args.added);\n\n      if (removed && removed.size) {\n        let removedRowsParents = new Set();\n        removedRowsParents = this.collectRowsChildrenAndDirectParents(removed, visibleRowIDs, false);\n        Array.from(removedRowsParents).forEach(parent => {\n          this.handleParentSelectionState(parent, visibleRowIDs);\n        });\n      }\n\n      if (added && added.size) {\n        let addedRowsParents = new Set();\n        addedRowsParents = this.collectRowsChildrenAndDirectParents(added, visibleRowIDs, true);\n        Array.from(addedRowsParents).forEach(parent => {\n          this.handleParentSelectionState(parent, visibleRowIDs);\n        });\n      }\n    }\n    /**\n     * recursively handle the selection state of the direct and indirect parents\n     */\n\n\n    handleParentSelectionState(treeRow, visibleRowIDs) {\n      if (!treeRow) {\n        return;\n      }\n\n      this.handleRowSelectionState(treeRow, visibleRowIDs);\n\n      if (treeRow.parent) {\n        this.handleParentSelectionState(treeRow.parent, visibleRowIDs);\n      }\n    }\n    /**\n     * Handle the selection state of a given row based the selection states of its direct children\n     */\n\n\n    handleRowSelectionState(treeRow, visibleRowIDs) {\n      let visibleChildren = [];\n\n      if (treeRow && treeRow.children) {\n        visibleChildren = treeRow.children.filter(child => visibleRowIDs.has(child.key));\n      }\n\n      if (visibleChildren.length) {\n        if (visibleChildren.every(row => this.rowsToBeSelected.has(row.key))) {\n          this.selectDeselectRow(treeRow.key, true);\n        } else if (visibleChildren.some(row => this.rowsToBeSelected.has(row.key) || this.rowsToBeIndeterminate.has(row.key))) {\n          this.rowsToBeIndeterminate.add(treeRow.key);\n          this.rowsToBeSelected.delete(treeRow.key);\n        } else {\n          this.selectDeselectRow(treeRow.key, false);\n        }\n      } else {\n        // if the children of the row has been deleted and the row was selected do not change its state\n        if (this.isRowSelected(treeRow.key)) {\n          this.selectDeselectRow(treeRow.key, true);\n        } else {\n          this.selectDeselectRow(treeRow.key, false);\n        }\n      }\n    }\n\n    get_all_children(record) {\n      const children = [];\n\n      if (record && record.children && record.children.length) {\n        for (const child of record.children) {\n          children.push(...this.get_all_children(child));\n          children.push(child);\n        }\n      }\n\n      return children;\n    }\n\n    selectDeselectRow(rowID, select) {\n      if (select) {\n        this.rowsToBeSelected.add(rowID);\n        this.rowsToBeIndeterminate.delete(rowID);\n      } else {\n        this.rowsToBeSelected.delete(rowID);\n        this.rowsToBeIndeterminate.delete(rowID);\n      }\n    }\n\n  }\n\n  IgxTreeGridSelectionService.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxTreeGridSelectionService_BaseFactory;\n    return function IgxTreeGridSelectionService_Factory(t) {\n      return (ɵIgxTreeGridSelectionService_BaseFactory || (ɵIgxTreeGridSelectionService_BaseFactory = i0.ɵɵgetInheritedFactory(IgxTreeGridSelectionService)))(t || IgxTreeGridSelectionService);\n    };\n  }();\n\n  IgxTreeGridSelectionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxTreeGridSelectionService,\n    factory: IgxTreeGridSelectionService.ɵfac\n  });\n  return IgxTreeGridSelectionService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxTreeGridCellComponent = /*#__PURE__*/(() => {\n  class IgxTreeGridCellComponent extends IgxGridExpandableCellComponent {\n    constructor() {\n      super(...arguments);\n      /**\n       * @hidden\n       */\n\n      this.level = 0;\n      /**\n       * @hidden\n       */\n\n      this.showIndicator = false;\n    }\n    /**\n     * Gets the row of the cell.\n     * ```typescript\n     * let cellRow = this.cell.row;\n     * ```\n     *\n     * @memberof IgxGridCellComponent\n     */\n\n\n    get row() {\n      // TODO: Fix types\n      return new IgxTreeGridRow(this.grid, this.intRow.index, this.intRow.data);\n    }\n    /**\n     * @hidden\n     */\n\n\n    toggle(event) {\n      event.stopPropagation();\n      this.grid.gridAPI.set_row_expansion_state(this.intRow.key, !this.intRow.expanded, event);\n    }\n    /**\n     * @hidden\n     */\n\n\n    onLoadingDblClick(event) {\n      event.stopPropagation();\n    }\n\n  }\n\n  IgxTreeGridCellComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxTreeGridCellComponent_BaseFactory;\n    return function IgxTreeGridCellComponent_Factory(t) {\n      return (ɵIgxTreeGridCellComponent_BaseFactory || (ɵIgxTreeGridCellComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxTreeGridCellComponent)))(t || IgxTreeGridCellComponent);\n    };\n  }();\n\n  IgxTreeGridCellComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxTreeGridCellComponent,\n    selectors: [[\"igx-tree-grid-cell\"]],\n    inputs: {\n      level: \"level\",\n      showIndicator: \"showIndicator\",\n      isLoading: \"isLoading\",\n      row: \"row\"\n    },\n    features: [i0.ɵɵProvidersFeature([HammerGesturesManager]), i0.ɵɵInheritDefinitionFeature],\n    decls: 14,\n    vars: 3,\n    consts: [[\"defaultPinnedIndicator\", \"\"], [\"defaultCell\", \"\"], [\"addRowCell\", \"\"], [\"inlineEditor\", \"\"], [4, \"ngIf\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"defaultExpandedTemplate\", \"\"], [\"defaultCollapsedTemplate\", \"\"], [\"class\", \"igx-grid__td--pinned-chip\", 3, \"disabled\", \"displayDensity\", 4, \"ngIf\"], [1, \"igx-grid__td--pinned-chip\", 3, \"disabled\", \"displayDensity\"], [\"igxTextHighlight\", \"\", \"class\", \"igx-grid__td-text\", \"style\", \"pointer-events: none;\", 3, \"cssClass\", \"activeCssClass\", \"groupName\", \"value\", \"row\", \"column\", \"containerClass\", \"metadata\", 4, \"ngIf\"], [3, \"ngClass\", 4, \"ngIf\"], [\"igxTextHighlight\", \"\", 1, \"igx-grid__td-text\", 2, \"pointer-events\", \"none\", 3, \"cssClass\", \"activeCssClass\", \"groupName\", \"value\", \"row\", \"column\", \"containerClass\", \"metadata\"], [3, \"ngClass\"], [\"igxTextHighlight\", \"\", \"class\", \"igx-grid__td-text\", \"style\", \"pointer-events: none\", 3, \"cssClass\", \"activeCssClass\", \"groupName\", \"value\", \"row\", \"column\", \"containerClass\", \"metadata\", 4, \"ngIf\"], [\"displayDensity\", \"compact\"], [\"igxInput\", \"\", 3, \"ngModel\", \"igxFocus\", \"ngModelChange\"], [\"igxInput\", \"\", \"type\", \"number\", 3, \"ngModel\", \"igxFocus\", \"step\", \"ngModelChange\"], [3, \"ngModel\", \"disableRipple\", \"ngModelChange\"], [\"mode\", \"dropdown\", 3, \"outlet\", \"locale\", \"value\", \"igxFocus\", \"valueChange\"], [\"mode\", \"dropdown\", 3, \"outlet\", \"inputFormat\", \"ngModel\", \"igxFocus\", \"ngModelChange\"], [\"type\", \"text\", \"igxInput\", \"\", 3, \"igxDateTimeEditor\", \"ngModel\", \"igxFocus\", \"ngModelChange\"], [\"class\", \"igx-grid__tree-grouping-indicator\", 3, \"ngStyle\", \"click\", \"focus\", 4, \"ngIf\"], [\"class\", \"igx-grid__tree-loading-indicator\", 3, \"dblclick\", 4, \"ngIf\"], [\"defaultLoadingIndicatorTemplate\", \"\"], [3, \"ngStyle\"], [\"indentationDiv\", \"\"], [1, \"igx-grid__tree-grouping-indicator\", 3, \"ngStyle\", \"click\", \"focus\"], [\"indicator\", \"\"], [1, \"igx-grid__tree-loading-indicator\", 3, \"dblclick\"], [4, \"ngTemplateOutlet\"], [3, \"indeterminate\"]],\n    template: function IgxTreeGridCellComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxTreeGridCellComponent_ng_template_0_Template, 1, 1, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, IgxTreeGridCellComponent_ng_template_2_Template, 2, 2, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(4, IgxTreeGridCellComponent_ng_template_4_Template, 1, 1, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(6, IgxTreeGridCellComponent_ng_template_6_Template, 8, 8, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(8, IgxTreeGridCellComponent_ng_container_8_Template, 6, 3, \"ng-container\", 4);\n        i0.ɵɵtemplate(9, IgxTreeGridCellComponent_ng_container_9_Template, 1, 0, \"ng-container\", 5);\n        i0.ɵɵtemplate(10, IgxTreeGridCellComponent_ng_template_10_Template, 2, 0, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(12, IgxTreeGridCellComponent_ng_template_12_Template, 2, 0, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(8);\n        i0.ɵɵproperty(\"ngIf\", !ctx.editMode);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template)(\"ngTemplateOutletContext\", ctx.context);\n      }\n    },\n    directives: [IgxChipComponent, IgxIconComponent, IgxInputGroupComponent, IgxCheckboxComponent, IgxDatePickerComponent, IgxTimePickerComponent, IgxCircularProgressBarComponent, i4.NgIf, IgxTextHighlightDirective, i4.NgClass, i12.DefaultValueAccessor, IgxInputDirective, i12.NgControlStatus, i12.NgModel, IgxFocusDirective, i12.NumberValueAccessor, IgxDateTimeEditorDirective, IgxPrefixDirective, IgxSuffixDirective, i4.NgStyle, i4.NgTemplateOutlet],\n    pipes: [IgxColumnFormatterPipe, i4.DecimalPipe, i4.DatePipe, i4.CurrencyPipe, i4.PercentPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxTreeGridCellComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxTreeGridRowComponent = /*#__PURE__*/(() => {\n  class IgxTreeGridRowComponent extends IgxRowDirective {\n    /**\n     * The `ITreeGridRecord` passed to the row component.\n     *\n     * ```typescript\n     * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;\n     * const treeRow = row.treeRow;\n     * ```\n     */\n    get treeRow() {\n      return this._treeRow;\n    }\n\n    set treeRow(value) {\n      if (this._treeRow !== value) {\n        this._treeRow = value;\n        this.data = this._treeRow.data;\n      }\n    }\n    /**\n     * Sets whether the row is pinned.\n     * Default value is `false`.\n     * ```typescript\n     * this.grid.selectedRows[0].pinned = true;\n     * ```\n     */\n\n\n    set pinned(value) {\n      if (value) {\n        this.grid.pinRow(this.key);\n      } else {\n        this.grid.unpinRow(this.key);\n      }\n    }\n    /**\n     * Gets whether the row is pinned.\n     * ```typescript\n     * let isPinned = row.pinned;\n     * ```\n     */\n\n\n    get pinned() {\n      return this.grid.isRecordPinned(this._treeRow);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get isRoot() {\n      let treeRec = this.treeRow;\n      const isPinnedArea = this.pinned && !this.disabled;\n\n      if (isPinnedArea) {\n        treeRec = this.grid.unpinnedRecords.find(x => x.data === this.data);\n      }\n\n      return treeRec.level === 0;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hasChildren() {\n      return true;\n    }\n    /**\n     * Returns a value indicating whether the row component is expanded.\n     *\n     * ```typescript\n     * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;\n     * const expanded = row.expanded;\n     * ```\n     */\n\n\n    get expanded() {\n      return this._treeRow.expanded;\n    }\n    /**\n     * Sets a value indicating whether the row component is expanded.\n     *\n     * ```typescript\n     * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;\n     * row.expanded = true;\n     * ```\n     */\n\n\n    set expanded(value) {\n      this.grid.gridAPI.set_row_expansion_state(this._treeRow.key, value);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get viewIndex() {\n      return this.index + this.grid.page * this.grid.perPage;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get showIndicator() {\n      return this.grid.loadChildrenOnDemand ? this.grid.expansionStates.has(this.key) ? this.treeRow.children && this.treeRow.children.length : this.grid.hasChildrenKey ? this.data[this.grid.hasChildrenKey] : true : this.treeRow.children && this.treeRow.children.length;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get indeterminate() {\n      return this.selectionService.isRowInIndeterminateState(this.key);\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngDoCheck() {\n      this.isLoading = this.grid.loadChildrenOnDemand ? this.grid.loadingRows.has(this.key) : false;\n      super.ngDoCheck();\n    }\n    /**\n     * Spawns the add child row UI for the specific row.\n     *\n     * @example\n     * ```typescript\n     * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;\n     * row.beginAddChild();\n     * ```\n     * @param rowID\n     */\n\n\n    beginAddChild() {\n      this.grid.crudService.enterAddRowMode(this, true);\n    }\n\n  }\n\n  IgxTreeGridRowComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxTreeGridRowComponent_BaseFactory;\n    return function IgxTreeGridRowComponent_Factory(t) {\n      return (ɵIgxTreeGridRowComponent_BaseFactory || (ɵIgxTreeGridRowComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxTreeGridRowComponent)))(t || IgxTreeGridRowComponent);\n    };\n  }();\n\n  IgxTreeGridRowComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxTreeGridRowComponent,\n    selectors: [[\"igx-tree-grid-row\"]],\n    viewQuery: function IgxTreeGridRowComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c234, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._cells = _t);\n      }\n    },\n    hostVars: 1,\n    hostBindings: function IgxTreeGridRowComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-expanded\", ctx.expanded);\n      }\n    },\n    inputs: {\n      treeRow: \"treeRow\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxRowDirective,\n      useExisting: forwardRef(() => IgxTreeGridRowComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 5,\n    vars: 1,\n    consts: [[4, \"ngTemplateOutlet\"], [\"addTemp\", \"\"], [\"defaultTemp\", \"\"], [1, \"igx-grid__tr--inner\", 3, \"animationend\"], [4, \"ngIf\"], [\"igxGridFor\", \"\", 3, \"igxGridForOf\", \"igxForScrollContainer\", \"igxForScrollOrientation\", \"igxForContainerSize\", \"igxForSizePropName\", \"igxForTrackBy\"], [\"igxDirRef\", \"\"], [\"rowSelectorBaseTemplate\", \"\"], [\"pinnedCellsTemplate\", \"\"], [3, \"igxRowDrag\", \"ghostTemplate\", \"click\"], [1, \"igx-grid__cbx-selection\", \"igx-grid__tr-action\", 3, \"click\", \"pointerdown\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"cellTemplate\", \"\"], [\"treeCellTemplate\", \"\"], [1, \"igx-grid__td\", \"igx-grid__td--fw\", 3, \"ngClass\", \"ngStyle\", \"editMode\", \"column\", \"formatter\", \"intRow\", \"rowData\", \"width\", \"visibleColumnIndex\", \"value\", \"cellTemplate\", \"lastSearchInfo\", \"active\", \"cellSelectionMode\", \"displayPinnedChip\"], [\"treeCell\", \"\"], [1, \"igx-grid__td\", \"igx-grid__td--fw\", \"igx-grid__td--tree-cell\", 3, \"ngClass\", \"ngStyle\", \"level\", \"expanded\", \"showIndicator\", \"editMode\", \"column\", \"formatter\", \"intRow\", \"rowData\", \"width\", \"visibleColumnIndex\", \"value\", \"isLoading\", \"cellTemplate\", \"lastSearchInfo\", \"active\", \"cellSelectionMode\", \"displayPinnedChip\"], [1, \"igx-grid__cbx-padding\"], [3, \"tabindex\", \"readonly\", \"checked\", \"indeterminate\", \"disabled\", \"disableRipple\", \"disableTransitions\", \"aria-label\"], [\"ngFor\", \"\", 3, \"ngForOf\"], [1, \"igx-grid__td\", \"igx-grid__td--fw\", \"igx-grid__td--pinned\", 3, \"ngClass\", \"ngStyle\", \"editMode\", \"column\", \"formatter\", \"intRow\", \"firstPinned\", \"lastPinned\", \"rowData\", \"width\", \"visibleColumnIndex\", \"value\", \"cellTemplate\", \"lastSearchInfo\", \"active\", \"cellSelectionMode\", \"displayPinnedChip\"], [1, \"igx-grid__td\", \"igx-grid__td--fw\", \"igx-grid__td--tree-cell\", \"igx-grid__td--pinned\", 3, \"ngClass\", \"ngStyle\", \"level\", \"expanded\", \"showIndicator\", \"editMode\", \"column\", \"formatter\", \"intRow\", \"lastPinned\", \"rowData\", \"width\", \"visibleColumnIndex\", \"value\", \"isLoading\", \"cellTemplate\", \"lastSearchInfo\", \"active\", \"cellSelectionMode\", \"displayPinnedChip\"]],\n    template: function IgxTreeGridRowComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxTreeGridRowComponent_ng_container_0_Template, 1, 0, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, IgxTreeGridRowComponent_ng_template_1_Template, 2, 3, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(3, IgxTreeGridRowComponent_ng_template_3_Template, 11, 12, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        const _r1 = i0.ɵɵreference(2);\n\n        const _r3 = i0.ɵɵreference(4);\n\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.addRowUI ? _r1 : _r3);\n      }\n    },\n    directives: [IgxGridCellComponent, IgxTreeGridCellComponent, IgxCheckboxComponent, i4.NgTemplateOutlet, i4.NgIf, IgxRowDragDirective, IgxGridForOfDirective, i4.NgClass, i4.NgStyle, i4.NgForOf],\n    pipes: [IgxGridNotGroupedPipe, IgxGridTransactionStatePipe, IgxStringReplacePipe, IgxGridCellStyleClassesPipe, IgxGridCellStylesPipe, IgxGridDataMapperPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxTreeGridRowComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxTreeGridHierarchizingPipe = /*#__PURE__*/(() => {\n  class IgxTreeGridHierarchizingPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(collection, primaryKey, foreignKey, childDataKey, _) {\n      let hierarchicalRecords = [];\n      const treeGridRecordsMap = new Map();\n      const flatData = [];\n\n      if (primaryKey && foreignKey) {\n        hierarchicalRecords = this.hierarchizeFlatData(collection, primaryKey, foreignKey, treeGridRecordsMap, flatData);\n      } else if (childDataKey) {\n        hierarchicalRecords = this.hierarchizeRecursive(collection, primaryKey, childDataKey, undefined, flatData, 0, treeGridRecordsMap);\n      }\n\n      this.grid.flatData = this.grid.transactions.enabled ? flatData.filter(rec => {\n        const state = this.grid.transactions.getState(this.getRowID(primaryKey, rec));\n        return !state || state.type !== TransactionType.ADD;\n      }) : flatData;\n      this.grid.records = treeGridRecordsMap;\n      this.grid.rootRecords = hierarchicalRecords;\n      return hierarchicalRecords;\n    }\n\n    getRowID(primaryKey, rowData) {\n      return primaryKey ? rowData[primaryKey] : rowData;\n    }\n\n    hierarchizeFlatData(collection, primaryKey, foreignKey, map, flatData) {\n      const result = [];\n      const missingParentRecords = [];\n      collection.forEach(row => {\n        const record = {\n          key: this.getRowID(primaryKey, row),\n          data: row,\n          children: []\n        };\n        const parent = map.get(row[foreignKey]);\n\n        if (parent) {\n          record.parent = parent;\n          parent.children.push(record);\n        } else {\n          missingParentRecords.push(record);\n        }\n\n        map.set(row[primaryKey], record);\n      });\n      missingParentRecords.forEach(record => {\n        const parent = map.get(record.data[foreignKey]);\n\n        if (parent) {\n          record.parent = parent;\n          parent.children.push(record);\n        } else {\n          result.push(record);\n        }\n      });\n      this.setIndentationLevels(result, 0, flatData);\n      return result;\n    }\n\n    setIndentationLevels(collection, indentationLevel, flatData) {\n      for (const record of collection) {\n        record.level = indentationLevel;\n        record.expanded = this.grid.gridAPI.get_row_expansion_state(record);\n        flatData.push(record.data);\n\n        if (record.children && record.children.length > 0) {\n          this.setIndentationLevels(record.children, indentationLevel + 1, flatData);\n        }\n      }\n    }\n\n    hierarchizeRecursive(collection, primaryKey, childDataKey, parent, flatData, indentationLevel, map) {\n      const result = [];\n\n      for (const item of collection) {\n        const record = {\n          key: this.getRowID(primaryKey, item),\n          data: item,\n          parent,\n          level: indentationLevel\n        };\n        record.expanded = this.grid.gridAPI.get_row_expansion_state(record);\n        flatData.push(item);\n        map.set(record.key, record);\n        record.children = item[childDataKey] ? this.hierarchizeRecursive(item[childDataKey], primaryKey, childDataKey, record, flatData, indentationLevel + 1, map) : undefined;\n        result.push(record);\n      }\n\n      return result;\n    }\n\n  }\n\n  IgxTreeGridHierarchizingPipe.ɵfac = function IgxTreeGridHierarchizingPipe_Factory(t) {\n    return new (t || IgxTreeGridHierarchizingPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxTreeGridHierarchizingPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"treeGridHierarchizing\",\n    type: IgxTreeGridHierarchizingPipe,\n    pure: true\n  });\n  return IgxTreeGridHierarchizingPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxTreeGridFlatteningPipe = /*#__PURE__*/(() => {\n  class IgxTreeGridFlatteningPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(collection, expandedLevels, expandedStates, _) {\n      const data = [];\n      this.grid.processedRootRecords = collection;\n      this.grid.processedRecords = new Map();\n      this.getFlatDataRecursive(collection, data, expandedLevels, expandedStates, true);\n      this.grid.processedExpandedFlatData = data.map(r => r.data);\n      return data;\n    }\n\n    getFlatDataRecursive(collection, data, expandedLevels, expandedStates, parentExpanded) {\n      if (!collection || !collection.length) {\n        return;\n      }\n\n      for (const hierarchicalRecord of collection) {\n        if (parentExpanded) {\n          data.push(hierarchicalRecord);\n        }\n\n        hierarchicalRecord.expanded = this.grid.gridAPI.get_row_expansion_state(hierarchicalRecord);\n        this.updateNonProcessedRecordExpansion(this.grid, hierarchicalRecord);\n        this.grid.processedRecords.set(hierarchicalRecord.key, hierarchicalRecord);\n        this.getFlatDataRecursive(hierarchicalRecord.children, data, expandedLevels, expandedStates, parentExpanded && hierarchicalRecord.expanded);\n      }\n    }\n\n    updateNonProcessedRecordExpansion(grid, record) {\n      const rec = grid.records.get(record.key);\n      rec.expanded = record.expanded;\n    }\n\n  }\n\n  IgxTreeGridFlatteningPipe.ɵfac = function IgxTreeGridFlatteningPipe_Factory(t) {\n    return new (t || IgxTreeGridFlatteningPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxTreeGridFlatteningPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"treeGridFlattening\",\n    type: IgxTreeGridFlatteningPipe,\n    pure: true\n  });\n  return IgxTreeGridFlatteningPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxTreeGridSortingPipe = /*#__PURE__*/(() => {\n  class IgxTreeGridSortingPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(hierarchicalData, expressions, sorting, _, pinned) {\n      let result;\n\n      if (!expressions.length) {\n        result = hierarchicalData;\n      } else {\n        result = DataUtil.treeGridSort(hierarchicalData, expressions, sorting, null, this.grid);\n      }\n\n      const filteredSortedData = [];\n      this.flattenTreeGridRecords(result, filteredSortedData);\n      this.grid.setFilteredSortedData(filteredSortedData, pinned);\n      return result;\n    }\n\n    flattenTreeGridRecords(records, flatData) {\n      if (records && records.length) {\n        for (const record of records) {\n          flatData.push(record.data);\n          this.flattenTreeGridRecords(record.children, flatData);\n        }\n      }\n    }\n\n  }\n\n  IgxTreeGridSortingPipe.ɵfac = function IgxTreeGridSortingPipe_Factory(t) {\n    return new (t || IgxTreeGridSortingPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxTreeGridSortingPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"treeGridSorting\",\n    type: IgxTreeGridSortingPipe,\n    pure: true\n  });\n  return IgxTreeGridSortingPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxTreeGridPagingPipe = /*#__PURE__*/(() => {\n  class IgxTreeGridPagingPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(collection, page = 0, perPage = 15, _) {\n      if (!this.grid.paginator || this.grid.pagingMode !== GridPagingMode.Local) {\n        return collection;\n      }\n\n      const len = this.grid._totalRecords >= 0 ? this.grid._totalRecords : collection.length;\n      const totalPages = Math.ceil(len / perPage);\n      const state = {\n        index: totalPages > 0 && page >= totalPages ? totalPages - 1 : page,\n        recordsPerPage: perPage\n      };\n      const result = DataUtil.page(cloneArray(collection), state, len);\n      this.grid.pagingState = state;\n      this.grid.paginator.page = state.index;\n      return result;\n    }\n\n  }\n\n  IgxTreeGridPagingPipe.ɵfac = function IgxTreeGridPagingPipe_Factory(t) {\n    return new (t || IgxTreeGridPagingPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxTreeGridPagingPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"treeGridPaging\",\n    type: IgxTreeGridPagingPipe,\n    pure: true\n  });\n  return IgxTreeGridPagingPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxTreeGridTransactionPipe = /*#__PURE__*/(() => {\n  class IgxTreeGridTransactionPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(collection, _) {\n      if (this.grid.transactions.enabled) {\n        const aggregatedChanges = this.grid.transactions.getAggregatedChanges(true);\n\n        if (aggregatedChanges.length > 0) {\n          const primaryKey = this.grid.primaryKey;\n\n          if (!primaryKey) {\n            return collection;\n          }\n\n          const foreignKey = this.grid.foreignKey;\n          const childDataKey = this.grid.childDataKey;\n\n          if (foreignKey) {\n            const flatDataClone = cloneArray(collection);\n            return DataUtil.mergeTransactions(flatDataClone, aggregatedChanges, this.grid.primaryKey, this.grid.dataCloneStrategy);\n          } else if (childDataKey) {\n            const hierarchicalDataClone = cloneHierarchicalArray(collection, childDataKey);\n            return DataUtil.mergeHierarchicalTransactions(hierarchicalDataClone, aggregatedChanges, childDataKey, this.grid.primaryKey, this.grid.dataCloneStrategy);\n          }\n        }\n      }\n\n      return collection;\n    }\n\n  }\n\n  IgxTreeGridTransactionPipe.ɵfac = function IgxTreeGridTransactionPipe_Factory(t) {\n    return new (t || IgxTreeGridTransactionPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxTreeGridTransactionPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"treeGridTransaction\",\n    type: IgxTreeGridTransactionPipe,\n    pure: true\n  });\n  return IgxTreeGridTransactionPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * This pipe maps the original record to ITreeGridRecord format used in TreeGrid.\n */\n\n\nlet IgxTreeGridNormalizeRecordsPipe = /*#__PURE__*/(() => {\n  class IgxTreeGridNormalizeRecordsPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(_, __) {\n      const primaryKey = this.grid.primaryKey; // using flattened data because origin data may be hierarchical.\n\n      const flatData = this.grid.flatData;\n      const res = flatData.map(rec => ({\n        rowID: this.grid.primaryKey ? rec[primaryKey] : rec,\n        data: rec,\n        level: 0,\n        children: []\n      }));\n      return res;\n    }\n\n  }\n\n  IgxTreeGridNormalizeRecordsPipe.ɵfac = function IgxTreeGridNormalizeRecordsPipe_Factory(t) {\n    return new (t || IgxTreeGridNormalizeRecordsPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxTreeGridNormalizeRecordsPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"treeGridNormalizeRecord\",\n    type: IgxTreeGridNormalizeRecordsPipe,\n    pure: true\n  });\n  return IgxTreeGridNormalizeRecordsPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxTreeGridAddRowPipe = /*#__PURE__*/(() => {\n  class IgxTreeGridAddRowPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(collection, isPinned = false, _pipeTrigger) {\n      if (!this.grid.rowEditable || !this.grid.crudService.row || this.grid.crudService.row.getClassName() !== IgxAddRow.name || !this.grid.gridAPI.crudService.addRowParent || isPinned !== this.grid.gridAPI.crudService.addRowParent.isPinned) {\n        return collection;\n      }\n\n      const copy = collection.slice(0);\n      const rec = this.grid.crudService.row.recordRef;\n      copy.splice(this.grid.crudService.row.index, 0, rec);\n      this.grid.records.set(rec.key, rec);\n      return copy;\n    }\n\n  }\n\n  IgxTreeGridAddRowPipe.ɵfac = function IgxTreeGridAddRowPipe_Factory(t) {\n    return new (t || IgxTreeGridAddRowPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxTreeGridAddRowPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"treeGridAddRow\",\n    type: IgxTreeGridAddRowPipe,\n    pure: true\n  });\n  return IgxTreeGridAddRowPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxTreeGridFilteringPipe = /*#__PURE__*/(() => {\n  class IgxTreeGridFilteringPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(hierarchyData, expressionsTree, filterStrategy, advancedFilteringExpressionsTree, _, __, pinned) {\n      const state = {\n        expressionsTree,\n        advancedExpressionsTree: advancedFilteringExpressionsTree,\n        strategy: new TreeGridFilteringStrategy()\n      };\n\n      if (filterStrategy) {\n        state.strategy = filterStrategy;\n      }\n\n      if (FilteringExpressionsTree.empty(state.expressionsTree) && FilteringExpressionsTree.empty(state.advancedExpressionsTree)) {\n        this.grid.setFilteredData(null, pinned);\n        return hierarchyData;\n      }\n\n      const result = this.filter(hierarchyData, state, this.grid);\n      const filteredData = [];\n      this.expandAllRecursive(this.grid, result, this.grid.expansionStates, filteredData);\n      this.grid.setFilteredData(filteredData, pinned);\n      return result;\n    }\n\n    expandAllRecursive(grid, data, expandedStates, filteredData) {\n      for (const rec of data) {\n        filteredData.push(rec.data);\n\n        if (rec.children && rec.children.length > 0) {\n          expandedStates.set(rec.key, true);\n          this.expandAllRecursive(grid, rec.children, expandedStates, filteredData);\n        }\n      }\n    }\n\n    filter(data, state, grid) {\n      return state.strategy.filter(data, state.expressionsTree, state.advancedExpressionsTree, grid);\n    }\n\n  }\n\n  IgxTreeGridFilteringPipe.ɵfac = function IgxTreeGridFilteringPipe_Factory(t) {\n    return new (t || IgxTreeGridFilteringPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxTreeGridFilteringPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"treeGridFiltering\",\n    type: IgxTreeGridFilteringPipe,\n    pure: true\n  });\n  return IgxTreeGridFilteringPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxTreeGridSummaryPipe = /*#__PURE__*/(() => {\n  class IgxTreeGridSummaryPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(flatData, hasSummary, summaryCalculationMode, summaryPosition, showSummaryOnCollapse, _, __) {\n      if (!flatData || !hasSummary || summaryCalculationMode === GridSummaryCalculationMode.rootLevelOnly) {\n        return flatData;\n      }\n\n      return this.addSummaryRows(this.grid, flatData, summaryPosition, showSummaryOnCollapse);\n    }\n\n    addSummaryRows(grid, collection, summaryPosition, showSummaryOnCollapse) {\n      const recordsWithSummary = [];\n      const maxSummaryHeight = grid.summaryService.calcMaxSummaryHeight();\n\n      for (const record of collection) {\n        recordsWithSummary.push(record);\n        const isCollapsed = !record.expanded && record.children && record.children.length > 0 && showSummaryOnCollapse;\n\n        if (isCollapsed) {\n          let childData = record.children.filter(r => !r.isFilteredOutParent).map(r => r.data);\n          childData = this.removeDeletedRecord(grid, record.key, childData);\n          const summaries = grid.summaryService.calculateSummaries(record.key, childData);\n          const summaryRecord = {\n            summaries,\n            max: maxSummaryHeight,\n            cellIndentation: record.level + 1\n          };\n          recordsWithSummary.push(summaryRecord);\n        }\n\n        const isExpanded = record.children && record.children.length > 0 && record.expanded;\n\n        if (summaryPosition === GridSummaryPosition.bottom && !isExpanded) {\n          let childRecord = record;\n          let parent = record.parent;\n\n          while (parent) {\n            const children = parent.children;\n\n            if (children[children.length - 1] === childRecord) {\n              let childData = children.filter(r => !r.isFilteredOutParent).map(r => r.data);\n              childData = this.removeDeletedRecord(grid, parent.key, childData);\n              const summaries = grid.summaryService.calculateSummaries(parent.key, childData);\n              const summaryRecord = {\n                summaries,\n                max: maxSummaryHeight,\n                cellIndentation: parent.level + 1\n              };\n              recordsWithSummary.push(summaryRecord);\n              childRecord = parent;\n              parent = childRecord.parent;\n            } else {\n              break;\n            }\n          }\n        } else if (summaryPosition === GridSummaryPosition.top && isExpanded) {\n          let childData = record.children.filter(r => !r.isFilteredOutParent).map(r => r.data);\n          childData = this.removeDeletedRecord(grid, record.key, childData);\n          const summaries = grid.summaryService.calculateSummaries(record.key, childData);\n          const summaryRecord = {\n            summaries,\n            max: maxSummaryHeight,\n            cellIndentation: record.level + 1\n          };\n          recordsWithSummary.push(summaryRecord);\n        }\n      }\n\n      return recordsWithSummary;\n    }\n\n    removeDeletedRecord(grid, rowId, data) {\n      if (!grid.transactions.enabled || !grid.cascadeOnDelete) {\n        return data;\n      }\n\n      const deletedRows = grid.transactions.getTransactionLog().filter(t => t.type === 'delete').map(t => t.id);\n      let row = grid.records.get(rowId);\n\n      if (!row && deletedRows.lenght === 0) {\n        return [];\n      }\n\n      row = row.children ? row : row.parent;\n\n      while (row) {\n        rowId = row.key;\n\n        if (deletedRows.indexOf(rowId) !== -1) {\n          return [];\n        }\n\n        row = row.parent;\n      }\n\n      deletedRows.forEach(rowID => {\n        const tempData = grid.primaryKey ? data.map(rec => rec[grid.primaryKey]) : data;\n        const index = tempData.indexOf(rowID);\n\n        if (index !== -1) {\n          data.splice(index, 1);\n        }\n      });\n      return data;\n    }\n\n  }\n\n  IgxTreeGridSummaryPipe.ɵfac = function IgxTreeGridSummaryPipe_Factory(t) {\n    return new (t || IgxTreeGridSummaryPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxTreeGridSummaryPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"treeGridSummary\",\n    type: IgxTreeGridSummaryPipe,\n    pure: true\n  });\n  return IgxTreeGridSummaryPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$7 = 0;\n/**\n * **Ignite UI for Angular Tree Grid** -\n * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid/grid)\n *\n * The Ignite UI Tree Grid displays and manipulates hierarchical data with consistent schema formatted as a table and\n * provides features such as sorting, filtering, editing, column pinning, paging, column moving and hiding.\n *\n * Example:\n * ```html\n * <igx-tree-grid [data]=\"employeeData\" primaryKey=\"employeeID\" foreignKey=\"PID\" [autoGenerate]=\"false\">\n *   <igx-column field=\"first\" header=\"First Name\"></igx-column>\n *   <igx-column field=\"last\" header=\"Last Name\"></igx-column>\n *   <igx-column field=\"role\" header=\"Role\"></igx-column>\n * </igx-tree-grid>\n * ```\n */\n\nlet IgxTreeGridComponent = /*#__PURE__*/(() => {\n  class IgxTreeGridComponent extends IgxGridBaseDirective {\n    // Kind of stupid\n    // private get _gridAPI(): IgxTreeGridAPIService {\n    //     return this.gridAPI as IgxTreeGridAPIService;\n    // }\n    constructor(selectionService, colResizingService, gridAPI, // public gridAPI: GridBaseAPIService<IgxGridBaseDirective & GridType>,\n    transactionFactory, _elementRef, _zone, document, cdr, resolver, differs, viewRef, appRef, moduleRef, injector, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, localeId, platform, _diTransactions) {\n      super(selectionService, colResizingService, gridAPI, transactionFactory, _elementRef, _zone, document, cdr, resolver, differs, viewRef, appRef, moduleRef, injector, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, localeId, platform);\n      this.selectionService = selectionService;\n      this.colResizingService = colResizingService;\n      this.gridAPI = gridAPI;\n      this.transactionFactory = transactionFactory;\n      this.document = document;\n      this.cdr = cdr;\n      this.resolver = resolver;\n      this.differs = differs;\n      this.viewRef = viewRef;\n      this.navigation = navigation;\n      this.filteringService = filteringService;\n      this.overlayService = overlayService;\n      this.summaryService = summaryService;\n      this._displayDensityOptions = _displayDensityOptions;\n      this.platform = platform;\n      this._diTransactions = _diTransactions;\n      /**\n       * An @Input property indicating whether child records should be deleted when their parent gets deleted.\n       * By default it is set to true and deletes all children along with the parent.\n       * ```html\n       * <igx-tree-grid [data]=\"employeeData\" [primaryKey]=\"'employeeID'\" [foreignKey]=\"'parentID'\" cascadeOnDelete=\"false\">\n       * </igx-tree-grid>\n       * ```\n       *\n       * @memberof IgxTreeGridComponent\n       */\n\n      this.cascadeOnDelete = true;\n      /**\n       * @hidden @internal\n       */\n\n      this.role = 'treegrid';\n      /**\n       * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.\n       * ```html\n       * <igx-tree-grid [id]=\"'igx-tree-grid-1'\"></igx-tree-grid>\n       * ```\n       *\n       * @memberof IgxTreeGridComponent\n       */\n\n      this.id = `igx-tree-grid-${NEXT_ID$7++}`;\n      /**\n       * Returns a map of all `ITreeGridRecord`s.\n       * ```typescript\n       * // gets the record with primaryKey=2\n       * const states = this.grid.records.get(2);\n       * ```\n       *\n       * @memberof IgxTreeGridComponent\n       */\n\n      this.records = new Map();\n      /**\n       * Returns a map of all processed (filtered and sorted) `ITreeGridRecord`s.\n       * ```typescript\n       * // gets the processed record with primaryKey=2\n       * const states = this.grid.processedRecords.get(2);\n       * ```\n       *\n       * @memberof IgxTreeGridComponent\n       */\n\n      this.processedRecords = new Map();\n      /**\n       * @hidden\n       */\n\n      this.loadingRows = new Set();\n      this._filterStrategy = new TreeGridFilteringStrategy();\n      this._expansionDepth = Infinity;\n      this._filteredData = null;\n    }\n    /**\n     * An @Input property that lets you fill the `IgxTreeGridComponent` with an array of data.\n     * ```html\n     * <igx-tree-grid [data]=\"Data\" [autoGenerate]=\"true\"></igx-tree-grid>\n     * ```\n     *\n     * @memberof IgxTreeGridComponent\n     */\n\n\n    get data() {\n      return this._data;\n    }\n\n    set data(value) {\n      this._data = value || [];\n      this.summaryService.clearSummaryCache();\n\n      if (this.shouldGenerate) {\n        this.setupColumns();\n      }\n\n      this.cdr.markForCheck();\n    }\n    /**\n     * Returns an array of objects containing the filtered data in the `IgxGridComponent`.\n     * ```typescript\n     * let filteredData = this.grid.filteredData;\n     * ```\n     *\n     * @memberof IgxTreeGridComponent\n     */\n\n\n    get filteredData() {\n      return this._filteredData;\n    }\n    /**\n     * Sets an array of objects containing the filtered data in the `IgxGridComponent`.\n     * ```typescript\n     * this.grid.filteredData = [{\n     *       ID: 1,\n     *       Name: \"A\"\n     * }];\n     * ```\n     *\n     * @memberof IgxTreeGridComponent\n     */\n\n\n    set filteredData(value) {\n      this._filteredData = value;\n    }\n    /**\n     * Get transactions service for the grid.\n     *\n     * @experimental @hidden\n     */\n\n\n    get transactions() {\n      if (this._diTransactions && !this.batchEditing) {\n        return this._diTransactions;\n      }\n\n      return this._transactions;\n    }\n    /**\n     * An @Input property that sets the count of levels to be expanded in the `IgxTreeGridComponent`. By default it is\n     * set to `Infinity` which means all levels would be expanded.\n     * ```html\n     * <igx-tree-grid #grid [data]=\"employeeData\" [childDataKey]=\"'employees'\" expansionDepth=\"1\" [autoGenerate]=\"true\"></igx-tree-grid>\n     * ```\n     *\n     * @memberof IgxTreeGridComponent\n     */\n\n\n    get expansionDepth() {\n      return this._expansionDepth;\n    }\n\n    set expansionDepth(value) {\n      this._expansionDepth = value;\n      this.notifyChanges();\n    }\n    /**\n     * An @Input property that provides a template for the row loading indicator when load on demand is enabled.\n     * ```html\n     * <ng-template #rowLoadingTemplate>\n     *     <igx-icon>loop</igx-icon>\n     * </ng-template>\n     *\n     * <igx-tree-grid #grid [data]=\"employeeData\" [primaryKey]=\"'ID'\" [foreignKey]=\"'parentID'\"\n     *                [loadChildrenOnDemand]=\"loadChildren\"\n     *                [rowLoadingIndicatorTemplate]=\"rowLoadingTemplate\">\n     * </igx-tree-grid>\n     * ```\n     *\n     * @memberof IgxTreeGridComponent\n     */\n\n\n    get rowLoadingIndicatorTemplate() {\n      return this._rowLoadingIndicatorTemplate;\n    }\n\n    set rowLoadingIndicatorTemplate(value) {\n      this._rowLoadingIndicatorTemplate = value;\n      this.notifyChanges();\n    }\n    /**\n     * @deprecated in version 12.1.0. Use `getCellByColumn` or `getCellByKey` instead\n     *\n     * Returns a `CellType` object that matches the conditions.\n     *\n     * @example\n     * ```typescript\n     * const myCell = this.grid1.getCellByColumnVisibleIndex(2,\"UnitPrice\");\n     * ```\n     * @param rowIndex\n     * @param index\n     */\n\n\n    getCellByColumnVisibleIndex(rowIndex, index) {\n      const row = this.getRowByIndex(rowIndex);\n      const column = this.columnList.find(col => col.visibleIndex === index);\n\n      if (row && row instanceof IgxTreeGridRow && column) {\n        return new IgxGridCell(this, rowIndex, column.field);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      super.ngOnInit();\n      this.rowToggle.pipe(takeUntil(this.destroy$)).subscribe(args => {\n        this.loadChildrenOnRowExpansion(args);\n      }); // TODO: cascade selection logic should be refactor to be handled in the already existing subs\n\n      this.rowAddedNotifier.pipe(takeUntil(this.destroy$)).subscribe(args => {\n        if (this.rowSelection === GridSelectionMode.multipleCascade) {\n          let rec = this.gridAPI.get_rec_by_id(this.primaryKey ? args.data[this.primaryKey] : args.data);\n\n          if (rec && rec.parent) {\n            this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(new Set([rec.parent]), rec.parent.key);\n          } else {\n            // The record is still not available\n            // Wait for the change detection to update records through pipes\n            requestAnimationFrame(() => {\n              rec = this.gridAPI.get_rec_by_id(this.primaryKey ? args.data[this.primaryKey] : args.data);\n\n              if (rec && rec.parent) {\n                this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(new Set([rec.parent]), rec.parent.key);\n              }\n\n              this.notifyChanges();\n            });\n          }\n        }\n      });\n      this.rowDeletedNotifier.pipe(takeUntil(this.destroy$)).subscribe(args => {\n        if (this.rowSelection === GridSelectionMode.multipleCascade) {\n          if (args.data) {\n            const rec = this.gridAPI.get_rec_by_id(this.primaryKey ? args.data[this.primaryKey] : args.data);\n            this.handleCascadeSelection(args, rec);\n          } else {\n            // if a row has been added and before commiting the transaction deleted\n            const leafRowsDirectParents = new Set();\n            this.records.forEach(record => {\n              if (record && (!record.children || record.children.length === 0) && record.parent) {\n                leafRowsDirectParents.add(record.parent);\n              }\n            }); // Wait for the change detection to update records through pipes\n\n            requestAnimationFrame(() => {\n              this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(leafRowsDirectParents);\n              this.notifyChanges();\n            });\n          }\n        }\n      });\n      this.filteringDone.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        if (this.rowSelection === GridSelectionMode.multipleCascade) {\n          const leafRowsDirectParents = new Set();\n          this.records.forEach(record => {\n            if (record && (!record.children || record.children.length === 0) && record.parent) {\n              leafRowsDirectParents.add(record.parent);\n            }\n          });\n          this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(leafRowsDirectParents);\n          this.notifyChanges();\n        }\n      });\n    }\n\n    ngDoCheck() {\n      super.ngDoCheck();\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterViewInit() {\n      super.ngAfterViewInit(); // TODO: pipesExectured event\n      // run after change detection in super triggers pipes for records structure\n\n      if (this.rowSelection === GridSelectionMode.multipleCascade && this.selectedRows.length) {\n        const selRows = this.selectedRows;\n        this.selectionService.clearRowSelection();\n        this.selectRows(selRows, true);\n        this.cdr.detectChanges();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterContentInit() {\n      if (this.rowLoadingTemplate) {\n        this._rowLoadingIndicatorTemplate = this.rowLoadingTemplate.template;\n      }\n\n      super.ngAfterContentInit();\n    }\n\n    getDefaultExpandState(record) {\n      return record.children && record.children.length && record.level < this.expansionDepth;\n    }\n    /**\n     * Expands all rows.\n     * ```typescript\n     * this.grid.expandAll();\n     * ```\n     *\n     * @memberof IgxTreeGridComponent\n     */\n\n\n    expandAll() {\n      this._expansionDepth = Infinity;\n      this.expansionStates = new Map();\n    }\n    /**\n     * Collapses all rows.\n     *\n     * ```typescript\n     * this.grid.collapseAll();\n     *  ```\n     *\n     * @memberof IgxTreeGridComponent\n     */\n\n\n    collapseAll() {\n      this._expansionDepth = 0;\n      this.expansionStates = new Map();\n    }\n    /**\n     * @hidden\n     */\n\n\n    refreshGridState(args) {\n      super.refreshGridState();\n\n      if (this.primaryKey && this.foreignKey && args) {\n        const rowID = args.data[this.foreignKey];\n        this.summaryService.clearSummaryCache({\n          rowID\n        });\n        this.pipeTrigger++;\n        this.cdr.detectChanges();\n      }\n    }\n    /**\n     * Creates a new `IgxTreeGridRowComponent` with the given data. If a parentRowID is not specified, the newly created\n     * row would be added at the root level. Otherwise, it would be added as a child of the row whose primaryKey matches\n     * the specified parentRowID. If the parentRowID does not exist, an error would be thrown.\n     * ```typescript\n     * const record = {\n     *     ID: this.grid.data[this.grid1.data.length - 1].ID + 1,\n     *     Name: this.newRecord\n     * };\n     * this.grid.addRow(record, 1); // Adds a new child row to the row with ID=1.\n     * ```\n     *\n     * @param data\n     * @param parentRowID\n     * @memberof IgxTreeGridComponent\n     */\n    // TODO: remove evt emission\n\n\n    addRow(data, parentRowID) {\n      this.crudService.endEdit(true);\n      this.gridAPI.addRowToData(data, parentRowID);\n      this.rowAddedNotifier.next({\n        data\n      });\n      this.pipeTrigger++;\n      this.notifyChanges();\n    }\n    /**\n     * Enters add mode by spawning the UI with the context of the specified row by index.\n     *\n     * @remarks\n     * Accepted values for index are integers from 0 to this.grid.dataView.length\n     * @remarks\n     * When adding the row as a child, the parent row is the specified row.\n     * @remarks\n     * To spawn the UI on top, call the function with index = null or a negative number.\n     * In this case trying to add this row as a child will result in error.\n     * @example\n     * ```typescript\n     * this.grid.beginAddRowByIndex(10);\n     * this.grid.beginAddRowByIndex(10, true);\n     * this.grid.beginAddRowByIndex(null);\n     * ```\n     * @param index - The index to spawn the UI at. Accepts integers from 0 to this.grid.dataView.length\n     * @param asChild - Whether the record should be added as a child. Only applicable to igxTreeGrid.\n     */\n\n\n    beginAddRowByIndex(index, asChild) {\n      if (index === null || index < 0) {\n        return this.beginAddRowById(null, asChild);\n      }\n\n      return this._addRowForIndex(index - 1, asChild);\n    }\n    /**\n     * @hidden\n     */\n\n\n    getContext(rowData, rowIndex, pinned) {\n      return {\n        $implicit: this.isGhostRecord(rowData) ? rowData.recordRef : rowData,\n        index: this.getDataViewIndex(rowIndex, pinned),\n        templateID: {\n          type: this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow',\n          id: null\n        },\n        disabled: this.isGhostRecord(rowData) ? rowData.recordRef.isFilteredOutParent === undefined : false\n      };\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    getInitialPinnedIndex(rec) {\n      const id = this.gridAPI.get_row_id(rec);\n      return this._pinnedRecordIDs.indexOf(id);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    isRecordPinned(rec) {\n      return this.getInitialPinnedIndex(rec.data) !== -1;\n    }\n    /**\n     * @inheritdoc\n     */\n\n\n    getSelectedData(formatters = false, headers = false) {\n      let source = [];\n\n      const process = record => {\n        if (record.summaries) {\n          source.push(null);\n          return;\n        }\n\n        source.push(record.data);\n      };\n\n      this.unpinnedDataView.forEach(process);\n      source = this.isRowPinningToTop ? [...this.pinnedDataView, ...source] : [...source, ...this.pinnedDataView];\n      return this.extractDataFromSelection(source, formatters, headers);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    getEmptyRecordObjectFor(inTreeRow) {\n      const treeRowRec = (inTreeRow === null || inTreeRow === void 0 ? void 0 : inTreeRow.treeRow) || null;\n      const row = Object.assign({}, treeRowRec);\n      const data = (treeRowRec === null || treeRowRec === void 0 ? void 0 : treeRowRec.data) || {};\n      row.data = Object.assign({}, data);\n      Object.keys(row.data).forEach(key => {\n        // persist foreign key if one is set.\n        if (this.foreignKey && key === this.foreignKey) {\n          row.data[key] = treeRowRec.data[key];\n        } else {\n          row.data[key] = undefined;\n        }\n      });\n      let id = this.generateRowID();\n      const rootRecPK = this.foreignKey && this.rootRecords && this.rootRecords.length > 0 ? this.rootRecords[0].data[this.foreignKey] : null;\n\n      if (id === rootRecPK) {\n        // safeguard in case generated id matches the root foreign key.\n        id = this.generateRowID();\n      }\n\n      row.key = id;\n      row.data[this.primaryKey] = id;\n      return {\n        rowID: id,\n        data: row.data,\n        recordRef: row\n      };\n    }\n    /** @hidden */\n\n\n    deleteRowById(rowId) {\n      //  if this is flat self-referencing data, and CascadeOnDelete is set to true\n      //  and if we have transactions we should start pending transaction. This allows\n      //  us in case of delete action to delete all child rows as single undo action\n      return this.gridAPI.deleteRowById(rowId);\n    }\n    /**\n     * Returns the `IgxTreeGridRow` by index.\n     *\n     * @example\n     * ```typescript\n     * const myRow = treeGrid.getRowByIndex(1);\n     * ```\n     * @param index\n     */\n\n\n    getRowByIndex(index) {\n      if (index < 0 || index >= this.dataView.length) {\n        return undefined;\n      }\n\n      return this.createRow(index);\n    }\n    /**\n     * Returns the `RowType` object by the specified primary key.\n     *\n     * @example\n     * ```typescript\n     * const myRow = this.treeGrid.getRowByIndex(1);\n     * ```\n     * @param index\n     */\n\n\n    getRowByKey(key) {\n      const rec = this.filteredSortedData ? this.primaryKey ? this.filteredSortedData.find(r => r[this.primaryKey] === key) : this.filteredSortedData.find(r => r === key) : undefined;\n      const index = this.dataView.findIndex(r => r.data && r.data === rec);\n\n      if (index < 0 || index >= this.filteredSortedData.length) {\n        return undefined;\n      }\n\n      return new IgxTreeGridRow(this, index, rec);\n    }\n    /**\n     * Returns the collection of all RowType for current page.\n     *\n     * @hidden @internal\n     */\n\n\n    allRows() {\n      return this.dataView.map((rec, index) => this.createRow(index));\n    }\n    /**\n     * Returns the collection of `IgxTreeGridRow`s for current page.\n     *\n     * @hidden @internal\n     */\n\n\n    dataRows() {\n      return this.allRows().filter(row => row instanceof IgxTreeGridRow);\n    }\n    /**\n     * Returns an array of the selected `IgxGridCell`s.\n     *\n     * @example\n     * ```typescript\n     * const selectedCells = this.grid.selectedCells;\n     * ```\n     */\n\n\n    get selectedCells() {\n      return this.dataRows().map(row => row.cells.filter(cell => cell.selected)).reduce((a, b) => a.concat(b), []);\n    }\n    /**\n     * Returns a `CellType` object that matches the conditions.\n     *\n     * @example\n     * ```typescript\n     * const myCell = this.grid1.getCellByColumn(2, \"UnitPrice\");\n     * ```\n     * @param rowIndex\n     * @param columnField\n     */\n\n\n    getCellByColumn(rowIndex, columnField) {\n      const row = this.getRowByIndex(rowIndex);\n      const column = this.columnList.find(col => col.field === columnField);\n\n      if (row && row instanceof IgxTreeGridRow && column) {\n        return new IgxGridCell(this, rowIndex, columnField);\n      }\n    }\n    /**\n     * Returns a `CellType` object that matches the conditions.\n     *\n     * @remarks\n     * Requires that the primaryKey property is set.\n     * @example\n     * ```typescript\n     * grid.getCellByKey(1, 'index');\n     * ```\n     * @param rowSelector match any rowID\n     * @param columnField\n     */\n\n\n    getCellByKey(rowSelector, columnField) {\n      const row = this.getRowByKey(rowSelector);\n      const column = this.columnList.find(col => col.field === columnField);\n\n      if (row && column) {\n        return new IgxGridCell(this, row.index, columnField);\n      }\n    }\n\n    pinRow(rowID, index) {\n      const row = this.getRowByKey(rowID);\n      return super.pinRow(rowID, index, row);\n    }\n\n    unpinRow(rowID) {\n      const row = this.getRowByKey(rowID);\n      return super.unpinRow(rowID, row);\n    }\n    /** @hidden */\n\n\n    generateRowPath(rowId) {\n      const path = [];\n      let record = this.records.get(rowId);\n\n      while (record.parent) {\n        path.push(record.parent.key);\n        record = record.parent;\n      }\n\n      return path.reverse();\n    }\n    /** @hidden */\n\n\n    isTreeRow(record) {\n      return record.key !== undefined && record.data;\n    }\n    /** @hidden */\n\n\n    getUnpinnedIndexById(id) {\n      return this.unpinnedRecords.findIndex(x => x.data[this.primaryKey] === id);\n    }\n    /**\n     * @hidden\n     */\n\n\n    createRow(index, data) {\n      let row;\n\n      const dataIndex = this._getDataViewIndex(index);\n\n      const rec = data !== null && data !== void 0 ? data : this.dataView[dataIndex];\n\n      if (this.isSummaryRow(rec)) {\n        row = new IgxSummaryRow(this, index, rec.summaries, GridInstanceType.TreeGrid);\n      }\n\n      if (!row && rec) {\n        const isTreeRow = this.isTreeRow(rec);\n        const dataRec = isTreeRow ? rec.data : rec;\n        const treeRow = isTreeRow ? rec : undefined;\n        row = new IgxTreeGridRow(this, index, dataRec, treeRow);\n      }\n\n      return row;\n    }\n    /**\n     * Returns if the `IgxTreeGridComponent` has groupable columns.\n     *\n     * @example\n     * ```typescript\n     * const groupableGrid = this.grid.hasGroupableColumns;\n     * ```\n     */\n\n\n    get hasGroupableColumns() {\n      return this.columnList.some(col => col.groupable && !col.columnGroup);\n    }\n\n    generateDataFields(data) {\n      return super.generateDataFields(data).filter(field => field !== this.childDataKey);\n    }\n\n    transactionStatusUpdate(event) {\n      let actions = [];\n\n      if (event.origin === TransactionEventOrigin.REDO) {\n        actions = event.actions ? event.actions.filter(x => x.transaction.type === TransactionType.DELETE) : [];\n\n        if (this.rowSelection === GridSelectionMode.multipleCascade) {\n          this.handleCascadeSelection(event);\n        }\n      } else if (event.origin === TransactionEventOrigin.UNDO) {\n        actions = event.actions ? event.actions.filter(x => x.transaction.type === TransactionType.ADD) : [];\n\n        if (this.rowSelection === GridSelectionMode.multipleCascade) {\n          if (event.actions[0].transaction.type === 'add') {\n            const rec = this.gridAPI.get_rec_by_id(event.actions[0].transaction.id);\n            this.handleCascadeSelection(event, rec);\n          } else {\n            this.handleCascadeSelection(event);\n          }\n        }\n      }\n\n      if (actions.length) {\n        for (const action of actions) {\n          this.deselectChildren(action.transaction.id);\n        }\n      }\n\n      super.transactionStatusUpdate(event);\n    }\n\n    findRecordIndexInView(rec) {\n      return this.dataView.findIndex(x => x.data[this.primaryKey] === rec[this.primaryKey]);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    getDataBasedBodyHeight() {\n      return !this.flatData || this.flatData.length < this._defaultTargetRecordNumber ? 0 : this.defaultTargetBodyHeight;\n    }\n    /**\n     * @hidden\n     */\n\n\n    scrollTo(row, column) {\n      let delayScrolling = false;\n      let record;\n\n      if (typeof row !== 'number') {\n        const rowData = row;\n        const rowID = this.gridAPI.get_row_id(rowData);\n        record = this.processedRecords.get(rowID);\n        this.gridAPI.expand_path_to_record(record);\n\n        if (this.paginator) {\n          const rowIndex = this.processedExpandedFlatData.indexOf(rowData);\n          const page = Math.floor(rowIndex / this.paginator.perPage);\n\n          if (this.paginator.page !== page) {\n            delayScrolling = true;\n            this.paginator.page = page;\n          }\n        }\n      }\n\n      if (delayScrolling) {\n        this.verticalScrollContainer.dataChanged.pipe(first$1()).subscribe(() => {\n          this.scrollDirective(this.verticalScrollContainer, typeof row === 'number' ? row : this.unpinnedDataView.indexOf(record));\n        });\n      } else {\n        this.scrollDirective(this.verticalScrollContainer, typeof row === 'number' ? row : this.unpinnedDataView.indexOf(record));\n      }\n\n      this.scrollToHorizontally(column);\n    }\n\n    writeToData(rowIndex, value) {\n      mergeObjects(this.flatData[rowIndex], value);\n    }\n    /**\n     * @hidden\n     */\n\n\n    initColumns(collection, cb = null) {\n      if (this.hasColumnLayouts) {\n        // invalid configuration - tree grid should not allow column layouts\n        // remove column layouts\n        const nonColumnLayoutColumns = this.columnList.filter(col => !col.columnLayout && !col.columnLayoutChild);\n        this.columnList.reset(nonColumnLayoutColumns);\n      }\n\n      super.initColumns(collection, cb);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    getGroupAreaHeight() {\n      return this.groupArea ? this.getComputedHeight(this.groupArea.nativeElement) : 0;\n    }\n    /**\n     * @description A recursive way to deselect all selected children of a given record\n     * @param recordID ID of the record whose children to deselect\n     * @hidden\n     * @internal\n     */\n\n\n    deselectChildren(recordID) {\n      const selectedChildren = []; // G.E. Apr 28, 2021 #9465 Records which are not in view can also be selected so we need to\n      // deselect them as well, hence using 'records' map instead of getRowByKey() method which will\n      // return only row components (i.e. records in view).\n\n      const rowToDeselect = this.records.get(recordID);\n      this.selectionService.deselectRow(recordID);\n      this.gridAPI.get_selected_children(rowToDeselect, selectedChildren);\n\n      if (selectedChildren.length > 0) {\n        selectedChildren.forEach(x => this.deselectChildren(x));\n      }\n    }\n\n    addChildRows(children, parentID) {\n      if (this.primaryKey && this.foreignKey) {\n        for (const child of children) {\n          child[this.foreignKey] = parentID;\n        }\n\n        this.data.push(...children);\n      } else if (this.childDataKey) {\n        let parent = this.records.get(parentID);\n        let parentData = parent.data;\n\n        if (this.transactions.enabled && this.transactions.getAggregatedChanges(true).length) {\n          const path = [];\n\n          while (parent) {\n            path.push(parent.key);\n            parent = parent.parent;\n          }\n\n          let collection = this.data;\n          let record;\n\n          for (let i = path.length - 1; i >= 0; i--) {\n            const pid = path[i];\n            record = collection.find(r => r[this.primaryKey] === pid);\n\n            if (!record) {\n              break;\n            }\n\n            collection = record[this.childDataKey];\n          }\n\n          if (record) {\n            parentData = record;\n          }\n        }\n\n        parentData[this.childDataKey] = children;\n      }\n\n      this.selectionService.clearHeaderCBState();\n      this.pipeTrigger++;\n\n      if (this.rowSelection === GridSelectionMode.multipleCascade) {\n        // Force pipe triggering for building the data structure\n        this.cdr.detectChanges();\n\n        if (this.selectionService.isRowSelected(parentID)) {\n          this.selectionService.rowSelection.delete(parentID);\n          this.selectionService.selectRowsWithNoEvent([parentID]);\n        }\n      }\n    }\n\n    loadChildrenOnRowExpansion(args) {\n      if (this.loadChildrenOnDemand) {\n        const parentID = args.rowID;\n\n        if (args.expanded && !this._expansionStates.has(parentID)) {\n          this.loadingRows.add(parentID);\n          this.loadChildrenOnDemand(parentID, children => {\n            this.loadingRows.delete(parentID);\n            this.addChildRows(children, parentID);\n            this.notifyChanges();\n          });\n        }\n      }\n    }\n\n    handleCascadeSelection(event, rec = null) {\n      // Wait for the change detection to update records through the pipes\n      requestAnimationFrame(() => {\n        if (rec === null) {\n          rec = this.gridAPI.get_rec_by_id(event.actions[0].transaction.id);\n        }\n\n        if (rec && rec.parent) {\n          this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(new Set([rec.parent]), rec.parent.key);\n          this.notifyChanges();\n        }\n      });\n    }\n\n  }\n\n  IgxTreeGridComponent.ɵfac = function IgxTreeGridComponent_Factory(t) {\n    return new (t || IgxTreeGridComponent)(i0.ɵɵdirectiveInject(IgxGridSelectionService), i0.ɵɵdirectiveInject(IgxColumnResizingService), i0.ɵɵdirectiveInject(IGX_GRID_SERVICE_BASE), i0.ɵɵdirectiveInject(IgxHierarchicalTransactionFactory), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ApplicationRef), i0.ɵɵdirectiveInject(i0.NgModuleRef), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(IgxGridNavigationService), i0.ɵɵdirectiveInject(IgxFilteringService), i0.ɵɵdirectiveInject(IgxOverlayService), i0.ɵɵdirectiveInject(IgxGridSummaryService), i0.ɵɵdirectiveInject(DisplayDensityToken, 8), i0.ɵɵdirectiveInject(LOCALE_ID), i0.ɵɵdirectiveInject(PlatformUtil), i0.ɵɵdirectiveInject(IgxGridTransaction, 8));\n  };\n\n  IgxTreeGridComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxTreeGridComponent,\n    selectors: [[\"igx-tree-grid\"]],\n    contentQueries: function IgxTreeGridComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxTreeGridGroupByAreaComponent, 5, IgxTreeGridGroupByAreaComponent);\n        i0.ɵɵcontentQuery(dirIndex, IgxRowLoadingIndicatorTemplateDirective, 5, IgxRowLoadingIndicatorTemplateDirective);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.groupArea = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.rowLoadingTemplate = _t.first);\n      }\n    },\n    viewQuery: function IgxTreeGridComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c192, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c216, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c219, 7, TemplateRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dragIndicatorIconBase = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.recordTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.summaryTemplate = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function IgxTreeGridComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"id\", ctx.id);\n      }\n    },\n    inputs: {\n      childDataKey: \"childDataKey\",\n      foreignKey: \"foreignKey\",\n      hasChildrenKey: \"hasChildrenKey\",\n      cascadeOnDelete: \"cascadeOnDelete\",\n      loadChildrenOnDemand: \"loadChildrenOnDemand\",\n      id: \"id\",\n      data: \"data\",\n      expansionDepth: \"expansionDepth\",\n      rowLoadingIndicatorTemplate: \"rowLoadingIndicatorTemplate\"\n    },\n    features: [i0.ɵɵProvidersFeature([IgxGridCRUDService, IgxGridSummaryService, IgxGridNavigationService, {\n      provide: IgxGridSelectionService,\n      useClass: IgxTreeGridSelectionService\n    }, {\n      provide: IGX_GRID_SERVICE_BASE,\n      useClass: IgxTreeGridAPIService\n    }, {\n      provide: IGX_GRID_BASE,\n      useExisting: IgxTreeGridComponent\n    }, IgxFilteringService, IgxForOfSyncService, IgxForOfScrollSyncService]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c238,\n    decls: 88,\n    vars: 144,\n    consts: [[\"tabindex\", \"0\", 1, \"igx-grid-thead\", 3, \"grid\", \"hasMRL\", \"activeDescendant\", \"width\", \"pinnedColumnCollection\", \"unpinnedColumnCollection\", \"keydown.meta.c\", \"keydown.control.c\", \"copy\", \"keydown\", \"focus\"], [\"igxGridBody\", \"\", \"role\", \"rowgroup\", 1, \"igx-grid__tbody\", 3, \"keydown.control.c\", \"copy\"], [\"tabindex\", \"0\", 1, \"igx-grid__tbody-content\", 3, \"igxGridDragSelect\", \"focus\", \"keydown\", \"dragStop\", \"dragScroll\", \"scroll\"], [\"tbody\", \"\"], [\"id\", \"left\", \"class\", \"igx-grid__scroll-on-drag-left\", 3, \"igxColumnMovingDrop\", 4, \"ngIf\"], [\"id\", \"left\", \"class\", \"igx-grid__scroll-on-drag-pinned\", 3, \"igxColumnMovingDrop\", \"left\", 4, \"ngIf\"], [\"pinnedRecordsTemplate\", \"\"], [4, \"ngTemplateOutlet\"], [\"igxGridFor\", \"\", 3, \"igxGridForOf\", \"igxForScrollOrientation\", \"igxForScrollContainer\", \"igxForContainerSize\", \"igxForItemSize\", \"dataChanging\", \"dataChanged\"], [\"verticalScrollContainer\", \"\"], [\"record_template\", \"\"], [\"pinned_record_template\", \"\"], [\"summary_template\", \"\"], [\"igxOverlayOutlet\", \"\", 1, \"igx-grid__row-editing-outlet\"], [\"igxRowEditingOverlayOutlet\", \"\"], [\"igxToggle\", \"\"], [\"loadingOverlay\", \"\"], [3, \"indeterminate\", 4, \"ngIf\"], [\"id\", \"right\", \"class\", \"igx-grid__scroll-on-drag-right\", 3, \"igxColumnMovingDrop\", 4, \"ngIf\"], [1, \"igx-grid__tbody-scrollbar\", 3, \"hidden\", \"pointerdown\"], [1, \"igx-grid__tbody-scrollbar-start\"], [1, \"igx-grid__tbody-scrollbar-main\"], [\"igxGridFor\", \"\", 3, \"igxGridForOf\"], [\"verticalScrollHolder\", \"\"], [1, \"igx-grid__tbody-scrollbar-end\"], [1, \"igx-grid__addrow-snackbar\"], [3, \"outlet\", \"actionText\", \"displayTime\"], [\"addRowSnackbar\", \"\"], [\"igxOverlayOutlet\", \"\"], [\"igxBodyOverlayOutlet\", \"overlay-outlet\"], [\"role\", \"rowgroup\", 1, \"igx-grid__tfoot\"], [\"tfoot\", \"\"], [\"tabindex\", \"0\", 3, \"focus\", \"keydown\"], [\"role\", \"row\", \"class\", \"igx-grid__summaries\", 3, \"width\", \"height\", \"gridID\", \"summaries\", \"index\", 4, \"ngIf\"], [1, \"igx-grid__tfoot-thumb\", 3, \"hidden\"], [1, \"igx-grid__scroll\", 3, \"hidden\", \"pointerdown\"], [\"scr\", \"\"], [1, \"igx-grid__scroll-start\"], [1, \"igx-grid__scroll-main\"], [\"scrollContainer\", \"\"], [1, \"igx-grid__scroll-end\", 3, \"hidden\"], [1, \"igx-grid__footer\"], [\"footer\", \"\"], [4, \"ngIf\"], [\"emptyFilteredGrid\", \"\"], [\"defaultEmptyGrid\", \"\"], [\"defaultAddRowEmptyTemplate\", \"\"], [\"defaultLoadingGrid\", \"\"], [\"igxToggle\", \"\", 4, \"ngIf\"], [\"defaultRowEditText\", \"\"], [\"defaultRowEditActions\", \"\"], [\"defaultRowEditTemplate\", \"\"], [\"dragIndicatorIconBase\", \"\"], [\"igxOverlayOutlet\", \"\", 1, \"igx-grid__loading-outlet\"], [\"igxLoadingOverlayOutlet\", \"\"], [\"igxOverlayOutlet\", \"\", 1, \"igx-grid__outlet\"], [\"igxFilteringOverlayOutlet\", \"\"], [\"id\", \"left\", 1, \"igx-grid__scroll-on-drag-left\", 3, \"igxColumnMovingDrop\"], [\"id\", \"left\", 1, \"igx-grid__scroll-on-drag-pinned\", 3, \"igxColumnMovingDrop\"], [\"class\", \"igx-grid__tr--pinned\", 3, \"ngClass\", \"width\", 4, \"ngIf\"], [1, \"igx-grid__tr--pinned\", 3, \"ngClass\"], [\"pinContainer\", \"\"], [4, \"ngFor\", \"ngForOf\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [3, \"igxTemplateOutlet\", \"igxTemplateOutletContext\", \"cachedViewLoaded\"], [3, \"gridID\", \"index\", \"treeRow\", \"disabled\", \"ngClass\", \"ngStyle\"], [\"row\", \"\"], [3, \"gridID\", \"index\", \"treeRow\", \"ngClass\", \"ngStyle\"], [\"row\", \"\", \"pinnedRow\", \"\"], [\"role\", \"row\", 1, \"igx-grid__summaries--body\", 3, \"gridID\", \"summaries\", \"firstCellIndentation\", \"index\"], [\"summaryRow\", \"\"], [3, \"indeterminate\"], [\"id\", \"right\", 1, \"igx-grid__scroll-on-drag-right\", 3, \"igxColumnMovingDrop\"], [\"role\", \"row\", 1, \"igx-grid__summaries\", 3, \"gridID\", \"summaries\", \"index\"], [\"role\", \"cell\", 1, \"igx-grid__tbody-message\"], [\"igxButton\", \"raised\", \"igxRipple\", \"\", 3, \"click\"], [1, \"igx-grid__loading\"], [\"rowEditingOverlay\", \"\"], [3, \"className\"], [\"igxButton\", \"\", \"igxRowEditTabStop\", \"\", 3, \"click\"], [1, \"igx-banner__message\"], [1, \"igx-banner__text\"], [1, \"igx-banner__actions\"], [1, \"igx-banner__row\"]],\n    template: function IgxTreeGridComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c237);\n        i0.ɵɵprojection(0);\n        i0.ɵɵprojection(1, 1);\n        i0.ɵɵelementStart(2, \"igx-grid-header-row\", 0);\n        i0.ɵɵlistener(\"keydown.meta.c\", function IgxTreeGridComponent_Template_igx_grid_header_row_keydown_meta_c_2_listener($event) {\n          return ctx.copyHandler($event);\n        })(\"keydown.control.c\", function IgxTreeGridComponent_Template_igx_grid_header_row_keydown_control_c_2_listener($event) {\n          return ctx.copyHandler($event);\n        })(\"copy\", function IgxTreeGridComponent_Template_igx_grid_header_row_copy_2_listener($event) {\n          return ctx.copyHandler($event);\n        })(\"keydown\", function IgxTreeGridComponent_Template_igx_grid_header_row_keydown_2_listener($event) {\n          return ctx.navigation.headerNavigation($event);\n        })(\"focus\", function IgxTreeGridComponent_Template_igx_grid_header_row_focus_2_listener() {\n          return ctx.navigation.focusFirstCell();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"div\", 1);\n        i0.ɵɵlistener(\"keydown.control.c\", function IgxTreeGridComponent_Template_div_keydown_control_c_3_listener($event) {\n          return ctx.copyHandler($event);\n        })(\"copy\", function IgxTreeGridComponent_Template_div_copy_3_listener($event) {\n          return ctx.copyHandler($event);\n        });\n        i0.ɵɵelementStart(4, \"div\", 2, 3);\n        i0.ɵɵlistener(\"focus\", function IgxTreeGridComponent_Template_div_focus_4_listener($event) {\n          return ctx.navigation.focusTbody($event);\n        })(\"keydown\", function IgxTreeGridComponent_Template_div_keydown_4_listener($event) {\n          return ctx.navigation.handleNavigation($event);\n        })(\"dragStop\", function IgxTreeGridComponent_Template_div_dragStop_4_listener($event) {\n          return ctx.selectionService.dragMode = $event;\n        })(\"dragScroll\", function IgxTreeGridComponent_Template_div_dragScroll_4_listener($event) {\n          return ctx.dragScroll($event);\n        })(\"scroll\", function IgxTreeGridComponent_Template_div_scroll_4_listener($event) {\n          return ctx.preventContainerScroll($event);\n        });\n        i0.ɵɵtemplate(6, IgxTreeGridComponent_span_6_Template, 1, 2, \"span\", 4);\n        i0.ɵɵtemplate(7, IgxTreeGridComponent_span_7_Template, 1, 4, \"span\", 5);\n        i0.ɵɵtemplate(8, IgxTreeGridComponent_ng_template_8_Template, 8, 45, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(10, IgxTreeGridComponent_ng_container_10_Template, 1, 0, \"ng-container\", 7);\n        i0.ɵɵtemplate(11, IgxTreeGridComponent_ng_template_11_Template, 1, 2, \"ng-template\", 8, 9, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵpipe(13, \"gridRowPinning\");\n        i0.ɵɵpipe(14, \"treeGridAddRow\");\n        i0.ɵɵpipe(15, \"treeGridSummary\");\n        i0.ɵɵpipe(16, \"treeGridPaging\");\n        i0.ɵɵpipe(17, \"treeGridFlattening\");\n        i0.ɵɵpipe(18, \"treeGridSorting\");\n        i0.ɵɵpipe(19, \"treeGridFiltering\");\n        i0.ɵɵpipe(20, \"treeGridHierarchizing\");\n        i0.ɵɵpipe(21, \"visibleColumns\");\n        i0.ɵɵpipe(22, \"treeGridTransaction\");\n        i0.ɵɵlistener(\"dataChanging\", function IgxTreeGridComponent_Template_ng_template_dataChanging_11_listener($event) {\n          return ctx.dataRebinding($event);\n        })(\"dataChanged\", function IgxTreeGridComponent_Template_ng_template_dataChanged_11_listener($event) {\n          return ctx.dataRebound($event);\n        });\n        i0.ɵɵtemplate(23, IgxTreeGridComponent_ng_container_23_Template, 1, 0, \"ng-container\", 7);\n        i0.ɵɵtemplate(24, IgxTreeGridComponent_ng_template_24_Template, 4, 37, \"ng-template\", null, 10, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(26, IgxTreeGridComponent_ng_template_26_Template, 5, 36, \"ng-template\", null, 11, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(28, IgxTreeGridComponent_ng_template_28_Template, 2, 4, \"ng-template\", null, 12, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(30, IgxTreeGridComponent_ng_container_30_Template, 1, 0, \"ng-container\", 7);\n        i0.ɵɵelement(31, \"div\", 13, 14)(33, \"igc-trial-watermark\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(34, \"div\", 15, 16);\n        i0.ɵɵtemplate(36, IgxTreeGridComponent_igx_circular_bar_36_Template, 1, 1, \"igx-circular-bar\", 17);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(37, IgxTreeGridComponent_span_37_Template, 1, 2, \"span\", 18);\n        i0.ɵɵelementStart(38, \"div\", 19);\n        i0.ɵɵlistener(\"pointerdown\", function IgxTreeGridComponent_Template_div_pointerdown_38_listener($event) {\n          return $event.preventDefault();\n        });\n        i0.ɵɵelement(39, \"div\", 20);\n        i0.ɵɵelementStart(40, \"div\", 21);\n        i0.ɵɵtemplate(41, IgxTreeGridComponent_ng_template_41_Template, 0, 0, \"ng-template\", 22, 23, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(43, \"div\", 24);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(44, \"div\", 25)(45, \"igx-snackbar\", 26, 27);\n        i0.ɵɵtext(47);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelement(48, \"div\", 28, 29);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(50, \"div\", 30, 31)(52, \"div\", 32);\n        i0.ɵɵlistener(\"focus\", function IgxTreeGridComponent_Template_div_focus_52_listener() {\n          return ctx.navigation.focusFirstCell(false);\n        })(\"keydown\", function IgxTreeGridComponent_Template_div_keydown_52_listener($event) {\n          return ctx.navigation.summaryNav($event);\n        });\n        i0.ɵɵtemplate(53, IgxTreeGridComponent_igx_grid_summary_row_53_Template, 3, 10, \"igx-grid-summary-row\", 33);\n        i0.ɵɵelement(54, \"div\", 34);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(55, \"div\", 35, 36);\n        i0.ɵɵlistener(\"pointerdown\", function IgxTreeGridComponent_Template_div_pointerdown_55_listener($event) {\n          return $event.preventDefault();\n        });\n        i0.ɵɵelement(57, \"div\", 37);\n        i0.ɵɵelementStart(58, \"div\", 38);\n        i0.ɵɵtemplate(59, IgxTreeGridComponent_ng_template_59_Template, 0, 0, \"ng-template\", 22, 39, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(61, \"div\", 40);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(62, \"div\", 41, 42);\n        i0.ɵɵprojection(64, 2);\n        i0.ɵɵtemplate(65, IgxTreeGridComponent_ng_container_65_Template, 2, 0, \"ng-container\", 43);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(66, IgxTreeGridComponent_ng_template_66_Template, 4, 2, \"ng-template\", null, 44, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(68, IgxTreeGridComponent_ng_template_68_Template, 4, 2, \"ng-template\", null, 45, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(70, IgxTreeGridComponent_ng_template_70_Template, 2, 1, \"ng-template\", null, 46, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(72, IgxTreeGridComponent_ng_template_72_Template, 2, 1, \"ng-template\", null, 47, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(74, IgxTreeGridComponent_div_74_Template, 4, 6, \"div\", 48);\n        i0.ɵɵtemplate(75, IgxTreeGridComponent_ng_template_75_Template, 1, 1, \"ng-template\", null, 49, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(77, IgxTreeGridComponent_ng_template_77_Template, 4, 2, \"ng-template\", null, 50, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(79, IgxTreeGridComponent_ng_template_79_Template, 6, 8, \"ng-template\", null, 51, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(81, IgxTreeGridComponent_ng_template_81_Template, 2, 0, \"ng-template\", null, 52, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(83, IgxTreeGridComponent_igx_grid_column_resizer_83_Template, 1, 0, \"igx-grid-column-resizer\", 43);\n        i0.ɵɵelement(84, \"div\", 53, 54)(86, \"div\", 55, 56);\n      }\n\n      if (rf & 2) {\n        const _r3 = i0.ɵɵreference(9);\n\n        const _r23 = i0.ɵɵreference(49);\n\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"grid\", ctx)(\"hasMRL\", ctx.hasColumnLayouts)(\"activeDescendant\", ctx.activeDescendant)(\"width\", ctx.calcWidth)(\"pinnedColumnCollection\", ctx.pinnedColumns)(\"unpinnedColumnCollection\", ctx.unpinnedColumns);\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"height\", ctx.totalHeight, \"px\")(\"width\", ctx.calcWidth, \"px\");\n        i0.ɵɵproperty(\"igxGridDragSelect\", ctx.selectionService.dragMode);\n        i0.ɵɵattribute(\"aria-activedescendant\", ctx.activeDescendant)(\"role\", ctx.dataView.length ? null : \"row\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.moving && ctx.columnInDrag && ctx.pinnedColumns.length <= 0);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.moving && ctx.columnInDrag && ctx.pinnedColumns.length > 0);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.hasPinnedRecords && ctx.isRowPinningToTop ? _r3 : null);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"igxGridForOf\", i0.ɵɵpipeBind4(13, 70, i0.ɵɵpipeBind3(14, 75, i0.ɵɵpipeBindV(15, 79, i0.ɵɵpureFunction7(134, _c214, i0.ɵɵpipeBind4(16, 87, i0.ɵɵpipeBind4(17, 92, i0.ɵɵpipeBind4(18, 97, i0.ɵɵpipeBindV(19, 102, i0.ɵɵpureFunction6(127, _c215, i0.ɵɵpipeBindV(20, 109, i0.ɵɵpureFunction5(121, _c71, i0.ɵɵpipeBind2(21, 115, i0.ɵɵpipeBind2(22, 118, ctx.data, ctx.pipeTrigger), ctx.hasVisibleColumns), ctx.primaryKey, ctx.foreignKey, ctx.childDataKey, ctx.pipeTrigger)), ctx.filteringExpressionsTree, ctx.filterStrategy, ctx.advancedFilteringExpressionsTree, ctx.pipeTrigger, ctx.filteringPipeTrigger)), ctx.sortingExpressions, ctx.sortStrategy, ctx.pipeTrigger), ctx.expansionDepth, ctx.expansionStates, ctx.pipeTrigger), ctx.paginator == null ? null : ctx.paginator.page, ctx.paginator == null ? null : ctx.paginator.perPage, ctx.pipeTrigger), ctx.hasSummarizedColumns, ctx.summaryCalculationMode, ctx.summaryPosition, ctx.showSummaryOnCollapse, ctx.pipeTrigger, ctx.summaryPipeTrigger)), false, ctx.pipeTrigger), ctx.id, false, ctx.pipeTrigger))(\"igxForScrollOrientation\", \"vertical\")(\"igxForScrollContainer\", ctx.verticalScroll)(\"igxForContainerSize\", ctx.calcHeight)(\"igxForItemSize\", ctx.renderedRowHeight);\n        i0.ɵɵadvance(12);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.hasPinnedRecords && !ctx.isRowPinningToTop ? _r3 : null);\n        i0.ɵɵadvance(7);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template);\n        i0.ɵɵadvance(6);\n        i0.ɵɵproperty(\"ngIf\", ctx.shouldOverlayLoading);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.moving && ctx.columnInDrag);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.scrollSize, \"px\")(\"height\", ctx.calcHeight, \"px\");\n        i0.ɵɵproperty(\"hidden\", !ctx.hasVerticalScroll());\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"height\", ctx.isRowPinningToTop ? ctx.pinnedRowHeight : 0, \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"height\", ctx.calcHeight, \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"igxGridForOf\", i0.ɵɵpureFunction0(142, _c115));\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"height\", !ctx.isRowPinningToTop ? ctx.pinnedRowHeight : 0, \"px\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"outlet\", _r23)(\"actionText\", ctx.resourceStrings.igx_grid_snackbar_addrow_actiontext)(\"displayTime\", ctx.snackbarDisplayTime);\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate(ctx.resourceStrings.igx_grid_snackbar_addrow_label);\n        i0.ɵɵadvance(3);\n        i0.ɵɵstyleProp(\"height\", ctx.summaryRowHeight, \"px\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵattribute(\"aria-activedescendant\", ctx.activeDescendant);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasSummarizedColumns && ctx.rootSummariesEnabled);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"height\", ctx.summaryRowHeight, \"px\")(\"width\", ctx.scrollSize, \"px\");\n        i0.ɵɵproperty(\"hidden\", !ctx.hasVerticalScroll());\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"height\", ctx.scrollSize, \"px\");\n        i0.ɵɵproperty(\"hidden\", ctx.isHorizontalScrollHidden);\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"width\", ctx.isPinningToStart ? ctx.pinnedWidth : ctx.headerFeaturesWidth, \"px\")(\"min-width\", ctx.isPinningToStart ? ctx.pinnedWidth : ctx.headerFeaturesWidth, \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.unpinnedWidth, \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"igxGridForOf\", i0.ɵɵpureFunction0(143, _c115));\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"float\", \"right\")(\"width\", ctx.pinnedWidth, \"px\")(\"min-width\", ctx.pinnedWidth, \"px\");\n        i0.ɵɵproperty(\"hidden\", ctx.pinnedWidth === 0 || ctx.isPinningToStart);\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"ngIf\", ctx.totalRecords || ctx.pagingMode === 1);\n        i0.ɵɵadvance(9);\n        i0.ɵɵproperty(\"ngIf\", ctx.rowEditable);\n        i0.ɵɵadvance(9);\n        i0.ɵɵproperty(\"ngIf\", ctx.colResizingService.showResizer);\n      }\n    },\n    directives: [IgxGridHeaderRowComponent, IgxTreeGridRowComponent, IgxSummaryRowComponent, IgxCircularProgressBarComponent, IgxSnackbarComponent, IgxIconComponent, IgxGridColumnResizerComponent, IgxGridBodyDirective, IgxGridDragSelectDirective, i4.NgIf, IgxColumnMovingDropDirective, i4.NgClass, i4.NgForOf, i4.NgTemplateOutlet, IgxGridForOfDirective, IgxTemplateOutletDirective, i4.NgStyle, IgxOverlayOutletDirective, IgxToggleDirective, IgxButtonDirective, IgxRippleDirective, IgxRowEditTabStopDirective],\n    pipes: [IgxTreeGridSortingPipe, IgxTreeGridFilteringPipe, IgxGridRowPinningPipe, IgxTreeGridAddRowPipe, IgxTreeGridNormalizeRecordsPipe, IgxHasVisibleColumnsPipe, IgxTreeGridTransactionPipe, IgxTreeGridSummaryPipe, IgxTreeGridPagingPipe, IgxTreeGridFlatteningPipe, IgxTreeGridHierarchizingPipe, IgxGridRowClassesPipe, IgxGridRowStylesPipe, IgxSummaryDataPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxTreeGridComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst HIDDEN_FIELD_NAME = '_Igx_Hidden_Data_';\n/**\n * @hidden\n * @internal\n */\n\nclass GroupByRecord {}\n\nclass ITreeGridAggregation {}\n\nlet IgxGroupedTreeGridSorting = /*#__PURE__*/(() => {\n  class IgxGroupedTreeGridSorting extends IgxSorting {\n    static instance() {\n      return this._instance || (this._instance = new IgxGroupedTreeGridSorting());\n    }\n\n    getFieldValue(obj, key, isDate = false, isTime = false) {\n      const data = obj.data[HIDDEN_FIELD_NAME] ? obj.data.hasOwnProperty(key) ? obj.data : obj.data[HIDDEN_FIELD_NAME] : obj.data;\n      return super.getFieldValue(data, key, isDate, isTime);\n    }\n\n  }\n\n  IgxGroupedTreeGridSorting._instance = null;\n  /** @hidden */\n\n  return IgxGroupedTreeGridSorting;\n})();\nlet IgxTreeGridGroupingPipe = /*#__PURE__*/(() => {\n  class IgxTreeGridGroupingPipe {\n    transform(collection, groupingExpressions, groupKey, childDataKey, grid, aggregations) {\n      if (groupingExpressions.length === 0) {\n        return collection;\n      }\n\n      if ((groupKey === null || groupKey === void 0 ? void 0 : groupKey.toLowerCase()) === (childDataKey === null || childDataKey === void 0 ? void 0 : childDataKey.toLowerCase())) {\n        throw new Error('Group key and child data key cannot be the same.');\n      }\n\n      this.grid = grid;\n      const result = [];\n      const groupedRecords = this.groupByMultiple(collection, groupingExpressions);\n      this.flattenGrouping(groupedRecords, groupKey, childDataKey, result, aggregations);\n      return result;\n    }\n\n    flattenGrouping(groupRecords, groupKey, childDataKey, data, aggregations = []) {\n      for (const groupRecord of groupRecords) {\n        const parent = {};\n        const children = groupRecord.records;\n        parent[childDataKey] = [];\n\n        for (const aggregation of aggregations) {\n          parent[aggregation.field] = aggregation.aggregate(parent, children);\n        }\n\n        parent[groupKey] = groupRecord.value + ` (${groupRecord.records.length})`;\n        parent[HIDDEN_FIELD_NAME] = {\n          [groupRecord.key]: groupRecord.value\n        };\n        data.push(parent);\n\n        if (groupRecord.groups) {\n          this.flattenGrouping(groupRecord.groups, groupKey, childDataKey, parent[childDataKey], aggregations);\n        } else {\n          parent[childDataKey] = children;\n        }\n      }\n    }\n\n    groupByMultiple(array, groupingExpressions, index = 0) {\n      const res = this.groupBy(array, groupingExpressions[index]);\n\n      if (index + 1 < groupingExpressions.length) {\n        for (const groupByRecord of res) {\n          groupByRecord.groups = this.groupByMultiple(groupByRecord.records, groupingExpressions, index + 1);\n        }\n      }\n\n      return res;\n    }\n\n    groupBy(array, groupingExpression) {\n      var _a;\n\n      const key = groupingExpression.fieldName;\n      const column = (_a = this.grid) === null || _a === void 0 ? void 0 : _a.getColumnByName(key);\n      const isDateTime = (column === null || column === void 0 ? void 0 : column.dataType) === GridColumnDataType.Date || (column === null || column === void 0 ? void 0 : column.dataType) === GridColumnDataType.DateTime || (column === null || column === void 0 ? void 0 : column.dataType) === GridColumnDataType.Time;\n      const map = new Map();\n\n      for (const record of array) {\n        const value = isDateTime ? formatDate(record[key], column.pipeArgs.format, this.grid.locale) : record[key];\n        let valueCase = value;\n        let groupByRecord;\n\n        if (groupingExpression.ignoreCase) {\n          valueCase = value === null || value === void 0 ? void 0 : value.toString().toLowerCase();\n        }\n\n        if (map.has(valueCase)) {\n          groupByRecord = map.get(valueCase);\n        } else {\n          groupByRecord = new GroupByRecord();\n          groupByRecord.key = key;\n          groupByRecord.value = value;\n          groupByRecord.records = [];\n          map.set(valueCase, groupByRecord);\n        }\n\n        groupByRecord.records.push(record);\n      }\n\n      return Array.from(map.values());\n    }\n\n  }\n\n  IgxTreeGridGroupingPipe.ɵfac = function IgxTreeGridGroupingPipe_Factory(t) {\n    return new (t || IgxTreeGridGroupingPipe)();\n  };\n\n  IgxTreeGridGroupingPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"treeGridGrouping\",\n    type: IgxTreeGridGroupingPipe,\n    pure: true\n  });\n  return IgxTreeGridGroupingPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxTreeGridModule = /*#__PURE__*/(() => {\n  class IgxTreeGridModule {}\n\n  IgxTreeGridModule.ɵfac = function IgxTreeGridModule_Factory(t) {\n    return new (t || IgxTreeGridModule)();\n  };\n\n  IgxTreeGridModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxTreeGridModule\n  });\n  IgxTreeGridModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[IgxGridCommonModule], IgxGridCommonModule]\n  });\n  return IgxTreeGridModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxHierarchicalGridNavigationService = /*#__PURE__*/(() => {\n  class IgxHierarchicalGridNavigationService extends IgxGridNavigationService {\n    constructor() {\n      super(...arguments);\n      this._pendingNavigation = false;\n    }\n\n    dispatchEvent(event) {\n      const key = event.key.toLowerCase();\n\n      if (!this.activeNode || !(SUPPORTED_KEYS.has(key) || key === 'tab' && this.grid.crudService.cell) && !this.grid.crudService.rowEditingBlocked && !this.grid.crudService.rowInEditMode) {\n        return;\n      }\n\n      const targetGrid = this.getClosestElemByTag(event.target, 'igx-hierarchical-grid');\n\n      if (targetGrid !== this.grid.nativeElement) {\n        return;\n      }\n\n      if (this._pendingNavigation && NAVIGATION_KEYS.has(key)) {\n        // In case focus needs to be moved from one grid to another, however there is a pending scroll operation\n        // which is an async operation, any additional navigation keys should be ignored\n        // untill operation complete.\n        event.preventDefault();\n        return;\n      }\n\n      super.dispatchEvent(event);\n    }\n\n    navigateInBody(rowIndex, visibleColIndex, cb = null) {\n      const rec = this.grid.dataView[rowIndex];\n\n      if (rec && this.grid.isChildGridRecord(rec)) {\n        // target is child grid\n        const virtState = this.grid.verticalScrollContainer.state;\n        const inView = rowIndex >= virtState.startIndex && rowIndex <= virtState.startIndex + virtState.chunkSize;\n        const isNext = this.activeNode.row < rowIndex;\n        const targetLayoutIndex = isNext ? null : this.grid.childLayoutKeys.length - 1;\n\n        if (inView) {\n          this._moveToChild(rowIndex, visibleColIndex, isNext, targetLayoutIndex, cb);\n        } else {\n          let scrollAmount = this.grid.verticalScrollContainer.getScrollForIndex(rowIndex, !isNext);\n          scrollAmount += isNext ? 1 : -1;\n          this.grid.verticalScrollContainer.getScroll().scrollTop = scrollAmount;\n          this._pendingNavigation = true;\n          this.grid.verticalScrollContainer.chunkLoad.pipe(first$1()).subscribe(() => {\n            this._moveToChild(rowIndex, visibleColIndex, isNext, targetLayoutIndex, cb);\n\n            this._pendingNavigation = false;\n          });\n        }\n\n        return;\n      }\n\n      const isLast = rowIndex === this.grid.dataView.length;\n\n      if ((rowIndex === -1 || isLast) && this.grid.parent !== null) {\n        // reached end of child grid\n        const nextSiblingIndex = this.nextSiblingIndex(isLast);\n\n        if (nextSiblingIndex !== null) {\n          this.grid.parent.navigation._moveToChild(this.grid.childRow.index, visibleColIndex, isLast, nextSiblingIndex, cb);\n        } else {\n          this._moveToParent(isLast, visibleColIndex, cb);\n        }\n\n        return;\n      }\n\n      if (this.grid.parent) {\n        const isNext = this.activeNode && typeof this.activeNode.row === 'number' ? rowIndex > this.activeNode.row : false;\n\n        const cbHandler = args => {\n          this._handleScrollInChild(rowIndex, isNext);\n\n          cb(args);\n        };\n\n        if (!this.activeNode) {\n          this.activeNode = {\n            row: null,\n            column: null\n          };\n        }\n\n        super.navigateInBody(rowIndex, visibleColIndex, cbHandler);\n        return;\n      }\n\n      if (!this.activeNode) {\n        this.activeNode = {\n          row: null,\n          column: null\n        };\n      }\n\n      super.navigateInBody(rowIndex, visibleColIndex, cb);\n    }\n\n    shouldPerformVerticalScroll(index, visibleColumnIndex = -1, isNext) {\n      const targetRec = this.grid.dataView[index];\n\n      if (this.grid.isChildGridRecord(targetRec)) {\n        const scrollAmount = this.grid.verticalScrollContainer.getScrollForIndex(index, !isNext);\n        const currScroll = this.grid.verticalScrollContainer.getScroll().scrollTop;\n        const shouldScroll = !isNext ? scrollAmount > currScroll : currScroll < scrollAmount;\n        return shouldScroll;\n      } else {\n        return super.shouldPerformVerticalScroll(index, visibleColumnIndex);\n      }\n    }\n\n    focusTbody(event) {\n      if (!this.activeNode || this.activeNode.row === null) {\n        this.activeNode = {\n          row: 0,\n          column: 0\n        };\n        this.grid.navigateTo(0, 0, obj => {\n          this.grid.clearCellSelection();\n          obj.target.activate(event);\n        });\n      } else {\n        super.focusTbody(event);\n      }\n    }\n\n    nextSiblingIndex(isNext) {\n      const layoutKey = this.grid.childRow.layout.key;\n      const layoutIndex = this.grid.parent.childLayoutKeys.indexOf(layoutKey);\n      const nextIndex = isNext ? layoutIndex + 1 : layoutIndex - 1;\n\n      if (nextIndex <= this.grid.parent.childLayoutKeys.length - 1 && nextIndex > -1) {\n        return nextIndex;\n      } else {\n        return null;\n      }\n    }\n    /**\n     * Handles scrolling in child grid and ensures target child row is in main grid view port.\n     *\n     * @param rowIndex The row index which should be in view.\n     * @param isNext  Optional. Whether we are navigating to next. Used to determine scroll direction.\n     * @param cb  Optional.Callback function called when operation is complete.\n     */\n\n\n    _handleScrollInChild(rowIndex, isNext, cb) {\n      const shouldScroll = this.shouldPerformVerticalScroll(rowIndex, -1, isNext);\n\n      if (shouldScroll) {\n        this.grid.navigation.performVerticalScrollToCell(rowIndex, -1, () => {\n          this.positionInParent(rowIndex, isNext, cb);\n        });\n      } else {\n        this.positionInParent(rowIndex, isNext, cb);\n      }\n    }\n    /**\n     *\n     * @param rowIndex Row index that should come in view.\n     * @param isNext  Whether we are navigating to next. Used to determine scroll direction.\n     * @param cb  Optional.Callback function called when operation is complete.\n     */\n\n\n    positionInParent(rowIndex, isNext, cb) {\n      const row = this.grid.gridAPI.get_row_by_index(rowIndex);\n\n      if (!row) {\n        if (cb) {\n          cb();\n        }\n\n        return;\n      }\n\n      const positionInfo = this.getPositionInfo(row, isNext);\n\n      if (!positionInfo.inView) {\n        // stop event from triggering multiple times before scrolling is complete.\n        this._pendingNavigation = true;\n        const scrollableGrid = isNext ? this.getNextScrollableDown(this.grid) : this.getNextScrollableUp(this.grid);\n        scrollableGrid.grid.verticalScrollContainer.recalcUpdateSizes();\n        scrollableGrid.grid.verticalScrollContainer.addScrollTop(positionInfo.offset);\n        scrollableGrid.grid.verticalScrollContainer.chunkLoad.pipe(first$1()).subscribe(() => {\n          this._pendingNavigation = false;\n\n          if (cb) {\n            cb();\n          }\n        });\n      } else {\n        if (cb) {\n          cb();\n        }\n      }\n    }\n    /**\n     * Moves navigation to child grid.\n     *\n     * @param parentRowIndex The parent row index, at which the child grid is rendered.\n     * @param childLayoutIndex Optional. The index of the child row island to which the child grid belongs to. Uses first if not set.\n     */\n\n\n    _moveToChild(parentRowIndex, visibleColIndex, isNext, childLayoutIndex, cb) {\n      const ri = typeof childLayoutIndex !== 'number' ? this.grid.childLayoutList.first : this.grid.childLayoutList.toArray()[childLayoutIndex];\n      const rowId = this.grid.dataView[parentRowIndex].rowID;\n      const pathSegment = {\n        rowID: rowId,\n        rowIslandKey: ri.key\n      };\n      const childGrid = this.grid.gridAPI.getChildGrid([pathSegment]);\n      const targetIndex = isNext ? 0 : childGrid.dataView.length - 1;\n      const targetRec = childGrid.dataView[targetIndex];\n\n      if (!targetRec) {\n        // if no target rec, then move on in next sibling or parent\n        childGrid.navigation.navigateInBody(targetIndex, visibleColIndex, cb);\n        return;\n      }\n\n      if (childGrid.isChildGridRecord(targetRec)) {\n        // if target is a child grid record should move into it.\n        this.grid.navigation.activeNode.row = null;\n        childGrid.navigation.activeNode = {\n          row: targetIndex,\n          column: this.activeNode.column\n        };\n\n        childGrid.navigation._handleScrollInChild(targetIndex, isNext, () => {\n          const targetLayoutIndex = isNext ? 0 : childGrid.childLayoutList.toArray().length - 1;\n\n          childGrid.navigation._moveToChild(targetIndex, visibleColIndex, isNext, targetLayoutIndex, cb);\n        });\n\n        return;\n      }\n\n      const childGridNav = childGrid.navigation;\n      this.clearActivation();\n      const lastVisibleIndex = childGridNav.lastColumnIndex;\n      const columnIndex = visibleColIndex <= lastVisibleIndex ? visibleColIndex : lastVisibleIndex;\n      childGridNav.activeNode = {\n        row: targetIndex,\n        column: columnIndex\n      };\n      childGrid.tbody.nativeElement.focus({\n        preventScroll: true\n      });\n      this._pendingNavigation = false;\n\n      childGrid.navigation._handleScrollInChild(targetIndex, isNext, () => {\n        childGrid.navigateTo(targetIndex, columnIndex, cb);\n      });\n    }\n    /**\n     * Moves navigation back to parent grid.\n     *\n     * @param rowIndex\n     */\n\n\n    _moveToParent(isNext, columnIndex, cb) {\n      const indexInParent = this.grid.childRow.index;\n      const hasNextTarget = this.hasNextTarget(this.grid.parent, indexInParent, isNext);\n\n      if (!hasNextTarget) {\n        return;\n      }\n\n      this.clearActivation();\n      const targetRowIndex = isNext ? indexInParent + 1 : indexInParent - 1;\n      const lastVisibleIndex = this.grid.parent.navigation.lastColumnIndex;\n      const nextColumnIndex = columnIndex <= lastVisibleIndex ? columnIndex : lastVisibleIndex;\n      this._pendingNavigation = true;\n\n      const cbFunc = args => {\n        this._pendingNavigation = false;\n        cb(args);\n        args.target.grid.tbody.nativeElement.focus();\n      };\n\n      this.grid.parent.navigation.navigateInBody(targetRowIndex, nextColumnIndex, cbFunc);\n    }\n    /**\n     * Gets information on the row position relative to the root grid view port.\n     * Returns whether the row is in view and its offset.\n     *\n     * @param rowObj\n     * @param isNext\n     */\n\n\n    getPositionInfo(row, isNext) {\n      // XXX: Fix type\n      let rowElem = row.nativeElement;\n\n      if (row.layout) {\n        const childLayoutKeys = this.grid.childLayoutKeys;\n        const riKey = isNext ? childLayoutKeys[0] : childLayoutKeys[childLayoutKeys.length - 1];\n        const pathSegment = {\n          rowID: row.data.rowID,\n          rowIslandKey: riKey\n        };\n        const childGrid = this.grid.gridAPI.getChildGrid([pathSegment]);\n        rowElem = childGrid.tfoot.nativeElement;\n      }\n\n      const gridBottom = this._getMinBottom(this.grid);\n\n      const diffBottom = rowElem.getBoundingClientRect().bottom - gridBottom;\n\n      const gridTop = this._getMaxTop(this.grid);\n\n      const diffTop = rowElem.getBoundingClientRect().bottom - rowElem.offsetHeight - gridTop;\n      const isInView = isNext ? diffBottom <= 0 : diffTop >= 0;\n      const calcOffset = isNext ? diffBottom : diffTop;\n      return {\n        inView: isInView,\n        offset: calcOffset\n      };\n    }\n    /**\n     * Gets closest element by its tag name.\n     *\n     * @param sourceElem The element from which to start the search.\n     * @param targetTag The target element tag name, for which to search.\n     */\n\n\n    getClosestElemByTag(sourceElem, targetTag) {\n      let result = sourceElem;\n\n      while (result !== null && result.nodeType === 1) {\n        if (result.tagName.toLowerCase() === targetTag.toLowerCase()) {\n          return result;\n        }\n\n        result = result.parentNode;\n      }\n\n      return null;\n    }\n\n    clearActivation() {\n      // clear if previous activation exists.\n      if (this.activeNode && Object.keys(this.activeNode).length) {\n        this.activeNode = Object.assign({});\n      }\n    }\n\n    hasNextTarget(grid, index, isNext) {\n      const targetRowIndex = isNext ? index + 1 : index - 1;\n      const hasTargetRecord = !!grid.dataView[targetRowIndex];\n\n      if (hasTargetRecord) {\n        return true;\n      } else {\n        let hasTargetRecordInParent = false;\n\n        if (grid.parent) {\n          const indexInParent = grid.childRow.index;\n          hasTargetRecordInParent = this.hasNextTarget(grid.parent, indexInParent, isNext);\n        }\n\n        return hasTargetRecordInParent;\n      }\n    }\n    /**\n     * Gets the max top view in the current grid hierarchy.\n     *\n     * @param grid\n     */\n\n\n    _getMaxTop(grid) {\n      let currGrid = grid;\n      let top = currGrid.tbody.nativeElement.getBoundingClientRect().top;\n\n      while (currGrid.parent) {\n        currGrid = currGrid.parent;\n        const pinnedRowsHeight = currGrid.hasPinnedRecords && currGrid.isRowPinningToTop ? currGrid.pinnedRowHeight : 0;\n        top = Math.max(top, currGrid.tbody.nativeElement.getBoundingClientRect().top + pinnedRowsHeight);\n      }\n\n      return top;\n    }\n    /**\n     * Gets the min bottom view in the current grid hierarchy.\n     *\n     * @param grid\n     */\n\n\n    _getMinBottom(grid) {\n      let currGrid = grid;\n      let bottom = currGrid.tbody.nativeElement.getBoundingClientRect().bottom;\n\n      while (currGrid.parent) {\n        currGrid = currGrid.parent;\n        const pinnedRowsHeight = currGrid.hasPinnedRecords && !currGrid.isRowPinningToTop ? currGrid.pinnedRowHeight : 0;\n        bottom = Math.min(bottom, currGrid.tbody.nativeElement.getBoundingClientRect().bottom - pinnedRowsHeight);\n      }\n\n      return bottom;\n    }\n    /**\n     * Finds the next grid that allows scrolling down.\n     *\n     * @param grid The grid from which to begin the search.\n     */\n\n\n    getNextScrollableDown(grid) {\n      let currGrid = grid.parent;\n\n      if (!currGrid) {\n        return {\n          grid,\n          prev: null\n        };\n      }\n\n      let scrollTop = currGrid.verticalScrollContainer.scrollPosition;\n      let scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;\n      let nonScrollable = scrollHeight === 0 || Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;\n      let prev = grid;\n\n      while (nonScrollable && currGrid.parent !== null) {\n        prev = currGrid;\n        currGrid = currGrid.parent;\n        scrollTop = currGrid.verticalScrollContainer.scrollPosition;\n        scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;\n        nonScrollable = scrollHeight === 0 || Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;\n      }\n\n      return {\n        grid: currGrid,\n        prev\n      };\n    }\n    /**\n     * Finds the next grid that allows scrolling up.\n     *\n     * @param grid The grid from which to begin the search.\n     */\n\n\n    getNextScrollableUp(grid) {\n      let currGrid = grid.parent;\n\n      if (!currGrid) {\n        return {\n          grid,\n          prev: null\n        };\n      }\n\n      let nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;\n      let prev = grid;\n\n      while (nonScrollable && currGrid.parent !== null) {\n        prev = currGrid;\n        currGrid = currGrid.parent;\n        nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;\n      }\n\n      return {\n        grid: currGrid,\n        prev\n      };\n    }\n\n  }\n\n  IgxHierarchicalGridNavigationService.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxHierarchicalGridNavigationService_BaseFactory;\n    return function IgxHierarchicalGridNavigationService_Factory(t) {\n      return (ɵIgxHierarchicalGridNavigationService_BaseFactory || (ɵIgxHierarchicalGridNavigationService_BaseFactory = i0.ɵɵgetInheritedFactory(IgxHierarchicalGridNavigationService)))(t || IgxHierarchicalGridNavigationService);\n    };\n  }();\n\n  IgxHierarchicalGridNavigationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxHierarchicalGridNavigationService,\n    factory: IgxHierarchicalGridNavigationService.ɵfac\n  });\n  return IgxHierarchicalGridNavigationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxHierarchicalGridAPIService = /*#__PURE__*/(() => {\n  class IgxHierarchicalGridAPIService extends GridBaseAPIService {\n    constructor() {\n      super(...arguments);\n      this.childRowIslands = new Map();\n      this.childGrids = new Map();\n    }\n\n    registerChildRowIsland(rowIsland) {\n      this.childRowIslands.set(rowIsland.key, rowIsland);\n      this.destroyMap.set(rowIsland.key, new Subject());\n    }\n\n    unsetChildRowIsland(rowIsland) {\n      this.childGrids.delete(rowIsland.key);\n      this.childRowIslands.delete(rowIsland.key);\n      this.destroyMap.delete(rowIsland.key);\n    }\n\n    getChildRowIsland(key) {\n      return this.childRowIslands.get(key);\n    }\n\n    getChildGrid(path) {\n      const currPath = path;\n      let grid;\n      const pathElem = currPath.shift();\n      const childrenForLayout = this.childGrids.get(pathElem.rowIslandKey);\n\n      if (childrenForLayout) {\n        const childGrid = childrenForLayout.get(pathElem.rowID);\n\n        if (currPath.length === 0) {\n          grid = childGrid;\n        } else {\n          grid = childGrid.gridAPI.getChildGrid(currPath);\n        }\n      }\n\n      return grid;\n    }\n\n    getChildGrids(inDepth) {\n      const allChildren = [];\n      this.childGrids.forEach(layoutMap => {\n        layoutMap.forEach(grid => {\n          allChildren.push(grid);\n\n          if (inDepth) {\n            const children = grid.gridAPI.getChildGrids(inDepth);\n            children.forEach(item => {\n              allChildren.push(item);\n            });\n          }\n        });\n      });\n      return allChildren;\n    }\n\n    getParentRowId(childGrid) {\n      let rowID;\n      this.childGrids.forEach(layoutMap => {\n        layoutMap.forEach((grid, key) => {\n          if (grid === childGrid) {\n            rowID = key;\n            return;\n          }\n        });\n      });\n      return rowID;\n    }\n\n    registerChildGrid(parentRowID, rowIslandKey, grid) {\n      let childrenForLayout = this.childGrids.get(rowIslandKey);\n\n      if (!childrenForLayout) {\n        this.childGrids.set(rowIslandKey, new Map());\n        childrenForLayout = this.childGrids.get(rowIslandKey);\n      }\n\n      childrenForLayout.set(parentRowID, grid);\n    }\n\n    getChildGridsForRowIsland(rowIslandKey) {\n      const childrenForLayout = this.childGrids.get(rowIslandKey);\n      const children = [];\n\n      if (childrenForLayout) {\n        childrenForLayout.forEach(child => {\n          children.push(child);\n        });\n      }\n\n      return children;\n    }\n\n    getChildGridByID(rowIslandKey, rowID) {\n      const childrenForLayout = this.childGrids.get(rowIslandKey);\n      return childrenForLayout.get(rowID);\n    }\n\n    get_row_expansion_state(record) {\n      let inState;\n\n      if (record.childGridsData !== undefined) {\n        const ri = record.key;\n        const states = this.grid.expansionStates;\n        const expanded = states.get(ri);\n\n        if (expanded !== undefined) {\n          return expanded;\n        } else {\n          return this.grid.getDefaultExpandState(record);\n        }\n      } else {\n        inState = !!super.get_row_expansion_state(record);\n      }\n\n      return inState && this.grid.childLayoutList.length !== 0;\n    }\n\n    allow_expansion_state_change(rowID, expanded) {\n      const rec = this.get_rec_by_id(rowID);\n      const grid = this.grid;\n\n      if (grid.hasChildrenKey && !rec[grid.hasChildrenKey]) {\n        return false;\n      }\n\n      return !!rec && this.grid.expansionStates.get(rowID) !== expanded;\n    }\n\n    get_rec_by_id(rowID) {\n      const data = this.get_all_data(false);\n      const index = this.get_row_index_in_data(rowID, data);\n      return data[index];\n    }\n\n  }\n\n  IgxHierarchicalGridAPIService.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxHierarchicalGridAPIService_BaseFactory;\n    return function IgxHierarchicalGridAPIService_Factory(t) {\n      return (ɵIgxHierarchicalGridAPIService_BaseFactory || (ɵIgxHierarchicalGridAPIService_BaseFactory = i0.ɵɵgetInheritedFactory(IgxHierarchicalGridAPIService)))(t || IgxHierarchicalGridAPIService);\n    };\n  }();\n\n  IgxHierarchicalGridAPIService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxHierarchicalGridAPIService,\n    factory: IgxHierarchicalGridAPIService.ɵfac\n  });\n  return IgxHierarchicalGridAPIService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst hierarchicalTransactionServiceFactory = () => new IgxTransactionService();\n\nconst IgxHierarchicalTransactionServiceFactory = {\n  provide: IgxGridTransaction,\n  useFactory: hierarchicalTransactionServiceFactory\n};\nlet IgxHierarchicalGridBaseDirective = /*#__PURE__*/(() => {\n  class IgxHierarchicalGridBaseDirective extends IgxGridBaseDirective {\n    constructor(selectionService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, appRef, moduleRef, injector, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, localeId, platform, _diTransactions) {\n      super(selectionService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, appRef, moduleRef, injector, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, localeId, platform);\n      this.selectionService = selectionService;\n      this.colResizingService = colResizingService;\n      this.gridAPI = gridAPI;\n      this.transactionFactory = transactionFactory;\n      this.document = document;\n      this.overlayService = overlayService;\n      this.summaryService = summaryService;\n      this._displayDensityOptions = _displayDensityOptions;\n      this.platform = platform;\n      this._diTransactions = _diTransactions;\n      /**\n       * Gets/Sets whether the expand/collapse all button in the header should be rendered.\n       *\n       * @remark\n       * The default value is false.\n       * @example\n       * ```html\n       * <igx-hierarchical-grid #grid [data]=\"localData\" [showExpandAll]=\"true\">\n       * </igx-hierarchical-grid>\n       * ```\n       */\n\n      this.showExpandAll = false;\n      /**\n       * Emitted when a new chunk of data is loaded from virtualization.\n       *\n       * @example\n       * ```typescript\n       *  <igx-hierarchical-grid [id]=\"'igx-grid-1'\" [data]=\"Data\" [autoGenerate]=\"true\" (dataPreLoad)=\"handleEvent()\">\n       *  </igx-hierarchical-grid>\n       * ```\n       */\n\n      this.dataPreLoad = new EventEmitter();\n      /** @hidden @internal */\n\n      this.batchEditingChange = new EventEmitter();\n    }\n    /**\n     * @hidden\n     */\n\n\n    get maxLevelHeaderDepth() {\n      if (this._maxLevelHeaderDepth === null) {\n        this._maxLevelHeaderDepth = this.columnList.reduce((acc, col) => Math.max(acc, col.level), 0);\n      }\n\n      return this._maxLevelHeaderDepth;\n    }\n    /**\n     * Gets the outlet used to attach the grid's overlays to.\n     *\n     * @remark\n     * If set, returns the outlet defined outside the grid. Otherwise returns the grid's internal outlet directive.\n     */\n\n\n    get outlet() {\n      return this.rootGrid ? this.rootGrid.resolveOutlet() : this.resolveOutlet();\n    }\n    /**\n     * Sets the outlet used to attach the grid's overlays to.\n     */\n\n\n    set outlet(val) {\n      this._userOutletDirective = val;\n    }\n\n    get batchEditing() {\n      return this._batchEditing;\n    }\n\n    set batchEditing(val) {\n      if (val !== this._batchEditing) {\n        delete this._transactions;\n        this.switchTransactionService(val);\n        this.subscribeToTransactions();\n        this.batchEditingChange.emit(val);\n        this._batchEditing = val;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    createColumnsList(cols) {\n      const columns = [];\n      const topLevelCols = cols.filter(c => c.level === 0);\n      topLevelCols.forEach(col => {\n        const ref = this._createColumn(col);\n\n        ref.changeDetectorRef.detectChanges();\n        columns.push(ref.instance);\n      });\n      const result = flatten(columns);\n      this.columnList.reset(result);\n      this.columnList.notifyOnChanges();\n      this.initPinning();\n      const factoryColumn = this.resolver.resolveComponentFactory(IgxColumnComponent);\n      const outputs = factoryColumn.outputs.filter(o => o.propName !== 'columnChange');\n      outputs.forEach(output => {\n        this.columnList.forEach(column => {\n          if (column[output.propName]) {\n            column[output.propName].pipe(takeUntil(column.destroy$)).subscribe(args => {\n              const rowIslandColumn = this.parentIsland.childColumns.find(col => col.field === column.field);\n              rowIslandColumn[output.propName].emit({\n                args,\n                owner: this\n              });\n            });\n          }\n        });\n      });\n    }\n\n    _createColumn(col) {\n      let ref;\n\n      if (col instanceof IgxColumnGroupComponent) {\n        ref = this._createColGroupComponent(col);\n      } else {\n        ref = this._createColComponent(col);\n      }\n\n      return ref;\n    }\n\n    _createColGroupComponent(col) {\n      const factoryGroup = this.resolver.resolveComponentFactory(IgxColumnGroupComponent);\n      const ref = this.viewRef.createComponent(IgxColumnGroupComponent, {\n        injector: this.viewRef.injector\n      });\n      ref.changeDetectorRef.detectChanges();\n      factoryGroup.inputs.forEach(input => {\n        const propName = input.propName;\n        ref.instance[propName] = col[propName];\n      });\n\n      if (col.children.length > 0) {\n        const newChildren = [];\n        col.children.forEach(child => {\n          const newCol = this._createColumn(child).instance;\n\n          newCol.parent = ref.instance;\n          newChildren.push(newCol);\n        });\n        ref.instance.children.reset(newChildren);\n        ref.instance.children.notifyOnChanges();\n      }\n\n      return ref;\n    }\n\n    _createColComponent(col) {\n      const factoryColumn = this.resolver.resolveComponentFactory(IgxColumnComponent);\n      const ref = this.viewRef.createComponent(IgxColumnComponent, {\n        injector: this.viewRef.injector\n      });\n      factoryColumn.inputs.forEach(input => {\n        const propName = input.propName;\n\n        if (!(col[propName] instanceof IgxSummaryOperand)) {\n          ref.instance[propName] = col[propName];\n        } else {\n          ref.instance[propName] = col[propName].constructor;\n        }\n      });\n      return ref;\n    }\n\n    getGridsForIsland(rowIslandID) {\n      return this.gridAPI.getChildGridsForRowIsland(rowIslandID);\n    }\n\n    getChildGrid(path) {\n      if (!path) {\n        return;\n      }\n\n      return this.gridAPI.getChildGrid(path);\n    }\n\n  }\n\n  IgxHierarchicalGridBaseDirective.ɵfac = function IgxHierarchicalGridBaseDirective_Factory(t) {\n    return new (t || IgxHierarchicalGridBaseDirective)(i0.ɵɵdirectiveInject(IgxGridSelectionService), i0.ɵɵdirectiveInject(IgxColumnResizingService), i0.ɵɵdirectiveInject(IGX_GRID_SERVICE_BASE), i0.ɵɵdirectiveInject(IgxFlatTransactionFactory), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ApplicationRef), i0.ɵɵdirectiveInject(i0.NgModuleRef), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(IgxHierarchicalGridNavigationService), i0.ɵɵdirectiveInject(IgxFilteringService), i0.ɵɵdirectiveInject(IgxOverlayService), i0.ɵɵdirectiveInject(IgxGridSummaryService), i0.ɵɵdirectiveInject(DisplayDensityToken, 8), i0.ɵɵdirectiveInject(LOCALE_ID), i0.ɵɵdirectiveInject(PlatformUtil), i0.ɵɵdirectiveInject(IgxGridTransaction, 8));\n  };\n\n  IgxHierarchicalGridBaseDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxHierarchicalGridBaseDirective,\n    viewQuery: function IgxHierarchicalGridBaseDirective_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c192, 7, TemplateRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dragIndicatorIconBase = _t.first);\n      }\n    },\n    inputs: {\n      hasChildrenKey: \"hasChildrenKey\",\n      showExpandAll: \"showExpandAll\"\n    },\n    outputs: {\n      dataPreLoad: \"dataPreLoad\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return IgxHierarchicalGridBaseDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst flatten = arr => {\n  let result = [];\n  arr.forEach(el => {\n    result.push(el);\n\n    if (el.children) {\n      result = result.concat(flatten(el.children.toArray()));\n    }\n  });\n  return result;\n};\n\nlet IgxRowIslandAPIService = /*#__PURE__*/(() => {\n  class IgxRowIslandAPIService {\n    constructor() {\n      this.change = new Subject();\n      this.state = new Map();\n      this.destroyMap = new Map();\n      this.childRowIslands = new Map();\n      this.childGrids = new Map();\n    }\n\n    register(rowIsland) {\n      this.state.set(rowIsland.id, rowIsland);\n      this.destroyMap.set(rowIsland.id, new Subject());\n    }\n\n    unsubscribe(rowIsland) {\n      this.state.delete(rowIsland.id);\n    }\n\n    get(id) {\n      return this.state.get(id);\n    }\n\n    unset(id) {\n      this.state.delete(id);\n      this.destroyMap.delete(id);\n    }\n\n    reset(oldId, newId) {\n      const destroy = this.destroyMap.get(oldId);\n      const rowIsland = this.get(oldId);\n      this.unset(oldId);\n\n      if (rowIsland) {\n        this.state.set(newId, rowIsland);\n      }\n\n      if (destroy) {\n        this.destroyMap.set(newId, destroy);\n      }\n    }\n\n    registerChildRowIsland(rowIsland) {\n      this.childRowIslands.set(rowIsland.key, rowIsland);\n      this.destroyMap.set(rowIsland.key, new Subject());\n    }\n\n    unsetChildRowIsland(rowIsland) {\n      this.childRowIslands.delete(rowIsland.key);\n      this.destroyMap.delete(rowIsland.key);\n    }\n\n    getChildRowIsland(rowIslandKey) {\n      return this.childRowIslands.get(rowIslandKey);\n    }\n\n    registerChildGrid(parentRowID, grid) {\n      this.childGrids.set(parentRowID, grid);\n    }\n\n    getChildGrids(inDepth) {\n      let allChildren = [];\n      this.childGrids.forEach(grid => {\n        allChildren.push(grid);\n      });\n\n      if (inDepth) {\n        this.childRowIslands.forEach(layout => {\n          allChildren = allChildren.concat(layout.rowIslandAPI.getChildGrids(inDepth));\n        });\n      }\n\n      return allChildren;\n    }\n\n    getChildGridByID(rowID) {\n      return this.childGrids.get(rowID);\n    }\n\n  }\n\n  IgxRowIslandAPIService.ɵfac = function IgxRowIslandAPIService_Factory(t) {\n    return new (t || IgxRowIslandAPIService)();\n  };\n\n  IgxRowIslandAPIService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxRowIslandAPIService,\n    factory: IgxRowIslandAPIService.ɵfac\n  });\n  return IgxRowIslandAPIService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxRowIslandComponent = /*#__PURE__*/(() => {\n  class IgxRowIslandComponent extends IgxHierarchicalGridBaseDirective {\n    constructor(selectionService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, moduleRef, injector, appRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, rowIslandAPI, localeId, platform) {\n      super(selectionService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, appRef, moduleRef, injector, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, localeId, platform);\n      this.selectionService = selectionService;\n      this.colResizingService = colResizingService;\n      this.transactionFactory = transactionFactory;\n      this.document = document;\n      this.overlayService = overlayService;\n      this.summaryService = summaryService;\n      this._displayDensityOptions = _displayDensityOptions;\n      this.rowIslandAPI = rowIslandAPI;\n      this.platform = platform;\n      /**\n       * @hidden\n       */\n\n      this.children = new QueryList();\n      /**\n       * @hidden\n       */\n\n      this.childColumns = new QueryList();\n      /**\n       * @hidden\n       */\n\n      this.layoutChange = new EventEmitter();\n      /**\n       * Event emmited when a grid is being created based on this row island.\n       * ```html\n       * <igx-hierarchical-grid [data]=\"Data\" [autoGenerate]=\"true\">\n       *      <igx-row-island [key]=\"'childData'\" (gridCreated)=\"gridCreated($event)\" #rowIsland>\n       *          <!-- ... -->\n       *      </igx-row-island>\n       * </igx-hierarchical-grid>\n       * ```\n       *\n       * @memberof IgxRowIslandComponent\n       */\n\n      this.gridCreated = new EventEmitter();\n      /**\n       * Emitted after a grid is being initialized for this row island.\n       * The emitting is done in `ngAfterViewInit`.\n       * ```html\n       * <igx-hierarchical-grid [data]=\"Data\" [autoGenerate]=\"true\">\n       *      <igx-row-island [key]=\"'childData'\" (gridInitialized)=\"gridInitialized($event)\" #rowIsland>\n       *          <!-- ... -->\n       *      </igx-row-island>\n       * </igx-hierarchical-grid>\n       * ```\n       *\n       * @memberof IgxRowIslandComponent\n       */\n\n      this.gridInitialized = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.initialChanges = [];\n      /**\n       * @hidden\n       */\n\n      this.rootGrid = null;\n      this.layout_id = `igx-row-island-`;\n      this.isInit = false;\n    }\n    /**\n     * Sets if all immediate children of the grids for this `IgxRowIslandComponent` should be expanded/collapsed.\n     * ```html\n     * <igx-hierarchical-grid [data]=\"Data\" [autoGenerate]=\"true\">\n     *      <igx-row-island [key]=\"'childData'\" [expandChildren]=\"true\" #rowIsland>\n     *          <!-- ... -->\n     *      </igx-row-island>\n     * </igx-hierarchical-grid>\n     * ```\n     *\n     * @memberof IgxRowIslandComponent\n     */\n\n\n    set expandChildren(value) {\n      this._defaultExpandState = value;\n      this.rowIslandAPI.getChildGrids().forEach(grid => {\n        if (document.body.contains(grid.nativeElement)) {\n          // Detect changes right away if the grid is visible\n          grid.expandChildren = value;\n          grid.cdr.detectChanges();\n        } else {\n          // Else defer the detection on changes when the grid gets into view for performance.\n          grid.updateOnRender = true;\n        }\n      });\n    }\n    /**\n     * Gets if all immediate children of the grids for this `IgxRowIslandComponent` have been set to be expanded/collapsed.\n     * ```typescript\n     * const expanded = this.rowIsland.expandChildren;\n     * ```\n     *\n     * @memberof IgxRowIslandComponent\n     */\n\n\n    get expandChildren() {\n      return this._defaultExpandState;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get id() {\n      const pId = this.parentId ? this.parentId.substring(this.parentId.indexOf(this.layout_id) + this.layout_id.length) + '-' : '';\n      return this.layout_id + pId + this.key;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get parentId() {\n      return this.parentIsland ? this.parentIsland.id : null;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get level() {\n      let ptr = this.parentIsland;\n      let lvl = 0;\n\n      while (ptr) {\n        lvl++;\n        ptr = ptr.parentIsland;\n      }\n\n      return lvl + 1;\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      this.filteringService.grid = this;\n      this.rootGrid = this.gridAPI.grid;\n      this.rowIslandAPI.rowIsland = this;\n      this.ri_columnListDiffer = this.differs.find([]).create(null);\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterContentInit() {\n      this.updateChildren();\n      this.children.notifyOnChanges();\n      this.children.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        this.updateChildren(); // update existing grids since their child ri have been changed.\n\n        this.getGridsForIsland(this.key).forEach(grid => {\n          grid.onRowIslandChange(this.children);\n        });\n      });\n      const nestedColumns = this.children.map(layout => layout.columnList.toArray());\n      const colsArray = [].concat.apply([], nestedColumns);\n      const topCols = this.columnList.filter(item => colsArray.indexOf(item) === -1);\n      this.childColumns.reset(topCols);\n      this.columnList.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        Promise.resolve().then(() => {\n          this.updateColumnList();\n        });\n      }); // handle column changes so that they are passed to child grid instances when columnChange is emitted.\n\n      this.ri_columnListDiffer.diff(this.childColumns);\n      this.childColumns.toArray().forEach(x => x.columnChange.pipe(takeUntil(x.destroy$)).subscribe(() => this.updateColumnList()));\n      this.childColumns.changes.pipe(takeUntil(this.destroy$)).subscribe(change => {\n        const diff = this.ri_columnListDiffer.diff(change);\n\n        if (diff) {\n          diff.forEachAddedItem(record => {\n            record.item.columnChange.pipe(takeUntil(record.item.destroy$)).subscribe(() => this.updateColumnList());\n          });\n        }\n      });\n      this.actionStrip = this.actionStrips.first;\n\n      if (this.actionStrip) {\n        this.actionStrip.menuOverlaySettings.outlet = this.outlet;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterViewInit() {\n      this.rowIslandAPI.register(this);\n\n      if (this.parentIsland) {\n        this.parentIsland.rowIslandAPI.registerChildRowIsland(this);\n      } else {\n        this.rootGrid.gridAPI.registerChildRowIsland(this);\n      }\n\n      this._init = false; // Create the child toolbar if the parent island has a toolbar definition\n\n      this.gridCreated.pipe(pluck('grid'), takeUntil(this.destroy$)).subscribe(grid => {\n        grid.rendered$.pipe(first$1(), filter(() => !!this.islandToolbarTemplate)).subscribe(() => grid.toolbarOutlet.createEmbeddedView(this.islandToolbarTemplate, {\n          $implicit: grid\n        }));\n        grid.rendered$.pipe(first$1(), filter(() => !!this.islandPaginatorTemplate)).subscribe(() => {\n          this.rootGrid.paginatorList.changes.pipe(takeUntil(this.destroy$)).subscribe(() => grid.setUpPaginator());\n          grid.paginatorOutlet.createEmbeddedView(this.islandPaginatorTemplate);\n        });\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnChanges(changes) {\n      this.layoutChange.emit(changes);\n\n      if (!this.isInit) {\n        this.initialChanges.push(changes);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      // Override the base destroy because we don't have rendered anything to use removeEventListener on\n      this.destroy$.next(true);\n      this.destroy$.complete();\n      this._destroyed = true;\n      this.rowIslandAPI.unset(this.id);\n\n      if (this.parentIsland) {\n        this.getGridsForIsland(this.key).forEach(grid => {\n          this.cleanGridState(grid);\n          grid.gridAPI.unsetChildRowIsland(this);\n        });\n        this.parentIsland.rowIslandAPI.unsetChildRowIsland(this);\n      } else {\n        this.rootGrid.gridAPI.unsetChildRowIsland(this);\n        this.cleanGridState(this.rootGrid);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    reflow() {}\n    /**\n     * @hidden\n     */\n\n\n    calculateGridHeight() {}\n\n    updateColumnList() {\n      const nestedColumns = this.children.map(layout => layout.columnList.toArray());\n      const colsArray = [].concat.apply([], nestedColumns);\n      const topCols = this.columnList.filter(item => {\n        if (colsArray.indexOf(item) === -1) {\n          /* Reset the default width of the columns that come into this row island,\n          because the root catches them first during the detectChanges() and sets their defaultWidth. */\n          item.defaultWidth = undefined;\n          return true;\n        }\n\n        return false;\n      });\n      this.childColumns.reset(topCols);\n\n      if (this.parentIsland) {\n        this.parentIsland.columnList.notifyOnChanges();\n      } else {\n        this.rootGrid.columnList.notifyOnChanges();\n      }\n\n      this.rowIslandAPI.getChildGrids().forEach(grid => {\n        grid.createColumnsList(this.childColumns.toArray());\n\n        if (!document.body.contains(grid.nativeElement)) {\n          grid.updateOnRender = true;\n        }\n      });\n    }\n\n    updateChildren() {\n      if (this.children.first === this) {\n        this.children.reset(this.children.toArray().slice(1));\n      }\n\n      this.children.forEach(child => {\n        child.parentIsland = this;\n      });\n    }\n\n    cleanGridState(grid) {\n      grid.childGridTemplates.forEach(tmpl => {\n        tmpl.owner.cleanView(tmpl.context.templateID);\n      });\n      grid.childGridTemplates.clear();\n      grid.onRowIslandChange();\n    }\n\n  }\n\n  IgxRowIslandComponent.ɵfac = function IgxRowIslandComponent_Factory(t) {\n    return new (t || IgxRowIslandComponent)(i0.ɵɵdirectiveInject(IgxGridSelectionService), i0.ɵɵdirectiveInject(IgxColumnResizingService), i0.ɵɵdirectiveInject(IGX_GRID_SERVICE_BASE), i0.ɵɵdirectiveInject(IgxFlatTransactionFactory), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.NgModuleRef), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ApplicationRef), i0.ɵɵdirectiveInject(IgxHierarchicalGridNavigationService), i0.ɵɵdirectiveInject(IgxFilteringService), i0.ɵɵdirectiveInject(IgxOverlayService), i0.ɵɵdirectiveInject(IgxGridSummaryService), i0.ɵɵdirectiveInject(DisplayDensityToken, 8), i0.ɵɵdirectiveInject(IgxRowIslandAPIService), i0.ɵɵdirectiveInject(LOCALE_ID), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxRowIslandComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxRowIslandComponent,\n    selectors: [[\"igx-row-island\"]],\n    contentQueries: function IgxRowIslandComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxGridToolbarDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxPaginatorDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxRowIslandComponent, 4, IgxRowIslandComponent);\n        i0.ɵɵcontentQuery(dirIndex, IgxColumnComponent, 4, IgxColumnComponent);\n        i0.ɵɵcontentQuery(dirIndex, IgxActionStripComponent, 4, IgxActionStripComponent);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.islandToolbarTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.islandPaginatorTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.children = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.childColumns = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.actionStrips = _t);\n      }\n    },\n    inputs: {\n      key: \"key\",\n      expandChildren: \"expandChildren\"\n    },\n    outputs: {\n      layoutChange: \"layoutChange\",\n      gridCreated: \"gridCreated\",\n      gridInitialized: \"gridInitialized\"\n    },\n    features: [i0.ɵɵProvidersFeature([IgxRowIslandAPIService, IgxFilteringService, IgxGridSelectionService]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature],\n    decls: 0,\n    vars: 0,\n    template: function IgxRowIslandComponent_Template(rf, ctx) {},\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxRowIslandComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxHierarchicalGridCellComponent = /*#__PURE__*/(() => {\n  class IgxHierarchicalGridCellComponent extends IgxGridCellComponent {\n    constructor(selectionService, grid, cdr, helement, zone, touchManager, platformUtil) {\n      super(selectionService, grid, cdr, helement, zone, touchManager, platformUtil);\n      this.selectionService = selectionService;\n      this.grid = grid;\n      this.cdr = cdr;\n      this.zone = zone;\n      this.platformUtil = platformUtil;\n    }\n\n    ngOnInit() {\n      super.ngOnInit();\n      this._rootGrid = this._getRootGrid();\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    activate(event) {\n      this._clearAllHighlights();\n\n      const currentElement = this.grid.nativeElement;\n      let parentGrid = this.grid;\n      let childGrid; // add highligh to the current grid\n\n      if (this._rootGrid.id !== currentElement.id) {\n        currentElement.classList.add('igx-grid__tr--highlighted');\n      } // add highligh to the current grid\n\n\n      while (this._rootGrid.id !== parentGrid.id) {\n        childGrid = parentGrid;\n        parentGrid = parentGrid.parent;\n        const parentRowID = parentGrid.gridAPI.getParentRowId(childGrid);\n        parentGrid.highlightedRowID = parentRowID;\n      }\n\n      this.grid.navigation.activeNode.gridID = this.gridID;\n      super.activate(event);\n    }\n\n    _getRootGrid() {\n      let currGrid = this.grid;\n\n      while (currGrid.parent) {\n        currGrid = currGrid.parent;\n      }\n\n      return currGrid;\n    } // TODO: Extend the new selection service to avoid complete traversal\n\n\n    _clearAllHighlights() {\n      [this._rootGrid, ...this._rootGrid.getChildGrids(true)].forEach(grid => {\n        if (grid !== this.grid && grid.navigation.activeNode) {\n          grid.navigation.clearActivation();\n          grid.selectionService.initKeyboardState();\n          grid.selectionService.clear();\n        }\n\n        grid.selectionService.activeElement = null;\n        grid.nativeElement.classList.remove('igx-grid__tr--highlighted');\n        grid.highlightedRowID = null;\n        grid.cdr.markForCheck();\n      });\n    }\n\n  }\n\n  IgxHierarchicalGridCellComponent.ɵfac = function IgxHierarchicalGridCellComponent_Factory(t) {\n    return new (t || IgxHierarchicalGridCellComponent)(i0.ɵɵdirectiveInject(IgxGridSelectionService), i0.ɵɵdirectiveInject(IGX_GRID_BASE), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(HammerGesturesManager), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxHierarchicalGridCellComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxHierarchicalGridCellComponent,\n    selectors: [[\"igx-hierarchical-grid-cell\"]],\n    features: [i0.ɵɵProvidersFeature([HammerGesturesManager]), i0.ɵɵInheritDefinitionFeature],\n    decls: 10,\n    vars: 4,\n    consts: [[\"defaultPinnedIndicator\", \"\"], [\"defaultCell\", \"\"], [\"addRowCell\", \"\"], [\"inlineEditor\", \"\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"class\", \"igx-grid__td--pinned-chip\", 3, \"disabled\", \"displayDensity\", 4, \"ngIf\"], [1, \"igx-grid__td--pinned-chip\", 3, \"disabled\", \"displayDensity\"], [\"igxTextHighlight\", \"\", \"class\", \"igx-grid__td-text\", \"style\", \"pointer-events: none;\", 3, \"cssClass\", \"activeCssClass\", \"groupName\", \"value\", \"row\", \"column\", \"containerClass\", \"metadata\", 4, \"ngIf\"], [3, \"ngClass\", 4, \"ngIf\"], [\"igxTextHighlight\", \"\", 1, \"igx-grid__td-text\", 2, \"pointer-events\", \"none\", 3, \"cssClass\", \"activeCssClass\", \"groupName\", \"value\", \"row\", \"column\", \"containerClass\", \"metadata\"], [3, \"ngClass\"], [\"igxTextHighlight\", \"\", \"class\", \"igx-grid__td-text\", \"style\", \"pointer-events: none\", 3, \"cssClass\", \"activeCssClass\", \"groupName\", \"value\", \"row\", \"column\", \"containerClass\", \"metadata\", 4, \"ngIf\"], [4, \"ngIf\"], [\"displayDensity\", \"compact\"], [\"igxInput\", \"\", 3, \"ngModel\", \"igxFocus\", \"ngModelChange\"], [\"igxInput\", \"\", \"type\", \"number\", 3, \"ngModel\", \"igxFocus\", \"step\", \"ngModelChange\"], [3, \"checked\", \"igxFocus\", \"disableRipple\", \"change\"], [\"mode\", \"dropdown\", 3, \"outlet\", \"locale\", \"value\", \"igxFocus\", \"valueChange\"], [\"mode\", \"dropdown\", 3, \"outlet\", \"locale\", \"inputFormat\", \"value\", \"igxFocus\", \"valueChange\"], [\"type\", \"text\", \"igxInput\", \"\", 3, \"igxDateTimeEditor\", \"ngModel\", \"igxFocus\", \"ngModelChange\"]],\n    template: function IgxHierarchicalGridCellComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxHierarchicalGridCellComponent_ng_template_0_Template, 1, 1, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, IgxHierarchicalGridCellComponent_ng_template_2_Template, 2, 2, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(4, IgxHierarchicalGridCellComponent_ng_template_4_Template, 1, 1, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(6, IgxHierarchicalGridCellComponent_ng_template_6_Template, 8, 8, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(8, IgxHierarchicalGridCellComponent_ng_container_8_Template, 1, 0, \"ng-container\", 4);\n        i0.ɵɵtemplate(9, IgxHierarchicalGridCellComponent_ng_container_9_Template, 1, 0, \"ng-container\", 4);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(8);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.pinnedIndicatorTemplate)(\"ngTemplateOutletContext\", ctx.context);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template)(\"ngTemplateOutletContext\", ctx.context);\n      }\n    },\n    directives: [IgxChipComponent, IgxIconComponent, IgxInputGroupComponent, IgxCheckboxComponent, IgxDatePickerComponent, IgxTimePickerComponent, i4.NgIf, IgxTextHighlightDirective, i4.NgClass, i12.DefaultValueAccessor, IgxInputDirective, i12.NgControlStatus, i12.NgModel, IgxFocusDirective, i12.NumberValueAccessor, IgxDateTimeEditorDirective, IgxPrefixDirective, IgxSuffixDirective, i4.NgTemplateOutlet],\n    pipes: [IgxColumnFormatterPipe, i4.DecimalPipe, i4.DatePipe, i4.CurrencyPipe, i4.PercentPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxHierarchicalGridCellComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxHierarchicalRowComponent = /*#__PURE__*/(() => {\n  class IgxHierarchicalRowComponent extends IgxRowDirective {\n    constructor() {\n      super(...arguments);\n      this.expanderClass = 'igx-grid__hierarchical-expander';\n      this.rolActionClass = 'igx-grid__tr-action';\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this.select = () => {\n        this.grid.selectRows([this.key]);\n      };\n      /**\n       * @hidden\n       * @internal\n       */\n\n\n      this.deselect = () => {\n        this.grid.deselectRows([this.key]);\n      };\n    }\n    /**\n     * @hidden\n     */\n\n\n    get expanderClassResolved() {\n      return {\n        [`${this.expanderClass} ${this.rolActionClass}`]: !this.pinned || this.disabled,\n        [`${this.expanderClass}--empty`]: this.pinned && !this.disabled\n      };\n    }\n\n    get viewIndex() {\n      var _a, _b;\n\n      return this.index + (((_a = this.grid.paginator) === null || _a === void 0 ? void 0 : _a.page) || 0) * (((_b = this.grid.paginator) === null || _b === void 0 ? void 0 : _b.perPage) || 0);\n    }\n    /**\n     * Returns whether the row is expanded.\n     * ```typescript\n     * const RowExpanded = this.grid1.rowList.first.expanded;\n     * ```\n     */\n\n\n    get expanded() {\n      return this.grid.gridAPI.get_row_expansion_state(this.data);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get expandedClass() {\n      return this.expanded && !this.pinned;\n    }\n\n    get hasChildren() {\n      return !!this.grid.childLayoutKeys.length;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get highlighted() {\n      return this.grid && this.grid.highlightedRowID === this.key;\n    }\n    /**\n     * @hidden\n     */\n\n\n    expanderClick(event) {\n      event.stopPropagation();\n      this.toggle();\n    }\n    /**\n     * Toggles the hierarchical row.\n     * ```typescript\n     * this.grid1.rowList.first.toggle()\n     * ```\n     */\n\n\n    toggle() {\n      if (this.added) {\n        return;\n      } // K.D. 28 Feb, 2022 #10634 Don't trigger endEdit/commit upon row expansion state change\n      // this.endEdit(this.grid.rootGrid);\n\n\n      this.grid.gridAPI.set_row_expansion_state(this.key, !this.expanded);\n      this.grid.cdr.detectChanges();\n    }\n    /**\n     * @hidden\n     */\n\n\n    get iconTemplate() {\n      let expandable = true;\n\n      if (this.grid.hasChildrenKey) {\n        expandable = this.data[this.grid.hasChildrenKey];\n      }\n\n      if (!expandable || this.pinned && !this.disabled) {\n        return this.defaultEmptyTemplate;\n      }\n\n      if (this.expanded) {\n        return this.grid.rowExpandedIndicatorTemplate || this.defaultExpandedTemplate;\n      } else {\n        return this.grid.rowCollapsedIndicatorTemplate || this.defaultCollapsedTemplate;\n      }\n    } // TODO: consider moving into CRUD\n\n\n    endEdit(grid) {\n      if (grid.gridAPI.crudService.cellInEditMode) {\n        grid.gridAPI.crudService.endEdit();\n      }\n\n      grid.gridAPI.getChildGrids(true).forEach(g => {\n        if (g.gridAPI.crudService.cellInEditMode) {\n          g.gridAPI.crudService.endEdit();\n        }\n      });\n    }\n\n  }\n\n  IgxHierarchicalRowComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxHierarchicalRowComponent_BaseFactory;\n    return function IgxHierarchicalRowComponent_Factory(t) {\n      return (ɵIgxHierarchicalRowComponent_BaseFactory || (ɵIgxHierarchicalRowComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxHierarchicalRowComponent)))(t || IgxHierarchicalRowComponent);\n    };\n  }();\n\n  IgxHierarchicalRowComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxHierarchicalRowComponent,\n    selectors: [[\"igx-hierarchical-grid-row\"]],\n    viewQuery: function IgxHierarchicalRowComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c239, 5, ElementRef);\n        i0.ɵɵviewQuery(_c195, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c240, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c196, 7, TemplateRef);\n        i0.ɵɵviewQuery(IgxHierarchicalGridCellComponent, 5, IgxHierarchicalGridCellComponent);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.expander = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultExpandedTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultEmptyTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultCollapsedTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._cells = _t);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function IgxHierarchicalRowComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-grid__tr--expanded\", ctx.expandedClass)(\"igx-grid__tr--highlighted\", ctx.highlighted);\n      }\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxRowDirective,\n      useExisting: forwardRef(() => IgxHierarchicalRowComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 11,\n    vars: 1,\n    consts: [[4, \"ngTemplateOutlet\"], [\"defaultExpandedTemplate\", \"\"], [\"defaultCollapsedTemplate\", \"\"], [\"defaultEmptyTemplate\", \"\"], [\"addTemp\", \"\"], [\"defaultTemp\", \"\"], [3, \"active\"], [1, \"igx-grid__tr--inner\", 3, \"animationend\"], [4, \"ngIf\"], [3, \"ngClass\", \"click\", \"mousedown\", 4, \"ngIf\"], [\"igxGridFor\", \"\", 3, \"igxGridForOf\", \"igxForScrollContainer\", \"igxForSizePropName\", \"igxForScrollOrientation\", \"igxForContainerSize\", \"igxForTrackBy\"], [\"igxDirRef\", \"\"], [\"rowSelectorBaseTemplate\", \"\"], [\"pinnedCellsTemplate\", \"\"], [3, \"igxRowDrag\", \"ghostTemplate\", \"click\", \"pointerdown\"], [1, \"igx-grid__cbx-selection\", \"igx-grid__tr-action\", 3, \"click\", \"pointerdown\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [3, \"ngClass\", \"click\", \"mousedown\"], [\"expander\", \"\"], [1, \"igx-grid__td\", \"igx-grid__td--fw\", 3, \"ngClass\", \"ngStyle\", \"editMode\", \"column\", \"formatter\", \"intRow\", \"active\", \"rowData\", \"width\", \"visibleColumnIndex\", \"value\", \"cellTemplate\", \"lastSearchInfo\", \"cellSelectionMode\", \"displayPinnedChip\"], [1, \"igx-grid__cbx-padding\"], [3, \"tabindex\", \"readonly\", \"checked\", \"disableRipple\", \"disabled\", \"disableTransitions\", \"aria-label\"], [\"class\", \"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\", 3, \"igx-grid__td--edited\", \"igx-grid__td--number\", \"ngClass\", \"ngStyle\", \"editMode\", \"column\", \"formatter\", \"intRow\", \"active\", \"firstPinned\", \"lastPinned\", \"min-height\", \"rowData\", \"min-width\", \"max-width\", \"flex-basis\", \"left\", \"width\", \"visibleColumnIndex\", \"value\", \"cellTemplate\", \"lastSearchInfo\", \"cellSelectionMode\", \"displayPinnedChip\", 4, \"ngFor\", \"ngForOf\"], [1, \"igx-grid__td\", \"igx-grid__td--fw\", \"igx-grid__td--pinned\", 3, \"ngClass\", \"ngStyle\", \"editMode\", \"column\", \"formatter\", \"intRow\", \"active\", \"firstPinned\", \"lastPinned\", \"rowData\", \"width\", \"visibleColumnIndex\", \"value\", \"cellTemplate\", \"lastSearchInfo\", \"cellSelectionMode\", \"displayPinnedChip\"]],\n    template: function IgxHierarchicalRowComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxHierarchicalRowComponent_ng_container_0_Template, 1, 0, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, IgxHierarchicalRowComponent_ng_template_1_Template, 2, 1, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(3, IgxHierarchicalRowComponent_ng_template_3_Template, 2, 1, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(5, IgxHierarchicalRowComponent_ng_template_5_Template, 1, 0, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(7, IgxHierarchicalRowComponent_ng_template_7_Template, 2, 3, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(9, IgxHierarchicalRowComponent_ng_template_9_Template, 12, 13, \"ng-template\", null, 5, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        const _r7 = i0.ɵɵreference(8);\n\n        const _r9 = i0.ɵɵreference(10);\n\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.addRowUI ? _r7 : _r9);\n      }\n    },\n    directives: [IgxIconComponent, IgxHierarchicalGridCellComponent, IgxCheckboxComponent, i4.NgTemplateOutlet, i4.NgIf, IgxRowDragDirective, i4.NgClass, IgxGridForOfDirective, i4.NgStyle, i4.NgForOf],\n    pipes: [IgxGridNotGroupedPipe, IgxGridTransactionStatePipe, IgxStringReplacePipe, IgxGridCellStyleClassesPipe, IgxGridCellStylesPipe, IgxGridDataMapperPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxHierarchicalRowComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxGridHierarchicalPipe = /*#__PURE__*/(() => {\n  class IgxGridHierarchicalPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(collection, state = new Map(), id, primaryKey, childKeys, _pipeTrigger) {\n      if (childKeys.length === 0) {\n        return collection;\n      }\n\n      if (this.grid.verticalScrollContainer.isRemote) {\n        return collection;\n      }\n\n      const result = this.addHierarchy(this.grid, cloneArray(collection), state, primaryKey, childKeys);\n      return result;\n    }\n\n    addHierarchy(grid, data, state, primaryKey, childKeys) {\n      const result = [];\n      data.forEach(v => {\n        result.push(v);\n        const childGridsData = {};\n        childKeys.forEach(childKey => {\n          if (!v[childKey]) {\n            v[childKey] = [];\n          }\n\n          const childData = v[childKey];\n          childGridsData[childKey] = childData;\n        });\n\n        if (grid.gridAPI.get_row_expansion_state(v)) {\n          result.push({\n            rowID: primaryKey ? v[primaryKey] : v,\n            childGridsData\n          });\n        }\n      });\n      return result;\n    }\n\n  }\n\n  IgxGridHierarchicalPipe.ɵfac = function IgxGridHierarchicalPipe_Factory(t) {\n    return new (t || IgxGridHierarchicalPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxGridHierarchicalPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"gridHierarchical\",\n    type: IgxGridHierarchicalPipe,\n    pure: true\n  });\n  return IgxGridHierarchicalPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxGridHierarchicalPagingPipe = /*#__PURE__*/(() => {\n  class IgxGridHierarchicalPagingPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(collection, page = 0, perPage = 15, _id, _pipeTrigger) {\n      const paginator = this.grid.paginator;\n\n      if (!paginator || this.grid.pagingMode !== GridPagingMode.Local) {\n        return collection;\n      }\n\n      const state = {\n        index: page,\n        recordsPerPage: perPage\n      };\n      const total = this.grid._totalRecords >= 0 ? this.grid._totalRecords : collection.length;\n      const result = DataUtil.page(cloneArray(collection), state, total);\n      this.grid.pagingState = state;\n      return result;\n    }\n\n  }\n\n  IgxGridHierarchicalPagingPipe.ɵfac = function IgxGridHierarchicalPagingPipe_Factory(t) {\n    return new (t || IgxGridHierarchicalPagingPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxGridHierarchicalPagingPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"gridHierarchicalPaging\",\n    type: IgxGridHierarchicalPagingPipe,\n    pure: true\n  });\n  return IgxGridHierarchicalPagingPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$6 = 0;\nlet IgxChildGridRowComponent = /*#__PURE__*/(() => {\n  class IgxChildGridRowComponent {\n    constructor(gridAPI, element, resolver, cdr) {\n      this.gridAPI = gridAPI;\n      this.element = element;\n      this.resolver = resolver;\n      this.cdr = cdr;\n      /**\n       *  The data passed to the row component.\n       *\n       * ```typescript\n       * // get the row data for the first selected row\n       * let selectedRowData = this.grid.selectedRows[0].data;\n       * ```\n       */\n\n      this.data = [];\n      /**\n       * Returns whether the row is expanded.\n       * ```typescript\n       * const RowExpanded = this.grid1.rowList.first.expanded;\n       * ```\n       */\n\n      this.expanded = false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get parentHasScroll() {\n      return !this.parentGrid.verticalScrollContainer.dc.instance.notVirtual;\n    }\n    /**\n     * Get a reference to the grid that contains the selected row.\n     *\n     * ```typescript\n     * handleRowSelection(event) {\n     *  // the grid on which the rowSelected event was triggered\n     *  const grid = event.row.grid;\n     * }\n     * ```\n     *\n     * ```html\n     *  <igx-grid\n     *    [data]=\"data\"\n     *    (rowSelected)=\"handleRowSelection($event)\">\n     *  </igx-grid>\n     * ```\n     */\n    // TODO: Refactor\n\n\n    get parentGrid() {\n      return this.gridAPI.grid;\n    }\n\n    get level() {\n      return this.layout.level;\n    }\n    /**\n     * The native DOM element representing the row. Could be null in certain environments.\n     *\n     * ```typescript\n     * // get the nativeElement of the second selected row\n     * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;\n     * ```\n     */\n\n\n    get nativeElement() {\n      return this.element.nativeElement;\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      this.layout.layoutChange.subscribe(ch => {\n        this._handleLayoutChanges(ch);\n      });\n      const changes = this.layout.initialChanges;\n      changes.forEach(change => {\n        this._handleLayoutChanges(change);\n      });\n      this.hGrid.parent = this.parentGrid;\n      this.hGrid.parentIsland = this.layout;\n      this.hGrid.childRow = this; // handler logic that re-emits hgrid events on the row island\n\n      this.setupEventEmitters();\n      this.layout.gridCreated.emit({\n        owner: this.layout,\n        parentID: this.data.rowID,\n        grid: this.hGrid\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterViewInit() {\n      this.hGrid.childLayoutList = this.layout.children;\n      const layouts = this.hGrid.childLayoutList.toArray();\n      layouts.forEach(l => this.hGrid.gridAPI.registerChildRowIsland(l));\n      this.parentGrid.gridAPI.registerChildGrid(this.data.rowID, this.layout.key, this.hGrid);\n      this.layout.rowIslandAPI.registerChildGrid(this.data.rowID, this.hGrid);\n      this.layout.gridInitialized.emit({\n        owner: this.layout,\n        parentID: this.data.rowID,\n        grid: this.hGrid\n      });\n      this.hGrid.cdr.detectChanges();\n    }\n\n    setupEventEmitters() {\n      const destructor = takeUntil(this.hGrid.destroy$);\n      const factory = this.resolver.resolveComponentFactory(IgxGridComponent); // exclude outputs related to two-way binding functionality\n\n      const inputNames = factory.inputs.map(input => input.propName);\n      const outputs = factory.outputs.filter(o => {\n        const matchingInputPropName = o.propName.slice(0, o.propName.indexOf('Change'));\n        return inputNames.indexOf(matchingInputPropName) === -1;\n      }); // TODO: Skip the `rendered` output. Rendered should be called once per grid.\n\n      outputs.filter(o => o.propName !== 'rendered').forEach(output => {\n        if (this.hGrid[output.propName]) {\n          this.hGrid[output.propName].pipe(destructor).subscribe(args => {\n            if (!args) {\n              args = {};\n            }\n\n            args.owner = this.hGrid;\n            this.layout[output.propName].emit(args);\n          });\n        }\n      });\n    }\n\n    _handleLayoutChanges(changes) {\n      for (const change in changes) {\n        if (changes.hasOwnProperty(change)) {\n          this.hGrid[change] = changes[change].currentValue;\n        }\n      }\n    }\n\n  }\n\n  IgxChildGridRowComponent.ɵfac = function IgxChildGridRowComponent_Factory(t) {\n    return new (t || IgxChildGridRowComponent)(i0.ɵɵdirectiveInject(IGX_GRID_SERVICE_BASE), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  IgxChildGridRowComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxChildGridRowComponent,\n    selectors: [[\"igx-child-grid-row\"]],\n    viewQuery: function IgxChildGridRowComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c242, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.hGrid = _t.first);\n      }\n    },\n    hostVars: 1,\n    hostBindings: function IgxChildGridRowComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-level\", ctx.level);\n      }\n    },\n    inputs: {\n      layout: \"layout\",\n      parentGridID: \"parentGridID\",\n      data: \"data\",\n      index: \"index\"\n    },\n    decls: 3,\n    vars: 4,\n    consts: [[1, \"igx-grid__hierarchical-indent\", 3, \"ngClass\"], [3, \"data\"], [\"hgrid\", \"\"]],\n    template: function IgxChildGridRowComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵelement(1, \"igx-hierarchical-grid\", 1, 2);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(2, _c243, ctx.parentHasScroll));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"data\", ctx.data.childGridsData[ctx.layout.key]);\n      }\n    },\n    directives: function () {\n      return [IgxHierarchicalGridComponent, i4.NgClass];\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxChildGridRowComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxHierarchicalGridComponent = /*#__PURE__*/(() => {\n  class IgxHierarchicalGridComponent extends IgxHierarchicalGridBaseDirective {\n    constructor() {\n      super(...arguments);\n      /**\n       * @hidden @internal\n       */\n\n      this.role = 'grid';\n      /**\n       * @hidden\n       */\n\n      this.childLayoutKeys = [];\n      /**\n       * @hidden\n       */\n\n      this.highlightedRowID = null;\n      /**\n       * @hidden\n       */\n\n      this.updateOnRender = false;\n      /**\n       * @hidden\n       */\n\n      this.parent = null;\n      this._filteredData = null;\n      this.h_id = `igx-hierarchical-grid-${NEXT_ID$6++}`;\n      this.childGridTemplates = new Map();\n      this.scrollTop = 0;\n      this.scrollLeft = 0;\n    } // @ViewChild('headerHierarchyExpander', { read: ElementRef, static: true })\n\n\n    get headerHierarchyExpander() {\n      return this.theadRow.headerHierarchyExpander;\n    }\n    /**\n     * Gets/Sets the value of the `id` attribute.\n     *\n     * @remarks\n     * If not provided it will be automatically generated.\n     * @example\n     * ```html\n     * <igx-hierarchical-grid [id]=\"'igx-hgrid-1'\" [data]=\"Data\" [autoGenerate]=\"true\"></igx-hierarchical-grid>\n     * ```\n     */\n\n\n    get id() {\n      return this.h_id;\n    }\n\n    set id(value) {\n      this.h_id = value;\n    }\n    /**\n     * An @Input property that lets you fill the `IgxHierarchicalGridComponent` with an array of data.\n     * ```html\n     * <igx-hierarchical-grid [data]=\"Data\" [autoGenerate]=\"true\"></igx-hierarchical-grid>\n     * ```\n     *\n     * @memberof IgxHierarchicalGridComponent\n     */\n\n\n    set data(value) {\n      this._data = value || [];\n      this.summaryService.clearSummaryCache();\n\n      if (this.shouldGenerate) {\n        this.setupColumns();\n        this.reflow();\n      }\n\n      this.cdr.markForCheck();\n\n      if (this.parent && (this.height === null || this.height.indexOf('%') !== -1)) {\n        // If the height will change based on how much data there is, recalculate sizes in igxForOf.\n        this.notifyChanges(true);\n      }\n    }\n    /**\n     * Returns an array of data set to the `IgxHierarchicalGridComponent`.\n     * ```typescript\n     * let filteredData = this.grid.filteredData;\n     * ```\n     *\n     * @memberof IgxHierarchicalGridComponent\n     */\n\n\n    get data() {\n      return this._data;\n    }\n    /** @hidden @internal */\n\n\n    get paginator() {\n      var _a, _b;\n\n      const id = this.id;\n      return !this.parentIsland && ((_a = this.paginationComponents) === null || _a === void 0 ? void 0 : _a.first) || ((_b = this.rootGrid.paginatorList) === null || _b === void 0 ? void 0 : _b.find(pg => {\n        var _a;\n\n        return ((_a = pg.nativeElement.offsetParent) === null || _a === void 0 ? void 0 : _a.id) === id;\n      }));\n    }\n    /**\n     * Sets an array of objects containing the filtered data in the `IgxHierarchicalGridComponent`.\n     * ```typescript\n     * this.grid.filteredData = [{\n     *       ID: 1,\n     *       Name: \"A\"\n     * }];\n     * ```\n     *\n     * @memberof IgxHierarchicalGridComponent\n     */\n\n\n    set filteredData(value) {\n      this._filteredData = value;\n    }\n    /**\n     * Returns an array of objects containing the filtered data in the `IgxHierarchicalGridComponent`.\n     * ```typescript\n     * let filteredData = this.grid.filteredData;\n     * ```\n     *\n     * @memberof IgxHierarchicalGridComponent\n     */\n\n\n    get filteredData() {\n      return this._filteredData;\n    }\n    /**\n     * Gets/Sets the total number of records in the data source.\n     *\n     * @remarks\n     * This property is required for remote grid virtualization to function when it is bound to remote data.\n     * @example\n     * ```typescript\n     * const itemCount = this.grid1.totalItemCount;\n     * this.grid1.totalItemCount = 55;\n     * ```\n     */\n\n\n    set totalItemCount(count) {\n      this.verticalScrollContainer.totalItemCount = count;\n      this.cdr.detectChanges();\n    }\n\n    get totalItemCount() {\n      return this.verticalScrollContainer.totalItemCount;\n    }\n    /**\n     * Sets if all immediate children of the `IgxHierarchicalGridComponent` should be expanded/collapsed.\n     * Defult value is false.\n     * ```html\n     * <igx-hierarchical-grid [id]=\"'igx-grid-1'\" [data]=\"Data\" [autoGenerate]=\"true\" [expandChildren]=\"true\"></igx-hierarchical-grid>\n     * ```\n     *\n     * @memberof IgxHierarchicalGridComponent\n     */\n\n\n    set expandChildren(value) {\n      this._defaultExpandState = value;\n      this.expansionStates = new Map();\n    }\n    /**\n     * Gets if all immediate children of the `IgxHierarchicalGridComponent` previously have been set to be expanded/collapsed.\n     * If previously set and some rows have been manually expanded/collapsed it will still return the last set value.\n     * ```typescript\n     * const expanded = this.grid.expandChildren;\n     * ```\n     *\n     * @memberof IgxHierarchicalGridComponent\n     */\n\n\n    get expandChildren() {\n      return this._defaultExpandState;\n    }\n    /**\n     * @deprecated in version 12.1.0. Use `getCellByColumn` or `getCellByKey` instead\n     *\n     * Returns a `CellType` object that matches the conditions.\n     *\n     * @example\n     * ```typescript\n     * const myCell = this.grid1.getCellByColumnVisibleIndex(2,\"UnitPrice\");\n     * ```\n     * @param rowIndex\n     * @param index\n     */\n\n\n    getCellByColumnVisibleIndex(rowIndex, index) {\n      const row = this.getRowByIndex(rowIndex);\n      const column = this.columnList.find(col => col.visibleIndex === index);\n\n      if (row && row instanceof IgxHierarchicalGridRow && column) {\n        return new IgxGridCell(this, rowIndex, column.field);\n      }\n    }\n    /**\n     * Gets the unique identifier of the parent row. It may be a `string` or `number` if `primaryKey` of the\n     * parent grid is set or an object reference of the parent record otherwise.\n     * ```typescript\n     * const foreignKey = this.grid.foreignKey;\n     * ```\n     *\n     * @memberof IgxHierarchicalGridComponent\n     */\n\n\n    get foreignKey() {\n      if (!this.parent) {\n        return null;\n      }\n\n      return this.parent.gridAPI.getParentRowId(this);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hasExpandableChildren() {\n      return !!this.childLayoutKeys.length;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get resolveRowEditContainer() {\n      if (this.parentIsland && this.parentIsland.rowEditCustom) {\n        return this.parentIsland.rowEditContainer;\n      }\n\n      return this.rowEditContainer;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get resolveRowEditActions() {\n      return this.parentIsland ? this.parentIsland.rowEditActions : this.rowEditActions;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get resolveRowEditText() {\n      return this.parentIsland ? this.parentIsland.rowEditText : this.rowEditText;\n    }\n    /** @hidden */\n\n\n    hideActionStrip() {\n      if (!this.parent) {\n        // hide child layout actions strips when\n        // moving outside root grid.\n        super.hideActionStrip();\n        this.allLayoutList.forEach(ri => {\n          var _a;\n\n          (_a = ri.actionStrip) === null || _a === void 0 ? void 0 : _a.hide();\n        });\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get parentRowOutletDirective() {\n      // Targeting parent outlet in order to prevent hiding when outlet\n      // is present at a child grid and is attached to a row.\n      return this.parent ? this.parent.rowOutletDirective : this.outlet;\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      // this.expansionStatesChange.pipe(takeUntil(this.destroy$)).subscribe((value: Map<any, boolean>) => {\n      //     const res = Array.from(value.entries()).filter(({1: v}) => v === true).map(([k]) => k);\n      // });\n      this.batchEditing = !!this.rootGrid.batchEditing;\n\n      if (this.rootGrid !== this) {\n        this.rootGrid.batchEditingChange.pipe(takeUntil(this.destroy$)).subscribe(val => {\n          this.batchEditing = val;\n        });\n      }\n\n      super.ngOnInit();\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterViewInit() {\n      super.ngAfterViewInit();\n      this.zone.runOutsideAngular(() => {\n        this.verticalScrollContainer.getScroll().addEventListener('scroll', this.hg_verticalScrollHandler.bind(this));\n        this.headerContainer.getScroll().addEventListener('scroll', this.hg_horizontalScrollHandler.bind(this));\n      });\n      this.verticalScrollContainer.beforeViewDestroyed.pipe(takeUntil(this.destroy$)).subscribe(view => {\n        const rowData = view.context.$implicit;\n\n        if (this.isChildGridRecord(rowData)) {\n          const cachedData = this.childGridTemplates.get(rowData.rowID);\n\n          if (cachedData) {\n            const tmlpOutlet = cachedData.owner;\n\n            tmlpOutlet._viewContainerRef.detach(0);\n          }\n        }\n      });\n\n      if (this.parent) {\n        this._displayDensity = this.rootGrid.displayDensity;\n        this.summaryService.summaryHeight = 0;\n        this.rootGrid.onDensityChanged.pipe(takeUntil(this.destroy$)).subscribe(() => {\n          this._displayDensity = this.rootGrid.displayDensity;\n          this.summaryService.summaryHeight = 0;\n          this.notifyChanges(true);\n          this.cdr.markForCheck();\n        });\n        this.childLayoutKeys = this.parentIsland.children.map(item => item.key);\n      }\n\n      this.actionStrip = this.parentIsland ? this.parentIsland.actionStrip : this.actionStrip;\n      this.headSelectorsTemplates = this.parentIsland ? this.parentIsland.headSelectorsTemplates : this.headSelectorsTemplates;\n      this.rowSelectorsTemplates = this.parentIsland ? this.parentIsland.rowSelectorsTemplates : this.rowSelectorsTemplates;\n      this.dragIndicatorIconTemplate = this.parentIsland ? this.parentIsland.dragIndicatorIconTemplate : this.dragIndicatorIconTemplate;\n      this.rowExpandedIndicatorTemplate = this.rootGrid.rowExpandedIndicatorTemplate;\n      this.rowCollapsedIndicatorTemplate = this.rootGrid.rowCollapsedIndicatorTemplate;\n      this.headerCollapseIndicatorTemplate = this.rootGrid.headerCollapseIndicatorTemplate;\n      this.headerExpandIndicatorTemplate = this.rootGrid.headerExpandIndicatorTemplate;\n      this.excelStyleHeaderIconTemplate = this.rootGrid.excelStyleHeaderIconTemplate;\n      this.sortAscendingHeaderIconTemplate = this.rootGrid.sortAscendingHeaderIconTemplate;\n      this.sortDescendingHeaderIconTemplate = this.rootGrid.sortDescendingHeaderIconTemplate;\n      this.sortHeaderIconTemplate = this.rootGrid.sortHeaderIconTemplate;\n      this.hasChildrenKey = this.parentIsland ? this.parentIsland.hasChildrenKey || this.rootGrid.hasChildrenKey : this.rootGrid.hasChildrenKey;\n      this.showExpandAll = this.parentIsland ? this.parentIsland.showExpandAll : this.rootGrid.showExpandAll;\n    }\n\n    get outletDirective() {\n      return this.rootGrid.outlet;\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterContentInit() {\n      this.updateColumnList(false);\n      this.childLayoutKeys = this.parent ? this.parentIsland.children.map(item => item.key) : this.childLayoutKeys = this.childLayoutList.map(item => item.key);\n      this.childLayoutList.notifyOnChanges();\n      this.childLayoutList.changes.pipe(takeUntil(this.destroy$)).subscribe(() => this.onRowIslandChange());\n      super.ngAfterContentInit();\n    }\n    /**\n     * Returns the `RowType` by index.\n     *\n     * @example\n     * ```typescript\n     * const myRow = this.grid1.getRowByIndex(1);\n     * ```\n     * @param index\n     */\n\n\n    getRowByIndex(index) {\n      if (index < 0 || index >= this.dataView.length) {\n        return undefined;\n      }\n\n      return this.createRow(index);\n    }\n    /**\n     * Returns the `RowType` by key.\n     *\n     * @example\n     * ```typescript\n     * const myRow = this.grid1.getRowByKey(1);\n     * ```\n     * @param key\n     */\n\n\n    getRowByKey(key) {\n      const data = this.dataView;\n      const rec = this.primaryKey ? data.find(record => record[this.primaryKey] === key) : data.find(record => record === key);\n      const index = data.indexOf(rec);\n\n      if (index < 0 || index > data.length) {\n        return undefined;\n      }\n\n      return new IgxHierarchicalGridRow(this, index, rec);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    allRows() {\n      return this.dataView.map((rec, index) => this.createRow(index));\n    }\n    /**\n     * Returns the collection of `IgxHierarchicalGridRow`s for current page.\n     *\n     * @hidden @internal\n     */\n\n\n    dataRows() {\n      return this.allRows().filter(row => row instanceof IgxHierarchicalGridRow);\n    }\n    /**\n     * Returns an array of the selected `IgxGridCell`s.\n     *\n     * @example\n     * ```typescript\n     * const selectedCells = this.grid.selectedCells;\n     * ```\n     */\n\n\n    get selectedCells() {\n      return this.dataRows().map(row => row.cells.filter(cell => cell.selected)).reduce((a, b) => a.concat(b), []);\n    }\n    /**\n     * Returns a `CellType` object that matches the conditions.\n     *\n     * @example\n     * ```typescript\n     * const myCell = this.grid1.getCellByColumn(2, \"UnitPrice\");\n     * ```\n     * @param rowIndex\n     * @param columnField\n     */\n\n\n    getCellByColumn(rowIndex, columnField) {\n      const row = this.getRowByIndex(rowIndex);\n      const column = this.columnList.find(col => col.field === columnField);\n\n      if (row && row instanceof IgxHierarchicalGridRow && column) {\n        return new IgxGridCell(this, rowIndex, columnField);\n      }\n    }\n    /**\n     * Returns a `CellType` object that matches the conditions.\n     *\n     * @remarks\n     * Requires that the primaryKey property is set.\n     * @example\n     * ```typescript\n     * grid.getCellByKey(1, 'index');\n     * ```\n     * @param rowSelector match any rowID\n     * @param columnField\n     */\n\n\n    getCellByKey(rowSelector, columnField) {\n      const row = this.getRowByKey(rowSelector);\n      const column = this.columnList.find(col => col.field === columnField);\n\n      if (row && column) {\n        return new IgxGridCell(this, row.index, columnField);\n      }\n    }\n\n    pinRow(rowID, index) {\n      const row = this.getRowByKey(rowID);\n      return super.pinRow(rowID, index, row);\n    }\n\n    unpinRow(rowID) {\n      const row = this.getRowByKey(rowID);\n      return super.unpinRow(rowID, row);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    dataLoading(event) {\n      this.dataPreLoad.emit(event);\n    }\n    /** @hidden */\n\n\n    featureColumnsWidth() {\n      return super.featureColumnsWidth(this.headerHierarchyExpander);\n    }\n    /**\n     * @hidden\n     */\n\n\n    onRowIslandChange() {\n      if (this.parent) {\n        this.childLayoutKeys = this.parentIsland.children.filter(item => !item._destroyed).map(item => item.key);\n      } else {\n        this.childLayoutKeys = this.childLayoutList.filter(item => !item._destroyed).map(item => item.key);\n      }\n\n      if (!this.cdr.destroyed) {\n        this.cdr.detectChanges();\n      }\n    }\n\n    ngOnDestroy() {\n      if (!this.parent) {\n        this.gridAPI.getChildGrids(true).forEach(grid => {\n          if (!grid.childRow.cdr.destroyed) {\n            grid.childRow.cdr.destroy();\n          }\n        });\n      }\n\n      if (this.parent && this.selectionService.activeElement) {\n        // in case selection is in destroyed child grid, selection should be cleared.\n        this._clearSeletionHighlights();\n      }\n\n      super.ngOnDestroy();\n    }\n    /**\n     * @hidden\n     */\n\n\n    isRowHighlighted(rowData) {\n      return this.highlightedRowID === rowData.rowID;\n    }\n    /**\n     * @hidden\n     */\n\n\n    isHierarchicalRecord(record) {\n      if (this.isGhostRecord(record)) {\n        record = record.recordRef;\n      }\n\n      return this.childLayoutList.length !== 0 && record[this.childLayoutList.first.key];\n    }\n    /**\n     * @hidden\n     */\n\n\n    isChildGridRecord(record) {\n      // Can be null when there is defined layout but no child data was found\n      return (record === null || record === void 0 ? void 0 : record.childGridsData) !== undefined;\n    }\n    /**\n     * @hidden\n     */\n\n\n    trackChanges(index, rec) {\n      if (rec.childGridsData !== undefined) {\n        // if is child rec\n        return rec.rowID;\n      }\n\n      return rec;\n    }\n    /**\n     * @hidden\n     */\n\n\n    getContext(rowData, rowIndex, pinned) {\n      if (this.isChildGridRecord(rowData)) {\n        const cachedData = this.childGridTemplates.get(rowData.rowID);\n\n        if (cachedData) {\n          const view = cachedData.view;\n          const tmlpOutlet = cachedData.owner;\n          return {\n            $implicit: rowData,\n            moveView: view,\n            owner: tmlpOutlet,\n            index: this.dataView.indexOf(rowData)\n          };\n        } else {\n          // child rows contain unique grids, hence should have unique templates\n          return {\n            $implicit: rowData,\n            templateID: {\n              type: 'childRow',\n              id: rowData.rowID\n            },\n            index: this.dataView.indexOf(rowData)\n          };\n        }\n      } else {\n        return {\n          $implicit: this.isGhostRecord(rowData) ? rowData.recordRef : rowData,\n          templateID: {\n            type: 'dataRow',\n            id: null\n          },\n          index: this.getDataViewIndex(rowIndex, pinned),\n          disabled: this.isGhostRecord(rowData)\n        };\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get rootGrid() {\n      let currGrid = this;\n\n      while (currGrid.parent) {\n        currGrid = currGrid.parent;\n      }\n\n      return currGrid;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get iconTemplate() {\n      const expanded = this.hasExpandedRecords() && this.hasExpandableChildren;\n\n      if (!expanded && this.showExpandAll) {\n        return this.headerCollapseIndicatorTemplate || this.defaultCollapsedTemplate;\n      } else {\n        return this.headerExpandIndicatorTemplate || this.defaultExpandedTemplate;\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    getDragGhostCustomTemplate() {\n      if (this.parentIsland) {\n        return this.parentIsland.getDragGhostCustomTemplate();\n      }\n\n      return super.getDragGhostCustomTemplate();\n    }\n    /**\n     * @hidden\n     * Gets the visible content height that includes header + tbody + footer.\n     * For hierarchical child grid it may be scrolled and not fully visible.\n     */\n\n\n    getVisibleContentHeight() {\n      let height = super.getVisibleContentHeight();\n\n      if (this.parent) {\n        const rootHeight = this.rootGrid.getVisibleContentHeight();\n        const topDiff = this.nativeElement.getBoundingClientRect().top - this.rootGrid.nativeElement.getBoundingClientRect().top;\n        height = rootHeight - topDiff > height ? height : rootHeight - topDiff;\n      }\n\n      return height;\n    }\n    /**\n     * @hidden\n     */\n\n\n    toggleAll() {\n      const expanded = this.hasExpandedRecords() && this.hasExpandableChildren;\n\n      if (!expanded && this.showExpandAll) {\n        this.expandAll();\n      } else {\n        this.collapseAll();\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    hasExpandedRecords() {\n      if (this.expandChildren) {\n        return true;\n      }\n\n      let hasExpandedEntry = false;\n      this.expansionStates.forEach(value => {\n        if (value) {\n          hasExpandedEntry = value;\n        }\n      });\n      return hasExpandedEntry;\n    }\n\n    getDefaultExpandState(record) {\n      if (this.hasChildrenKey && !record[this.hasChildrenKey]) {\n        return false;\n      }\n\n      return this.expandChildren;\n    }\n    /**\n     * @hidden\n     */\n\n\n    isExpanded(record) {\n      return this.gridAPI.get_row_expansion_state(record);\n    }\n    /**\n     * @hidden\n     */\n\n\n    viewCreatedHandler(args) {\n      if (this.isChildGridRecord(args.context.$implicit)) {\n        const key = args.context.$implicit.rowID;\n        this.childGridTemplates.set(key, args);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    viewMovedHandler(args) {\n      if (this.isChildGridRecord(args.context.$implicit)) {\n        // view was moved, update owner in cache\n        const key = args.context.$implicit.rowID;\n        const cachedData = this.childGridTemplates.get(key);\n        cachedData.owner = args.owner;\n        this.childLayoutList.forEach(layout => {\n          const relatedGrid = this.gridAPI.getChildGridByID(layout.key, args.context.$implicit.rowID);\n\n          if (relatedGrid && relatedGrid.updateOnRender) {\n            // Detect changes if `expandChildren` has changed when the grid wasn't visible. This is for performance reasons.\n            relatedGrid.notifyChanges(true);\n            relatedGrid.updateOnRender = false;\n          }\n        });\n      }\n    }\n\n    onContainerScroll() {\n      this.hideOverlays();\n    }\n    /**\n     * @hidden\n     */\n\n\n    createRow(index, data) {\n      let row;\n\n      const dataIndex = this._getDataViewIndex(index);\n\n      const rec = data !== null && data !== void 0 ? data : this.dataView[dataIndex];\n\n      if (!row && rec && !rec.childGridsData) {\n        row = new IgxHierarchicalGridRow(this, index, rec);\n      }\n\n      return row;\n    }\n    /** @hidden @internal */\n\n\n    getChildGrids(inDeph) {\n      return this.gridAPI.getChildGrids(inDeph);\n    }\n\n    generateDataFields(data) {\n      return super.generateDataFields(data).filter(field => {\n        const layoutsList = this.parentIsland ? this.parentIsland.children : this.childLayoutList;\n        const keys = layoutsList.map(item => item.key);\n        return keys.indexOf(field) === -1;\n      });\n    }\n\n    resizeNotifyHandler() {\n      // do not trigger reflow if element is detached or if it is child grid.\n      if (this.document.contains(this.nativeElement) && !this.parent) {\n        this.notifyChanges(true);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    initColumns(collection, cb = null) {\n      if (this.hasColumnLayouts) {\n        // invalid configuration - hierarchical grid should not allow column layouts\n        // remove column layouts\n        const nonColumnLayoutColumns = this.columnList.filter(col => !col.columnLayout && !col.columnLayoutChild);\n        this.columnList.reset(nonColumnLayoutColumns);\n      }\n\n      super.initColumns(collection, cb);\n    }\n\n    setupColumns() {\n      if (this.parentIsland && this.parentIsland.childColumns.length > 0 && !this.autoGenerate) {\n        this.createColumnsList(this.parentIsland.childColumns.toArray());\n      }\n\n      super.setupColumns();\n    }\n\n    onColumnsChanged(change) {\n      Promise.resolve().then(() => {\n        this.updateColumnList();\n        const cols = change.filter(c => c.grid === this);\n\n        if (cols.length > 0 || this.autoGenerate) {\n          this.columnList.reset(cols);\n          super.onColumnsChanged(this.columnList);\n        }\n      });\n    }\n\n    _shouldAutoSize(renderedHeight) {\n      if (this.isPercentHeight && this.parent) {\n        return true;\n      }\n\n      return super._shouldAutoSize(renderedHeight);\n    }\n\n    updateColumnList(recalcColSizes = true) {\n      const childLayouts = this.parent ? this.childLayoutList : this.allLayoutList;\n      const nestedColumns = childLayouts.map(layout => layout.columnList.toArray());\n      const colsArray = [].concat.apply([], nestedColumns);\n      const colLength = this.columnList.length;\n\n      if (colsArray.length > 0) {\n        const topCols = this.columnList.filter(item => colsArray.indexOf(item) === -1);\n        this.columnList.reset(topCols);\n\n        if (recalcColSizes && this.columnList.length !== colLength) {\n          this.calculateGridSizes(false);\n        }\n      }\n    }\n\n    _clearSeletionHighlights() {\n      [this.rootGrid, ...this.rootGrid.getChildGrids(true)].forEach(grid => {\n        grid.selectionService.clear();\n        grid.selectionService.activeElement = null;\n        grid.nativeElement.classList.remove('igx-grid__tr--highlighted');\n        grid.highlightedRowID = null;\n        grid.cdr.markForCheck();\n      });\n    }\n\n    hg_verticalScrollHandler(event) {\n      this.scrollTop = this.verticalScrollContainer.scrollPosition;\n    }\n\n    hg_horizontalScrollHandler(event) {\n      this.scrollLeft = this.headerContainer.scrollPosition;\n    }\n\n  }\n\n  IgxHierarchicalGridComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxHierarchicalGridComponent_BaseFactory;\n    return function IgxHierarchicalGridComponent_Factory(t) {\n      return (ɵIgxHierarchicalGridComponent_BaseFactory || (ɵIgxHierarchicalGridComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxHierarchicalGridComponent)))(t || IgxHierarchicalGridComponent);\n    };\n  }();\n\n  IgxHierarchicalGridComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxHierarchicalGridComponent,\n    selectors: [[\"igx-hierarchical-grid\"]],\n    contentQueries: function IgxHierarchicalGridComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxGridToolbarDirective, 7, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxRowIslandComponent, 4, IgxRowIslandComponent);\n        i0.ɵɵcontentQuery(dirIndex, IgxRowIslandComponent, 5, IgxRowIslandComponent);\n        i0.ɵɵcontentQuery(dirIndex, IgxPaginatorComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.childLayoutList = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.allLayoutList = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.paginatorList = _t);\n      }\n    },\n    viewQuery: function IgxHierarchicalGridComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c244, 5, ViewContainerRef);\n        i0.ɵɵviewQuery(_c245, 5, ViewContainerRef);\n        i0.ɵɵviewQuery(_c246, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c247, 7, TemplateRef);\n        i0.ɵɵviewQuery(IgxTemplateOutletDirective, 5, IgxTemplateOutletDirective);\n        i0.ɵɵviewQuery(IgxChildGridRowComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarOutlet = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.paginatorOutlet = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.hierarchicalRecordTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.childTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.templateOutlets = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.hierarchicalRows = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function IgxHierarchicalGridComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"id\", ctx.id);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      data: \"data\",\n      expandChildren: \"expandChildren\"\n    },\n    features: [i0.ɵɵProvidersFeature([IgxGridCRUDService, IgxGridSelectionService, {\n      provide: IGX_GRID_SERVICE_BASE,\n      useClass: IgxHierarchicalGridAPIService\n    }, {\n      provide: IGX_GRID_BASE,\n      useExisting: IgxHierarchicalGridComponent\n    }, IgxGridSummaryService, IgxFilteringService, IgxHierarchicalGridNavigationService, IgxForOfSyncService, IgxForOfScrollSyncService, IgxRowIslandAPIService]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c229,\n    decls: 94,\n    vars: 143,\n    consts: [[\"toolbarOutlet\", \"\"], [\"tabindex\", \"0\", 1, \"igx-grid-thead\", 3, \"grid\", \"hasMRL\", \"activeDescendant\", \"width\", \"pinnedColumnCollection\", \"unpinnedColumnCollection\", \"keydown.meta.c\", \"keydown.control.c\", \"copy\", \"keydown\", \"focus\"], [\"igxGridBody\", \"\", \"role\", \"rowgroup\", 1, \"igx-grid__tbody\", 3, \"keydown.control.c\", \"copy\"], [\"tabindex\", \"0\", 1, \"igx-grid__tbody-content\", 3, \"igxGridDragSelect\", \"focus\", \"keydown\", \"dragStop\", \"dragScroll\", \"scroll\"], [\"tbody\", \"\"], [\"id\", \"left\", \"class\", \"igx-grid__scroll-on-drag-left\", 3, \"igxColumnMovingDrop\", 4, \"ngIf\"], [\"id\", \"left\", \"class\", \"igx-grid__scroll-on-drag-pinned\", 3, \"igxColumnMovingDrop\", \"left\", 4, \"ngIf\"], [\"pinnedRecordsTemplate\", \"\"], [4, \"ngTemplateOutlet\"], [\"igxGridFor\", \"\", 3, \"igxGridForOf\", \"igxForScrollOrientation\", \"igxForScrollContainer\", \"igxForContainerSize\", \"igxForItemSize\", \"igxForTrackBy\", \"chunkPreload\", \"dataChanging\", \"dataChanged\"], [\"verticalScrollContainer\", \"\"], [\"hierarchical_record_template\", \"\"], [\"pinned_hierarchical_record_template\", \"\"], [\"child_record_template\", \"\"], [\"id\", \"right\", \"class\", \"igx-grid__scroll-on-drag-right\", 3, \"igxColumnMovingDrop\", 4, \"ngIf\"], [\"igxOverlayOutlet\", \"\", 1, \"igx-grid__row-editing-outlet\"], [\"igxRowEditingOverlayOutlet\", \"\"], [4, \"ngIf\"], [\"igxToggle\", \"\"], [\"loadingOverlay\", \"\"], [3, \"indeterminate\", 4, \"ngIf\"], [1, \"igx-grid__tbody-scrollbar\", 3, \"hidden\", \"pointerdown\"], [1, \"igx-grid__tbody-scrollbar-start\"], [1, \"igx-grid__tbody-scrollbar-main\"], [\"igxGridFor\", \"\", 3, \"igxGridForOf\"], [\"verticalScrollHolder\", \"\"], [1, \"igx-grid__tbody-scrollbar-end\"], [1, \"igx-grid__addrow-snackbar\"], [3, \"outlet\", \"actionText\", \"displayTime\"], [\"addRowSnackbar\", \"\"], [\"igxOverlayOutlet\", \"\"], [\"igxBodyOverlayOutlet\", \"overlay-outlet\"], [\"role\", \"rowgroup\", 1, \"igx-grid__tfoot\"], [\"tfoot\", \"\"], [\"tabindex\", \"0\", 3, \"focus\", \"keydown\"], [\"role\", \"row\", \"class\", \"igx-grid__summaries\", 3, \"width\", \"height\", \"gridID\", \"summaries\", \"index\", 4, \"ngIf\"], [1, \"igx-grid__tfoot-thumb\", 3, \"hidden\"], [1, \"igx-grid__scroll\", 3, \"hidden\", \"pointerdown\"], [\"scr\", \"\"], [1, \"igx-grid__scroll-start\"], [1, \"igx-grid__scroll-main\"], [\"scrollContainer\", \"\"], [1, \"igx-grid__scroll-end\", 3, \"hidden\"], [1, \"igx-grid__footer\"], [\"footer\", \"\"], [\"paginatorOutlet\", \"\"], [\"emptyFilteredGrid\", \"\"], [\"defaultEmptyGrid\", \"\"], [\"defaultAddRowEmptyTemplate\", \"\"], [\"defaultLoadingGrid\", \"\"], [\"defaultCollapsedTemplate\", \"\"], [\"defaultExpandedTemplate\", \"\"], [\"igxToggle\", \"\", 4, \"ngIf\"], [\"defaultRowEditText\", \"\"], [\"defaultRowEditActions\", \"\"], [\"defaultRowEditTemplate\", \"\"], [\"dragIndicatorIconBase\", \"\"], [\"igxOverlayOutlet\", \"\", 1, \"igx-grid__loading-outlet\"], [\"igxLoadingOverlayOutlet\", \"\"], [\"igxOverlayOutlet\", \"\", 1, \"igx-grid__outlet\"], [\"igxFilteringOverlayOutlet\", \"\"], [\"id\", \"left\", 1, \"igx-grid__scroll-on-drag-left\", 3, \"igxColumnMovingDrop\"], [\"id\", \"left\", 1, \"igx-grid__scroll-on-drag-pinned\", 3, \"igxColumnMovingDrop\"], [\"class\", \"igx-grid__tr--pinned\", 3, \"ngClass\", \"width\", 4, \"ngIf\"], [1, \"igx-grid__tr--pinned\", 3, \"ngClass\"], [\"pinContainer\", \"\"], [4, \"ngFor\", \"ngForOf\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [3, \"igxTemplateOutlet\", \"igxTemplateOutletContext\", \"viewCreated\", \"viewMoved\", \"cachedViewLoaded\"], [3, \"gridID\", \"index\", \"disabled\", \"data\", \"ngClass\", \"ngStyle\"], [\"row\", \"\"], [3, \"gridID\", \"index\", \"data\", \"ngClass\", \"ngStyle\"], [\"row\", \"\", \"pinnedRow\", \"\"], [2, \"overflow\", \"auto\", \"width\", \"100%\", 3, \"ngClass\", \"scroll\"], [3, \"parentGridID\", \"index\", \"data\", \"layout\", 4, \"ngFor\", \"ngForOf\"], [3, \"parentGridID\", \"index\", \"data\", \"layout\"], [\"id\", \"right\", 1, \"igx-grid__scroll-on-drag-right\", 3, \"igxColumnMovingDrop\"], [3, \"indeterminate\"], [\"role\", \"row\", 1, \"igx-grid__summaries\", 3, \"gridID\", \"summaries\", \"index\"], [\"summaryRow\", \"\"], [\"role\", \"cell\", 1, \"igx-grid__tbody-message\"], [\"igxButton\", \"raised\", \"igxRipple\", \"\", 3, \"click\"], [1, \"igx-grid__loading\"], [\"role\", \"button\"], [\"role\", \"button\", 3, \"active\"], [\"rowEditingOverlay\", \"\"], [3, \"className\"], [\"igxButton\", \"\", \"igxRowEditTabStop\", \"\", 3, \"click\"], [1, \"igx-banner__message\"], [1, \"igx-banner__text\"], [1, \"igx-banner__actions\"], [1, \"igx-banner__row\"]],\n    template: function IgxHierarchicalGridComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c227);\n        i0.ɵɵprojection(0);\n        i0.ɵɵelementContainer(1, null, 0);\n        i0.ɵɵelementStart(3, \"igx-grid-header-row\", 1);\n        i0.ɵɵlistener(\"keydown.meta.c\", function IgxHierarchicalGridComponent_Template_igx_grid_header_row_keydown_meta_c_3_listener($event) {\n          return ctx.copyHandler($event);\n        })(\"keydown.control.c\", function IgxHierarchicalGridComponent_Template_igx_grid_header_row_keydown_control_c_3_listener($event) {\n          return ctx.copyHandler($event);\n        })(\"copy\", function IgxHierarchicalGridComponent_Template_igx_grid_header_row_copy_3_listener($event) {\n          return ctx.copyHandler($event);\n        })(\"keydown\", function IgxHierarchicalGridComponent_Template_igx_grid_header_row_keydown_3_listener($event) {\n          return ctx.navigation.headerNavigation($event);\n        })(\"focus\", function IgxHierarchicalGridComponent_Template_igx_grid_header_row_focus_3_listener() {\n          return ctx.navigation.focusFirstCell();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(4, \"div\", 2);\n        i0.ɵɵlistener(\"keydown.control.c\", function IgxHierarchicalGridComponent_Template_div_keydown_control_c_4_listener($event) {\n          return ctx.copyHandler($event);\n        })(\"copy\", function IgxHierarchicalGridComponent_Template_div_copy_4_listener($event) {\n          return ctx.copyHandler($event);\n        });\n        i0.ɵɵelementStart(5, \"div\", 3, 4);\n        i0.ɵɵlistener(\"focus\", function IgxHierarchicalGridComponent_Template_div_focus_5_listener($event) {\n          return ctx.navigation.focusTbody($event);\n        })(\"keydown\", function IgxHierarchicalGridComponent_Template_div_keydown_5_listener($event) {\n          return ctx.navigation.handleNavigation($event);\n        })(\"dragStop\", function IgxHierarchicalGridComponent_Template_div_dragStop_5_listener($event) {\n          return ctx.selectionService.dragMode = $event;\n        })(\"dragScroll\", function IgxHierarchicalGridComponent_Template_div_dragScroll_5_listener($event) {\n          return ctx.dragScroll($event);\n        })(\"scroll\", function IgxHierarchicalGridComponent_Template_div_scroll_5_listener($event) {\n          return ctx.preventContainerScroll($event);\n        });\n        i0.ɵɵtemplate(7, IgxHierarchicalGridComponent_span_7_Template, 1, 2, \"span\", 5);\n        i0.ɵɵtemplate(8, IgxHierarchicalGridComponent_span_8_Template, 1, 4, \"span\", 6);\n        i0.ɵɵtemplate(9, IgxHierarchicalGridComponent_ng_template_9_Template, 7, 47, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(11, IgxHierarchicalGridComponent_ng_container_11_Template, 1, 0, \"ng-container\", 8);\n        i0.ɵɵtemplate(12, IgxHierarchicalGridComponent_ng_template_12_Template, 1, 2, \"ng-template\", 9, 10, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵpipe(14, \"gridRowPinning\");\n        i0.ɵɵpipe(15, \"gridAddRow\");\n        i0.ɵɵpipe(16, \"gridHierarchical\");\n        i0.ɵɵpipe(17, \"gridHierarchicalPaging\");\n        i0.ɵɵpipe(18, \"gridSort\");\n        i0.ɵɵpipe(19, \"gridFiltering\");\n        i0.ɵɵpipe(20, \"visibleColumns\");\n        i0.ɵɵpipe(21, \"gridTransaction\");\n        i0.ɵɵlistener(\"chunkPreload\", function IgxHierarchicalGridComponent_Template_ng_template_chunkPreload_12_listener($event) {\n          return ctx.dataLoading($event);\n        })(\"dataChanging\", function IgxHierarchicalGridComponent_Template_ng_template_dataChanging_12_listener($event) {\n          return ctx.dataRebinding($event);\n        })(\"dataChanged\", function IgxHierarchicalGridComponent_Template_ng_template_dataChanged_12_listener($event) {\n          return ctx.dataRebound($event);\n        });\n        i0.ɵɵtemplate(22, IgxHierarchicalGridComponent_ng_template_22_Template, 4, 36, \"ng-template\", null, 11, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(24, IgxHierarchicalGridComponent_ng_template_24_Template, 5, 35, \"ng-template\", null, 12, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(26, IgxHierarchicalGridComponent_ng_template_26_Template, 2, 5, \"ng-template\", null, 13, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(28, IgxHierarchicalGridComponent_ng_container_28_Template, 1, 0, \"ng-container\", 8);\n        i0.ɵɵtemplate(29, IgxHierarchicalGridComponent_ng_container_29_Template, 1, 0, \"ng-container\", 8);\n        i0.ɵɵtemplate(30, IgxHierarchicalGridComponent_span_30_Template, 1, 2, \"span\", 14);\n        i0.ɵɵelement(31, \"div\", 15, 16);\n        i0.ɵɵtemplate(33, IgxHierarchicalGridComponent_igc_trial_watermark_33_Template, 1, 0, \"igc-trial-watermark\", 17);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(34, \"div\", 18, 19);\n        i0.ɵɵtemplate(36, IgxHierarchicalGridComponent_igx_circular_bar_36_Template, 1, 1, \"igx-circular-bar\", 20);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(37, IgxHierarchicalGridComponent_span_37_Template, 1, 2, \"span\", 14);\n        i0.ɵɵelementStart(38, \"div\", 21);\n        i0.ɵɵlistener(\"pointerdown\", function IgxHierarchicalGridComponent_Template_div_pointerdown_38_listener($event) {\n          return $event.preventDefault();\n        });\n        i0.ɵɵelement(39, \"div\", 22);\n        i0.ɵɵelementStart(40, \"div\", 23);\n        i0.ɵɵtemplate(41, IgxHierarchicalGridComponent_ng_template_41_Template, 0, 0, \"ng-template\", 24, 25, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(43, \"div\", 26);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(44, \"div\", 27)(45, \"igx-snackbar\", 28, 29);\n        i0.ɵɵtext(47);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelement(48, \"div\", 30, 31);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(50, \"div\", 32, 33)(52, \"div\", 34);\n        i0.ɵɵlistener(\"focus\", function IgxHierarchicalGridComponent_Template_div_focus_52_listener() {\n          return ctx.navigation.focusFirstCell(false);\n        })(\"keydown\", function IgxHierarchicalGridComponent_Template_div_keydown_52_listener($event) {\n          return ctx.navigation.summaryNav($event);\n        });\n        i0.ɵɵtemplate(53, IgxHierarchicalGridComponent_igx_grid_summary_row_53_Template, 3, 10, \"igx-grid-summary-row\", 35);\n        i0.ɵɵelement(54, \"div\", 36);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(55, \"div\", 37, 38);\n        i0.ɵɵlistener(\"pointerdown\", function IgxHierarchicalGridComponent_Template_div_pointerdown_55_listener($event) {\n          return $event.preventDefault();\n        });\n        i0.ɵɵelement(57, \"div\", 39);\n        i0.ɵɵelementStart(58, \"div\", 40);\n        i0.ɵɵtemplate(59, IgxHierarchicalGridComponent_ng_template_59_Template, 0, 0, \"ng-template\", 24, 41, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(61, \"div\", 42);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(62, \"div\", 43, 44);\n        i0.ɵɵprojection(64, 1);\n        i0.ɵɵtemplate(65, IgxHierarchicalGridComponent_ng_content_65_Template, 1, 0, \"ng-content\", 17);\n        i0.ɵɵelementContainer(66, null, 45);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(68, IgxHierarchicalGridComponent_ng_template_68_Template, 4, 2, \"ng-template\", null, 46, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(70, IgxHierarchicalGridComponent_ng_template_70_Template, 4, 2, \"ng-template\", null, 47, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(72, IgxHierarchicalGridComponent_ng_template_72_Template, 2, 1, \"ng-template\", null, 48, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(74, IgxHierarchicalGridComponent_ng_template_74_Template, 2, 1, \"ng-template\", null, 49, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(76, IgxHierarchicalGridComponent_ng_template_76_Template, 2, 0, \"ng-template\", null, 50, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(78, IgxHierarchicalGridComponent_ng_template_78_Template, 2, 1, \"ng-template\", null, 51, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(80, IgxHierarchicalGridComponent_div_80_Template, 4, 6, \"div\", 52);\n        i0.ɵɵtemplate(81, IgxHierarchicalGridComponent_ng_template_81_Template, 1, 1, \"ng-template\", null, 53, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(83, IgxHierarchicalGridComponent_ng_template_83_Template, 4, 2, \"ng-template\", null, 54, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(85, IgxHierarchicalGridComponent_ng_template_85_Template, 6, 8, \"ng-template\", null, 55, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(87, IgxHierarchicalGridComponent_ng_template_87_Template, 2, 0, \"ng-template\", null, 56, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(89, IgxHierarchicalGridComponent_igx_grid_column_resizer_89_Template, 1, 0, \"igx-grid-column-resizer\", 17);\n        i0.ɵɵelement(90, \"div\", 57, 58)(92, \"div\", 59, 60);\n      }\n\n      if (rf & 2) {\n        const _r4 = i0.ɵɵreference(10);\n\n        const _r26 = i0.ɵɵreference(49);\n\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"grid\", ctx)(\"hasMRL\", ctx.hasColumnLayouts)(\"activeDescendant\", ctx.activeDescendant)(\"width\", ctx.calcWidth)(\"pinnedColumnCollection\", ctx.pinnedColumns)(\"unpinnedColumnCollection\", ctx.unpinnedColumns);\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"height\", ctx.totalHeight, \"px\")(\"width\", ctx.calcWidth, \"px\");\n        i0.ɵɵproperty(\"igxGridDragSelect\", ctx.selectionService.dragMode);\n        i0.ɵɵattribute(\"aria-activedescendant\", ctx.activeDescendant)(\"role\", ctx.dataView.length ? null : \"row\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.moving && ctx.columnInDrag && ctx.pinnedColumns.length <= 0);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.moving && ctx.columnInDrag && ctx.pinnedColumns.length > 0);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.hasPinnedRecords && ctx.isRowPinningToTop ? _r4 : null);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"igxGridForOf\", i0.ɵɵpipeBind4(14, 71, i0.ɵɵpipeBind3(15, 76, i0.ɵɵpipeBindV(16, 80, i0.ɵɵpureFunction6(134, _c215, i0.ɵɵpipeBindV(17, 87, i0.ɵɵpureFunction5(128, _c71, i0.ɵɵpipeBindV(18, 93, i0.ɵɵpureFunction5(122, _c71, i0.ɵɵpipeBindV(19, 99, i0.ɵɵpureFunction7(114, _c214, i0.ɵɵpipeBind2(20, 107, i0.ɵɵpipeBind3(21, 110, ctx.data, ctx.id, ctx.pipeTrigger), ctx.hasVisibleColumns), ctx.filteringExpressionsTree, ctx.filterStrategy, ctx.advancedFilteringExpressionsTree, ctx.id, ctx.pipeTrigger, ctx.filteringPipeTrigger)), ctx.sortingExpressions, ctx.sortStrategy, ctx.id, ctx.pipeTrigger)), ctx.paginator == null ? null : ctx.paginator.page, ctx.paginator == null ? null : ctx.paginator.perPage, ctx.id, ctx.pipeTrigger)), ctx.expansionStates, ctx.id, ctx.primaryKey, ctx.childLayoutKeys, ctx.pipeTrigger)), false, ctx.pipeTrigger), ctx.id, false, ctx.pipeTrigger))(\"igxForScrollOrientation\", \"vertical\")(\"igxForScrollContainer\", ctx.verticalScroll)(\"igxForContainerSize\", ctx.calcHeight)(\"igxForItemSize\", ctx.renderedRowHeight)(\"igxForTrackBy\", ctx.trackChanges);\n        i0.ɵɵadvance(16);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.hasPinnedRecords && !ctx.isRowPinningToTop ? _r4 : null);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.moving && ctx.columnInDrag);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", !ctx.parent);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.shouldOverlayLoading);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.moving && ctx.columnInDrag);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.scrollSize, \"px\");\n        i0.ɵɵproperty(\"hidden\", !ctx.hasVerticalScroll());\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"height\", ctx.isRowPinningToTop ? ctx.pinnedRowHeight : 0, \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"height\", ctx.calcHeight, \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"igxGridForOf\", i0.ɵɵpureFunction0(141, _c115));\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"height\", !ctx.isRowPinningToTop ? ctx.pinnedRowHeight : 0, \"px\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"outlet\", _r26)(\"actionText\", ctx.resourceStrings.igx_grid_snackbar_addrow_actiontext)(\"displayTime\", ctx.snackbarDisplayTime);\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate(ctx.resourceStrings.igx_grid_snackbar_addrow_label);\n        i0.ɵɵadvance(3);\n        i0.ɵɵstyleProp(\"height\", ctx.summaryRowHeight, \"px\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵattribute(\"aria-activedescendant\", ctx.activeDescendant);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasSummarizedColumns && ctx.rootSummariesEnabled);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"height\", ctx.summaryRowHeight, \"px\")(\"width\", ctx.scrollSize, \"px\");\n        i0.ɵɵproperty(\"hidden\", !ctx.hasVerticalScroll());\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"height\", ctx.scrollSize, \"px\");\n        i0.ɵɵproperty(\"hidden\", ctx.isHorizontalScrollHidden);\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"width\", ctx.isPinningToStart ? ctx.pinnedWidth : ctx.headerFeaturesWidth, \"px\")(\"min-width\", ctx.isPinningToStart ? ctx.pinnedWidth : ctx.headerFeaturesWidth, \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.unpinnedWidth, \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"igxGridForOf\", i0.ɵɵpureFunction0(142, _c115));\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"float\", \"right\")(\"width\", ctx.pinnedWidth, \"px\")(\"min-width\", ctx.pinnedWidth, \"px\");\n        i0.ɵɵproperty(\"hidden\", ctx.pinnedWidth === 0 || ctx.isPinningToStart);\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"ngIf\", ctx.totalRecords || ctx.pagingMode === 1);\n        i0.ɵɵadvance(15);\n        i0.ɵɵproperty(\"ngIf\", ctx.rowEditable);\n        i0.ɵɵadvance(9);\n        i0.ɵɵproperty(\"ngIf\", ctx.colResizingService.showResizer);\n      }\n    },\n    directives: [IgxGridHeaderRowComponent, IgxHierarchicalRowComponent, IgxChildGridRowComponent, IgxCircularProgressBarComponent, IgxSnackbarComponent, IgxSummaryRowComponent, IgxIconComponent, IgxGridColumnResizerComponent, IgxGridBodyDirective, IgxGridDragSelectDirective, i4.NgIf, IgxColumnMovingDropDirective, i4.NgClass, i4.NgForOf, i4.NgTemplateOutlet, IgxGridForOfDirective, IgxTemplateOutletDirective, i4.NgStyle, IgxOverlayOutletDirective, IgxToggleDirective, IgxButtonDirective, IgxRippleDirective, IgxRowEditTabStopDirective],\n    pipes: [IgxGridSortingPipe, IgxGridFilteringPipe, IgxGridRowPinningPipe, IgxGridAddRowPipe, IgxHasVisibleColumnsPipe, IgxGridTransactionPipe, IgxGridHierarchicalPipe, IgxGridHierarchicalPagingPipe, IgxGridRowClassesPipe, IgxGridRowStylesPipe, IgxSummaryDataPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxHierarchicalGridComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxHierarchicalGridModule = /*#__PURE__*/(() => {\n  class IgxHierarchicalGridModule {}\n\n  IgxHierarchicalGridModule.ɵfac = function IgxHierarchicalGridModule_Factory(t) {\n    return new (t || IgxHierarchicalGridModule)();\n  };\n\n  IgxHierarchicalGridModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxHierarchicalGridModule\n  });\n  IgxHierarchicalGridModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[IgxGridModule], IgxGridModule]\n  });\n  return IgxHierarchicalGridModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * IgxActionIcon is a container for the action nav icon of the IgxNavbar.\n */\n\n\nlet IgxNavbarActionDirective = /*#__PURE__*/(() => {\n  class IgxNavbarActionDirective {}\n\n  IgxNavbarActionDirective.ɵfac = function IgxNavbarActionDirective_Factory(t) {\n    return new (t || IgxNavbarActionDirective)();\n  };\n\n  IgxNavbarActionDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxNavbarActionDirective,\n    selectors: [[\"igx-navbar-action\"], [\"\", \"igxNavbarAction\", \"\"]]\n  });\n  return IgxNavbarActionDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxNavbarTitleDirective = /*#__PURE__*/(() => {\n  class IgxNavbarTitleDirective {}\n\n  IgxNavbarTitleDirective.ɵfac = function IgxNavbarTitleDirective_Factory(t) {\n    return new (t || IgxNavbarTitleDirective)();\n  };\n\n  IgxNavbarTitleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxNavbarTitleDirective,\n    selectors: [[\"igx-navbar-title\"], [\"\", \"igxNavbarTitle\", \"\"]]\n  });\n  return IgxNavbarTitleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$5 = 0;\n/**\n * **Ignite UI for Angular Navbar** -\n * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navbar.html)\n *\n * The Ignite UI Navbar is most commonly used to provide an app header with a hamburger menu and navigation\n * state such as a \"Go Back\" button. It also supports other actions represented by icons.\n *\n * Example:\n * ```html\n * <igx-navbar title=\"Sample App\" actionButtonIcon=\"menu\">\n *   <igx-icon>search</igx-icon>\n *   <igx-icon>favorite</igx-icon>\n *   <igx-icon>more_vert</igx-icon>\n * </igx-navbar>\n * ```\n */\n\nlet IgxNavbarComponent = /*#__PURE__*/(() => {\n  class IgxNavbarComponent {\n    constructor() {\n      /**\n       * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.\n       * ```html\n       * <igx-navbar [id]=\"'igx-navbar-12'\" title=\"Sample App\" actionButtonIcon=\"menu\">\n       * ```\n       */\n      this.id = `igx-navbar-${NEXT_ID$5++}`;\n      /**\n       * The event that will be thrown when the action is executed,\n       * provides reference to the `IgxNavbar` component as argument\n       * ```typescript\n       * public actionExc(event){\n       *     alert(\"Action Execute!\");\n       * }\n       *  //..\n       * ```\n       * ```html\n       * <igx-navbar (action)=\"actionExc($event)\" title=\"Sample App\" actionButtonIcon=\"menu\">\n       * ```\n       */\n\n      this.action = new EventEmitter();\n      /**\n       * An @Input property that sets the titleId of the `IgxNavbarComponent`. If not set it will be automatically generated.\n       * ```html\n       * <igx-navbar [titleId]=\"'igx-navbar-7'\" title=\"Sample App\" actionButtonIcon=\"menu\">\n       * ```\n       */\n\n      this.titleId = `igx-navbar-title-${NEXT_ID$5++}`;\n      this.isVisible = true;\n    }\n    /**\n     * Sets whether the action button of the `IgxNavbarComponent` is visible.\n     * ```html\n     * <igx-navbar [title]=\"currentView\" [isActionButtonVisible]=\"'false'\"></igx-navbar>\n     * ```\n     */\n\n\n    set isActionButtonVisible(value) {\n      this.isVisible = value;\n    }\n    /**\n     * Returns whether the `IgxNavbarComponent` action button is visible, true/false.\n     * ```typescript\n     *  @ViewChild(\"MyChild\")\n     * public navBar: IgxNavbarComponent;\n     * ngAfterViewInit(){\n     *     let actionButtonVisibile = this.navBar.isActionButtonVisible;\n     * }\n     * ```\n     */\n\n\n    get isActionButtonVisible() {\n      if (this.actionIconTemplate || !this.actionButtonIcon) {\n        return false;\n      }\n\n      return this.isVisible;\n    }\n\n    get isTitleContentVisible() {\n      return this.titleContent ? true : false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    _triggerAction() {\n      this.action.emit(this);\n    }\n\n  }\n\n  IgxNavbarComponent.ɵfac = function IgxNavbarComponent_Factory(t) {\n    return new (t || IgxNavbarComponent)();\n  };\n\n  IgxNavbarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxNavbarComponent,\n    selectors: [[\"igx-navbar\"]],\n    contentQueries: function IgxNavbarComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxNavbarActionDirective, 5, IgxNavbarActionDirective);\n        i0.ɵɵcontentQuery(dirIndex, IgxNavbarTitleDirective, 5, IgxNavbarTitleDirective);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.actionIconTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.titleContent = _t.first);\n      }\n    },\n    hostVars: 1,\n    hostBindings: function IgxNavbarComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      actionButtonIcon: \"actionButtonIcon\",\n      title: \"title\",\n      titleId: \"titleId\",\n      isActionButtonVisible: \"isActionButtonVisible\"\n    },\n    outputs: {\n      action: \"action\"\n    },\n    ngContentSelectors: _c250,\n    decls: 8,\n    vars: 3,\n    consts: [[\"role\", \"navigation\", 1, \"igx-navbar\"], [1, \"igx-navbar__left\"], [3, \"click\", 4, \"ngIf\"], [\"class\", \"igx-navbar__title\", 4, \"ngIf\"], [1, \"igx-navbar__right\"], [3, \"click\"], [1, \"igx-navbar__title\"]],\n    template: function IgxNavbarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c249);\n        i0.ɵɵelementStart(0, \"nav\", 0)(1, \"div\", 1);\n        i0.ɵɵtemplate(2, IgxNavbarComponent_igx_icon_2_Template, 2, 1, \"igx-icon\", 2);\n        i0.ɵɵprojection(3);\n        i0.ɵɵtemplate(4, IgxNavbarComponent_h1_4_Template, 2, 2, \"h1\", 3);\n        i0.ɵɵprojection(5, 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(6, \"div\", 4);\n        i0.ɵɵprojection(7, 2);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-labelledby\", ctx.titleId);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.isActionButtonVisible);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", !ctx.isTitleContentVisible);\n      }\n    },\n    directives: [IgxIconComponent, i4.NgIf],\n    styles: [\"[_nghost-%COMP%]{display:block}\"]\n  });\n  return IgxNavbarComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxNavbarModule = /*#__PURE__*/(() => {\n  class IgxNavbarModule {}\n\n  IgxNavbarModule.ɵfac = function IgxNavbarModule_Factory(t) {\n    return new (t || IgxNavbarModule)();\n  };\n\n  IgxNavbarModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxNavbarModule\n  });\n  IgxNavbarModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[IgxButtonModule, IgxIconModule, CommonModule]]\n  });\n  return IgxNavbarModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxNavDrawerItemDirective = /*#__PURE__*/(() => {\n  class IgxNavDrawerItemDirective {\n    constructor() {\n      /**\n       * @hidden\n       */\n      this.active = false;\n      /**\n       * @hidden\n       */\n\n      this.isHeader = false;\n      /**\n       * @hidden\n       */\n\n      this.activeClass = 'igx-nav-drawer__item--active';\n    }\n    /**\n     * @hidden\n     */\n\n\n    get defaultCSS() {\n      return !this.active && !this.isHeader;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get currentCSS() {\n      return this.active && !this.isHeader;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get headerCSS() {\n      return this.isHeader;\n    }\n\n  }\n\n  IgxNavDrawerItemDirective.ɵfac = function IgxNavDrawerItemDirective_Factory(t) {\n    return new (t || IgxNavDrawerItemDirective)();\n  };\n\n  IgxNavDrawerItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxNavDrawerItemDirective,\n    selectors: [[\"\", \"igxDrawerItem\", \"\"]],\n    hostVars: 6,\n    hostBindings: function IgxNavDrawerItemDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-nav-drawer__item\", ctx.defaultCSS)(\"igx-nav-drawer__item--active\", ctx.currentCSS)(\"igx-nav-drawer__item--header\", ctx.headerCSS);\n      }\n    },\n    inputs: {\n      active: \"active\",\n      isHeader: \"isHeader\"\n    },\n    exportAs: [\"igxDrawerItem\"]\n  });\n  return IgxNavDrawerItemDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxNavDrawerTemplateDirective = /*#__PURE__*/(() => {\n  class IgxNavDrawerTemplateDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxNavDrawerTemplateDirective.ɵfac = function IgxNavDrawerTemplateDirective_Factory(t) {\n    return new (t || IgxNavDrawerTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxNavDrawerTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxNavDrawerTemplateDirective,\n    selectors: [[\"\", \"igxDrawer\", \"\"]]\n  });\n  return IgxNavDrawerTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxNavDrawerMiniTemplateDirective = /*#__PURE__*/(() => {\n  class IgxNavDrawerMiniTemplateDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  IgxNavDrawerMiniTemplateDirective.ɵfac = function IgxNavDrawerMiniTemplateDirective_Factory(t) {\n    return new (t || IgxNavDrawerMiniTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n\n  IgxNavDrawerMiniTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxNavDrawerMiniTemplateDirective,\n    selectors: [[\"\", \"igxDrawerMini\", \"\"]]\n  });\n  return IgxNavDrawerMiniTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$4 = 0;\n/**\n * **Ignite UI for Angular Navigation Drawer** -\n * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navdrawer)\n *\n * The Ignite UI Navigation Drawer is a collapsible side navigation container commonly used in combination with the Navbar.\n *\n * Example:\n * ```html\n * <igx-nav-drawer id=\"navigation\" [isOpen]=\"true\">\n *   <ng-template igxDrawer>\n *     <nav>\n *       <span igxDrawerItem [isHeader]=\"true\">Email</span>\n *       <span igxDrawerItem igxRipple>Inbox</span>\n *       <span igxDrawerItem igxRipple>Deleted</span>\n *       <span igxDrawerItem igxRipple>Sent</span>\n *     </nav>\n *   </ng-template>\n * </igx-nav-drawer>\n * ```\n */\n\nlet IgxNavigationDrawerComponent = /*#__PURE__*/(() => {\n  class IgxNavigationDrawerComponent {\n    constructor(elementRef, _state, renderer, _touchManager, platformUtil) {\n      this.elementRef = elementRef;\n      this._state = _state;\n      this.renderer = renderer;\n      this._touchManager = _touchManager;\n      this.platformUtil = platformUtil;\n      /** @hidden @internal */\n\n      this.cssClass = true;\n      /**\n       * ID of the component\n       *\n       * ```typescript\n       * // get\n       * let myNavDrawerId = this.navdrawer.id;\n       * ```\n       *\n       * ```html\n       * <!--set-->\n       *  <igx-nav-drawer id='navdrawer'></igx-nav-drawer>\n       * ```\n       */\n\n      this.id = `igx-nav-drawer-${NEXT_ID$4++}`;\n      /**\n       * Position of the Navigation Drawer. Can be \"left\"(default) or \"right\".\n       *\n       * ```typescript\n       * // get\n       * let myNavDrawerPosition = this.navdrawer.position;\n       * ```\n       *\n       * ```html\n       * <!--set-->\n       * <igx-nav-drawer [position]=\"'left'\"></igx-nav-drawer>\n       * ```\n       */\n\n      this.position = 'left';\n      /**\n       * Enables the use of touch gestures to manipulate the drawer:\n       * - swipe/pan from edge to open, swipe-toggle and pan-drag.\n       *\n       * ```typescript\n       * // get\n       * let gesturesEnabled = this.navdrawer.enableGestures;\n       * ```\n       *\n       * ```html\n       * <!--set-->\n       * <igx-nav-drawer [enableGestures]='true'></igx-nav-drawer>\n       * ```\n       */\n\n      this.enableGestures = true;\n      /**\n       * @hidden\n       */\n\n      this.isOpenChange = new EventEmitter();\n      /**\n       * Minimum device width required for automatic pin to be toggled.\n       * Default is 1024, can be set to a falsy value to disable this behavior.\n       *\n       * ```typescript\n       * // get\n       * let navDrawerPinThreshold = this.navdrawer.pinThreshold;\n       * ```\n       *\n       * ```html\n       * <!--set-->\n       * <igx-nav-drawer [pinThreshold]='1024'></igx-nav-drawer>\n       * ```\n       */\n\n      this.pinThreshold = 1024;\n      /**\n       * When pinned the drawer is relatively positioned instead of sitting above content.\n       * May require additional layout styling.\n       *\n       * ```typescript\n       * // get\n       * let navDrawerIsPinned = this.navdrawer.pin;\n       * ```\n       *\n       * ```html\n       * <!--set-->\n       * <igx-nav-drawer [pin]='false'></igx-nav-drawer>\n       * ```\n       */\n\n      this.pin = false;\n      /**\n       * Width of the drawer in its open state. Defaults to \"280px\".\n       *\n       * ```typescript\n       * // get\n       * let navDrawerWidth = this.navdrawer.width;\n       * ```\n       *\n       * ```html\n       * <!--set-->\n       * <igx-nav-drawer [width]=\"'228px'\"></igx-nav-drawer>\n       * ```\n       */\n\n      this.width = '280px';\n      /**\n       * Enables/disables the animation, when toggling the drawer. Set to `false` by default.\n       * ````html\n       * <igx-nav-drawer [disableAnimation]=\"true\"></igx-nav-drawer>\n       * ````\n       */\n\n      this.disableAnimation = false;\n      /**\n       * Width of the drawer in its mini state. Defaults to 68px.\n       *\n       * ```typescript\n       * // get\n       * let navDrawerMiniWidth = this.navdrawer.miniWidth;\n       * ```\n       *\n       * ```html\n       * <!--set-->\n       * <igx-nav-drawer [miniWidth]=\"'34px'\"></igx-nav-drawer>\n       * ```\n       */\n\n      this.miniWidth = '68px';\n      /**\n       * Pinned state change output for two-way binding.\n       *\n       * ```html\n       * <igx-nav-drawer [(pin)]='isPinned'></igx-nav-drawer>\n       * ```\n       */\n\n      this.pinChange = new EventEmitter(true);\n      /**\n       * Event fired as the Navigation Drawer is about to open.\n       *\n       * ```html\n       *  <igx-nav-drawer (opening)='onOpening()'></igx-nav-drawer>\n       * ```\n       */\n\n      this.opening = new EventEmitter();\n      /**\n       * Event fired when the Navigation Drawer has opened.\n       *\n       * ```html\n       * <igx-nav-drawer (opened)='onOpened()'></igx-nav-drawer>\n       * ```\n       */\n\n      this.opened = new EventEmitter();\n      /**\n       * Event fired as the Navigation Drawer is about to close.\n       *\n       * ```html\n       * <igx-nav-drawer (closing)='onClosing()'></igx-nav-drawer>\n       * ```\n       */\n\n      this.closing = new EventEmitter();\n      /**\n       * Event fired when the Navigation Drawer has closed.\n       *\n       * ```html\n       * <igx-nav-drawer (closed)='onClosed()'></igx-nav-drawer>\n       * ```\n       */\n\n      this.closed = new EventEmitter();\n      this._isOpen = false;\n      this._gesturesAttached = false;\n      this._widthCache = {\n        width: null,\n        miniWidth: null,\n        windowWidth: null\n      };\n      this.css = {\n        drawer: 'igx-nav-drawer__aside',\n        mini: 'igx-nav-drawer__aside--mini',\n        overlay: 'igx-nav-drawer__overlay',\n        styleDummy: 'igx-nav-drawer__style-dummy'\n      };\n      /** Pan animation properties */\n\n      this._panning = false;\n      this._maxEdgeZone = 50;\n\n      this.checkPinThreshold = evt => {\n        if (!this.platformUtil.isBrowser) {\n          return;\n        }\n\n        let windowWidth;\n\n        if (this.pinThreshold) {\n          windowWidth = this.getWindowWidth();\n\n          if (evt && this._widthCache.windowWidth === windowWidth) {\n            return;\n          }\n\n          this._widthCache.windowWidth = windowWidth;\n\n          if (!this.pin && windowWidth >= this.pinThreshold) {\n            this.pin = true;\n            this.pinChange.emit(true);\n          } else if (this.pin && windowWidth < this.pinThreshold) {\n            this.pin = false;\n            this.pinChange.emit(false);\n          }\n        }\n      };\n\n      this.swipe = evt => {\n        // TODO: Could also force input type: http://stackoverflow.com/a/27108052\n        if (!this.enableGestures || evt.pointerType !== 'touch') {\n          return;\n        } // HammerJS swipe is horizontal-only by default, don't check deltaY\n\n\n        let deltaX;\n        let startPosition;\n\n        if (this.position === 'right') {\n          // when on the right use inverse of deltaX\n          deltaX = -evt.deltaX;\n          startPosition = this.getWindowWidth() - (evt.center.x + evt.distance);\n        } else {\n          deltaX = evt.deltaX;\n          startPosition = evt.center.x - evt.distance;\n        } // only accept closing swipe (ignoring minEdgeZone) when the drawer is expanded:\n\n\n        if (this.isOpen && deltaX < 0 || // positive deltaX from the edge:\n        deltaX > 0 && startPosition < this.maxEdgeZone) {\n          this.toggle();\n        }\n      };\n\n      this.panstart = evt => {\n        if (!this.enableGestures || this.pin || evt.pointerType !== 'touch') {\n          return;\n        }\n\n        const startPosition = this.position === 'right' ? this.getWindowWidth() - (evt.center.x + evt.distance) : evt.center.x - evt.distance; // cache width during animation, flag to allow further handling\n\n        if (this.isOpen || startPosition < this.maxEdgeZone) {\n          this._panning = true;\n          this._panStartWidth = this.getExpectedWidth(!this.isOpen);\n          this._panLimit = this.getExpectedWidth(this.isOpen);\n          this.renderer.addClass(this.overlay, 'panning');\n          this.renderer.addClass(this.drawer, 'panning');\n        }\n      };\n\n      this.pan = evt => {\n        // TODO: input.deltaX = prevDelta.x + (center.x - offset.x);\n        // get actual delta (not total session one) from event?\n        // pan WILL also fire after a full swipe, only resize on flag\n        if (!this._panning) {\n          return;\n        }\n\n        const right = this.position === 'right'; // when on the right use inverse of deltaX\n\n        const deltaX = right ? -evt.deltaX : evt.deltaX;\n        let newX;\n        let percent;\n        const visibleWidth = this._panStartWidth + deltaX;\n\n        if (this.isOpen && deltaX < 0) {\n          // when visibleWidth hits limit - stop animating\n          if (visibleWidth <= this._panLimit) {\n            return;\n          }\n\n          if (this.hasAnimateWidth) {\n            percent = (visibleWidth - this._panLimit) / (this._panStartWidth - this._panLimit);\n            newX = visibleWidth;\n          } else {\n            percent = visibleWidth / this._panStartWidth;\n            newX = evt.deltaX;\n          }\n\n          this.setXSize(newX, percent.toPrecision(2));\n        } else if (!this.isOpen && deltaX > 0) {\n          // when visibleWidth hits limit - stop animating\n          if (visibleWidth >= this._panLimit) {\n            return;\n          }\n\n          if (this.hasAnimateWidth) {\n            percent = (visibleWidth - this._panStartWidth) / (this._panLimit - this._panStartWidth);\n            newX = visibleWidth;\n          } else {\n            percent = visibleWidth / this._panLimit;\n            newX = (this._panLimit - visibleWidth) * (right ? 1 : -1);\n          }\n\n          this.setXSize(newX, percent.toPrecision(2));\n        }\n      };\n\n      this.panEnd = evt => {\n        if (this._panning) {\n          const deltaX = this.position === 'right' ? -evt.deltaX : evt.deltaX;\n          const visibleWidth = this._panStartWidth + deltaX;\n          this.resetPan(); // check if pan brought the drawer to 50%\n\n          if (this.isOpen && visibleWidth <= this._panStartWidth / 2) {\n            this.close();\n          } else if (!this.isOpen && visibleWidth >= this._panLimit / 2) {\n            this.open();\n          }\n\n          this._panStartWidth = null;\n        }\n      };\n\n      this.toggleOpenedEvent = () => {\n        this.elementRef.nativeElement.removeEventListener('transitionend', this.toggleOpenedEvent, false);\n        this.opened.emit();\n      };\n\n      this.toggleClosedEvent = () => {\n        this.elementRef.nativeElement.removeEventListener('transitionend', this.toggleClosedEvent, false);\n        this.closed.emit();\n      };\n    }\n    /**\n     * State of the drawer.\n     *\n     * ```typescript\n     * // get\n     * let navDrawerIsOpen = this.navdrawer.isOpen;\n     * ```\n     *\n     * ```html\n     * <!--set-->\n     * <igx-nav-drawer [isOpen]='false'></igx-nav-drawer>\n     * ```\n     *\n     * Two-way data binding.\n     * ```html\n     * <!--set-->\n     * <igx-nav-drawer [(isOpen)]='model.isOpen'></igx-nav-drawer>\n     * ```\n     */\n\n\n    get isOpen() {\n      return this._isOpen;\n    }\n\n    set isOpen(value) {\n      this._isOpen = value;\n      this.isOpenChange.emit(this._isOpen);\n    }\n    /**\n     * Returns nativeElement of the component.\n     *\n     * @hidden\n     */\n\n\n    get element() {\n      return this.elementRef.nativeElement;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get template() {\n      if (this.miniTemplate && !this.isOpen) {\n        return this.miniTemplate.template;\n      } else if (this.contentTemplate) {\n        return this.contentTemplate.template;\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    get miniTemplate() {\n      return this._miniTemplate;\n    }\n    /**\n     * @hidden\n     */\n\n\n    set miniTemplate(v) {\n      if (!this.isOpen) {\n        this.setDrawerWidth(v ? this.miniWidth : '');\n      }\n\n      this._miniTemplate = v;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get flexWidth() {\n      if (!this.pin) {\n        return '0px';\n      }\n\n      if (this.isOpen) {\n        return this.width;\n      }\n\n      if (this.miniTemplate && this.miniWidth) {\n        return this.miniWidth;\n      }\n\n      return '0px';\n    }\n    /** @hidden */\n\n\n    get isPinnedRight() {\n      return this.pin && this.position === 'right' ? '1' : '0';\n    }\n    /**\n     * @hidden\n     */\n\n\n    get drawer() {\n      return this._drawer.nativeElement;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get overlay() {\n      return this._overlay.nativeElement;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get styleDummy() {\n      return this._styleDummy.nativeElement;\n    }\n    /**\n     * Property to decide whether to change width or translate the drawer from pan gesture.\n     *\n     * @hidden\n     */\n\n\n    get hasAnimateWidth() {\n      return this.pin || !!this.miniTemplate;\n    }\n    /**\n     * Used for touch gestures (swipe and pan).\n     * Defaults to 50 (in px) and is extended to at least 110% of the mini template width if available.\n     *\n     * @hidden\n     */\n\n\n    get maxEdgeZone() {\n      return this._maxEdgeZone;\n    }\n    /**\n     * Gets the Drawer width for specific state.\n     * Will attempt to evaluate requested state and cache.\n     *\n     *\n     * @hidden\n     */\n\n\n    get expectedWidth() {\n      return this.getExpectedWidth(false);\n    }\n    /**\n     * Get the Drawer mini width for specific state.\n     * Will attempt to evaluate requested state and cache.\n     *\n     * @hidden\n     */\n\n\n    get expectedMiniWidth() {\n      return this.getExpectedWidth(true);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get touchManager() {\n      return this._touchManager;\n    }\n    /**\n     * Exposes optional navigation service\n     *\n     * @hidden\n     */\n\n\n    get state() {\n      return this._state;\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      // DOM and @Input()-s initialized\n      if (this._state) {\n        this._state.add(this.id, this);\n      }\n\n      if (this.isOpen) {\n        this.setDrawerWidth(this.width);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterContentInit() {\n      // wait for template and ng-content to be ready\n      this.updateEdgeZone();\n      this.checkPinThreshold();\n      this.ensureEvents(); // TODO: apply platform-safe Ruler from http://plnkr.co/edit/81nWDyreYMzkunihfRgX?p=preview\n      // (https://github.com/angular/angular/issues/6515), blocked by https://github.com/angular/angular/issues/6904\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      this._touchManager.destroy();\n\n      if (this._state) {\n        this._state.remove(this.id);\n      }\n\n      if (this._resizeObserver) {\n        this._resizeObserver.unsubscribe();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnChanges(changes) {\n      // simple settings can come from attribute set (rather than binding), make sure boolean props are converted\n      if (changes.enableGestures && changes.enableGestures.currentValue !== undefined) {\n        this.enableGestures = !!(this.enableGestures && this.enableGestures.toString() === 'true');\n        this.ensureEvents();\n      }\n\n      if (changes.pin && changes.pin.currentValue !== undefined) {\n        this.pin = !!(this.pin && this.pin.toString() === 'true');\n\n        if (this.pin) {\n          this._touchManager.destroy();\n\n          this._gesturesAttached = false;\n        } else {\n          this.ensureEvents();\n        }\n      }\n\n      if (changes.pinThreshold) {\n        if (this.pinThreshold) {\n          this.ensureEvents();\n          this.checkPinThreshold();\n        }\n      }\n\n      if (changes.width && this.isOpen) {\n        this.setDrawerWidth(changes.width.currentValue);\n      }\n\n      if (changes.isOpen) {\n        this.setDrawerWidth(this.isOpen ? this.width : this.miniTemplate ? this.miniWidth : '');\n      }\n\n      if (changes.miniWidth) {\n        if (!this.isOpen) {\n          this.setDrawerWidth(changes.miniWidth.currentValue);\n        }\n\n        this.updateEdgeZone();\n      }\n    }\n    /**\n     * Toggle the open state of the Navigation Drawer.\n     *\n     * ```typescript\n     * this.navdrawer.toggle();\n     * ```\n     */\n\n\n    toggle() {\n      if (this.isOpen) {\n        this.close();\n      } else {\n        this.open();\n      }\n    }\n    /**\n     * Open the Navigation Drawer. Has no effect if already opened.\n     *\n     * ```typescript\n     * this.navdrawer.open();\n     * ```\n     */\n\n\n    open() {\n      if (this._panning) {\n        this.resetPan();\n      }\n\n      if (this.isOpen) {\n        return;\n      }\n\n      this.opening.emit();\n      this.isOpen = true; // TODO: Switch to animate API when available\n      // var animationCss = this.animate.css();\n      //     animationCss\n      //         .setStyles({'width':'50px'}, {'width':'400px'})\n      //         .start(this.elementRef.nativeElement)\n      //         .onComplete(() => animationCss.setToStyles({'width':'auto'}).start(this.elementRef.nativeElement));\n\n      this.elementRef.nativeElement.addEventListener('transitionend', this.toggleOpenedEvent, false);\n      this.setDrawerWidth(this.width);\n    }\n    /**\n     * Close the Navigation Drawer. Has no effect if already closed.\n     *\n     * ```typescript\n     * this.navdrawer.close();\n     * ```\n     */\n\n\n    close() {\n      if (this._panning) {\n        this.resetPan();\n      }\n\n      if (!this.isOpen) {\n        return;\n      }\n\n      this.closing.emit();\n      this.isOpen = false;\n      this.setDrawerWidth(this.miniTemplate ? this.miniWidth : '');\n      this.elementRef.nativeElement.addEventListener('transitionend', this.toggleClosedEvent, false);\n    }\n    /**\n     * @hidden\n     */\n\n\n    set_maxEdgeZone(value) {\n      this._maxEdgeZone = value;\n    }\n    /**\n     * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.\n     *\n     * @hidden\n     * @param [mini] - Request mini width instead\n     */\n\n\n    getExpectedWidth(mini) {\n      if (mini) {\n        if (!this.miniTemplate) {\n          return 0;\n        }\n\n        if (this.miniWidth) {\n          return parseFloat(this.miniWidth);\n        } else {\n          // if (!this.isOpen) { // This WON'T work due to transition timings...\n          //     return this.elementRef.nativeElement.children[1].offsetWidth;\n          // } else {\n          if (this._widthCache.miniWidth === null) {\n            // force class for width calc. TODO?\n            // force class for width calc. TODO?\n            this.renderer.addClass(this.styleDummy, this.css.drawer);\n            this.renderer.addClass(this.styleDummy, this.css.mini);\n            this._widthCache.miniWidth = this.styleDummy.offsetWidth;\n            this.renderer.removeClass(this.styleDummy, this.css.drawer);\n            this.renderer.removeClass(this.styleDummy, this.css.mini);\n          }\n\n          return this._widthCache.miniWidth;\n        }\n      } else {\n        if (this.width) {\n          return parseFloat(this.width);\n        } else {\n          if (this._widthCache.width === null) {\n            // force class for width calc. TODO?\n            // force class for width calc. TODO?\n            this.renderer.addClass(this.styleDummy, this.css.drawer);\n            this._widthCache.width = this.styleDummy.offsetWidth;\n            this.renderer.removeClass(this.styleDummy, this.css.drawer);\n          }\n\n          return this._widthCache.width;\n        }\n      }\n    }\n\n    getWindowWidth() {\n      return window.innerWidth > 0 ? window.innerWidth : screen.width;\n    }\n    /**\n     * Sets the drawer width.\n     */\n\n\n    setDrawerWidth(width) {\n      if (this.platformUtil.isBrowser) {\n        requestAnimationFrame(() => {\n          if (this.drawer) {\n            this.renderer.setStyle(this.drawer, 'width', width);\n          }\n        });\n      } else {\n        this.renderer.setStyle(this.drawer, 'width', width);\n      }\n    }\n    /**\n     * Get current Drawer width.\n     */\n\n\n    getDrawerWidth() {\n      return this.drawer.offsetWidth;\n    }\n\n    ensureEvents() {\n      // set listeners for swipe/pan only if needed, but just once\n      if (this.enableGestures && !this.pin && !this._gesturesAttached) {\n        // Built-in manager handler(L20887) causes endless loop and max stack exception.\n        // https://github.com/angular/angular/issues/6993\n        // Use ours for now (until beta.10):\n        // this.renderer.listen(document, \"swipe\", this.swipe);\n        this._touchManager.addGlobalEventListener('document', 'swipe', this.swipe);\n\n        this._gesturesAttached = true; // this.renderer.listen(document, \"panstart\", this.panstart);\n        // this.renderer.listen(document, \"pan\", this.pan);\n\n        this._touchManager.addGlobalEventListener('document', 'panstart', this.panstart);\n\n        this._touchManager.addGlobalEventListener('document', 'panmove', this.pan);\n\n        this._touchManager.addGlobalEventListener('document', 'panend', this.panEnd);\n      }\n\n      if (!this._resizeObserver && this.platformUtil.isBrowser) {\n        this._resizeObserver = fromEvent(window, 'resize').pipe(debounce(() => interval(150))).subscribe(value => {\n          this.checkPinThreshold(value);\n        });\n      }\n    }\n\n    updateEdgeZone() {\n      let maxValue;\n\n      if (this.miniTemplate) {\n        maxValue = Math.max(this._maxEdgeZone, this.getExpectedWidth(true) * 1.1);\n        this.set_maxEdgeZone(maxValue);\n      }\n    }\n\n    resetPan() {\n      this._panning = false;\n      /* styles fail to apply when set on parent due to extra attributes, prob ng bug */\n\n      /* styles fail to apply when set on parent due to extra attributes, prob ng bug */\n\n      this.renderer.removeClass(this.overlay, 'panning');\n      this.renderer.removeClass(this.drawer, 'panning');\n      this.setXSize(0, '');\n    }\n    /**\n     * Sets the absolute position or width in case the drawer doesn't change position.\n     *\n     * @param x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.\n     * @param opacity optional value to apply to the overlay\n     */\n\n\n    setXSize(x, opacity) {\n      // Angular polyfills patches window.requestAnimationFrame, but switch to DomAdapter API (TODO)\n      window.requestAnimationFrame(() => {\n        if (this.hasAnimateWidth) {\n          this.renderer.setStyle(this.drawer, 'width', x ? Math.abs(x) + 'px' : '');\n        } else {\n          this.renderer.setStyle(this.drawer, 'transform', x ? 'translate3d(' + x + 'px,0,0)' : '');\n          this.renderer.setStyle(this.drawer, '-webkit-transform', x ? 'translate3d(' + x + 'px,0,0)' : '');\n        }\n\n        if (opacity !== undefined) {\n          this.renderer.setStyle(this.overlay, 'opacity', opacity);\n        }\n      });\n    }\n\n  }\n\n  IgxNavigationDrawerComponent.ɵfac = function IgxNavigationDrawerComponent_Factory(t) {\n    return new (t || IgxNavigationDrawerComponent)(i0.ɵɵdirectiveInject(ElementRef), i0.ɵɵdirectiveInject(IgxNavigationService, 8), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(HammerGesturesManager), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxNavigationDrawerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxNavigationDrawerComponent,\n    selectors: [[\"igx-nav-drawer\"]],\n    contentQueries: function IgxNavigationDrawerComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxNavDrawerTemplateDirective, 5, IgxNavDrawerTemplateDirective);\n        i0.ɵɵcontentQuery(dirIndex, IgxNavDrawerMiniTemplateDirective, 5, IgxNavDrawerMiniTemplateDirective);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.miniTemplate = _t.first);\n      }\n    },\n    viewQuery: function IgxNavigationDrawerComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c251, 7);\n        i0.ɵɵviewQuery(_c252, 7);\n        i0.ɵɵviewQuery(_c253, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._drawer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._overlay = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._styleDummy = _t.first);\n      }\n    },\n    hostVars: 9,\n    hostBindings: function IgxNavigationDrawerComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id);\n        i0.ɵɵstyleProp(\"flex-basis\", ctx.flexWidth)(\"order\", ctx.isPinnedRight);\n        i0.ɵɵclassProp(\"igx-nav-drawer\", ctx.cssClass)(\"igx-nav-drawer--disable-animation\", ctx.disableAnimation);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      position: \"position\",\n      enableGestures: \"enableGestures\",\n      pinThreshold: \"pinThreshold\",\n      pin: \"pin\",\n      width: \"width\",\n      disableAnimation: \"disableAnimation\",\n      miniWidth: \"miniWidth\",\n      isOpen: \"isOpen\"\n    },\n    outputs: {\n      isOpenChange: \"isOpenChange\",\n      pinChange: \"pinChange\",\n      opening: \"opening\",\n      opened: \"opened\",\n      closing: \"closing\",\n      closed: \"closed\"\n    },\n    features: [i0.ɵɵProvidersFeature([HammerGesturesManager]), i0.ɵɵNgOnChangesFeature],\n    decls: 9,\n    vars: 18,\n    consts: [[\"defaultItemsTemplate\", \"\"], [1, \"igx-nav-drawer__overlay\", 3, \"hidden\", \"click\"], [\"overlay\", \"\"], [\"role\", \"navigation\", 1, \"igx-nav-drawer__aside\"], [\"aside\", \"\"], [4, \"ngTemplateOutlet\"], [1, \"igx-nav-drawer__style-dummy\"], [\"dummy\", \"\"], [\"igxDrawerItem\", \"\", 3, \"isHeader\"], [\"igxDrawerItem\", \"\"]],\n    template: function IgxNavigationDrawerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxNavigationDrawerComponent_ng_template_0_Template, 13, 1, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementStart(2, \"div\", 1, 2);\n        i0.ɵɵlistener(\"click\", function IgxNavigationDrawerComponent_Template_div_click_2_listener() {\n          return ctx.close();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(4, \"aside\", 3, 4);\n        i0.ɵɵtemplate(6, IgxNavigationDrawerComponent_ng_container_6_Template, 1, 0, \"ng-container\", 5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(7, \"div\", 6, 7);\n      }\n\n      if (rf & 2) {\n        const _r0 = i0.ɵɵreference(1);\n\n        i0.ɵɵadvance(2);\n        i0.ɵɵclassProp(\"igx-nav-drawer__overlay--hidden\", !ctx.isOpen)(\"igx-nav-drawer--disable-animation\", ctx.disableAnimation);\n        i0.ɵɵproperty(\"hidden\", ctx.pin);\n        i0.ɵɵadvance(2);\n        i0.ɵɵclassProp(\"igx-nav-drawer__aside--collapsed\", !ctx.miniTemplate && !ctx.isOpen)(\"igx-nav-drawer__aside--mini\", ctx.miniTemplate && !ctx.isOpen)(\"igx-nav-drawer__aside--normal\", !ctx.miniTemplate || ctx.isOpen)(\"igx-nav-drawer__aside--pinned\", ctx.pin)(\"igx-nav-drawer__aside--right\", ctx.position === \"right\")(\"igx-nav-drawer--disable-animation\", ctx.disableAnimation);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template || _r0);\n      }\n    },\n    directives: [IgxNavDrawerItemDirective, i4.NgTemplateOutlet],\n    styles: [\"[_nghost-%COMP%]{display:block;height:100%}\"]\n  });\n  return IgxNavigationDrawerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxNavigationDrawerModule = /*#__PURE__*/(() => {\n  class IgxNavigationDrawerModule {}\n\n  IgxNavigationDrawerModule.ɵfac = function IgxNavigationDrawerModule_Factory(t) {\n    return new (t || IgxNavigationDrawerModule)();\n  };\n\n  IgxNavigationDrawerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxNavigationDrawerModule\n  });\n  IgxNavigationDrawerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return IgxNavigationDrawerModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Template directive that allows you to set a custom template representing the lower label value of the {@link IgxSliderComponent}\n *\n * ```html\n * <igx-slider>\n *  <ng-template igxSliderThumbFrom let-value let-labels>{{value}}</ng-template>\n * </igx-slider>\n * ```\n *\n * @context {@link IgxSliderComponent.context}\n */\n\n\nlet IgxThumbFromTemplateDirective = /*#__PURE__*/(() => {\n  class IgxThumbFromTemplateDirective {}\n\n  IgxThumbFromTemplateDirective.ɵfac = function IgxThumbFromTemplateDirective_Factory(t) {\n    return new (t || IgxThumbFromTemplateDirective)();\n  };\n\n  IgxThumbFromTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxThumbFromTemplateDirective,\n    selectors: [[\"\", \"igxSliderThumbFrom\", \"\"]]\n  });\n  return IgxThumbFromTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Template directive that allows you to set a custom template representing the upper label value of the {@link IgxSliderComponent}\n *\n * ```html\n * <igx-slider>\n *  <ng-template igxSliderThumbTo let-value let-labels>{{value}}</ng-template>\n * </igx-slider>\n * ```\n *\n * @context {@link IgxSliderComponent.context}\n */\n\n\nlet IgxThumbToTemplateDirective = /*#__PURE__*/(() => {\n  class IgxThumbToTemplateDirective {}\n\n  IgxThumbToTemplateDirective.ɵfac = function IgxThumbToTemplateDirective_Factory(t) {\n    return new (t || IgxThumbToTemplateDirective)();\n  };\n\n  IgxThumbToTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxThumbToTemplateDirective,\n    selectors: [[\"\", \"igxSliderThumbTo\", \"\"]]\n  });\n  return IgxThumbToTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Template directive that allows you to set a custom template, represeting primary/secondary tick labels of the {@link IgxSliderComponent}\n *\n * @context {@link IgxTicksComponent.context}\n */\n\n\nlet IgxTickLabelTemplateDirective = /*#__PURE__*/(() => {\n  class IgxTickLabelTemplateDirective {}\n\n  IgxTickLabelTemplateDirective.ɵfac = function IgxTickLabelTemplateDirective_Factory(t) {\n    return new (t || IgxTickLabelTemplateDirective)();\n  };\n\n  IgxTickLabelTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxTickLabelTemplateDirective,\n    selectors: [[\"\", \"igxSliderTickLabel\", \"\"]]\n  });\n  return IgxTickLabelTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst IgxSliderType = mkenum({\n  /**\n   * Slider with single thumb.\n   */\n  SLIDER: 'slider',\n\n  /**\n   *  Range slider with multiple thumbs, that can mark the range.\n   */\n  RANGE: 'range'\n});\nconst SliderHandle = mkenum({\n  FROM: 'from',\n  TO: 'to'\n});\n/**\n * Slider Tick labels Orientation\n */\n\nconst TickLabelsOrientation = mkenum({\n  Horizontal: 'horizontal',\n  TopToBottom: 'toptobottom',\n  BottomToTop: 'bottomtotop'\n});\n/**\n * Slider Ticks orientation\n */\n\nconst TicksOrientation = mkenum({\n  Top: 'top',\n  Bottom: 'bottom',\n  Mirror: 'mirror'\n});\n/**\n * @hidden\n */\n\nlet IgxSliderThumbComponent = /*#__PURE__*/(() => {\n  class IgxSliderThumbComponent {\n    constructor(_elementRef, _dir) {\n      this._elementRef = _elementRef;\n      this._dir = _dir;\n      this.thumbValueChange = new EventEmitter();\n      this.thumbChange = new EventEmitter();\n      this.hoverChange = new EventEmitter();\n      this.tabindex = 0;\n      this.zIndex = 0;\n      this.isActive = false;\n      this._isActive = false;\n      this._isPressed = false;\n      this._destroy$ = new Subject();\n    }\n\n    get thumbFromClass() {\n      return this.type === SliderHandle.FROM;\n    }\n\n    get thumbToClass() {\n      return this.type === SliderHandle.TO;\n    }\n\n    get thumbFromActiveClass() {\n      return this.type === SliderHandle.FROM && this._isActive;\n    }\n\n    get thumbToActiveClass() {\n      return this.type === SliderHandle.TO && this._isActive;\n    }\n\n    get thumbFromDisabledClass() {\n      return this.type === SliderHandle.FROM && this.disabled;\n    }\n\n    get thumbToDisabledClass() {\n      return this.type === SliderHandle.TO && this.disabled;\n    }\n\n    get thumbFromPressedClass() {\n      return this.type === SliderHandle.FROM && this.isActive && this._isPressed;\n    }\n\n    get thumbToPressedClass() {\n      return this.type === SliderHandle.TO && this.isActive && this._isPressed;\n    }\n\n    get getDotClass() {\n      return {\n        'igx-slider-thumb-from__dot': this.type === SliderHandle.FROM,\n        'igx-slider-thumb-to__dot': this.type === SliderHandle.TO\n      };\n    }\n\n    get nativeElement() {\n      return this._elementRef.nativeElement;\n    }\n\n    get destroy() {\n      return this._destroy$;\n    }\n\n    get thumbPositionX() {\n      const thumbBounderies = this.nativeElement.getBoundingClientRect();\n      const thumbCenter = (thumbBounderies.right - thumbBounderies.left) / 2;\n      return thumbBounderies.left + thumbCenter;\n    }\n\n    onPinterEnter() {\n      this.hoverChange.emit(true);\n    }\n\n    onPointerLeave() {\n      this.hoverChange.emit(false);\n    }\n\n    onKeyDown(event) {\n      if (this.disabled) {\n        return;\n      }\n\n      let increment = 0;\n\n      if (event.key.endsWith('Left')) {\n        increment = this.step * -1;\n      } else if (event.key.endsWith('Right')) {\n        increment = this.step;\n      } else {\n        return;\n      }\n\n      this.thumbChange.emit();\n      this.thumbValueChange.emit(increment);\n    }\n\n    onBlur() {\n      this.isActive = false;\n      this.zIndex = 0;\n    }\n\n    onFocusListener() {\n      this.isActive = true;\n      this.zIndex = 1;\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      this.onPan.pipe(takeUntil(this._destroy$)).subscribe(mouseX => this.updateThumbValue(mouseX));\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      this._destroy$.next(true);\n\n      this._destroy$.complete();\n    }\n    /**\n     * Show thumb label and ripple.\n     */\n\n\n    showThumbIndicators() {\n      this.toggleThumbIndicators(true);\n    }\n    /**\n     * Hide thumb label and ripple.\n     */\n\n\n    hideThumbIndicators() {\n      this.toggleThumbIndicators(false);\n    }\n\n    updateThumbValue(mouseX) {\n      const updateValue = this.calculateTrackUpdate(mouseX);\n\n      if (this.isActive && updateValue !== 0) {\n        this.thumbValueChange.emit(updateValue);\n      }\n    }\n\n    calculateTrackUpdate(mouseX) {\n      const scaleX = this._dir.rtl ? this.thumbPositionX - mouseX : mouseX - this.thumbPositionX;\n      const stepDistanceCenter = this.stepDistance / 2; // If the thumb scale range (slider update) is less thàn a half step,\n      // the position stays the same.\n\n      const scaleXPositive = Math.abs(scaleX);\n\n      if (scaleXPositive < stepDistanceCenter) {\n        return 0;\n      }\n\n      return this.stepToProceed(scaleX, this.stepDistance);\n    }\n\n    stepToProceed(scaleX, stepDist) {\n      return Math.round(scaleX / stepDist) * this.step;\n    }\n\n    toggleThumbIndicators(visible) {\n      this._isPressed = visible;\n\n      if (this.continuous || this.deactiveState) {\n        this._isActive = false;\n      } else {\n        this._isActive = visible;\n      }\n    }\n\n  }\n\n  IgxSliderThumbComponent.ɵfac = function IgxSliderThumbComponent_Factory(t) {\n    return new (t || IgxSliderThumbComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(IgxDirectionality));\n  };\n\n  IgxSliderThumbComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxSliderThumbComponent,\n    selectors: [[\"igx-thumb\"]],\n    hostVars: 18,\n    hostBindings: function IgxSliderThumbComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"pointerenter\", function IgxSliderThumbComponent_pointerenter_HostBindingHandler() {\n          return ctx.onPinterEnter();\n        })(\"pointerleave\", function IgxSliderThumbComponent_pointerleave_HostBindingHandler() {\n          return ctx.onPointerLeave();\n        })(\"keydown\", function IgxSliderThumbComponent_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        })(\"blur\", function IgxSliderThumbComponent_blur_HostBindingHandler() {\n          return ctx.onBlur();\n        })(\"focus\", function IgxSliderThumbComponent_focus_HostBindingHandler() {\n          return ctx.onFocusListener();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabindex\", ctx.tabindex)(\"z-index\", ctx.zIndex);\n        i0.ɵɵclassProp(\"igx-slider-thumb-from\", ctx.thumbFromClass)(\"igx-slider-thumb-to\", ctx.thumbToClass)(\"igx-slider-thumb-from--active\", ctx.thumbFromActiveClass)(\"igx-slider-thumb-to--active\", ctx.thumbToActiveClass)(\"igx-slider-thumb-from--disabled\", ctx.thumbFromDisabledClass)(\"igx-slider-thumb-to--disabled\", ctx.thumbToDisabledClass)(\"igx-slider-thumb-from--pressed\", ctx.thumbFromPressedClass)(\"igx-slider-thumb-to--pressed\", ctx.thumbToPressedClass);\n      }\n    },\n    inputs: {\n      value: \"value\",\n      continuous: \"continuous\",\n      thumbLabelVisibilityDuration: \"thumbLabelVisibilityDuration\",\n      disabled: \"disabled\",\n      onPan: \"onPan\",\n      stepDistance: \"stepDistance\",\n      step: \"step\",\n      templateRef: \"templateRef\",\n      context: \"context\",\n      type: \"type\",\n      deactiveState: \"deactiveState\"\n    },\n    outputs: {\n      thumbValueChange: \"thumbValueChange\",\n      thumbChange: \"thumbChange\",\n      hoverChange: \"hoverChange\"\n    },\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"ngClass\"]],\n    template: function IgxSliderThumbComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngClass\", ctx.getDotClass);\n      }\n    },\n    directives: [i4.NgClass],\n    encapsulation: 2\n  });\n  return IgxSliderThumbComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxThumbLabelComponent = /*#__PURE__*/(() => {\n  class IgxThumbLabelComponent {\n    constructor(_elementRef) {\n      this._elementRef = _elementRef;\n    }\n\n    get thumbFromClass() {\n      return this.type === SliderHandle.FROM;\n    }\n\n    get thumbToClass() {\n      return this.type === SliderHandle.TO;\n    }\n\n    get thumbFromActiveClass() {\n      return this.type === SliderHandle.FROM && this.active;\n    }\n\n    get thumbToActiveClass() {\n      return this.type === SliderHandle.TO && this.active;\n    }\n\n    get labelFromPressedClass() {\n      var _a;\n\n      return (_a = this.thumb) === null || _a === void 0 ? void 0 : _a.thumbFromPressedClass;\n    }\n\n    get labelToPressedClass() {\n      var _a;\n\n      return (_a = this.thumb) === null || _a === void 0 ? void 0 : _a.thumbToPressedClass;\n    }\n\n    get getLabelClass() {\n      return {\n        'igx-slider-thumb-label-from__container': this.type === SliderHandle.FROM,\n        'igx-slider-thumb-label-to__container': this.type === SliderHandle.TO\n      };\n    }\n\n    get nativeElement() {\n      return this._elementRef.nativeElement;\n    }\n\n    get active() {\n      return this._active;\n    }\n\n    set active(val) {\n      if (this.continuous || this.deactiveState) {\n        this._active = false;\n      } else {\n        this._active = val;\n      }\n    }\n\n  }\n\n  IgxThumbLabelComponent.ɵfac = function IgxThumbLabelComponent_Factory(t) {\n    return new (t || IgxThumbLabelComponent)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxThumbLabelComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxThumbLabelComponent,\n    selectors: [[\"igx-thumb-label\"]],\n    hostVars: 12,\n    hostBindings: function IgxThumbLabelComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-slider-thumb-label-from\", ctx.thumbFromClass)(\"igx-slider-thumb-label-to\", ctx.thumbToClass)(\"igx-slider-thumb-label-from--active\", ctx.thumbFromActiveClass)(\"igx-slider-thumb-label-to--active\", ctx.thumbToActiveClass)(\"igx-slider-thumb-label-from--pressed\", ctx.labelFromPressedClass)(\"igx-slider-thumb-label-to--pressed\", ctx.labelToPressedClass);\n      }\n    },\n    inputs: {\n      value: \"value\",\n      templateRef: \"templateRef\",\n      context: \"context\",\n      type: \"type\",\n      continuous: \"continuous\",\n      deactiveState: \"deactiveState\",\n      thumb: \"thumb\"\n    },\n    decls: 4,\n    vars: 3,\n    consts: [[3, \"ngClass\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"thumbFromDefaultTemplate\", \"\"]],\n    template: function IgxThumbLabelComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵtemplate(1, IgxThumbLabelComponent_ng_container_1_Template, 1, 0, \"ng-container\", 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(2, IgxThumbLabelComponent_ng_template_2_Template, 1, 1, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        const _r1 = i0.ɵɵreference(3);\n\n        i0.ɵɵproperty(\"ngClass\", ctx.getLabelClass);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.templateRef ? ctx.templateRef : _r1)(\"ngTemplateOutletContext\", ctx.context);\n      }\n    },\n    directives: [i4.NgClass, i4.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return IgxThumbLabelComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxTicksComponent = /*#__PURE__*/(() => {\n  class IgxTicksComponent {\n    constructor() {\n      /**\n       * @hidden\n       */\n      this.ticksClass = true;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get ticksTopClass() {\n      return this.ticksOrientation === TicksOrientation.Top;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get hasPrimaryClass() {\n      return this.primaryTicks > 0;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get labelsTopToBottomClass() {\n      return this.tickLabelsOrientation === TickLabelsOrientation.TopToBottom;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get labelsBottomToTopClass() {\n      return this.tickLabelsOrientation === TickLabelsOrientation.BottomToTop;\n    }\n    /**\n     * Returns the template context corresponding to\n     * {@link IgxTickLabelTemplateDirective}\n     *\n     * ```typescript\n     * return {\n     *  $implicit //returns the value per each tick label.\n     *  isPrimery //returns if the tick is primary.\n     *  labels // returns the {@link labels} collection.\n     *  index // returns the index per each tick of the whole sequence.\n     * }\n     * ```\n     *\n     * @param idx the index per each tick label.\n     */\n\n\n    context(idx) {\n      return {\n        $implicit: this.tickLabel(idx),\n        isPrimary: this.isPrimary(idx),\n        labels: this.labels,\n        index: idx\n      };\n    }\n    /**\n     * @hidden\n     */\n\n\n    get ticksLength() {\n      return this.primaryTicks > 0 ? (this.primaryTicks - 1) * this.secondaryTicks + this.primaryTicks : this.secondaryTicks > 0 ? this.secondaryTicks : 0;\n    }\n\n    hiddenTickLabels(idx) {\n      return this.isPrimary(idx) ? this.primaryTickLabels : this.secondaryTickLabels;\n    }\n    /**\n     * @hidden\n     */\n\n\n    isPrimary(idx) {\n      return this.primaryTicks <= 0 ? false : idx % (this.secondaryTicks + 1) === 0;\n    }\n    /**\n     * @hidden\n     */\n\n\n    tickLabel(idx) {\n      if (this.labelsViewEnabled) {\n        return this.labels[idx];\n      }\n\n      const labelStep = (Math.max(this.minValue, this.maxValue) - Math.min(this.minValue, this.maxValue)) / (this.ticksLength - 1);\n      const labelVal = labelStep * idx;\n      return (this.minValue + labelVal).toFixed(2);\n    }\n\n  }\n\n  IgxTicksComponent.ɵfac = function IgxTicksComponent_Factory(t) {\n    return new (t || IgxTicksComponent)();\n  };\n\n  IgxTicksComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxTicksComponent,\n    selectors: [[\"igx-ticks\"]],\n    hostVars: 10,\n    hostBindings: function IgxTicksComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-slider__ticks\", ctx.ticksClass)(\"igx-slider__ticks--top\", ctx.ticksTopClass)(\"igx-slider__ticks--tall\", ctx.hasPrimaryClass)(\"igx-slider__tick-labels--top-bottom\", ctx.labelsTopToBottomClass)(\"igx-slider__tick-labels--bottom-top\", ctx.labelsBottomToTopClass);\n      }\n    },\n    inputs: {\n      primaryTicks: \"primaryTicks\",\n      secondaryTicks: \"secondaryTicks\",\n      primaryTickLabels: \"primaryTickLabels\",\n      secondaryTickLabels: \"secondaryTickLabels\",\n      ticksOrientation: \"ticksOrientation\",\n      tickLabelsOrientation: \"tickLabelsOrientation\",\n      maxValue: \"maxValue\",\n      minValue: \"minValue\",\n      labelsViewEnabled: \"labelsViewEnabled\",\n      labels: \"labels\",\n      tickLabelTemplateRef: \"tickLabelTemplateRef\"\n    },\n    decls: 3,\n    vars: 2,\n    consts: [[\"class\", \"igx-slider__ticks-group\", 3, \"ngClass\", 4, \"ngFor\", \"ngForOf\"], [\"tickLabelDefaultTemplate\", \"\"], [1, \"igx-slider__ticks-group\", 3, \"ngClass\"], [1, \"igx-slider__ticks-tick\"], [1, \"igx-slider__ticks-label\", 3, \"ngClass\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function IgxTicksComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxTicksComponent_div_0_Template, 4, 8, \"div\", 0);\n        i0.ɵɵtemplate(1, IgxTicksComponent_ng_template_1_Template, 1, 1, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpureFunction0(1, _c115).constructor(ctx.ticksLength));\n      }\n    },\n    directives: [i4.NgForOf, i4.NgClass, i4.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return IgxTicksComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxTickLabelsPipe = /*#__PURE__*/(() => {\n  class IgxTickLabelsPipe {\n    transform(labels, secondaryTicks) {\n      if (!labels) {\n        return;\n      }\n\n      const result = [];\n      labels.forEach(item => {\n        result.push(item);\n\n        for (let i = 0; i < secondaryTicks; i++) {\n          result.push('');\n        }\n      });\n      return result;\n    }\n\n  }\n\n  IgxTickLabelsPipe.ɵfac = function IgxTickLabelsPipe_Factory(t) {\n    return new (t || IgxTickLabelsPipe)();\n  };\n\n  IgxTickLabelsPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"spreadTickLabels\",\n    type: IgxTickLabelsPipe,\n    pure: true\n  });\n  return IgxTickLabelsPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$3 = 0;\n/**\n * **Ignite UI for Angular Slider** -\n * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/slider/slider)\n *\n * The Ignite UI Slider allows selection in a given range by moving the thumb along the track. The track\n * can be defined as continuous or stepped, and you can choose between single and range slider types.\n *\n * Example:\n * ```html\n * <igx-slider id=\"slider\"\n *            [minValue]=\"0\" [maxValue]=\"100\"\n *            [continuous]=true [(ngModel)]=\"volume\">\n * </igx-slider>\n * ```\n */\n\nlet IgxSliderComponent = /*#__PURE__*/(() => {\n  class IgxSliderComponent {\n    constructor(renderer, _el, _cdr, _ngZone, _dir, platform) {\n      this.renderer = renderer;\n      this._el = _el;\n      this._cdr = _cdr;\n      this._ngZone = _ngZone;\n      this._dir = _dir;\n      this.platform = platform;\n      /**\n       * @hidden\n       */\n\n      this.role = 'slider';\n      /**\n       * @hidden\n       */\n\n      this.slierClass = true;\n      /**\n       * An @Input property that sets the value of the `id` attribute.\n       * If not provided it will be automatically generated.\n       * ```html\n       * <igx-slider [id]=\"'igx-slider-32'\" [(ngModel)]=\"task.percentCompleted\" [step]=\"5\" [lowerBound]=\"20\">\n       * ```\n       */\n\n      this.id = `igx-slider-${NEXT_ID$3++}`;\n      /**\n       * An @Input property that sets the duration visibility of thumbs labels. The default value is 750 milliseconds.\n       * ```html\n       * <igx-slider #slider [thumbLabelVisibilityDuration]=\"3000\" [(ngModel)]=\"task.percentCompleted\" [step]=\"5\">\n       * ```\n       */\n\n      this.thumbLabelVisibilityDuration = 750;\n      /**\n       * Show/hide slider ticks\n       * ```html\n       * <igx-slier [showTicks]=\"true\" [primaryTicks]=\"5\"></igx-slier>\n       * ```\n       */\n\n      this.showTicks = false;\n      /**\n       * show/hide primary tick labels\n       * ```html\n       * <igx-slider [primaryTicks]=\"5\" [primaryTickLabels]=\"false\"></igx-slider>\n       * ```\n       */\n\n      this.primaryTickLabels = true;\n      /**\n       * show/hide secondary tick labels\n       * ```html\n       * <igx-slider [secondaryTicks]=\"5\" [secondaryTickLabels]=\"false\"></igx-slider>\n       * ```\n       */\n\n      this.secondaryTickLabels = true;\n      /**\n       * Changes ticks orientation:\n       * bottom - The default orienation, below the slider track.\n       * top - Above the slider track\n       * mirror - combines top and bottom orientation.\n       * ```html\n       * <igx-slider [primaryTicks]=\"5\" [ticksOrientation]=\"ticksOrientation\"></igx-slider>\n       * ```\n       */\n\n      this.ticksOrientation = TicksOrientation.Bottom;\n      /**\n       * Changes tick labels rotation:\n       * horizontal - The default rotation\n       * toptobottom - Rotates tick labels vertically to 90deg\n       * bottomtotop - Rotate tick labels vertically to -90deg\n       * ```html\n       * <igx-slider [primaryTicks]=\"5\" [secondaryTicks]=\"3\" [tickLabelsOrientation]=\"tickLabelsOrientaiton\"></igx-slider>\n       * ```\n       */\n\n      this.tickLabelsOrientation = TickLabelsOrientation.Horizontal;\n      /**\n       * This event is emitted every time the value is changed.\n       * ```typescript\n       * public change(event){\n       *    alert(\"The value has been changed!\");\n       * }\n       * ```\n       * ```html\n       * <igx-slider (valueChange)=\"change($event)\" #slider [(ngModel)]=\"task.percentCompleted\" [step]=\"5\">\n       * ```\n       */\n\n      this.valueChange = new EventEmitter();\n      /**\n       * This event is emitted at the end of every slide interaction.\n       * ```typescript\n       * public change(event){\n       *    alert(\"The value has been changed!\");\n       * }\n       * ```\n       * ```html\n       * <igx-slider (dragFinished)=\"change($event)\" #slider [(ngModel)]=\"task.percentCompleted\" [step]=\"5\">\n       * ```\n       */\n\n      this.dragFinished = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.thumbs = new QueryList();\n      /**\n       * @hidden\n       */\n\n      this.labelRefs = new QueryList();\n      /**\n       * @hidden\n       */\n\n      this.onPan = new Subject(); // Limit handle travel zone\n\n      this._pMin = 0;\n      this._pMax = 1; // From/upperValue in percent values\n\n      this._hasViewInit = false;\n      this._minValue = 0;\n      this._maxValue = 100;\n      this._continuous = false;\n      this._disabled = false;\n      this._step = 1;\n      this._value = 0; // ticks\n\n      this._primaryTicks = 0;\n      this._secondaryTicks = 0;\n      this._labels = new Array();\n      this._type = IgxSliderType.SLIDER;\n      this._destroyer$ = new Subject();\n      this._indicatorsDestroyer$ = new Subject();\n      this._onChangeCallback = noop;\n      this._onTouchedCallback = noop;\n      this.stepDistance = this._step;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get thumbFrom() {\n      return this.thumbs.find(thumb => thumb.type === SliderHandle.FROM);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get thumbTo() {\n      return this.thumbs.find(thumb => thumb.type === SliderHandle.TO);\n    }\n\n    get labelFrom() {\n      return this.labelRefs.find(label => label.type === SliderHandle.FROM);\n    }\n\n    get labelTo() {\n      return this.labelRefs.find(label => label.type === SliderHandle.TO);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get valuemin() {\n      return this.minValue;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get valuemax() {\n      return this.maxValue;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get readonly() {\n      return this.disabled;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get disabledClass() {\n      return this.disabled;\n    }\n    /**\n     * An @Input property that gets the type of the `IgxSliderComponent`.\n     * The slider can be IgxSliderType.SLIDER(default) or IgxSliderType.RANGE.\n     * ```typescript\n     * @ViewChild(\"slider2\")\n     * public slider: IgxSliderComponent;\n     * ngAfterViewInit(){\n     *     let type = this.slider.type;\n     * }\n     */\n\n\n    get type() {\n      return this._type;\n    }\n    /**\n     * An @Input property that sets the type of the `IgxSliderComponent`.\n     * The slider can be IgxSliderType.SLIDER(default) or IgxSliderType.RANGE.\n     * ```typescript\n     * sliderType: IgxSliderType = IgxSliderType.RANGE;\n     * ```\n     * ```html\n     * <igx-slider #slider2 [type]=\"sliderType\" [(ngModel)]=\"rangeValue\" [minValue]=\"0\" [maxValue]=\"100\">\n     * ```\n     */\n\n\n    set type(type) {\n      this._type = type;\n\n      if (type === IgxSliderType.SLIDER) {\n        this.lowerValue = 0;\n      }\n\n      if (this.labelsViewEnabled && this.upperValue > this.maxValue) {\n        this.upperValue = this.labels.length - 1;\n      }\n\n      if (this._hasViewInit) {\n        this.updateTrack();\n      }\n    }\n    /**\n     * Enables `labelView`, by accepting a collection of primitive values with more than one element.\n     * Each element will be equally spread over the slider and it will serve as a thumb label.\n     * Once the property is set, it will precendence over {@link maxValue}, {@link minValue}, {@link step}.\n     * This means that the manipulation for those properties won't be allowed.\n     */\n\n\n    get labels() {\n      return this._labels;\n    }\n\n    set labels(labels) {\n      this._labels = labels;\n      this._pMax = this.valueToFraction(this.upperBound, 0, 1);\n      this._pMin = this.valueToFraction(this.lowerBound, 0, 1);\n      this.positionHandlersAndUpdateTrack();\n\n      if (this._hasViewInit) {\n        this.stepDistance = this.calculateStepDistance();\n        this.setTickInterval();\n      }\n    }\n    /**\n     * Returns the template context corresponding\n     * to {@link IgxThumbFromTemplateDirective} and {@link IgxThumbToTemplateDirective} templates.\n     *\n     * ```typescript\n     * return {\n     *  $implicit // returns the value of the label,\n     *  labels // returns the labels collection the user has passed.\n     * }\n     * ```\n     */\n\n\n    get context() {\n      return {\n        $implicit: this.value,\n        labels: this.labels\n      };\n    }\n    /**\n     * An @Input property that sets the incremental/decremental step of the value when dragging the thumb.\n     * The default step is 1, and step should not be less or equal than 0.\n     * ```html\n     * <igx-slider #slider [(ngModel)]=\"task.percentCompleted\" [step]=\"5\">\n     * ```\n     */\n\n\n    set step(step) {\n      this._step = step;\n\n      if (this._hasViewInit) {\n        this.stepDistance = this.calculateStepDistance();\n        this.normalizeByStep(this._value);\n        this.setValue(this._value, true);\n        this.positionHandlersAndUpdateTrack();\n        this.setTickInterval();\n      }\n    }\n    /**\n     * Returns the incremental/decremental dragging step of the {@link IgxSliderComponent}.\n     * ```typescript\n     * @ViewChild(\"slider2\")\n     * public slider: IgxSliderComponent;\n     * ngAfterViewInit(){\n     *     let step = this.slider.step;\n     * }\n     * ```\n     */\n\n\n    get step() {\n      return this.labelsViewEnabled ? 1 : this._step;\n    }\n    /**\n     * Returns if the {@link IgxSliderComponent} is disabled.\n     * ```typescript\n     * @ViewChild(\"slider2\")\n     * public slider: IgxSliderComponent;\n     * ngAfterViewInit(){\n     *     let isDisabled = this.slider.disabled;\n     * }\n     * ```\n     */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n    /**\n     * An @Input property that disables or enables UI interaction.\n     * ```html\n     * <igx-slider #slider [disabled]=\"'true'\" [(ngModel)]=\"task.percentCompleted\" [step]=\"5\" [lowerBound]=\"20\">\n     * ```\n     */\n\n\n    set disabled(disable) {\n      this._disabled = disable;\n\n      if (this._hasViewInit) {\n        this.changeThumbFocusableState(disable);\n      }\n    }\n    /**\n     * Returns if the {@link IgxSliderComponent} is set as continuous.\n     * ```typescript\n     * @ViewChild(\"slider2\")\n     * public slider: IgxSliderComponent;\n     * ngAfterViewInit(){\n     *     let continuous = this.slider.continuous;\n     * }\n     * ```\n     */\n\n\n    get continuous() {\n      return this._continuous;\n    }\n    /**\n     * An @Input property that marks the {@link IgxSliderComponent} as continuous.\n     * By default is considered that the {@link IgxSliderComponent} is discrete.\n     * Discrete {@link IgxSliderComponent} slider has step indicators over the track and visible thumb labels during interaction.\n     * Continuous {@link IgxSliderComponent} does not have ticks and does not show bubble labels for values.\n     * ```html\n     * <igx-slider #slider [continuous]=\"'true'\" [(ngModel)]=\"task.percentCompleted\" [step]=\"5\" [lowerBound]=\"20\">\n     * ```\n     */\n\n\n    set continuous(continuous) {\n      this._continuous = continuous;\n\n      if (this._hasViewInit) {\n        this.setTickInterval();\n      }\n    }\n    /**\n     * Returns the minimal value of the `IgxSliderComponent`.\n     * ```typescript\n     *  @ViewChild(\"slider2\")\n     * public slider: IgxSliderComponent;\n     * ngAfterViewInit(){\n     *     let sliderMin = this.slider.minValue;\n     * }\n     * ```\n     */\n\n\n    get minValue() {\n      if (this.labelsViewEnabled) {\n        return 0;\n      }\n\n      return this._minValue;\n    }\n    /**\n     * Sets the minimal value for the `IgxSliderComponent`.\n     * The default minimal value is 0.\n     * ```html\n     * <igx-slider [type]=\"sliderType\" [minValue]=\"56\" [maxValue]=\"100\">\n     * ```\n     */\n\n\n    set minValue(value) {\n      if (value >= this.maxValue) {\n        return;\n      } else {\n        this._minValue = value;\n      }\n\n      if (value > this.upperBound) {\n        this.updateUpperBoundAndMaxTravelZone();\n        this.lowerBound = value;\n      } // Refresh min travel zone limit.\n\n\n      this._pMin = 0; // Recalculate step distance.\n\n      this.positionHandlersAndUpdateTrack();\n\n      if (this._hasViewInit) {\n        this.stepDistance = this.calculateStepDistance();\n        this.setTickInterval();\n      }\n    }\n    /**\n     * Returns the maximum value for the {@link IgxSliderComponent}.\n     * ```typescript\n     * @ViewChild(\"slider\")\n     * public slider: IgxSliderComponent;\n     * ngAfterViewInit(){\n     *     let sliderMax = this.slider.maxValue;\n     * }\n     *  ```\n     */\n\n\n    get maxValue() {\n      return this.labelsViewEnabled ? this.labels.length - 1 : this._maxValue;\n    }\n    /**\n     * Sets the maximal value for the `IgxSliderComponent`.\n     * The default maximum value is 100.\n     * ```html\n     * <igx-slider [type]=\"sliderType\" [minValue]=\"56\" [maxValue]=\"256\">\n     * ```\n     */\n\n\n    set maxValue(value) {\n      if (value <= this._minValue) {\n        return;\n      } else {\n        this._maxValue = value;\n      }\n\n      if (value < this.lowerBound) {\n        this.updateLowerBoundAndMinTravelZone();\n        this.upperBound = value;\n      } // refresh max travel zone limits.\n\n\n      this._pMax = 1; // recalculate step distance.\n\n      this.positionHandlersAndUpdateTrack();\n\n      if (this._hasViewInit) {\n        this.stepDistance = this.calculateStepDistance();\n        this.setTickInterval();\n      }\n    }\n    /**\n     * Returns the lower boundary of the `IgxSliderComponent`.\n     * ```typescript\n     * @ViewChild(\"slider\")\n     * public slider: IgxSliderComponent;\n     * ngAfterViewInit(){\n     *     let sliderLowBound = this.slider.lowerBound;\n     * }\n     * ```\n     */\n\n\n    get lowerBound() {\n      if (!Number.isNaN(this._lowerBound) && this._lowerBound !== undefined) {\n        return this.valueInRange(this._lowerBound, this.minValue, this.maxValue);\n      }\n\n      return this.minValue;\n    }\n    /**\n     * Sets the lower boundary of the `IgxSliderComponent`.\n     * If not set is the same as min value.\n     * ```html\n     * <igx-slider [step]=\"5\" [lowerBound]=\"20\">\n     * ```\n     */\n\n\n    set lowerBound(value) {\n      if (value >= this.upperBound || this.labelsViewEnabled && value < 0) {\n        return;\n      }\n\n      this._lowerBound = this.valueInRange(value, this.minValue, this.maxValue); // Refresh min travel zone.\n\n      this._pMin = this.valueToFraction(this._lowerBound, 0, 1);\n      this.positionHandlersAndUpdateTrack();\n    }\n    /**\n     * Returns the upper boundary of the `IgxSliderComponent`.\n     * ```typescript\n     * @ViewChild(\"slider\")\n     * public slider: IgxSliderComponent;\n     * ngAfterViewInit(){\n     *    let sliderUpBound = this.slider.upperBound;\n     * }\n     * ```\n     */\n\n\n    get upperBound() {\n      if (!Number.isNaN(this._upperBound) && this._upperBound !== undefined) {\n        return this.valueInRange(this._upperBound, this.minValue, this.maxValue);\n      }\n\n      return this.maxValue;\n    }\n    /**\n     * Sets the upper boundary of the `IgxSliderComponent`.\n     * If not set is the same as max value.\n     * ```html\n     * <igx-slider [step]=\"5\" [upperBound]=\"20\">\n     * ```\n     */\n\n\n    set upperBound(value) {\n      if (value <= this.lowerBound || this.labelsViewEnabled && value > this.labels.length - 1) {\n        return;\n      }\n\n      this._upperBound = this.valueInRange(value, this.minValue, this.maxValue); // Refresh time travel zone.\n\n      this._pMax = this.valueToFraction(this._upperBound, 0, 1);\n      this.positionHandlersAndUpdateTrack();\n    }\n    /**\n     * Returns the slider value. If the slider is of type {@link IgxSliderType.SLIDER} the returned value is number.\n     * If the slider type is {@link IgxSliderType.RANGE}.\n     * The returned value represents an object of {@link lowerValue} and {@link upperValue}.\n     * ```typescript\n     * @ViewChild(\"slider2\")\n     * public slider: IgxSliderComponent;\n     * public sliderValue(event){\n     *     let sliderVal = this.slider.value;\n     * }\n     * ```\n     */\n\n\n    get value() {\n      if (this.isRange) {\n        return {\n          lower: this.valueInRange(this.lowerValue, this.lowerBound, this.upperBound),\n          upper: this.valueInRange(this.upperValue, this.lowerBound, this.upperBound)\n        };\n      } else {\n        return this.valueInRange(this.upperValue, this.lowerBound, this.upperBound);\n      }\n    }\n    /**\n     * Sets the slider value.\n     * If the slider is of type {@link IgxSliderType.SLIDER}.\n     * The argument is number. By default the {@link value} gets the {@link lowerBound}.\n     * If the slider type is {@link IgxSliderType.RANGE} the argument\n     * represents an object of {@link lowerValue} and {@link upperValue} properties.\n     * By default the object is associated with the {@link lowerBound} and {@link upperBound} property values.\n     * ```typescript\n     * rangeValue = {\n     *   lower: 30,\n     *   upper: 60\n     * };\n     * ```\n     * ```html\n     * <igx-slider [type]=\"sliderType\" [(ngModel)]=\"rangeValue\" [minValue]=\"56\" [maxValue]=\"256\">\n     * ```\n     */\n\n\n    set value(value) {\n      this.normalizeByStep(value);\n\n      if (this._hasViewInit) {\n        this.setValue(this._value, true);\n        this.positionHandlersAndUpdateTrack();\n      }\n    }\n    /**\n     * Returns the number of the presented primary ticks.\n     * ```typescript\n     * const primaryTicks = this.slider.primaryTicks;\n     * ```\n     */\n\n\n    get primaryTicks() {\n      if (this.labelsViewEnabled) {\n        return this._primaryTicks = this.labels.length;\n      }\n\n      return this._primaryTicks;\n    }\n    /**\n     * Sets the number of primary ticks. If {@link @labels} is enabled, this property won't function.\n     * Insted enable ticks by {@link showTicks} property.\n     * ```typescript\n     * this.slider.primaryTicks = 5;\n     * ```\n     */\n\n\n    set primaryTicks(val) {\n      if (val <= 1) {\n        return;\n      }\n\n      this._primaryTicks = val;\n    }\n    /**\n     * Returns the number of the presented secondary ticks.\n     * ```typescript\n     * const secondaryTicks = this.slider.secondaryTicks;\n     * ```\n     */\n\n\n    get secondaryTicks() {\n      return this._secondaryTicks;\n    }\n    /**\n     * Sets the number of secondary ticks. The property functions even when {@link labels} is enabled,\n     * but all secondary ticks won't present any tick labels.\n     * ```typescript\n     * this.slider.secondaryTicks = 5;\n     * ```\n     */\n\n\n    set secondaryTicks(val) {\n      if (val < 1) {\n        return;\n      }\n\n      this._secondaryTicks = val;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get deactivateThumbLabel() {\n      return (this.primaryTicks && this.primaryTickLabels || this.secondaryTicks && this.secondaryTickLabels) && (this.ticksOrientation === TicksOrientation.Top || this.ticksOrientation === TicksOrientation.Mirror);\n    }\n    /**\n     * @hidden\n     */\n\n\n    onPointerDown($event) {\n      this.findClosestThumb($event);\n\n      if (!this.thumbTo.isActive && this.thumbFrom === undefined) {\n        return;\n      }\n\n      const activeThumb = this.thumbTo.isActive ? this.thumbTo : this.thumbFrom;\n      activeThumb.nativeElement.setPointerCapture($event.pointerId);\n      this.showSliderIndicators();\n      $event.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onPointerUp($event) {\n      if (!this.thumbTo.isActive && this.thumbFrom === undefined) {\n        return;\n      }\n\n      const activeThumb = this.thumbTo.isActive ? this.thumbTo : this.thumbTo;\n      activeThumb.nativeElement.releasePointerCapture($event.pointerId);\n      this.hideSliderIndicators();\n      this.dragFinished.emit(this.value);\n    }\n    /**\n     * @hidden\n     */\n\n\n    onFocus() {\n      this.toggleSliderIndicators();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onPanListener($event) {\n      this.update($event.srcEvent.clientX);\n    }\n    /**\n     * Returns whether the `IgxSliderComponent` type is RANGE.\n     * ```typescript\n     *  @ViewChild(\"slider\")\n     * public slider: IgxSliderComponent;\n     * ngAfterViewInit(){\n     *     let sliderRange = this.slider.isRange;\n     * }\n     * ```\n     */\n\n\n    get isRange() {\n      return this.type === IgxSliderType.RANGE;\n    }\n    /**\n     * Returns the lower value of the `IgxSliderComponent`.\n     * ```typescript\n     * @ViewChild(\"slider\")\n     * public slider: IgxSliderComponent;\n     * public lowValue(event){\n     *    let sliderLowValue = this.slider.lowerValue;\n     * }\n     * ```\n     */\n\n\n    get lowerValue() {\n      if (!Number.isNaN(this._lowerValue) && this._lowerValue !== undefined && this._lowerValue >= this.lowerBound) {\n        return this._lowerValue;\n      }\n\n      return this.lowerBound;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    set lowerValue(value) {\n      value = this.valueInRange(value, this.lowerBound, this.upperBound);\n      this._lowerValue = value;\n    }\n    /**\n     * Returns the upper value of the `IgxSliderComponent`.\n     * ```typescript\n     *  @ViewChild(\"slider2\")\n     * public slider: IgxSliderComponent;\n     * public upperValue(event){\n     *     let upperValue = this.slider.upperValue;\n     * }\n     * ```\n     */\n\n\n    get upperValue() {\n      if (!Number.isNaN(this._upperValue) && this._upperValue !== undefined && this._upperValue <= this.upperBound) {\n        return this._upperValue;\n      }\n\n      return this.upperBound;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    set upperValue(value) {\n      value = this.valueInRange(value, this.lowerBound, this.upperBound);\n      this._upperValue = value;\n    }\n    /**\n     * Returns the value corresponding the lower label.\n     * ```typescript\n     * @ViewChild(\"slider\")\n     * public slider: IgxSliderComponent;\n     * let label = this.slider.lowerLabel;\n     * ```\n     */\n\n\n    get lowerLabel() {\n      return this.labelsViewEnabled ? this.labels[this.lowerValue] : this.lowerValue;\n    }\n    /**\n     * Returns the value corresponding the upper label.\n     * ```typescript\n     * @ViewChild(\"slider\")\n     * public slider: IgxSliderComponent;\n     * let label = this.slider.upperLabel;\n     * ```\n     */\n\n\n    get upperLabel() {\n      return this.labelsViewEnabled ? this.labels[this.upperValue] : this.upperValue;\n    }\n    /**\n     * Returns if label view is enabled.\n     * If the {@link labels} is set, the view is automatically activated.\n     * ```typescript\n     * @ViewChild(\"slider\")\n     * public slider: IgxSliderComponent;\n     * let labelView = this.slider.labelsViewEnabled;\n     * ```\n     */\n\n\n    get labelsViewEnabled() {\n      return !!(this.labels && this.labels.length > 1);\n    }\n    /**\n     * @hidden\n     */\n\n\n    get showTopTicks() {\n      return this.ticksOrientation === TicksOrientation.Top || this.ticksOrientation === TicksOrientation.Mirror;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get showBottomTicks() {\n      return this.ticksOrientation === TicksOrientation.Bottom || this.ticksOrientation === TicksOrientation.Mirror;\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnChanges(changes) {\n      if (changes.minValue && changes.maxValue && changes.minValue.currentValue < changes.maxValue.currentValue) {\n        this._maxValue = changes.maxValue.currentValue;\n        this._minValue = changes.minValue.currentValue;\n      }\n\n      if (changes.step && changes.step.isFirstChange()) {\n        this.normalizeByStep(this._value);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      this.sliderSetup(); // Set track travel zone\n\n      this._pMin = this.valueToFraction(this.lowerBound) || 0;\n      this._pMax = this.valueToFraction(this.upperBound) || 1;\n    }\n\n    ngAfterContentInit() {\n      this.setValue(this._value, false);\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterViewInit() {\n      this._hasViewInit = true;\n      this.stepDistance = this.calculateStepDistance();\n      this.positionHandlersAndUpdateTrack();\n      this.setTickInterval();\n      this.changeThumbFocusableState(this.disabled);\n      this.subscribeTo(this.thumbFrom, this.thumbChanged.bind(this));\n      this.subscribeTo(this.thumbTo, this.thumbChanged.bind(this));\n      this.thumbs.changes.pipe(takeUntil(this._destroyer$)).subscribe(change => {\n        const thumbFrom = change.find(thumb => thumb.type === SliderHandle.FROM);\n        this.positionHandler(thumbFrom, null, this.lowerValue);\n        this.subscribeTo(thumbFrom, this.thumbChanged.bind(this));\n        this.changeThumbFocusableState(this.disabled);\n      });\n      this.labelRefs.changes.pipe(takeUntil(this._destroyer$)).subscribe(() => {\n        const labelFrom = this.labelRefs.find(label => label.type === SliderHandle.FROM);\n        this.positionHandler(null, labelFrom, this.lowerValue);\n      });\n\n      this._ngZone.runOutsideAngular(() => {\n        resizeObservable(this._el.nativeElement).pipe(throttleTime(40), takeUntil(this._destroyer$)).subscribe(() => this._ngZone.run(() => {\n          this.stepDistance = this.calculateStepDistance();\n        }));\n      });\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnDestroy() {\n      this._destroyer$.next(true);\n\n      this._destroyer$.complete();\n\n      this._indicatorsDestroyer$.next(true);\n\n      this._indicatorsDestroyer$.complete();\n    }\n    /**\n     * @hidden\n     */\n\n\n    writeValue(value) {\n      if (!value) {\n        return;\n      }\n\n      this.normalizeByStep(value);\n      this.setValue(this._value, false);\n      this.positionHandlersAndUpdateTrack();\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnChange(fn) {\n      this._onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     */\n\n\n    registerOnTouched(fn) {\n      this._onTouchedCallback = fn;\n    }\n    /** @hidden */\n\n\n    getEditElement() {\n      return this.isRange ? this.thumbFrom.nativeElement : this.thumbTo.nativeElement;\n    }\n    /**\n     *\n     * @hidden\n     */\n\n\n    update(mouseX) {\n      if (this.disabled) {\n        return;\n      } // Update To/From Values\n\n\n      this.onPan.next(mouseX); // Finally do positionHandlersAndUpdateTrack the DOM\n      // based on data values\n\n      this.positionHandlersAndUpdateTrack();\n\n      this._onTouchedCallback();\n    }\n    /**\n     * @hidden\n     */\n\n\n    thumbChanged(value, thumbType) {\n      const oldValue = this.value;\n      let newVal;\n\n      if (this.isRange) {\n        if (thumbType === SliderHandle.FROM) {\n          newVal = {\n            lower: this.value.lower + value,\n            upper: this.value.upper\n          };\n        } else {\n          newVal = {\n            lower: this.value.lower,\n            upper: this.value.upper + value\n          };\n        } // Swap the thumbs if a collision appears.\n\n\n        if (newVal.lower >= newVal.upper) {\n          this.value = this.swapThumb(newVal);\n        } else {\n          this.value = newVal;\n        }\n      } else {\n        this.value = this.value + value;\n      }\n\n      if (this.hasValueChanged(oldValue)) {\n        this.emitValueChange(oldValue);\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    onThumbChange() {\n      this.toggleSliderIndicators();\n    }\n    /**\n     * @hidden\n     */\n\n\n    onHoverChange(state) {\n      return state ? this.showSliderIndicators() : this.hideSliderIndicators();\n    }\n\n    setValue(value, triggerChange) {\n      let res;\n\n      if (!this.isRange) {\n        this.upperValue = value - value % this.step;\n        res = this.upperValue;\n      } else {\n        value = this.validateInitialValue(value);\n        this.upperValue = value.upper;\n        this.lowerValue = value.lower;\n        res = {\n          lower: this.lowerValue,\n          upper: this.upperValue\n        };\n      }\n\n      if (triggerChange) {\n        this._onChangeCallback(res);\n      }\n    }\n\n    swapThumb(value) {\n      if (this.thumbFrom.isActive) {\n        value.upper = this.upperValue;\n        value.lower = this.upperValue;\n      } else {\n        value.upper = this.lowerValue;\n        value.lower = this.lowerValue;\n      }\n\n      this.toggleThumb();\n      return value;\n    }\n\n    findClosestThumb(event) {\n      if (this.isRange) {\n        this.closestHandle(event);\n      } else {\n        this.thumbTo.nativeElement.focus();\n      }\n\n      this.update(event.clientX);\n    }\n\n    updateLowerBoundAndMinTravelZone() {\n      this.lowerBound = this.minValue;\n      this._pMin = 0;\n    }\n\n    updateUpperBoundAndMaxTravelZone() {\n      this.upperBound = this.maxValue;\n      this._pMax = 1;\n    }\n\n    sliderSetup() {\n      /**\n       * if {@link SliderType.SLIDER} than the initial value shold be the lowest one.\n       */\n      if (!this.isRange && this._upperValue === undefined) {\n        this._upperValue = this.lowerBound;\n      }\n    }\n\n    calculateStepDistance() {\n      return this._el.nativeElement.getBoundingClientRect().width / (this.maxValue - this.minValue) * this.step;\n    }\n\n    toggleThumb() {\n      return this.thumbFrom.isActive ? this.thumbTo.nativeElement.focus() : this.thumbFrom.nativeElement.focus();\n    }\n\n    valueInRange(value, min = 0, max = 100) {\n      return Math.max(Math.min(value, max), min);\n    }\n\n    generateTickMarks(color, interval) {\n      return interval !== null ? `repeating-linear-gradient(\n            ${'to left'},\n            ${color},\n            ${color} 1.5px,\n            transparent 1.5px,\n            transparent ${interval}%\n        ), repeating-linear-gradient(\n            ${'to right'},\n            ${color},\n            ${color} 1.5px,\n            transparent 1.5px,\n            transparent ${interval}%\n        )` : interval;\n    }\n\n    positionHandler(thumbHandle, labelHandle, position) {\n      const percent = `${this.valueToFraction(position) * 100}%`;\n      const dir = this._dir.rtl ? 'right' : 'left';\n\n      if (thumbHandle) {\n        thumbHandle.nativeElement.style[dir] = percent;\n      }\n\n      if (labelHandle) {\n        labelHandle.nativeElement.style[dir] = percent;\n      }\n    }\n\n    positionHandlersAndUpdateTrack() {\n      if (!this.isRange) {\n        this.positionHandler(this.thumbTo, this.labelTo, this.value);\n      } else {\n        this.positionHandler(this.thumbTo, this.labelTo, this.value.upper);\n        this.positionHandler(this.thumbFrom, this.labelFrom, this.value.lower);\n      }\n\n      if (this._hasViewInit) {\n        this.updateTrack();\n      }\n    }\n\n    closestHandle(event) {\n      const fromOffset = this.thumbFrom.nativeElement.offsetLeft + this.thumbFrom.nativeElement.offsetWidth / 2;\n      const toOffset = this.thumbTo.nativeElement.offsetLeft + this.thumbTo.nativeElement.offsetWidth / 2;\n\n      const xPointer = event.clientX - this._el.nativeElement.getBoundingClientRect().left;\n\n      const match = this.closestTo(xPointer, [fromOffset, toOffset]);\n\n      if (fromOffset === toOffset && toOffset < xPointer) {\n        this.thumbTo.nativeElement.focus();\n      } else if (fromOffset === toOffset && toOffset > xPointer) {\n        this.thumbFrom.nativeElement.focus();\n      } else if (match === fromOffset) {\n        this.thumbFrom.nativeElement.focus();\n      } else {\n        this.thumbTo.nativeElement.focus();\n      }\n    }\n\n    setTickInterval() {\n      let interval;\n      const trackProgress = 100;\n\n      if (this.labelsViewEnabled) {\n        // Calc ticks depending on the labels length;\n        interval = trackProgress / (this.labels.length - 1) * 10 / 10;\n      } else {\n        const trackRange = this.maxValue - this.minValue;\n        interval = this.step > 1 ? trackProgress / (trackRange / this.step) * 10 / 10 : null;\n      }\n\n      const renderCallbackExecution = !this.continuous ? this.generateTickMarks('var(--igx-slider-track-step-color, var(--track-step-color, white))', interval) : null;\n      this.renderer.setStyle(this.ticks.nativeElement, 'background', renderCallbackExecution);\n    }\n\n    showSliderIndicators() {\n      if (this.disabled) {\n        return;\n      }\n\n      if (this._indicatorsTimer) {\n        this._indicatorsDestroyer$.next(true);\n\n        this._indicatorsTimer = null;\n      }\n\n      this.thumbTo.showThumbIndicators();\n      this.labelTo.active = true;\n\n      if (this.thumbFrom) {\n        this.thumbFrom.showThumbIndicators();\n      }\n\n      if (this.labelFrom) {\n        this.labelFrom.active = true;\n      }\n    }\n\n    hideSliderIndicators() {\n      if (this.disabled) {\n        return;\n      }\n\n      this._indicatorsTimer = timer(this.thumbLabelVisibilityDuration);\n\n      this._indicatorsTimer.pipe(takeUntil(this._indicatorsDestroyer$)).subscribe(() => {\n        this.thumbTo.hideThumbIndicators();\n        this.labelTo.active = false;\n\n        if (this.thumbFrom) {\n          this.thumbFrom.hideThumbIndicators();\n        }\n\n        if (this.labelFrom) {\n          this.labelFrom.active = false;\n        }\n      });\n    }\n\n    toggleSliderIndicators() {\n      this.showSliderIndicators();\n      this.hideSliderIndicators();\n    }\n\n    changeThumbFocusableState(state) {\n      const value = state ? -1 : 1;\n\n      if (this.isRange) {\n        this.thumbFrom.tabindex = value;\n      }\n\n      this.thumbTo.tabindex = value;\n\n      this._cdr.detectChanges();\n    }\n\n    closestTo(goal, positions) {\n      return positions.reduce((previous, current) => Math.abs(goal - current) < Math.abs(goal - previous) ? current : previous);\n    }\n\n    valueToFraction(value, pMin = this._pMin, pMax = this._pMax) {\n      return this.valueInRange((value - this.minValue) / (this.maxValue - this.minValue), pMin, pMax);\n    }\n    /**\n     * @hidden\n     * Normalizе the value when two-way data bind is used and {@link this.step} is set.\n     * @param value\n     */\n\n\n    normalizeByStep(value) {\n      if (this.isRange) {\n        this._value = {\n          lower: value.lower - value.lower % this.step,\n          upper: value.upper - value.upper % this.step\n        };\n      } else {\n        this._value = value - value % this.step;\n      }\n    }\n\n    updateTrack() {\n      const fromPosition = this.valueToFraction(this.lowerValue);\n      const toPosition = this.valueToFraction(this.upperValue);\n      const positionGap = toPosition - fromPosition;\n      let trackLeftIndention = fromPosition;\n\n      if (this.isRange) {\n        if (positionGap) {\n          trackLeftIndention = Math.round(1 / positionGap * fromPosition * 100);\n        }\n\n        trackLeftIndention = this._dir.rtl ? -trackLeftIndention : trackLeftIndention;\n        this.renderer.setStyle(this.trackRef.nativeElement, 'transform', `scaleX(${positionGap}) translateX(${trackLeftIndention}%)`);\n      } else {\n        this.renderer.setStyle(this.trackRef.nativeElement, 'transform', `scaleX(${toPosition})`);\n      }\n    }\n\n    validateInitialValue(value) {\n      if (value.lower < this.lowerBound && value.upper < this.lowerBound) {\n        value.upper = this.lowerBound;\n        value.lower = this.lowerBound;\n      }\n\n      if (value.lower > this.upperBound && value.upper > this.upperBound) {\n        value.upper = this.upperBound;\n        value.lower = this.upperBound;\n      }\n\n      if (value.upper < value.lower) {\n        value.upper = this.upperValue;\n        value.lower = this.lowerValue;\n      }\n\n      return value;\n    }\n\n    subscribeTo(thumb, callback) {\n      if (!thumb) {\n        return;\n      }\n\n      thumb.thumbValueChange.pipe(takeUntil(this.unsubscriber(thumb))).subscribe(value => callback(value, thumb.type));\n    }\n\n    unsubscriber(thumb) {\n      return merge(this._destroyer$, thumb.destroy);\n    }\n\n    hasValueChanged(oldValue) {\n      const isSliderWithDifferentValue = !this.isRange && oldValue !== this.value;\n      const isRangeWithOneDifferentValue = this.isRange && (oldValue.lower !== this.value.lower || oldValue.upper !== this.value.upper);\n      return isSliderWithDifferentValue || isRangeWithOneDifferentValue;\n    }\n\n    emitValueChange(oldValue) {\n      this.valueChange.emit({\n        oldValue,\n        value: this.value\n      });\n    }\n\n  }\n\n  IgxSliderComponent.ɵfac = function IgxSliderComponent_Factory(t) {\n    return new (t || IgxSliderComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(IgxDirectionality), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxSliderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxSliderComponent,\n    selectors: [[\"igx-slider\"]],\n    contentQueries: function IgxSliderComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxThumbFromTemplateDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxThumbToTemplateDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxTickLabelTemplateDirective, 5, TemplateRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.thumbFromTemplateRef = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.thumbToTemplateRef = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tickLabelTemplateRef = _t.first);\n      }\n    },\n    viewQuery: function IgxSliderComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c256, 7);\n        i0.ɵɵviewQuery(_c257, 7);\n        i0.ɵɵviewQuery(IgxSliderThumbComponent, 5);\n        i0.ɵɵviewQuery(IgxThumbLabelComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.trackRef = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.ticks = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.thumbs = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.labelRefs = _t);\n      }\n    },\n    hostVars: 9,\n    hostBindings: function IgxSliderComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"pointerdown\", function IgxSliderComponent_pointerdown_HostBindingHandler($event) {\n          return ctx.onPointerDown($event);\n        })(\"pointerup\", function IgxSliderComponent_pointerup_HostBindingHandler($event) {\n          return ctx.onPointerUp($event);\n        })(\"focus\", function IgxSliderComponent_focus_HostBindingHandler() {\n          return ctx.onFocus();\n        })(\"pan\", function IgxSliderComponent_pan_HostBindingHandler($event) {\n          return ctx.onPanListener($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"id\", ctx.id)(\"aria-valuemin\", ctx.valuemin)(\"aria-valuemax\", ctx.valuemax)(\"aria-readonly\", ctx.readonly);\n        i0.ɵɵclassProp(\"igx-slider\", ctx.slierClass)(\"igx-slider--disabled\", ctx.disabledClass);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      thumbLabelVisibilityDuration: \"thumbLabelVisibilityDuration\",\n      type: \"type\",\n      labels: \"labels\",\n      step: \"step\",\n      disabled: \"disabled\",\n      continuous: \"continuous\",\n      minValue: \"minValue\",\n      maxValue: \"maxValue\",\n      lowerBound: \"lowerBound\",\n      upperBound: \"upperBound\",\n      value: \"value\",\n      primaryTicks: \"primaryTicks\",\n      secondaryTicks: \"secondaryTicks\",\n      showTicks: \"showTicks\",\n      primaryTickLabels: \"primaryTickLabels\",\n      secondaryTickLabels: \"secondaryTickLabels\",\n      ticksOrientation: \"ticksOrientation\",\n      tickLabelsOrientation: \"tickLabelsOrientation\"\n    },\n    outputs: {\n      valueChange: \"valueChange\",\n      dragFinished: \"dragFinished\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: IgxSliderComponent,\n      multi: true\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 13,\n    vars: 20,\n    consts: [[1, \"igx-slider__track\"], [\"ticksOrientation\", \"top\", 3, \"primaryTicks\", \"secondaryTicks\", \"primaryTickLabels\", \"secondaryTickLabels\", \"tickLabelsOrientation\", \"labelsViewEnabled\", \"labels\", \"tickLabelTemplateRef\", \"minValue\", \"maxValue\", 4, \"ngIf\"], [1, \"igx-slider__track-fill\"], [\"track\", \"\"], [1, \"igx-slider__track-steps\"], [\"ticks\", \"\"], [\"ticksOrientation\", \"bottom\", 3, \"primaryTicks\", \"secondaryTicks\", \"primaryTickLabels\", \"secondaryTickLabels\", \"tickLabelsOrientation\", \"labelsViewEnabled\", \"labels\", \"tickLabelTemplateRef\", \"minValue\", \"maxValue\", 4, \"ngIf\"], [1, \"igx-slider__thumbs\"], [\"type\", \"from\", 3, \"value\", \"templateRef\", \"continuous\", \"context\", \"deactiveState\", \"thumb\", 4, \"ngIf\"], [\"type\", \"from\", 3, \"value\", \"disabled\", \"continuous\", \"onPan\", \"stepDistance\", \"step\", \"templateRef\", \"context\", \"deactiveState\", \"thumbLabelVisibilityDuration\", \"thumbChange\", \"hoverChange\", 4, \"ngIf\"], [\"type\", \"to\", 3, \"value\", \"templateRef\", \"continuous\", \"context\", \"deactiveState\", \"thumb\"], [\"type\", \"to\", 3, \"value\", \"disabled\", \"continuous\", \"onPan\", \"stepDistance\", \"step\", \"templateRef\", \"context\", \"deactiveState\", \"thumbLabelVisibilityDuration\", \"thumbChange\", \"hoverChange\"], [\"thumbTo\", \"\"], [\"ticksOrientation\", \"top\", 3, \"primaryTicks\", \"secondaryTicks\", \"primaryTickLabels\", \"secondaryTickLabels\", \"tickLabelsOrientation\", \"labelsViewEnabled\", \"labels\", \"tickLabelTemplateRef\", \"minValue\", \"maxValue\"], [\"ticksOrientation\", \"bottom\", 3, \"primaryTicks\", \"secondaryTicks\", \"primaryTickLabels\", \"secondaryTickLabels\", \"tickLabelsOrientation\", \"labelsViewEnabled\", \"labels\", \"tickLabelTemplateRef\", \"minValue\", \"maxValue\"], [\"type\", \"from\", 3, \"value\", \"templateRef\", \"continuous\", \"context\", \"deactiveState\", \"thumb\"], [\"type\", \"from\", 3, \"value\", \"disabled\", \"continuous\", \"onPan\", \"stepDistance\", \"step\", \"templateRef\", \"context\", \"deactiveState\", \"thumbLabelVisibilityDuration\", \"thumbChange\", \"hoverChange\"], [\"thumbFrom\", \"\"]],\n    template: function IgxSliderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵtemplate(1, IgxSliderComponent_igx_ticks_1_Template, 2, 13, \"igx-ticks\", 1);\n        i0.ɵɵelement(2, \"div\", 2, 3)(4, \"div\", 4, 5);\n        i0.ɵɵtemplate(6, IgxSliderComponent_igx_ticks_6_Template, 2, 13, \"igx-ticks\", 6);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(7, \"div\", 7);\n        i0.ɵɵtemplate(8, IgxSliderComponent_igx_thumb_label_8_Template, 1, 6, \"igx-thumb-label\", 8);\n        i0.ɵɵtemplate(9, IgxSliderComponent_igx_thumb_9_Template, 2, 10, \"igx-thumb\", 9);\n        i0.ɵɵelement(10, \"igx-thumb-label\", 10);\n        i0.ɵɵelementStart(11, \"igx-thumb\", 11, 12);\n        i0.ɵɵlistener(\"thumbChange\", function IgxSliderComponent_Template_igx_thumb_thumbChange_11_listener() {\n          return ctx.onThumbChange();\n        })(\"hoverChange\", function IgxSliderComponent_Template_igx_thumb_hoverChange_11_listener($event) {\n          return ctx.onHoverChange($event);\n        });\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        const _r6 = i0.ɵɵreference(12);\n\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showTicks && ctx.showTopTicks);\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"ngIf\", ctx.showTicks && ctx.showBottomTicks);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.isRange);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isRange);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"value\", ctx.upperLabel)(\"templateRef\", ctx.thumbToTemplateRef)(\"continuous\", ctx.continuous)(\"context\", ctx.context)(\"deactiveState\", ctx.deactivateThumbLabel)(\"thumb\", _r6);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"value\", ctx.upperLabel)(\"disabled\", ctx.disabled)(\"continuous\", ctx.continuous)(\"onPan\", ctx.onPan)(\"stepDistance\", ctx.stepDistance)(\"step\", ctx.step)(\"templateRef\", ctx.thumbToTemplateRef)(\"context\", ctx.context)(\"deactiveState\", ctx.deactivateThumbLabel)(\"thumbLabelVisibilityDuration\", ctx.thumbLabelVisibilityDuration);\n      }\n    },\n    directives: function () {\n      return [IgxTicksComponent, IgxThumbLabelComponent, IgxSliderThumbComponent, i4.NgIf];\n    },\n    pipes: function () {\n      return [IgxTickLabelsPipe];\n    },\n    encapsulation: 2\n  });\n  return IgxSliderComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxSliderModule = /*#__PURE__*/(() => {\n  class IgxSliderModule {}\n\n  IgxSliderModule.ɵfac = function IgxSliderModule_Factory(t) {\n    return new (t || IgxSliderModule)();\n  };\n\n  IgxSliderModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxSliderModule\n  });\n  IgxSliderModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, FormsModule]]\n  });\n  return IgxSliderModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst SwitchLabelPosition = mkenum({\n  BEFORE: 'before',\n  AFTER: 'after'\n});\nlet nextId = 0;\n/**\n *\n * The Switch component is a binary choice selection component.\n *\n * @igxModule IgxSwitchModule\n *\n * @igxTheme igx-switch-theme, igx-tooltip-theme\n *\n * @igxKeywords switch, states, tooltip\n *\n * @igxGroup Data Entry & Display\n *\n * @remarks\n *\n * The Ignite UI Switch lets the user toggle between on/off or true/false states.\n *\n * @example\n * ```html\n * <igx-switch [checked]=\"true\">\n *   Simple switch\n * </igx-switch>\n * ```\n */\n\nlet IgxSwitchComponent = /*#__PURE__*/(() => {\n  class IgxSwitchComponent {\n    constructor() {\n      /**\n       * Sets/gets the `id` of the switch component.\n       * If not set, the `id` of the first switch component will be `\"igx-switch-0\"`.\n       *\n       * @example\n       * ```html\n       * <igx-switch id=\"my-first-switch\"></igx-switch>\n       * ```\n       */\n      this.id = `igx-switch-${nextId++}`;\n      /**\n       * Sets/gets the id of the `label` element of the switch component.\n       * If not set, the label of the first switch component will have value `\"igx-switch-0-label\"`.\n       *\n       * @example\n       * ```html\n       * <igx-switch labelId=\"Label1\"></igx-switch>\n       * ```\n       */\n\n      this.labelId = `${this.id}-label`;\n      /**\n       * Sets/gets the value of the `tabindex` attribute.\n       *\n       * @example\n       * ```html\n       * <igx-switch [tabindex]=\"1\"></igx-switch>\n       * ```\n       */\n\n      this.tabindex = null;\n      /**\n       * Sets/gets the position of the `label` in the switch component.\n       * If not set, `labelPosition` will have value `\"after\"`.\n       *\n       * @example\n       * ```html\n       * <igx-switch labelPosition=\"before\"></igx-switch>\n       * ```\n       */\n\n      this.labelPosition = 'after';\n      /**\n       * Enables/Disables the ripple effect\n       * If not set, `disableRipple` will have value `false`.\n       *\n       * @example\n       * ```html\n       * <igx-switch [disableRipple]=\"true\"></igx-switch>\n       * ```\n       */\n\n      this.disableRipple = false;\n      /**\n       * Sets/gets the `aria-labelledBy` attribute.\n       * If not set, the  value of `aria-labelledBy` will be equal to the value of `labelId` attribute.\n       *\n       * @example\n       * ```html\n       * <igx-switch aria-labelledby = \"Label1\"></igx-switch>\n       * ```\n       */\n\n      this.ariaLabelledBy = this.labelId;\n      /**\n       * Sets/gets the value of the `aria-label` attribute.\n       *\n       * @example\n       * ```html\n       * <igx-switch aria-label=\"Label1\"></igx-switch>\n       * ```\n       */\n\n      this.ariaLabel = null;\n      /**\n       * An event that is emitted after the switch state is changed.\n       * Provides references to the `IgxSwitchComponent` and the `checked` property as event arguments.\n       */\n      // eslint-disable-next-line @angular-eslint/no-output-native\n\n      this.change = new EventEmitter();\n      /**\n       * Returns the class of the switch component.\n       *\n       * @example\n       * ```typescript\n       * let switchClass = this.switch.cssClass;\n       * ```\n       */\n\n      this.cssClass = 'igx-switch';\n      /**\n       * Sets/gets whether the switch component is on focus.\n       * Default value is `false`.\n       *\n       * @example\n       * ```typescript\n       * this.switch.focused = true;\n       * ```\n       */\n\n      this.focused = false;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this.inputId = `${this.id}-input`;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this._checked = false;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this._required = false;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this._disabled = false;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this._onTouchedCallback = noop;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this._onChangeCallback = noop;\n    }\n    /**\n     * Sets/gets whether switch is required.\n     * If not set, `required` will have value `false`.\n     *\n     * @example\n     * ```html\n     * <igx-switch required></igx-switch>\n     * ```\n     */\n\n\n    get required() {\n      return this._required;\n    }\n\n    set required(value) {\n      this._required = value === '' || value;\n    }\n    /**\n     * Sets/gets whether the switch is on or off.\n     * Default value is 'false'.\n     *\n     * @example\n     * ```html\n     *  <igx-switch [checked]=\"true\"></igx-switch>\n     * ```\n     */\n\n\n    set checked(value) {\n      if (this._checked !== value) {\n        this._checked = value;\n\n        this._onChangeCallback(this.checked);\n      }\n    }\n\n    get checked() {\n      return this._checked;\n    }\n    /**\n     * Sets/gets the `disabled` attribute.\n     * Default value is `false`.\n     *\n     * @example\n     * ```html\n     * <igx-switch disabled><igx-switch>\n     * ```\n     */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n\n    set disabled(value) {\n      this._disabled = value === '' || value;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onKeyUp(event) {\n      event.stopPropagation();\n      this.focused = true;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    _onSwitchClick() {\n      if (this.disabled) {\n        return;\n      }\n\n      this.nativeCheckbox.nativeElement.focus();\n      this.checked = !this.checked; // K.D. March 23, 2021 Emitting on click and not on the setter because otherwise every component\n      // bound on change would have to perform self checks for weather the value has changed because\n      // of the initial set on initialization\n\n      this.change.emit({\n        checked: this.checked,\n        switch: this\n      });\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    _onSwitchChange(event) {\n      event.stopPropagation();\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onBlur() {\n      this.focused = false;\n\n      this._onTouchedCallback();\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    writeValue(value) {\n      this._checked = value;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    getEditElement() {\n      return this.nativeCheckbox.nativeElement;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get labelClass() {\n      switch (this.labelPosition) {\n        case SwitchLabelPosition.BEFORE:\n          return `${this.cssClass}__label--before`;\n\n        case SwitchLabelPosition.AFTER:\n        default:\n          return `${this.cssClass}__label`;\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    registerOnChange(fn) {\n      this._onChangeCallback = fn;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    registerOnTouched(fn) {\n      this._onTouchedCallback = fn;\n    }\n    /** @hidden @internal */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n\n  }\n\n  IgxSwitchComponent.ɵfac = function IgxSwitchComponent_Factory(t) {\n    return new (t || IgxSwitchComponent)();\n  };\n\n  IgxSwitchComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxSwitchComponent,\n    selectors: [[\"igx-switch\"]],\n    viewQuery: function IgxSwitchComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c19, 7);\n        i0.ɵɵviewQuery(_c20, 7);\n        i0.ɵɵviewQuery(_c17, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nativeCheckbox = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nativeLabel = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.placeholderLabel = _t.first);\n      }\n    },\n    hostVars: 9,\n    hostBindings: function IgxSwitchComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keyup\", function IgxSwitchComponent_keyup_HostBindingHandler($event) {\n          return ctx.onKeyUp($event);\n        })(\"click\", function IgxSwitchComponent_click_HostBindingHandler() {\n          return ctx._onSwitchClick();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id);\n        i0.ɵɵclassProp(\"igx-switch\", ctx.cssClass)(\"igx-switch--checked\", ctx.checked)(\"igx-switch--disabled\", ctx.disabled)(\"igx-switch--focused\", ctx.focused);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      labelId: \"labelId\",\n      value: \"value\",\n      name: \"name\",\n      tabindex: \"tabindex\",\n      labelPosition: \"labelPosition\",\n      disableRipple: \"disableRipple\",\n      required: \"required\",\n      ariaLabelledBy: [\"aria-labelledby\", \"ariaLabelledBy\"],\n      ariaLabel: [\"aria-label\", \"ariaLabel\"],\n      checked: \"checked\",\n      disabled: \"disabled\"\n    },\n    outputs: {\n      change: \"change\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: IgxSwitchComponent,\n      multi: true\n    }])],\n    ngContentSelectors: _c8,\n    decls: 9,\n    vars: 16,\n    consts: [[\"type\", \"checkbox\", 1, \"igx-switch__input\", 3, \"id\", \"name\", \"value\", \"tabindex\", \"disabled\", \"checked\", \"required\", \"change\", \"blur\"], [\"checkbox\", \"\"], [\"igxRipple\", \"\", \"igxRippleTarget\", \".igx-switch__ripple\", 1, \"igx-switch__composite\", 3, \"igxRippleDisabled\", \"igxRippleCentered\", \"igxRippleDuration\"], [\"label\", \"\"], [1, \"igx-switch__composite-thumb\"], [1, \"igx-switch__ripple\"], [3, \"id\"], [\"placeholderLabel\", \"\"]],\n    template: function IgxSwitchComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"input\", 0, 1);\n        i0.ɵɵlistener(\"change\", function IgxSwitchComponent_Template_input_change_0_listener($event) {\n          return ctx._onSwitchChange($event);\n        })(\"blur\", function IgxSwitchComponent_Template_input_blur_0_listener() {\n          return ctx.onBlur();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(2, \"span\", 2, 3)(4, \"div\", 4);\n        i0.ɵɵelement(5, \"div\", 5);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(6, \"span\", 6, 7);\n        i0.ɵɵprojection(8);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"id\", ctx.inputId)(\"name\", ctx.name)(\"value\", ctx.value)(\"tabindex\", ctx.tabindex)(\"disabled\", ctx.disabled)(\"checked\", ctx.checked)(\"required\", ctx.required);\n        i0.ɵɵattribute(\"aria-checked\", ctx.checked)(\"aria-labelledby\", ctx.ariaLabel ? null : ctx.ariaLabelledBy)(\"aria-label\", ctx.ariaLabel);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"igxRippleDisabled\", ctx.disableRipple)(\"igxRippleCentered\", true)(\"igxRippleDuration\", 300);\n        i0.ɵɵadvance(4);\n        i0.ɵɵclassMap(ctx.labelClass);\n        i0.ɵɵproperty(\"id\", ctx.labelId);\n      }\n    },\n    directives: [IgxRippleDirective],\n    encapsulation: 2\n  });\n  return IgxSwitchComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst IGX_SWITCH_REQUIRED_VALIDATOR = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => IgxSwitchRequiredDirective),\n  multi: true\n};\n/* eslint-disable  @angular-eslint/directive-selector */\n\nlet IgxSwitchRequiredDirective = /*#__PURE__*/(() => {\n  class IgxSwitchRequiredDirective extends CheckboxRequiredValidator {}\n\n  IgxSwitchRequiredDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxSwitchRequiredDirective_BaseFactory;\n    return function IgxSwitchRequiredDirective_Factory(t) {\n      return (ɵIgxSwitchRequiredDirective_BaseFactory || (ɵIgxSwitchRequiredDirective_BaseFactory = i0.ɵɵgetInheritedFactory(IgxSwitchRequiredDirective)))(t || IgxSwitchRequiredDirective);\n    };\n  }();\n\n  IgxSwitchRequiredDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxSwitchRequiredDirective,\n    selectors: [[\"igx-switch\", \"required\", \"\", \"formControlName\", \"\"], [\"igx-switch\", \"required\", \"\", \"formControl\", \"\"], [\"igx-switch\", \"required\", \"\", \"ngModel\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([IGX_SWITCH_REQUIRED_VALIDATOR]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return IgxSwitchRequiredDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxSwitchModule = /*#__PURE__*/(() => {\n  class IgxSwitchModule {}\n\n  IgxSwitchModule.ɵfac = function IgxSwitchModule_Factory(t) {\n    return new (t || IgxSwitchModule)();\n  };\n\n  IgxSwitchModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxSwitchModule\n  });\n  IgxSwitchModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[IgxRippleModule]]\n  });\n  return IgxSwitchModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nclass IgxTabsBase {}\n/** @hidden */\n\n\nclass IgxTabItemBase {}\n/** @hidden */\n\n\nclass IgxTabHeaderBase {}\n/** @hidden */\n\n\nclass IgxTabContentBase {}\n\nlet IgxTabItemDirective = /*#__PURE__*/(() => {\n  class IgxTabItemDirective {\n    /** @hidden */\n    constructor(tabs) {\n      this.tabs = tabs;\n      /**\n       * Output to enable support for two-way binding on [(selected)]\n       */\n\n      this.selectedChange = new EventEmitter();\n      /**\n       * An @Input property that allows you to enable/disable the item.\n       */\n\n      this.disabled = false;\n      /** @hidden */\n\n      this.direction = Direction.NONE;\n      this._selected = false;\n    }\n    /**\n     * An @Input property which determines whether an item is selected.\n     */\n\n\n    get selected() {\n      return this._selected;\n    }\n\n    set selected(value) {\n      if (this._selected !== value) {\n        this._selected = value;\n        this.tabs.selectTab(this, this._selected);\n        this.selectedChange.emit(this._selected);\n      }\n    }\n\n  }\n\n  IgxTabItemDirective.ɵfac = function IgxTabItemDirective_Factory(t) {\n    return new (t || IgxTabItemDirective)(i0.ɵɵdirectiveInject(IgxTabsBase));\n  };\n\n  IgxTabItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxTabItemDirective,\n    contentQueries: function IgxTabItemDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxTabHeaderBase, 5);\n        i0.ɵɵcontentQuery(dirIndex, IgxTabContentBase, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerComponent = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.panelComponent = _t.first);\n      }\n    },\n    viewQuery: function IgxTabItemDirective_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c258, 7);\n        i0.ɵɵviewQuery(_c259, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.panelTemplate = _t.first);\n      }\n    },\n    inputs: {\n      disabled: \"disabled\",\n      selected: \"selected\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\"\n    }\n  });\n  return IgxTabItemDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxTabHeaderDirective = /*#__PURE__*/(() => {\n  class IgxTabHeaderDirective {\n    /** @hidden */\n    constructor(tabs, tab, elementRef, platform) {\n      this.tabs = tabs;\n      this.tab = tab;\n      this.elementRef = elementRef;\n      this.platform = platform;\n      /** @hidden */\n\n      this.role = 'tab';\n    }\n    /** @hidden */\n\n\n    get tabIndex() {\n      return this.tab.selected ? 0 : -1;\n    }\n    /** @hidden */\n\n\n    get ariaSelected() {\n      return this.tab.selected;\n    }\n    /** @hidden */\n\n\n    get ariaDisabled() {\n      return this.tab.disabled;\n    }\n    /** @hidden */\n\n\n    onClick() {\n      if (this.tab.panelComponent) {\n        this.tabs.selectTab(this.tab, true);\n      }\n    }\n    /** @hidden */\n\n\n    get nativeElement() {\n      return this.elementRef.nativeElement;\n    }\n\n  }\n\n  IgxTabHeaderDirective.ɵfac = function IgxTabHeaderDirective_Factory(t) {\n    return new (t || IgxTabHeaderDirective)(i0.ɵɵdirectiveInject(IgxTabsBase), i0.ɵɵdirectiveInject(IgxTabItemDirective), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(PlatformUtil));\n  };\n\n  IgxTabHeaderDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxTabHeaderDirective,\n    hostVars: 4,\n    hostBindings: function IgxTabHeaderDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function IgxTabHeaderDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"tabindex\", ctx.tabIndex)(\"aria-selected\", ctx.ariaSelected)(\"aria-disabled\", ctx.ariaDisabled);\n      }\n    }\n  });\n  return IgxTabHeaderDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxTabContentDirective = /*#__PURE__*/(() => {\n  class IgxTabContentDirective {\n    /** @hidden */\n    constructor(tab, elementRef) {\n      this.tab = tab;\n      this.elementRef = elementRef;\n      /** @hidden */\n\n      this.role = 'tabpanel';\n    }\n    /** @hidden */\n\n\n    get tabIndex() {\n      return this.tab.selected ? 0 : -1;\n    }\n    /** @hidden */\n\n\n    get zIndex() {\n      return this.tab.selected ? 'auto' : -1;\n    }\n    /** @hidden */\n\n\n    get nativeElement() {\n      return this.elementRef.nativeElement;\n    }\n\n  }\n\n  IgxTabContentDirective.ɵfac = function IgxTabContentDirective_Factory(t) {\n    return new (t || IgxTabContentDirective)(i0.ɵɵdirectiveInject(IgxTabItemDirective), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxTabContentDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxTabContentDirective,\n    hostVars: 4,\n    hostBindings: function IgxTabContentDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"tabindex\", ctx.tabIndex);\n        i0.ɵɵstyleProp(\"z-index\", ctx.zIndex);\n      }\n    }\n  });\n  return IgxTabContentDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxTabsDirective = /*#__PURE__*/(() => {\n  class IgxTabsDirective extends IgxCarouselComponentBase {\n    /** @hidden */\n    constructor(builder, cdr, dir) {\n      super(builder, cdr);\n      this.dir = dir;\n      /**\n       * Output to enable support for two-way binding on [(selectedIndex)]\n       */\n\n      this.selectedIndexChange = new EventEmitter();\n      /**\n       * Emitted when the selected index is about to change.\n       */\n\n      this.selectedIndexChanging = new EventEmitter();\n      /**\n       * Emitted when the selected item is changed.\n       */\n\n      this.selectedItemChange = new EventEmitter();\n      /** @hidden */\n\n      this._disableAnimation = false;\n      this._selectedIndex = -1;\n    }\n    /**\n     * An @Input property that gets/sets the index of the selected item.\n     * Default value is 0 if contents are defined otherwise defaults to -1.\n     */\n\n\n    get selectedIndex() {\n      return this._selectedIndex;\n    }\n\n    set selectedIndex(value) {\n      if (this._selectedIndex !== value) {\n        let newIndex = value;\n        const oldIndex = this._selectedIndex;\n        const args = {\n          owner: this,\n          cancel: false,\n          oldIndex,\n          newIndex\n        };\n        this.selectedIndexChanging.emit(args);\n\n        if (!args.cancel) {\n          newIndex = args.newIndex;\n          this._selectedIndex = newIndex;\n          this.selectedIndexChange.emit(this._selectedIndex);\n        }\n\n        this.updateSelectedTabs(oldIndex);\n      }\n    }\n    /**\n     * Enables/disables the transition animation of the contents.\n     */\n\n\n    get disableAnimation() {\n      return this._disableAnimation;\n    }\n\n    set disableAnimation(value) {\n      this._disableAnimation = value;\n    }\n    /**\n     * Gets the selected item.\n     */\n\n\n    get selectedItem() {\n      return this.items && this.selectedIndex >= 0 && this.selectedIndex < this.items.length ? this.items.get(this.selectedIndex) : null;\n    }\n    /** @hidden */\n\n\n    ngAfterViewInit() {\n      if (this._selectedIndex === -1) {\n        const hasSelectedTab = this.items.some((tab, i) => {\n          if (tab.selected) {\n            this._selectedIndex = i;\n          }\n\n          return tab.selected;\n        });\n\n        if (!hasSelectedTab && this.hasPanels) {\n          this._selectedIndex = 0;\n        }\n      } // Use promise to avoid expression changed after check error\n\n\n      Promise.resolve().then(() => {\n        this.updateSelectedTabs(null, false);\n      });\n      this._itemChanges$ = this.items.changes.subscribe(() => {\n        this.onItemChanges();\n      });\n      this.setAttributes();\n    }\n    /** @hidden */\n\n\n    ngOnDestroy() {\n      if (this._itemChanges$) {\n        this._itemChanges$.unsubscribe();\n      }\n    }\n    /** @hidden */\n\n\n    selectTab(tab, selected) {\n      if (!this.items) {\n        return;\n      }\n\n      const tabs = this.items.toArray();\n\n      if (selected) {\n        const index = tabs.indexOf(tab);\n\n        if (index > -1) {\n          this.selectedIndex = index;\n        }\n      } else {\n        if (tabs.every(t => !t.selected)) {\n          this.selectedIndex = -1;\n        }\n      }\n    }\n    /** @hidden */\n\n\n    getPreviousElement() {\n      return this.previousItem.panelComponent.nativeElement;\n    }\n    /** @hidden */\n\n\n    getCurrentElement() {\n      return this.currentItem.panelComponent.nativeElement;\n    }\n    /** @hidden */\n\n\n    scrollTabHeaderIntoView() {}\n    /** @hidden */\n\n\n    onItemChanges() {\n      this.setAttributes(); // Check if there is selected tab\n\n      let selectedIndex = -1;\n      this.items.some((tab, i) => {\n        if (tab.selected) {\n          selectedIndex = i;\n        }\n\n        return tab.selected;\n      });\n\n      if (selectedIndex >= 0) {\n        // Set the selected index to the tab that has selected=true\n        Promise.resolve().then(() => {\n          this.selectedIndex = selectedIndex;\n        });\n      } else {\n        if (this.selectedIndex >= 0 && this.selectedIndex < this.items.length) {\n          // Select the tab on the same index the previous selected tab was\n          Promise.resolve().then(() => {\n            this.updateSelectedTabs(null);\n          });\n        } else if (this.selectedIndex >= this.items.length) {\n          // Select the last tab\n          Promise.resolve().then(() => {\n            this.selectedIndex = this.items.length - 1;\n          });\n        }\n      }\n    }\n\n    setAttributes() {\n      this.items.forEach(item => {\n        if (item.panelComponent && !item.headerComponent.nativeElement.getAttribute('id')) {\n          const id = this.getNextTabId();\n          const tabHeaderId = `${this.componentName}-header-${id}`;\n          const tabPanelId = `${this.componentName}-content-${id}`;\n          this.setHeaderAttribute(item, 'id', tabHeaderId);\n          this.setHeaderAttribute(item, 'aria-controls', tabPanelId);\n          this.setPanelAttribute(item, 'id', tabPanelId);\n          this.setPanelAttribute(item, 'aria-labelledby', tabHeaderId);\n        }\n      });\n    }\n\n    setHeaderAttribute(item, attrName, value) {\n      item.headerComponent.nativeElement.setAttribute(attrName, value);\n    }\n\n    setPanelAttribute(item, attrName, value) {\n      item.panelComponent.nativeElement.setAttribute(attrName, value);\n    }\n\n    get hasPanels() {\n      return this.panels && this.panels.length;\n    }\n\n    updateSelectedTabs(oldSelectedIndex, raiseEvent = true) {\n      if (!this.items) {\n        return;\n      }\n\n      let newTab;\n      const oldTab = this.currentItem; // First select the new tab\n\n      if (this._selectedIndex >= 0 && this._selectedIndex < this.items.length) {\n        newTab = this.items.get(this._selectedIndex);\n        newTab.selected = true;\n      } // Then unselect the other tabs\n\n\n      this.items.forEach((tab, i) => {\n        if (i !== this._selectedIndex) {\n          tab.selected = false;\n        }\n      });\n\n      if (this._selectedIndex !== oldSelectedIndex) {\n        this.scrollTabHeaderIntoView();\n        this.triggerPanelAnimations(oldSelectedIndex);\n\n        if (raiseEvent && newTab !== oldTab) {\n          this.selectedItemChange.emit({\n            owner: this,\n            newItem: newTab,\n            oldItem: oldTab\n          });\n        }\n      }\n    }\n\n    triggerPanelAnimations(oldSelectedIndex) {\n      const item = this.items.get(this._selectedIndex);\n\n      if (item && !this.disableAnimation && this.hasPanels && this.currentItem && !this.currentItem.selected) {\n        item.direction = !this.dir.rtl && this._selectedIndex > oldSelectedIndex || this.dir.rtl && this._selectedIndex < oldSelectedIndex ? Direction.NEXT : Direction.PREV;\n\n        if (this.previousItem && this.previousItem.previous) {\n          this.previousItem.previous = false;\n        }\n\n        this.currentItem.direction = item.direction;\n        this.previousItem = this.currentItem;\n        this.currentItem = item;\n        this.triggerAnimations();\n      } else {\n        this.currentItem = item;\n      }\n    }\n\n  }\n\n  IgxTabsDirective.ɵfac = function IgxTabsDirective_Factory(t) {\n    return new (t || IgxTabsDirective)(i0.ɵɵdirectiveInject(i1.AnimationBuilder), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(IgxDirectionality));\n  };\n\n  IgxTabsDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxTabsDirective,\n    contentQueries: function IgxTabsDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxTabItemDirective, 4);\n        i0.ɵɵcontentQuery(dirIndex, IgxTabContentBase, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.items = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.panels = _t);\n      }\n    },\n    inputs: {\n      selectedIndex: \"selectedIndex\",\n      disableAnimation: \"disableAnimation\"\n    },\n    outputs: {\n      selectedIndexChange: \"selectedIndexChange\",\n      selectedIndexChanging: \"selectedIndexChanging\",\n      selectedItemChange: \"selectedItemChange\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return IgxTabsDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet NEXT_BOTTOM_NAV_ITEM_ID = 0;\n/**\n * Bottom Navigation component enables the user to navigate among a number of contents displayed in a single view.\n *\n * @igxModule IgxBottomNavModule\n *\n * @igxTheme igx-bottom-nav-theme\n *\n * @igxKeywords bottom navigation\n *\n * @igxGroup Layouts\n *\n * @remarks\n * The Ignite UI for Angular Bottom Navigation component enables the user to navigate among a number of contents\n * displayed in a single view. The navigation through the contents is accomplished with the tab buttons located at bottom.\n *\n * @example\n * ```html\n * <igx-bottom-nav>\n *     <igx-bottom-nav-item>\n *         <igx-bottom-nav-header>\n *             <igx-icon igxBottomNavHeaderIcon>folder</igx-icon>\n *             <span igxBottomNavHeaderLabel>Tab 1</span>\n *         </igx-bottom-nav-header>\n *         <igx-bottom-nav-content>\n *             Content 1\n *         </igx-bottom-nav-content>\n *     </igx-bottom-nav-item>\n *     ...\n * </igx-bottom-nav>\n * ```\n */\n\nlet IgxBottomNavComponent = /*#__PURE__*/(() => {\n  class IgxBottomNavComponent extends IgxTabsDirective {\n    constructor() {\n      super(...arguments);\n      /** @hidden */\n\n      this._disableAnimation = true;\n      /** @hidden */\n\n      this.componentName = 'igx-bottom-nav';\n    }\n    /** @hidden */\n\n\n    getNextTabId() {\n      return NEXT_BOTTOM_NAV_ITEM_ID++;\n    }\n\n  }\n\n  IgxBottomNavComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxBottomNavComponent_BaseFactory;\n    return function IgxBottomNavComponent_Factory(t) {\n      return (ɵIgxBottomNavComponent_BaseFactory || (ɵIgxBottomNavComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxBottomNavComponent)))(t || IgxBottomNavComponent);\n    };\n  }();\n\n  IgxBottomNavComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxBottomNavComponent,\n    selectors: [[\"igx-bottom-nav\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxTabsBase,\n      useExisting: IgxBottomNavComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 4,\n    vars: 2,\n    consts: [[4, \"ngFor\", \"ngForOf\"], [\"role\", \"tablist\", \"aria-orientation\", \"horizontal\", 1, \"igx-bottom-nav__menu\", \"igx-bottom-nav__menu--bottom\"], [\"tablist\", \"\"], [4, \"ngTemplateOutlet\"]],\n    template: function IgxBottomNavComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxBottomNavComponent_ng_container_0_Template, 2, 1, \"ng-container\", 0);\n        i0.ɵɵelementStart(1, \"div\", 1, 2);\n        i0.ɵɵtemplate(3, IgxBottomNavComponent_ng_container_3_Template, 2, 1, \"ng-container\", 0);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.items);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngForOf\", ctx.items);\n      }\n    },\n    directives: [i4.NgForOf, i4.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return IgxBottomNavComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxBottomNavItemComponent = /*#__PURE__*/(() => {\n  class IgxBottomNavItemComponent extends IgxTabItemDirective {}\n\n  IgxBottomNavItemComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxBottomNavItemComponent_BaseFactory;\n    return function IgxBottomNavItemComponent_Factory(t) {\n      return (ɵIgxBottomNavItemComponent_BaseFactory || (ɵIgxBottomNavItemComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxBottomNavItemComponent)))(t || IgxBottomNavItemComponent);\n    };\n  }();\n\n  IgxBottomNavItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxBottomNavItemComponent,\n    selectors: [[\"igx-bottom-nav-item\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxTabItemDirective,\n      useExisting: IgxBottomNavItemComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c261,\n    decls: 4,\n    vars: 0,\n    consts: [[\"headerTemplate\", \"\"], [\"panelTemplate\", \"\"]],\n    template: function IgxBottomNavItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c260);\n        i0.ɵɵtemplate(0, IgxBottomNavItemComponent_ng_template_0_Template, 1, 0, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, IgxBottomNavItemComponent_ng_template_2_Template, 1, 0, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxBottomNavItemComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxBottomNavHeaderComponent = /*#__PURE__*/(() => {\n  class IgxBottomNavHeaderComponent extends IgxTabHeaderDirective {\n    /** @hidden */\n    get cssClassSelected() {\n      return this.tab.selected;\n    }\n    /** @hidden */\n\n\n    get cssClassDisabled() {\n      return this.tab.disabled;\n    }\n    /** @hidden */\n\n\n    get cssClass() {\n      return !this.tab.disabled && !this.tab.selected;\n    }\n\n  }\n\n  IgxBottomNavHeaderComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxBottomNavHeaderComponent_BaseFactory;\n    return function IgxBottomNavHeaderComponent_Factory(t) {\n      return (ɵIgxBottomNavHeaderComponent_BaseFactory || (ɵIgxBottomNavHeaderComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxBottomNavHeaderComponent)))(t || IgxBottomNavHeaderComponent);\n    };\n  }();\n\n  IgxBottomNavHeaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxBottomNavHeaderComponent,\n    selectors: [[\"igx-bottom-nav-header\"]],\n    hostVars: 6,\n    hostBindings: function IgxBottomNavHeaderComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-bottom-nav__menu-item--selected\", ctx.cssClassSelected)(\"igx-bottom-nav__menu-item--disabled\", ctx.cssClassDisabled)(\"igx-bottom-nav__menu-item\", ctx.cssClass);\n      }\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxTabHeaderBase,\n      useExisting: IgxBottomNavHeaderComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c8,\n    decls: 1,\n    vars: 0,\n    template: function IgxBottomNavHeaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxBottomNavHeaderComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxBottomNavHeaderLabelDirective = /*#__PURE__*/(() => {\n  class IgxBottomNavHeaderLabelDirective {}\n\n  IgxBottomNavHeaderLabelDirective.ɵfac = function IgxBottomNavHeaderLabelDirective_Factory(t) {\n    return new (t || IgxBottomNavHeaderLabelDirective)();\n  };\n\n  IgxBottomNavHeaderLabelDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxBottomNavHeaderLabelDirective,\n    selectors: [[\"igx-bottom-nav-header-label\"], [\"\", \"igxBottomNavHeaderLabel\", \"\"]]\n  });\n  return IgxBottomNavHeaderLabelDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxBottomNavHeaderIconDirective = /*#__PURE__*/(() => {\n  class IgxBottomNavHeaderIconDirective {}\n\n  IgxBottomNavHeaderIconDirective.ɵfac = function IgxBottomNavHeaderIconDirective_Factory(t) {\n    return new (t || IgxBottomNavHeaderIconDirective)();\n  };\n\n  IgxBottomNavHeaderIconDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxBottomNavHeaderIconDirective,\n    selectors: [[\"igx-bottom-nav-header-icon\"], [\"\", \"igxBottomNavHeaderIcon\", \"\"]]\n  });\n  return IgxBottomNavHeaderIconDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxBottomNavContentComponent = /*#__PURE__*/(() => {\n  class IgxBottomNavContentComponent extends IgxTabContentDirective {\n    constructor() {\n      super(...arguments);\n      /** @hidden */\n\n      this.defaultClass = true;\n    }\n\n  }\n\n  IgxBottomNavContentComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxBottomNavContentComponent_BaseFactory;\n    return function IgxBottomNavContentComponent_Factory(t) {\n      return (ɵIgxBottomNavContentComponent_BaseFactory || (ɵIgxBottomNavContentComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxBottomNavContentComponent)))(t || IgxBottomNavContentComponent);\n    };\n  }();\n\n  IgxBottomNavContentComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxBottomNavContentComponent,\n    selectors: [[\"igx-bottom-nav-content\"]],\n    hostVars: 2,\n    hostBindings: function IgxBottomNavContentComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-bottom-nav__panel\", ctx.defaultClass);\n      }\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxTabContentBase,\n      useExisting: IgxBottomNavContentComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c8,\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngIf\"]],\n    template: function IgxBottomNavContentComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, IgxBottomNavContentComponent_ng_content_0_Template, 1, 0, \"ng-content\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.tab.selected || ctx.tab.previous);\n      }\n    },\n    directives: [i4.NgIf],\n    encapsulation: 2\n  });\n  return IgxBottomNavContentComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxBottomNavModule = /*#__PURE__*/(() => {\n  class IgxBottomNavModule {}\n\n  IgxBottomNavModule.ɵfac = function IgxBottomNavModule_Factory(t) {\n    return new (t || IgxBottomNavModule)();\n  };\n\n  IgxBottomNavModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxBottomNavModule\n  });\n  IgxBottomNavModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, IgxIconModule, IgxRippleModule]]\n  });\n  return IgxBottomNavModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst IgxTabsAlignment = mkenum({\n  start: 'start',\n  end: 'end',\n  center: 'center',\n  justify: 'justify'\n});\n/** @hidden */\n\nvar TabScrollButtonStyle = /*#__PURE__*/(() => {\n  (function (TabScrollButtonStyle) {\n    TabScrollButtonStyle[\"Visible\"] = \"visible\";\n    TabScrollButtonStyle[\"Hidden\"] = \"hidden\";\n    TabScrollButtonStyle[\"NotDisplayed\"] = \"not_displayed\";\n  })(TabScrollButtonStyle || (TabScrollButtonStyle = {}));\n\n  return TabScrollButtonStyle;\n})();\n\n/** @hidden */\nlet NEXT_TAB_ID = 0;\n/**\n * Tabs component is used to organize or switch between similar data sets.\n *\n * @igxModule IgxTabsModule\n *\n * @igxTheme igx-tabs-theme\n *\n * @igxKeywords tabs\n *\n * @igxGroup Layouts\n *\n * @remarks\n * The Ignite UI for Angular Tabs component places tabs at the top and allows for scrolling when there are multiple tab items on the screen.\n *\n * @example\n * ```html\n * <igx-tabs>\n *     <igx-tab-item>\n *         <igx-tab-header>\n *             <igx-icon igxTabHeaderIcon>folder</igx-icon>\n *             <span igxTabHeaderLabel>Tab 1</span>\n *         </igx-tab-header>\n *         <igx-tab-content>\n *             Content 1\n *         </igx-tab-content>\n *     </igx-tab-item>\n *     ...\n * </igx-tabs>\n * ```\n */\n\nlet IgxTabsComponent = /*#__PURE__*/(() => {\n  class IgxTabsComponent extends IgxTabsDirective {\n    constructor(builder, cdr, ngZone, dir) {\n      super(builder, cdr, dir);\n      this.ngZone = ngZone;\n      this.dir = dir;\n      /** @hidden */\n\n      this.defaultClass = true;\n      /**  @hidden */\n\n      this.offset = 0;\n      /** @hidden */\n\n      this.componentName = 'igx-tabs';\n      this._tabAlignment = 'start';\n    }\n    /**\n     * An @Input property which determines the tab alignment. Defaults to `start`.\n     */\n\n\n    get tabAlignment() {\n      return this._tabAlignment;\n    }\n\n    set tabAlignment(value) {\n      this._tabAlignment = value;\n      requestAnimationFrame(() => {\n        this.updateScrollButtons();\n        this.realignSelectedIndicator();\n      });\n    }\n    /** @hidden @internal */\n\n\n    ngAfterViewInit() {\n      super.ngAfterViewInit();\n      this.ngZone.runOutsideAngular(() => {\n        this._resizeObserver = new (getResizeObserver())(() => {\n          this.updateScrollButtons();\n          this.realignSelectedIndicator();\n        });\n\n        this._resizeObserver.observe(this.headerContainer.nativeElement);\n\n        this._resizeObserver.observe(this.viewPort.nativeElement);\n      });\n    }\n    /** @hidden @internal */\n\n\n    ngOnDestroy() {\n      super.ngOnDestroy();\n      this.ngZone.runOutsideAngular(() => {\n        var _a;\n\n        (_a = this._resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\n      });\n    }\n    /** @hidden */\n\n\n    scrollPrev() {\n      this.scroll(false);\n    }\n    /** @hidden */\n\n\n    scrollNext() {\n      this.scroll(true);\n    }\n    /** @hidden */\n\n\n    realignSelectedIndicator() {\n      if (this.selectedIndex >= 0 && this.selectedIndex < this.items.length) {\n        const header = this.items.get(this.selectedIndex).headerComponent.nativeElement;\n        this.alignSelectedIndicator(header, 0);\n      }\n    }\n    /** @hidden */\n\n\n    resolveHeaderScrollClasses() {\n      return {\n        'igx-tabs__header-scroll--start': this.tabAlignment === 'start',\n        'igx-tabs__header-scroll--end': this.tabAlignment === 'end',\n        'igx-tabs__header-scroll--center': this.tabAlignment === 'center',\n        'igx-tabs__header-scroll--justify': this.tabAlignment === 'justify'\n      };\n    }\n    /** @hidden */\n\n\n    scrollTabHeaderIntoView() {\n      if (this.selectedIndex >= 0) {\n        const tabItems = this.items.toArray();\n        const tabHeaderNativeElement = tabItems[this.selectedIndex].headerComponent.nativeElement; // Scroll left if there is need\n\n        if (this.getElementOffset(tabHeaderNativeElement) < this.offset) {\n          this.scrollElement(tabHeaderNativeElement, false);\n        } // Scroll right if there is need\n\n\n        const viewPortOffsetWidth = this.viewPort.nativeElement.offsetWidth;\n        const delta = this.getElementOffset(tabHeaderNativeElement) + tabHeaderNativeElement.offsetWidth - (viewPortOffsetWidth + this.offset); // Fix for IE 11, a difference is accumulated from the widths calculations\n\n        if (delta > 1) {\n          this.scrollElement(tabHeaderNativeElement, true);\n        }\n\n        this.alignSelectedIndicator(tabHeaderNativeElement);\n      } else {\n        this.hideSelectedIndicator();\n      }\n    }\n    /** @hidden */\n\n\n    getNextTabId() {\n      return NEXT_TAB_ID++;\n    }\n    /** @hidden */\n\n\n    onItemChanges() {\n      super.onItemChanges();\n      Promise.resolve().then(() => {\n        this.updateScrollButtons();\n      });\n    }\n\n    alignSelectedIndicator(element, duration = 0.3) {\n      if (this.selectedIndicator) {\n        this.selectedIndicator.nativeElement.style.visibility = 'visible';\n        this.selectedIndicator.nativeElement.style.transitionDuration = duration > 0 ? `${duration}s` : 'initial';\n        this.selectedIndicator.nativeElement.style.width = `${element.offsetWidth}px`;\n        this.selectedIndicator.nativeElement.style.transform = `translate(${element.offsetLeft}px)`;\n      }\n    }\n\n    hideSelectedIndicator() {\n      if (this.selectedIndicator) {\n        this.selectedIndicator.nativeElement.style.visibility = 'hidden';\n      }\n    }\n\n    scroll(scrollNext) {\n      const tabsArray = this.items.toArray();\n\n      for (let index = 0; index < tabsArray.length; index++) {\n        const tab = tabsArray[index];\n        const element = tab.headerComponent.nativeElement;\n\n        if (scrollNext) {\n          if (element.offsetWidth + this.getElementOffset(element) > this.viewPort.nativeElement.offsetWidth + this.offset) {\n            this.scrollElement(element, scrollNext);\n            break;\n          }\n        } else {\n          if (this.getElementOffset(element) >= this.offset) {\n            this.scrollElement(tabsArray[index - 1].headerComponent.nativeElement, scrollNext);\n            break;\n          }\n        }\n      }\n    }\n\n    scrollElement(element, scrollNext) {\n      const viewPortWidth = this.viewPort.nativeElement.offsetWidth;\n      this.offset = scrollNext ? element.offsetWidth + this.getElementOffset(element) - viewPortWidth : this.getElementOffset(element);\n      this.viewPort.nativeElement.scrollLeft = this.getOffset(this.offset);\n      this.updateScrollButtons();\n    }\n\n    updateScrollButtons() {\n      const itemsContainerWidth = this.getTabItemsContainerWidth();\n      const scrollPrevButtonStyle = this.resolveLeftScrollButtonStyle(itemsContainerWidth);\n      this.setScrollButtonStyle(this.scrollPrevButton.nativeElement, scrollPrevButtonStyle);\n      const scrollNextButtonStyle = this.resolveRightScrollButtonStyle(itemsContainerWidth);\n      this.setScrollButtonStyle(this.scrollNextButton.nativeElement, scrollNextButtonStyle);\n    }\n\n    setScrollButtonStyle(button, buttonStyle) {\n      if (buttonStyle === TabScrollButtonStyle.Visible) {\n        button.style.visibility = 'visible';\n        button.style.display = '';\n      } else if (buttonStyle === TabScrollButtonStyle.Hidden) {\n        button.style.visibility = 'hidden';\n        button.style.display = '';\n      } else if (buttonStyle === TabScrollButtonStyle.NotDisplayed) {\n        button.style.display = 'none';\n      }\n    }\n\n    resolveLeftScrollButtonStyle(itemsContainerWidth) {\n      const headerContainerWidth = this.headerContainer.nativeElement.offsetWidth;\n      const offset = this.offset;\n\n      if (offset === 0) {\n        // Fix for IE 11, a difference is accumulated from the widths calculations.\n        if (itemsContainerWidth - headerContainerWidth <= 1) {\n          return TabScrollButtonStyle.NotDisplayed;\n        }\n\n        return TabScrollButtonStyle.Hidden;\n      } else {\n        return TabScrollButtonStyle.Visible;\n      }\n    }\n\n    resolveRightScrollButtonStyle(itemsContainerWidth) {\n      const viewPortWidth = this.viewPort.nativeElement.offsetWidth;\n      const headerContainerWidth = this.headerContainer.nativeElement.offsetWidth;\n      const offset = this.offset;\n      const total = offset + viewPortWidth; // Fix for IE 11, a difference is accumulated from the widths calculations.\n\n      if (itemsContainerWidth - headerContainerWidth <= 1 && offset === 0) {\n        return TabScrollButtonStyle.NotDisplayed;\n      }\n\n      if (itemsContainerWidth > total) {\n        return TabScrollButtonStyle.Visible;\n      } else {\n        return TabScrollButtonStyle.Hidden;\n      }\n    }\n\n    getTabItemsContainerWidth() {\n      // We use this hacky way to get the width of the itemsContainer,\n      // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.\n      const itemsContainerChildrenCount = this.itemsContainer.nativeElement.children.length;\n      let itemsContainerWidth = 0;\n\n      if (itemsContainerChildrenCount > 1) {\n        const lastTab = this.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 1];\n        itemsContainerWidth = this.getElementOffset(lastTab) + lastTab.offsetWidth;\n      }\n\n      return itemsContainerWidth;\n    }\n\n    getOffset(offset) {\n      return this.dir.rtl ? -offset : offset;\n    }\n\n    getElementOffset(element) {\n      return this.dir.rtl ? this.itemsWrapper.nativeElement.offsetWidth - element.offsetLeft - element.offsetWidth : element.offsetLeft;\n    }\n\n  }\n\n  IgxTabsComponent.ɵfac = function IgxTabsComponent_Factory(t) {\n    return new (t || IgxTabsComponent)(i0.ɵɵdirectiveInject(i1.AnimationBuilder), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(IgxDirectionality));\n  };\n\n  IgxTabsComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxTabsComponent,\n    selectors: [[\"igx-tabs\"]],\n    viewQuery: function IgxTabsComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c262, 7);\n        i0.ɵɵviewQuery(_c263, 7);\n        i0.ɵɵviewQuery(_c264, 7);\n        i0.ɵɵviewQuery(_c265, 7);\n        i0.ɵɵviewQuery(_c266, 5);\n        i0.ɵɵviewQuery(_c267, 5);\n        i0.ɵɵviewQuery(_c268, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.viewPort = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.itemsWrapper = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.itemsContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.selectedIndicator = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.scrollPrevButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.scrollNextButton = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function IgxTabsComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-tabs\", ctx.defaultClass);\n      }\n    },\n    inputs: {\n      tabAlignment: \"tabAlignment\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxTabsBase,\n      useExisting: IgxTabsComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 20,\n    vars: 4,\n    consts: [[1, \"igx-tabs__header\"], [\"headerContainer\", \"\"], [\"igxButton\", \"icon\", \"igxRipple\", \"\", 1, \"igx-tabs__header-button\", 3, \"click\"], [\"scrollPrevButton\", \"\"], [1, \"igx-tabs__header-content\"], [\"viewPort\", \"\"], [\"role\", \"tablist\", 1, \"igx-tabs__header-wrapper\"], [\"itemsWrapper\", \"\"], [1, \"igx-tabs__header-scroll\", 3, \"ngClass\"], [\"itemsContainer\", \"\"], [4, \"ngFor\", \"ngForOf\"], [\"class\", \"igx-tabs__header-active-indicator\", 4, \"ngIf\"], [\"scrollNextButton\", \"\"], [1, \"igx-tabs__panels\"], [4, \"ngTemplateOutlet\"], [1, \"igx-tabs__header-active-indicator\"], [\"selectedIndicator\", \"\"]],\n    template: function IgxTabsComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0, 1)(2, \"button\", 2, 3);\n        i0.ɵɵlistener(\"click\", function IgxTabsComponent_Template_button_click_2_listener() {\n          return ctx.scrollPrev();\n        });\n        i0.ɵɵelementStart(4, \"igx-icon\");\n        i0.ɵɵtext(5, \"navigate_before\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(6, \"div\", 4, 5)(8, \"div\", 6, 7)(10, \"div\", 8, 9);\n        i0.ɵɵtemplate(12, IgxTabsComponent_ng_container_12_Template, 2, 1, \"ng-container\", 10);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(13, IgxTabsComponent_div_13_Template, 2, 0, \"div\", 11);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(14, \"button\", 2, 12);\n        i0.ɵɵlistener(\"click\", function IgxTabsComponent_Template_button_click_14_listener() {\n          return ctx.scrollNext();\n        });\n        i0.ɵɵelementStart(16, \"igx-icon\");\n        i0.ɵɵtext(17, \"navigate_next\");\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵelementStart(18, \"div\", 13);\n        i0.ɵɵtemplate(19, IgxTabsComponent_ng_container_19_Template, 2, 1, \"ng-container\", 10);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(10);\n        i0.ɵɵproperty(\"ngClass\", ctx.resolveHeaderScrollClasses());\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngForOf\", ctx.items);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.items.length > 0);\n        i0.ɵɵadvance(6);\n        i0.ɵɵproperty(\"ngForOf\", ctx.items);\n      }\n    },\n    directives: [IgxIconComponent, IgxRippleDirective, i4.NgClass, i4.NgForOf, i4.NgTemplateOutlet, i4.NgIf],\n    encapsulation: 2\n  });\n  return IgxTabsComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxTabItemComponent = /*#__PURE__*/(() => {\n  class IgxTabItemComponent extends IgxTabItemDirective {}\n\n  IgxTabItemComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxTabItemComponent_BaseFactory;\n    return function IgxTabItemComponent_Factory(t) {\n      return (ɵIgxTabItemComponent_BaseFactory || (ɵIgxTabItemComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxTabItemComponent)))(t || IgxTabItemComponent);\n    };\n  }();\n\n  IgxTabItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxTabItemComponent,\n    selectors: [[\"igx-tab-item\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxTabItemDirective,\n      useExisting: IgxTabItemComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c270,\n    decls: 4,\n    vars: 0,\n    consts: [[\"headerTemplate\", \"\"], [\"panelTemplate\", \"\"]],\n    template: function IgxTabItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c269);\n        i0.ɵɵtemplate(0, IgxTabItemComponent_ng_template_0_Template, 1, 0, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, IgxTabItemComponent_ng_template_2_Template, 1, 0, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxTabItemComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxTabHeaderComponent = /*#__PURE__*/(() => {\n  class IgxTabHeaderComponent extends IgxTabHeaderDirective {\n    /** @hidden @internal */\n    constructor(tabs, tab, elementRef, platform, ngZone, dir) {\n      super(tabs, tab, elementRef, platform);\n      this.tabs = tabs;\n      this.platform = platform;\n      this.ngZone = ngZone;\n      this.dir = dir;\n      /** @hidden @internal */\n\n      this.cssClass = true;\n    }\n    /** @hidden @internal */\n\n\n    get provideCssClassSelected() {\n      return this.tab.selected;\n    }\n    /** @hidden @internal */\n\n\n    get provideCssClassDisabled() {\n      return this.tab.disabled;\n    }\n    /** @hidden @internal */\n\n\n    keyDown(event) {\n      let unsupportedKey = false;\n      const itemsArray = this.tabs.items.toArray();\n      const previousIndex = itemsArray.indexOf(this.tab);\n      let newIndex = previousIndex;\n      const hasDisabledItems = itemsArray.some(item => item.disabled);\n\n      switch (event.key) {\n        case this.platform.KEYMAP.ARROW_RIGHT:\n          newIndex = this.getNewSelectionIndex(newIndex, itemsArray, event.key, hasDisabledItems);\n          break;\n\n        case this.platform.KEYMAP.ARROW_LEFT:\n          newIndex = this.getNewSelectionIndex(newIndex, itemsArray, event.key, hasDisabledItems);\n          break;\n\n        case this.platform.KEYMAP.HOME:\n          event.preventDefault();\n          newIndex = 0;\n\n          while (itemsArray[newIndex].disabled && newIndex < itemsArray.length) {\n            newIndex = newIndex === itemsArray.length - 1 ? 0 : newIndex + 1;\n          }\n\n          break;\n\n        case this.platform.KEYMAP.END:\n          event.preventDefault();\n          newIndex = itemsArray.length - 1;\n\n          while (hasDisabledItems && itemsArray[newIndex].disabled && newIndex > 0) {\n            newIndex = newIndex === 0 ? itemsArray.length - 1 : newIndex - 1;\n          }\n\n          break;\n\n        case this.platform.KEYMAP.ENTER:\n          if (!this.tab.panelComponent) {\n            this.nativeElement.click();\n          }\n\n          unsupportedKey = true;\n          break;\n\n        case this.platform.KEYMAP.SPACE:\n          event.preventDefault();\n\n          if (!this.tab.panelComponent) {\n            this.nativeElement.click();\n          }\n\n          unsupportedKey = true;\n          break;\n\n        default:\n          unsupportedKey = true;\n          break;\n      }\n\n      if (!unsupportedKey) {\n        itemsArray[newIndex].headerComponent.nativeElement.focus({\n          preventScroll: true\n        });\n\n        if (this.tab.panelComponent) {\n          this.tabs.selectedIndex = newIndex;\n        }\n      }\n    }\n    /** @hidden @internal */\n\n\n    ngAfterViewInit() {\n      this.ngZone.runOutsideAngular(() => {\n        this._resizeObserver = new (getResizeObserver())(() => {\n          this.tabs.realignSelectedIndicator();\n        });\n\n        this._resizeObserver.observe(this.nativeElement);\n      });\n    }\n    /** @hidden @internal */\n\n\n    ngOnDestroy() {\n      this.ngZone.runOutsideAngular(() => {\n        var _a;\n\n        (_a = this._resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\n      });\n    }\n\n    getNewSelectionIndex(newIndex, itemsArray, key, hasDisabledItems) {\n      if (key === this.platform.KEYMAP.ARROW_RIGHT && !this.dir.rtl || key === this.platform.KEYMAP.ARROW_LEFT && this.dir.rtl) {\n        newIndex = newIndex === itemsArray.length - 1 ? 0 : newIndex + 1;\n\n        while (hasDisabledItems && itemsArray[newIndex].disabled && newIndex < itemsArray.length) {\n          newIndex = newIndex === itemsArray.length - 1 ? 0 : newIndex + 1;\n        }\n      } else {\n        newIndex = newIndex === 0 ? itemsArray.length - 1 : newIndex - 1;\n\n        while (hasDisabledItems && itemsArray[newIndex].disabled && newIndex >= 0) {\n          newIndex = newIndex === 0 ? itemsArray.length - 1 : newIndex - 1;\n        }\n      }\n\n      return newIndex;\n    }\n\n  }\n\n  IgxTabHeaderComponent.ɵfac = function IgxTabHeaderComponent_Factory(t) {\n    return new (t || IgxTabHeaderComponent)(i0.ɵɵdirectiveInject(IgxTabsComponent), i0.ɵɵdirectiveInject(IgxTabItemDirective), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(PlatformUtil), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(IgxDirectionality));\n  };\n\n  IgxTabHeaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxTabHeaderComponent,\n    selectors: [[\"igx-tab-header\"]],\n    hostVars: 6,\n    hostBindings: function IgxTabHeaderComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function IgxTabHeaderComponent_keydown_HostBindingHandler($event) {\n          return ctx.keyDown($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-tabs__header-item--selected\", ctx.provideCssClassSelected)(\"igx-tabs__header-item--disabled\", ctx.provideCssClassDisabled)(\"igx-tabs__header-item\", ctx.cssClass);\n      }\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxTabHeaderBase,\n      useExisting: IgxTabHeaderComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c61,\n    decls: 4,\n    vars: 0,\n    consts: [[1, \"igx-tabs__header-item-inner\"]],\n    template: function IgxTabHeaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c59);\n        i0.ɵɵprojection(0);\n        i0.ɵɵelementStart(1, \"div\", 0);\n        i0.ɵɵprojection(2, 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵprojection(3, 2);\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxTabHeaderComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxTabHeaderLabelDirective = /*#__PURE__*/(() => {\n  class IgxTabHeaderLabelDirective {}\n\n  IgxTabHeaderLabelDirective.ɵfac = function IgxTabHeaderLabelDirective_Factory(t) {\n    return new (t || IgxTabHeaderLabelDirective)();\n  };\n\n  IgxTabHeaderLabelDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxTabHeaderLabelDirective,\n    selectors: [[\"igx-tab-header-label\"], [\"\", \"igxTabHeaderLabel\", \"\"]]\n  });\n  return IgxTabHeaderLabelDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxTabHeaderIconDirective = /*#__PURE__*/(() => {\n  class IgxTabHeaderIconDirective {}\n\n  IgxTabHeaderIconDirective.ɵfac = function IgxTabHeaderIconDirective_Factory(t) {\n    return new (t || IgxTabHeaderIconDirective)();\n  };\n\n  IgxTabHeaderIconDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxTabHeaderIconDirective,\n    selectors: [[\"igx-tab-header-icon\"], [\"\", \"igxTabHeaderIcon\", \"\"]]\n  });\n  return IgxTabHeaderIconDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxTabContentComponent = /*#__PURE__*/(() => {\n  class IgxTabContentComponent extends IgxTabContentDirective {\n    constructor() {\n      super(...arguments);\n      /** @hidden */\n\n      this.cssClass = true;\n    }\n\n  }\n\n  IgxTabContentComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxTabContentComponent_BaseFactory;\n    return function IgxTabContentComponent_Factory(t) {\n      return (ɵIgxTabContentComponent_BaseFactory || (ɵIgxTabContentComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxTabContentComponent)))(t || IgxTabContentComponent);\n    };\n  }();\n\n  IgxTabContentComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxTabContentComponent,\n    selectors: [[\"igx-tab-content\"]],\n    hostVars: 2,\n    hostBindings: function IgxTabContentComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-tabs__panel\", ctx.cssClass);\n      }\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxTabContentBase,\n      useExisting: IgxTabContentComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c8,\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngIf\"]],\n    template: function IgxTabContentComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, IgxTabContentComponent_ng_content_0_Template, 1, 0, \"ng-content\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.tab.selected || ctx.tab.previous);\n      }\n    },\n    directives: [i4.NgIf],\n    encapsulation: 2\n  });\n  return IgxTabContentComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxTabsModule = /*#__PURE__*/(() => {\n  class IgxTabsModule {}\n\n  IgxTabsModule.ɵfac = function IgxTabsModule_Factory(t) {\n    return new (t || IgxTabsModule)();\n  };\n\n  IgxTabsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxTabsModule\n  });\n  IgxTabsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, IgxIconModule, IgxRippleModule, IgxPrefixModule, IgxSuffixModule], IgxPrefixModule, IgxSuffixModule]\n  });\n  return IgxTabsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$2 = 0;\n/**\n * **Ignite UI for Angular Toast** -\n * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/toast)\n *\n * The Ignite UI Toast provides information and warning messages that are non-interactive and cannot\n * be dismissed by the user. Toasts can be displayed at the bottom, middle, or top of the page.\n *\n * Example:\n * ```html\n * <button (click)=\"toast.open()\">Show notification</button>\n * <igx-toast #toast displayTime=\"1000\">\n *      Notification displayed\n * </igx-toast>\n * ```\n */\n\nlet IgxToastComponent = /*#__PURE__*/(() => {\n  class IgxToastComponent extends IgxNotificationsDirective {\n    constructor(_element, cdr, navService, overlayService) {\n      super(_element, cdr, overlayService, navService);\n      this._element = _element;\n      /**\n       * @hidden\n       */\n\n      this.cssClass = 'igx-toast';\n      /**\n       * Sets/gets the `id` of the toast.\n       * If not set, the `id` will have value `\"igx-toast-0\"`.\n       * ```html\n       * <igx-toast id = \"my-first-toast\"></igx-toast>\n       * ```\n       * ```typescript\n       * let toastId = this.toast.id;\n       * ```\n       */\n\n      this.id = `igx-toast-${NEXT_ID$2++}`;\n      /**\n       * Sets/gets the `role` attribute.\n       * If not set, `role` will have value `\"alert\"`.\n       * ```html\n       * <igx-toast [role] = \"'notify'\"></igx-toast>\n       * ```\n       * ```typescript\n       * let toastRole = this.toast.role;\n       * ```\n       *\n       * @memberof IgxToastComponent\n       */\n\n      this.role = 'alert';\n      /**\n       * @hidden\n       */\n\n      this.isVisibleChange = new EventEmitter();\n      this._positionSettings = {\n        horizontalDirection: HorizontalAlignment.Center,\n        verticalDirection: VerticalAlignment.Bottom,\n        openAnimation: useAnimation(fadeIn),\n        closeAnimation: useAnimation(fadeOut)\n      };\n    }\n    /**\n     * Get the position and animation settings used by the toast.\n     * ```typescript\n     * @ViewChild('toast', { static: true }) public toast: IgxToastComponent;\n     * let currentPosition: PositionSettings = this.toast.positionSettings\n     * ```\n     */\n\n\n    get positionSettings() {\n      return this._positionSettings;\n    }\n    /**\n     * Set the position and animation settings used by the toast.\n     * ```html\n     * <igx-toast [positionSettings]=\"newPositionSettings\"></igx-toast>\n     * ```\n     * ```typescript\n     * import { slideInTop, slideOutBottom } from 'igniteui-angular';\n     * ...\n     * @ViewChild('toast', { static: true }) public toast: IgxToastComponent;\n     *  public newPositionSettings: PositionSettings = {\n     *      openAnimation: useAnimation(slideInTop, { params: { duration: '1000ms', fromPosition: 'translateY(100%)'}}),\n     *      closeAnimation: useAnimation(slideOutBottom, { params: { duration: '1000ms', fromPosition: 'translateY(0)'}}),\n     *      horizontalDirection: HorizontalAlignment.Left,\n     *      verticalDirection: VerticalAlignment.Middle,\n     *      horizontalStartPoint: HorizontalAlignment.Left,\n     *      verticalStartPoint: VerticalAlignment.Middle\n     *  };\n     * this.toast.positionSettings = this.newPositionSettings;\n     * ```\n     */\n\n\n    set positionSettings(settings) {\n      this._positionSettings = settings;\n    }\n    /**\n     * Gets the nativeElement of the toast.\n     * ```typescript\n     * let nativeElement = this.toast.element;\n     * ```\n     *\n     * @memberof IgxToastComponent\n     */\n\n\n    get element() {\n      return this._element.nativeElement;\n    }\n    /**\n     * Shows the toast.\n     * If `autoHide` is enabled, the toast will hide after `displayTime` is over.\n     *\n     * ```typescript\n     * this.toast.open();\n     * ```\n     */\n\n\n    open(message, settings) {\n      if (message !== undefined) {\n        this.textMessage = message;\n      }\n\n      if (settings !== undefined) {\n        this.positionSettings = settings;\n      }\n\n      this.strategy = new GlobalPositionStrategy(this.positionSettings);\n      super.open();\n    }\n    /**\n     * Opens or closes the toast, depending on its current state.\n     *\n     * ```typescript\n     * this.toast.toggle();\n     * ```\n     */\n\n\n    toggle() {\n      if (this.collapsed || this.isClosing) {\n        this.open();\n      } else {\n        this.close();\n      }\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      this.opened.pipe(takeUntil(this.d$)).subscribe(() => {\n        const openedEventArgs = {\n          owner: this,\n          id: this._overlayId\n        };\n        this.isVisibleChange.emit(openedEventArgs);\n      });\n      this.closed.pipe(takeUntil(this.d$)).subscribe(() => {\n        const closedEventArgs = {\n          owner: this,\n          id: this._overlayId\n        };\n        this.isVisibleChange.emit(closedEventArgs);\n      });\n    }\n\n  }\n\n  IgxToastComponent.ɵfac = function IgxToastComponent_Factory(t) {\n    return new (t || IgxToastComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(IgxNavigationService, 8), i0.ɵɵdirectiveInject(IgxOverlayService));\n  };\n\n  IgxToastComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxToastComponent,\n    selectors: [[\"igx-toast\"]],\n    hostVars: 4,\n    hostBindings: function IgxToastComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id)(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"igx-toast\", ctx.cssClass);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      role: \"role\",\n      positionSettings: \"positionSettings\"\n    },\n    outputs: {\n      isVisibleChange: \"isVisibleChange\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c8,\n    decls: 3,\n    vars: 1,\n    template: function IgxToastComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n        i0.ɵɵelementStart(1, \"span\");\n        i0.ɵɵtext(2);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate(ctx.textMessage);\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxToastComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxToastModule = /*#__PURE__*/(() => {\n  class IgxToastModule {}\n\n  IgxToastModule.ɵfac = function IgxToastModule_Factory(t) {\n    return new (t || IgxToastModule)();\n  };\n\n  IgxToastModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxToastModule\n  });\n  IgxToastModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return IgxToastModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents individual resizable/collapsible panes.\n *\n * @igxModule IgxSplitterModule\n *\n * @igxParent IgxSplitterComponent\n *\n * @igxKeywords pane\n *\n * @igxGroup presentation\n *\n * @remarks\n *  Users can control the resize behavior via the min and max size properties.\n */\n\n\nlet IgxSplitterPaneComponent = /*#__PURE__*/(() => {\n  class IgxSplitterPaneComponent {\n    constructor(el) {\n      this.el = el;\n      /**\n       * @hidden @internal\n       * Gets/Sets the 'display' property of the current pane.\n       */\n\n      this.display = 'flex';\n      /**\n       * Gets/Sets whether pane is resizable.\n       *\n       * @example\n       * ```html\n       * <igx-splitter>\n       *  <igx-splitter-pane [resizable]='false'>...</igx-splitter-pane>\n       * </igx-splitter>\n       * ```\n       * @remarks\n       * If pane is not resizable its related splitter bar cannot be dragged.\n       */\n\n      this.resizable = true;\n      /**\n       * Event fired when collapsed state of pane is changed.\n       *\n       * @example\n       * ```html\n       * <igx-splitter>\n       *  <igx-splitter-pane (collapsedChange)='paneCollapsedChange($event)'>...</igx-splitter-pane>\n       * </igx-splitter>\n       * ```\n       */\n\n      this.collapsedChange = new EventEmitter();\n      /**\n       * @hidden @internal\n       * Gets/Sets the `overflow`.\n       */\n\n      this.overflow = 'auto';\n      /**\n       * @hidden @internal\n       * Gets/Sets the `minHeight` and `minWidth` properties of the current pane.\n       */\n\n      this.minHeight = 0;\n      /**\n       * @hidden @internal\n       * Gets/Sets the `maxHeight` and `maxWidth` properties of the current `IgxSplitterPaneComponent`.\n       */\n\n      this.maxHeight = '100%';\n      this._size = 'auto';\n      this._collapsed = false;\n    }\n    /**\n     * Gets/Sets the size of the current pane.\n     *  * @example\n     * ```html\n     * <igx-splitter>\n     *  <igx-splitter-pane [size]='size'>...</igx-splitter-pane>\n     * </igx-splitter>\n     * ```\n     */\n\n\n    get size() {\n      return this._size;\n    }\n\n    set size(value) {\n      this._size = value;\n      this.el.nativeElement.style.flex = this.flex;\n    }\n    /** @hidden @internal */\n\n\n    get isPercentageSize() {\n      return this.size === 'auto' || this.size.indexOf('%') !== -1;\n    }\n    /** @hidden @internal */\n\n\n    get dragSize() {\n      return this._dragSize;\n    }\n\n    set dragSize(val) {\n      this._dragSize = val;\n      this.el.nativeElement.style.flex = this.flex;\n    }\n    /**\n     *\n     * @hidden @internal\n     * Gets the host native element.\n     */\n\n\n    get element() {\n      return this.el.nativeElement;\n    }\n    /**\n     * @hidden @internal\n     * Gets the `flex` property of the current `IgxSplitterPaneComponent`.\n     */\n\n\n    get flex() {\n      const isAuto = this.size === 'auto' && !this.dragSize;\n      const grow = !isAuto ? 0 : 1;\n      const size = this.dragSize || this.size;\n      return `${grow} ${grow} ${size}`;\n    }\n    /**\n     * Gets/Sets whether current pane is collapsed.\n     *\n     * @example\n     * ```typescript\n     * const isCollapsed = pane.collapsed;\n     * ```\n     */\n\n\n    set collapsed(value) {\n      if (this.owner) {\n        // reset sibling sizes when pane collapse state changes.\n        this._getSiblings().forEach(sibling => {\n          sibling.size = 'auto';\n          sibling.dragSize = null;\n        });\n      }\n\n      this._collapsed = value;\n      this.display = this._collapsed ? 'none' : 'flex';\n      this.collapsedChange.emit(this._collapsed);\n    }\n\n    get collapsed() {\n      return this._collapsed;\n    }\n    /**\n     * Toggles the collapsed state of the pane.\n     *\n     * @example\n     * ```typescript\n     * pane.toggle();\n     * ```\n     */\n\n\n    toggle() {\n      this.collapsed = !this.collapsed;\n    }\n    /** @hidden @internal */\n\n\n    _getSiblings() {\n      const panes = this.owner.panes.toArray();\n      const index = panes.indexOf(this);\n      const siblings = [];\n\n      if (index !== 0) {\n        siblings.push(panes[index - 1]);\n      }\n\n      if (index !== panes.length - 1) {\n        siblings.push(panes[index + 1]);\n      }\n\n      return siblings;\n    }\n\n  }\n\n  IgxSplitterPaneComponent.ɵfac = function IgxSplitterPaneComponent_Factory(t) {\n    return new (t || IgxSplitterPaneComponent)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxSplitterPaneComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxSplitterPaneComponent,\n    selectors: [[\"igx-splitter-pane\"]],\n    hostVars: 16,\n    hostBindings: function IgxSplitterPaneComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"display\", ctx.display)(\"order\", ctx.order)(\"overflow\", ctx.overflow)(\"min-height\", ctx.minHeight)(\"min-width\", ctx.minHeight)(\"max-height\", ctx.maxHeight)(\"max-width\", ctx.maxHeight)(\"flex\", ctx.flex);\n      }\n    },\n    inputs: {\n      minSize: \"minSize\",\n      maxSize: \"maxSize\",\n      resizable: \"resizable\",\n      size: \"size\",\n      collapsed: \"collapsed\"\n    },\n    outputs: {\n      collapsedChange: \"collapsedChange\"\n    },\n    ngContentSelectors: _c8,\n    decls: 1,\n    vars: 0,\n    template: function IgxSplitterPaneComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return IgxSplitterPaneComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * An enumeration that defines the `SplitterComponent` panes orientation.\n */\n\n\nvar SplitterType = /*#__PURE__*/(() => {\n  (function (SplitterType) {\n    SplitterType[SplitterType[\"Horizontal\"] = 0] = \"Horizontal\";\n    SplitterType[SplitterType[\"Vertical\"] = 1] = \"Vertical\";\n  })(SplitterType || (SplitterType = {}));\n\n  return SplitterType;\n})();\n\n/**\n * Provides a framework for a simple layout, splitting the view horizontally or vertically\n * into multiple smaller resizable and collapsible areas.\n *\n * @igxModule IgxSplitterModule\n *\n * @igxParent Layouts\n *\n * @igxTheme igx-splitter-theme\n *\n * @igxKeywords splitter panes layout\n *\n * @igxGroup presentation\n *\n * @example\n * ```html\n * <igx-splitter>\n *  <igx-splitter-pane>\n *      ...\n *  </igx-splitter-pane>\n *  <igx-splitter-pane>\n *      ...\n *  </igx-splitter-pane>\n * </igx-splitter>\n * ```\n */\nlet IgxSplitterComponent = /*#__PURE__*/(() => {\n  class IgxSplitterComponent {\n    constructor(document, elementRef) {\n      this.document = document;\n      this.elementRef = elementRef;\n      /**\n       * @hidden @internal\n       * Gets/Sets the `overflow` property of the current splitter.\n       */\n\n      this.overflow = 'hidden';\n      /**\n       * @hidden @internal\n       * Sets/Gets the `display` property of the current splitter.\n       */\n\n      this.display = 'flex';\n      /**\n       * Event fired when resizing of panes starts.\n       *\n       * @example\n       * ```html\n       * <igx-splitter (resizeStart)='resizeStart($event)'>\n       *  <igx-splitter-pane>...</igx-splitter-pane>\n       * </igx-splitter>\n       * ```\n       */\n\n      this.resizeStart = new EventEmitter();\n      /**\n       * Event fired when resizing of panes is in progress.\n       *\n       * @example\n       * ```html\n       * <igx-splitter (resizing)='resizing($event)'>\n       *  <igx-splitter-pane>...</igx-splitter-pane>\n       * </igx-splitter>\n       * ```\n       */\n\n      this.resizing = new EventEmitter();\n      /**\n       * Event fired when resizing of panes ends.\n       *\n       * @example\n       * ```html\n       * <igx-splitter (resizeEnd)='resizeEnd($event)'>\n       *  <igx-splitter-pane>...</igx-splitter-pane>\n       * </igx-splitter>\n       * ```\n       */\n\n      this.resizeEnd = new EventEmitter();\n      this._type = SplitterType.Horizontal;\n    }\n    /**\n     * Gets/Sets the splitter orientation.\n     *\n     * @example\n     * ```html\n     * <igx-splitter [type]=\"type\">...</igx-splitter>\n     * ```\n     */\n\n\n    get type() {\n      return this._type;\n    }\n\n    set type(value) {\n      this._type = value;\n      this.resetPaneSizes();\n    }\n    /**\n     * @hidden @internal\n     * Gets the `flex-direction` property of the current `SplitterComponent`.\n     */\n\n\n    get direction() {\n      return this.type === SplitterType.Horizontal ? 'row' : 'column';\n    }\n    /** @hidden @internal */\n\n\n    ngAfterContentInit() {\n      this.initPanes();\n      this.panes.changes.subscribe(() => {\n        this.initPanes();\n      });\n    }\n    /**\n     * @hidden @internal\n     * This method performs  initialization logic when the user starts dragging the splitter bar between each pair of panes.\n     * @param pane - the main pane associated with the currently dragged bar.\n     */\n\n\n    onMoveStart(pane) {\n      const panes = this.panes.toArray();\n      this.pane = pane;\n      this.sibling = panes[panes.indexOf(this.pane) + 1];\n      const paneRect = this.pane.element.getBoundingClientRect();\n      this.initialPaneSize = this.type === SplitterType.Horizontal ? paneRect.width : paneRect.height;\n      const siblingRect = this.sibling.element.getBoundingClientRect();\n      this.initialSiblingSize = this.type === SplitterType.Horizontal ? siblingRect.width : siblingRect.height;\n      const args = {\n        pane: this.pane,\n        sibling: this.sibling\n      };\n      this.resizeStart.emit(args);\n    }\n    /**\n     * @hidden @internal\n     * This method performs calculations concerning the sizes of each pair of panes when the bar between them is dragged.\n     * @param delta - The difference along the X (or Y) axis between the initial and the current point when dragging the bar.\n     */\n\n\n    onMoving(delta) {\n      const min = parseInt(this.pane.minSize, 10) || 0;\n      const max = parseInt(this.pane.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;\n      const minSibling = parseInt(this.sibling.minSize, 10) || 0;\n      const maxSibling = parseInt(this.sibling.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;\n      const paneSize = this.initialPaneSize - delta;\n      const siblingSize = this.initialSiblingSize + delta;\n\n      if (paneSize < min || paneSize > max || siblingSize < minSibling || siblingSize > maxSibling) {\n        return;\n      }\n\n      this.pane.dragSize = paneSize + 'px';\n      this.sibling.dragSize = siblingSize + 'px';\n      const args = {\n        pane: this.pane,\n        sibling: this.sibling\n      };\n      this.resizing.emit(args);\n    }\n\n    onMoveEnd(delta) {\n      const min = parseInt(this.pane.minSize, 10) || 0;\n      const max = parseInt(this.pane.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;\n      const minSibling = parseInt(this.sibling.minSize, 10) || 0;\n      const maxSibling = parseInt(this.sibling.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;\n      const paneSize = this.initialPaneSize - delta;\n      const siblingSize = this.initialSiblingSize + delta;\n\n      if (paneSize < min || paneSize > max || siblingSize < minSibling || siblingSize > maxSibling) {\n        return;\n      }\n\n      if (this.pane.isPercentageSize) {\n        // handle % resizes\n        const totalSize = this.getTotalSize();\n        const percentPaneSize = paneSize / totalSize * 100;\n        this.pane.size = percentPaneSize + '%';\n      } else {\n        // px resize\n        this.pane.size = paneSize + 'px';\n      }\n\n      if (this.sibling.isPercentageSize) {\n        // handle % resizes\n        const totalSize = this.getTotalSize();\n        const percentSiblingPaneSize = siblingSize / totalSize * 100;\n        this.sibling.size = percentSiblingPaneSize + '%';\n      } else {\n        // px resize\n        this.sibling.size = siblingSize + 'px';\n      }\n\n      this.pane.dragSize = null;\n      this.sibling.dragSize = null;\n      const args = {\n        pane: this.pane,\n        sibling: this.sibling\n      };\n      this.resizeEnd.emit(args);\n    }\n    /** @hidden @internal */\n\n\n    getPaneSiblingsByOrder(order, barIndex) {\n      const panes = this.panes.toArray();\n      const prevPane = panes[order - barIndex - 1];\n      const nextPane = panes[order - barIndex];\n      const siblings = [prevPane, nextPane];\n      return siblings;\n    }\n\n    getTotalSize() {\n      const computed = this.document.defaultView.getComputedStyle(this.elementRef.nativeElement);\n      const totalSize = this.type === SplitterType.Horizontal ? computed.getPropertyValue('width') : computed.getPropertyValue('height');\n      return parseFloat(totalSize);\n    }\n    /**\n     * @hidden @internal\n     * This method inits panes with properties.\n     */\n\n\n    initPanes() {\n      this.panes.forEach(pane => pane.owner = this);\n      this.assignFlexOrder();\n\n      if (this.panes.filter(x => x.collapsed).length > 0) {\n        // if any panes are collapsed, reset sizes.\n        this.resetPaneSizes();\n      }\n    }\n    /**\n     * @hidden @internal\n     * This method reset pane sizes.\n     */\n\n\n    resetPaneSizes() {\n      if (this.panes) {\n        // if type is changed runtime, should reset sizes.\n        this.panes.forEach(x => x.size = 'auto');\n      }\n    }\n    /**\n     * @hidden @internal\n     * This method assigns the order of each pane.\n     */\n\n\n    assignFlexOrder() {\n      let k = 0;\n      this.panes.forEach(pane => {\n        pane.order = k;\n        k += 2;\n      });\n    }\n\n  }\n\n  IgxSplitterComponent.ɵfac = function IgxSplitterComponent_Factory(t) {\n    return new (t || IgxSplitterComponent)(i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxSplitterComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxSplitterComponent,\n    selectors: [[\"igx-splitter\"]],\n    contentQueries: function IgxSplitterComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxSplitterPaneComponent, 4, IgxSplitterPaneComponent);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.panes = _t);\n      }\n    },\n    hostVars: 6,\n    hostBindings: function IgxSplitterComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"overflow\", ctx.overflow)(\"display\", ctx.display)(\"flex-direction\", ctx.direction);\n      }\n    },\n    inputs: {\n      type: \"type\"\n    },\n    outputs: {\n      resizeStart: \"resizeStart\",\n      resizing: \"resizing\",\n      resizeEnd: \"resizeEnd\"\n    },\n    ngContentSelectors: _c272,\n    decls: 2,\n    vars: 1,\n    consts: [[4, \"ngFor\", \"ngForOf\"], [\"role\", \"separator\", 3, \"order\", \"type\", \"pane\", \"siblings\", \"moveStart\", \"moving\", \"movingEnd\", 4, \"ngIf\"], [\"role\", \"separator\", 3, \"order\", \"type\", \"pane\", \"siblings\", \"moveStart\", \"moving\", \"movingEnd\"]],\n    template: function IgxSplitterComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c271);\n        i0.ɵɵprojection(0);\n        i0.ɵɵtemplate(1, IgxSplitterComponent_ng_container_1_Template, 2, 1, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.panes);\n      }\n    },\n    directives: function () {\n      return [IgxSplitBarComponent, i4.NgForOf, i4.NgIf];\n    },\n    encapsulation: 2\n  });\n  return IgxSplitterComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst SPLITTER_INTERACTION_KEYS = new Set('right down left up arrowright arrowdown arrowleft arrowup'.split(' '));\n/**\n * @hidden @internal\n * Represents the draggable bar that visually separates panes and allows for changing their sizes.\n */\n\nlet IgxSplitBarComponent = /*#__PURE__*/(() => {\n  class IgxSplitBarComponent {\n    constructor() {\n      /**\n       * Set css class to the host element.\n       */\n      this.cssClass = 'igx-splitter-bar-host';\n      /**\n       * Gets/Sets the orientation.\n       */\n\n      this.type = SplitterType.Horizontal;\n      /**\n       * An event that is emitted whenever we start dragging the current `SplitBarComponent`.\n       */\n\n      this.moveStart = new EventEmitter();\n      /**\n       * An event that is emitted while we are dragging the current `SplitBarComponent`.\n       */\n\n      this.moving = new EventEmitter();\n      this.movingEnd = new EventEmitter();\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get tabindex() {\n      return this.resizeDisallowed ? null : 0;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get orientation() {\n      return this.type === SplitterType.Horizontal ? 'horizontal' : 'vertical';\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get cursor() {\n      if (this.resizeDisallowed) {\n        return '';\n      }\n\n      return this.type === SplitterType.Horizontal ? 'col-resize' : 'row-resize';\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get prevButtonHidden() {\n      return this.siblings[0].collapsed && !this.siblings[1].collapsed;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    keyEvent(event) {\n      const key = event.key.toLowerCase();\n      const ctrl = event.ctrlKey;\n      event.stopPropagation();\n\n      if (SPLITTER_INTERACTION_KEYS.has(key)) {\n        event.preventDefault();\n      }\n\n      switch (key) {\n        case 'arrowup':\n        case 'up':\n          if (this.type === SplitterType.Vertical) {\n            if (ctrl) {\n              this.onCollapsing(false);\n              break;\n            }\n\n            if (!this.resizeDisallowed) {\n              event.preventDefault();\n              this.moveStart.emit(this.pane);\n              this.moving.emit(10);\n            }\n          }\n\n          break;\n\n        case 'arrowdown':\n        case 'down':\n          if (this.type === SplitterType.Vertical) {\n            if (ctrl) {\n              this.onCollapsing(true);\n              break;\n            }\n\n            if (!this.resizeDisallowed) {\n              event.preventDefault();\n              this.moveStart.emit(this.pane);\n              this.moving.emit(-10);\n            }\n          }\n\n          break;\n\n        case 'arrowleft':\n        case 'left':\n          if (this.type === SplitterType.Horizontal) {\n            if (ctrl) {\n              this.onCollapsing(false);\n              break;\n            }\n\n            if (!this.resizeDisallowed) {\n              event.preventDefault();\n              this.moveStart.emit(this.pane);\n              this.moving.emit(10);\n            }\n          }\n\n          break;\n\n        case 'arrowright':\n        case 'right':\n          if (this.type === SplitterType.Horizontal) {\n            if (ctrl) {\n              this.onCollapsing(true);\n              break;\n            }\n\n            if (!this.resizeDisallowed) {\n              event.preventDefault();\n              this.moveStart.emit(this.pane);\n              this.moving.emit(-10);\n            }\n          }\n\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get dragDir() {\n      return this.type === SplitterType.Horizontal ? DragDirection.VERTICAL : DragDirection.HORIZONTAL;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get nextButtonHidden() {\n      return this.siblings[1].collapsed && !this.siblings[0].collapsed;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onDragStart(event) {\n      if (this.resizeDisallowed) {\n        event.cancel = true;\n        return;\n      }\n\n      this.startPoint = this.type === SplitterType.Horizontal ? event.startX : event.startY;\n      this.moveStart.emit(this.pane);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onDragMove(event) {\n      const isHorizontal = this.type === SplitterType.Horizontal;\n      const curr = isHorizontal ? event.pageX : event.pageY;\n      const delta = this.startPoint - curr;\n\n      if (delta !== 0) {\n        this.moving.emit(delta);\n        event.cancel = true;\n        event.owner.element.nativeElement.style.transform = '';\n      }\n    }\n\n    onDragEnd(event) {\n      const isHorizontal = this.type === SplitterType.Horizontal;\n      const curr = isHorizontal ? event.pageX : event.pageY;\n      const delta = this.startPoint - curr;\n\n      if (delta !== 0) {\n        this.movingEnd.emit(delta);\n      }\n    }\n\n    get resizeDisallowed() {\n      const relatedTabs = this.siblings;\n      return !!relatedTabs.find(x => x.resizable === false || x.collapsed === true);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onCollapsing(next) {\n      const prevSibling = this.siblings[0];\n      const nextSibling = this.siblings[1];\n      let target;\n\n      if (next) {\n        // if next is clicked when prev pane is hidden, show prev pane, else hide next pane.\n        target = prevSibling.collapsed ? prevSibling : nextSibling;\n      } else {\n        // if prev is clicked when next pane is hidden, show next pane, else hide prev pane.\n        target = nextSibling.collapsed ? nextSibling : prevSibling;\n      }\n\n      target.toggle();\n    }\n\n  }\n\n  IgxSplitBarComponent.ɵfac = function IgxSplitBarComponent_Factory(t) {\n    return new (t || IgxSplitBarComponent)();\n  };\n\n  IgxSplitBarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxSplitBarComponent,\n    selectors: [[\"igx-splitter-bar\"]],\n    hostVars: 6,\n    hostBindings: function IgxSplitBarComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function IgxSplitBarComponent_keydown_HostBindingHandler($event) {\n          return ctx.keyEvent($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabindex\", ctx.tabindex)(\"aria-orientation\", ctx.orientation);\n        i0.ɵɵstyleProp(\"order\", ctx.order);\n        i0.ɵɵclassProp(\"igx-splitter-bar-host\", ctx.cssClass);\n      }\n    },\n    inputs: {\n      type: \"type\",\n      order: \"order\",\n      pane: \"pane\",\n      siblings: \"siblings\"\n    },\n    outputs: {\n      moveStart: \"moveStart\",\n      moving: \"moving\",\n      movingEnd: \"movingEnd\"\n    },\n    decls: 4,\n    vars: 8,\n    consts: [[\"igxDrag\", \"\", 1, \"igx-splitter-bar\", 3, \"ghost\", \"dragDirection\", \"dragStart\", \"dragMove\", \"dragEnd\"], [\"igxDragIgnore\", \"\", 1, \"igx-splitter-bar__expander--start\", 3, \"hidden\", \"click\"], [1, \"igx-splitter-bar__handle\"], [\"igxDragIgnore\", \"\", 1, \"igx-splitter-bar__expander--end\", 3, \"hidden\", \"click\"]],\n    template: function IgxSplitBarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵlistener(\"dragStart\", function IgxSplitBarComponent_Template_div_dragStart_0_listener($event) {\n          return ctx.onDragStart($event);\n        })(\"dragMove\", function IgxSplitBarComponent_Template_div_dragMove_0_listener($event) {\n          return ctx.onDragMove($event);\n        })(\"dragEnd\", function IgxSplitBarComponent_Template_div_dragEnd_0_listener($event) {\n          return ctx.onDragEnd($event);\n        });\n        i0.ɵɵelementStart(1, \"div\", 1);\n        i0.ɵɵlistener(\"click\", function IgxSplitBarComponent_Template_div_click_1_listener() {\n          return ctx.onCollapsing(false);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(2, \"div\", 2);\n        i0.ɵɵelementStart(3, \"div\", 3);\n        i0.ɵɵlistener(\"click\", function IgxSplitBarComponent_Template_div_click_3_listener() {\n          return ctx.onCollapsing(true);\n        });\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"cursor\", ctx.cursor);\n        i0.ɵɵclassProp(\"igx-splitter-bar--vertical\", ctx.type === 0);\n        i0.ɵɵproperty(\"ghost\", false)(\"dragDirection\", ctx.dragDir);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"hidden\", ctx.prevButtonHidden);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"hidden\", ctx.nextButtonHidden);\n      }\n    },\n    directives: [IgxDragDirective, IgxDragIgnoreDirective],\n    encapsulation: 2\n  });\n  return IgxSplitBarComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxSplitterModule = /*#__PURE__*/(() => {\n  class IgxSplitterModule {}\n\n  IgxSplitterModule.ɵfac = function IgxSplitterModule_Factory(t) {\n    return new (t || IgxSplitterModule)();\n  };\n\n  IgxSplitterModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxSplitterModule\n  });\n  IgxSplitterModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, IgxIconModule, IgxDragDropModule]]\n  });\n  return IgxSplitterModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // Enums\n\n\nconst IgxStepperOrientation = {\n  Horizontal: 'horizontal',\n  Vertical: 'vertical'\n};\nconst IgxStepType = {\n  Indicator: 'indicator',\n  Title: 'title',\n  Full: 'full'\n};\nconst IgxStepperTitlePosition = {\n  Bottom: 'bottom',\n  Top: 'top',\n  End: 'end',\n  Start: 'start'\n};\nconst VerticalAnimationType = {\n  Grow: 'grow',\n  Fade: 'fade',\n  None: 'none'\n}; // Token\n\nconst IGX_STEPPER_COMPONENT = new InjectionToken('IgxStepperToken');\nconst IGX_STEP_COMPONENT = new InjectionToken('IgxStepToken');\n/** @hidden @internal */\n\nlet IgxStepperService = /*#__PURE__*/(() => {\n  class IgxStepperService {\n    constructor() {\n      this.collapsingSteps = new Set();\n      this.linearDisabledSteps = new Set();\n      this.visitedSteps = new Set();\n    }\n    /**\n     * Activates the step, fires the steps change event and plays animations.\n     */\n\n\n    expand(step) {\n      if (this.activeStep === step) {\n        return;\n      }\n\n      const cancel = this.emitActivatingEvent(step);\n\n      if (cancel) {\n        return;\n      }\n\n      this.collapsingSteps.delete(step);\n      this.previousActiveStep = this.activeStep;\n      this.activeStep = step;\n      this.activeStep.activeChange.emit(true);\n      this.collapsingSteps.add(this.previousActiveStep);\n      this.visitedSteps.add(this.activeStep);\n\n      if (this.stepper.orientation === IgxStepperOrientation.Vertical) {\n        this.previousActiveStep.playCloseAnimation(this.previousActiveStep.contentContainer);\n        this.activeStep.cdr.detectChanges();\n        this.activeStep.playOpenAnimation(this.activeStep.contentContainer);\n      } else {\n        this.activeStep.cdr.detectChanges();\n        this.stepper.playHorizontalAnimations();\n      }\n    }\n    /**\n     * Activates the step and fires the steps change event without playing animations.\n     */\n\n\n    expandThroughApi(step) {\n      var _a, _b;\n\n      if (this.activeStep === step) {\n        return;\n      }\n\n      this.collapsingSteps.clear();\n      this.previousActiveStep = this.activeStep;\n      this.activeStep = step;\n\n      if (this.previousActiveStep) {\n        this.previousActiveStep.tabIndex = -1;\n      }\n\n      this.activeStep.tabIndex = 0;\n      this.visitedSteps.add(this.activeStep);\n      this.activeStep.cdr.detectChanges();\n      (_a = this.previousActiveStep) === null || _a === void 0 ? void 0 : _a.cdr.detectChanges();\n      this.activeStep.activeChange.emit(true);\n      (_b = this.previousActiveStep) === null || _b === void 0 ? void 0 : _b.activeChange.emit(false);\n    }\n    /**\n     * Collapses the currently active step and fires the change event.\n     */\n\n\n    collapse(step) {\n      if (this.activeStep === step) {\n        return;\n      }\n\n      step.activeChange.emit(false);\n      this.collapsingSteps.delete(step);\n    }\n    /**\n     * Determines the steps that should be marked as visited based on the active step.\n     */\n\n\n    calculateVisitedSteps() {\n      this.stepper.steps.forEach(step => {\n        if (step.index <= this.activeStep.index) {\n          this.visitedSteps.add(step);\n        } else {\n          this.visitedSteps.delete(step);\n        }\n      });\n    }\n    /**\n     * Determines the steps that should be disabled in linear mode based on the validity of the active step.\n     */\n\n\n    calculateLinearDisabledSteps() {\n      if (!this.activeStep) {\n        return;\n      }\n\n      if (this.activeStep.isValid) {\n        const firstRequiredIndex = this.getNextRequiredStep();\n\n        if (firstRequiredIndex !== -1) {\n          this.updateLinearDisabledSteps(firstRequiredIndex);\n        } else {\n          this.linearDisabledSteps.clear();\n        }\n      } else {\n        this.stepper.steps.forEach(s => {\n          if (s.index > this.activeStep.index) {\n            this.linearDisabledSteps.add(s);\n          }\n        });\n      }\n    }\n\n    emitActivatingEvent(step) {\n      const args = {\n        owner: this.stepper,\n        newIndex: step.index,\n        oldIndex: this.activeStep.index,\n        cancel: false\n      };\n      this.stepper.activeStepChanging.emit(args);\n      return args.cancel;\n    }\n    /**\n     * Updates the linearDisabled steps from the current active step to the next required invalid step.\n     *\n     * @param toIndex the index of the last step that should be enabled.\n     */\n\n\n    updateLinearDisabledSteps(toIndex) {\n      this.stepper.steps.forEach(s => {\n        if (s.index > this.activeStep.index) {\n          if (s.index <= toIndex) {\n            this.linearDisabledSteps.delete(s);\n          } else {\n            this.linearDisabledSteps.add(s);\n          }\n        }\n      });\n    }\n\n    getNextRequiredStep() {\n      if (!this.activeStep) {\n        return;\n      }\n\n      return this.stepper.steps.findIndex(s => s.index > this.activeStep.index && !s.optional && !s.disabled && !s.isValid);\n    }\n\n  }\n\n  IgxStepperService.ɵfac = function IgxStepperService_Factory(t) {\n    return new (t || IgxStepperService)();\n  };\n\n  IgxStepperService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxStepperService,\n    factory: IgxStepperService.ɵfac\n  });\n  return IgxStepperService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxStepActiveIndicatorDirective = /*#__PURE__*/(() => {\n  class IgxStepActiveIndicatorDirective {}\n\n  IgxStepActiveIndicatorDirective.ɵfac = function IgxStepActiveIndicatorDirective_Factory(t) {\n    return new (t || IgxStepActiveIndicatorDirective)();\n  };\n\n  IgxStepActiveIndicatorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxStepActiveIndicatorDirective,\n    selectors: [[\"\", \"igxStepActiveIndicator\", \"\"]]\n  });\n  return IgxStepActiveIndicatorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxStepCompletedIndicatorDirective = /*#__PURE__*/(() => {\n  class IgxStepCompletedIndicatorDirective {}\n\n  IgxStepCompletedIndicatorDirective.ɵfac = function IgxStepCompletedIndicatorDirective_Factory(t) {\n    return new (t || IgxStepCompletedIndicatorDirective)();\n  };\n\n  IgxStepCompletedIndicatorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxStepCompletedIndicatorDirective,\n    selectors: [[\"\", \"igxStepCompletedIndicator\", \"\"]]\n  });\n  return IgxStepCompletedIndicatorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxStepInvalidIndicatorDirective = /*#__PURE__*/(() => {\n  class IgxStepInvalidIndicatorDirective {}\n\n  IgxStepInvalidIndicatorDirective.ɵfac = function IgxStepInvalidIndicatorDirective_Factory(t) {\n    return new (t || IgxStepInvalidIndicatorDirective)();\n  };\n\n  IgxStepInvalidIndicatorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxStepInvalidIndicatorDirective,\n    selectors: [[\"\", \"igxStepInvalidIndicator\", \"\"]]\n  });\n  return IgxStepInvalidIndicatorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxStepIndicatorDirective = /*#__PURE__*/(() => {\n  class IgxStepIndicatorDirective {}\n\n  IgxStepIndicatorDirective.ɵfac = function IgxStepIndicatorDirective_Factory(t) {\n    return new (t || IgxStepIndicatorDirective)();\n  };\n\n  IgxStepIndicatorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxStepIndicatorDirective,\n    selectors: [[\"\", \"igxStepIndicator\", \"\"]]\n  });\n  return IgxStepIndicatorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxStepTitleDirective = /*#__PURE__*/(() => {\n  class IgxStepTitleDirective {\n    constructor() {\n      this.defaultClass = true;\n    }\n\n  }\n\n  IgxStepTitleDirective.ɵfac = function IgxStepTitleDirective_Factory(t) {\n    return new (t || IgxStepTitleDirective)();\n  };\n\n  IgxStepTitleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxStepTitleDirective,\n    selectors: [[\"\", \"igxStepTitle\", \"\"]],\n    hostVars: 2,\n    hostBindings: function IgxStepTitleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-stepper__step-title\", ctx.defaultClass);\n      }\n    }\n  });\n  return IgxStepTitleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxStepSubTitleDirective = /*#__PURE__*/(() => {\n  class IgxStepSubTitleDirective {\n    constructor() {\n      this.defaultClass = true;\n    }\n\n  }\n\n  IgxStepSubTitleDirective.ɵfac = function IgxStepSubTitleDirective_Factory(t) {\n    return new (t || IgxStepSubTitleDirective)();\n  };\n\n  IgxStepSubTitleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxStepSubTitleDirective,\n    selectors: [[\"\", \"igxStepSubTitle\", \"\"]],\n    hostVars: 2,\n    hostBindings: function IgxStepSubTitleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-stepper__step-subtitle\", ctx.defaultClass);\n      }\n    }\n  });\n  return IgxStepSubTitleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxStepContentDirective = /*#__PURE__*/(() => {\n  class IgxStepContentDirective {\n    constructor(step, stepperService, elementRef) {\n      this.step = step;\n      this.stepperService = stepperService;\n      this.elementRef = elementRef;\n      this.defaultClass = true;\n      this.role = 'tabpanel';\n      this.id = this.target.id.replace('step', 'content');\n      this._tabIndex = null;\n    }\n\n    get target() {\n      return this.step;\n    }\n\n    get stepId() {\n      return this.target.id;\n    }\n\n    get tabIndex() {\n      if (this._tabIndex !== null) {\n        return this._tabIndex;\n      }\n\n      return this.stepperService.activeStep === this.target ? 0 : -1;\n    }\n\n    set tabIndex(val) {\n      this._tabIndex = val;\n    }\n\n  }\n\n  IgxStepContentDirective.ɵfac = function IgxStepContentDirective_Factory(t) {\n    return new (t || IgxStepContentDirective)(i0.ɵɵdirectiveInject(IGX_STEP_COMPONENT), i0.ɵɵdirectiveInject(IgxStepperService), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxStepContentDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxStepContentDirective,\n    selectors: [[\"\", \"igxStepContent\", \"\"]],\n    hostVars: 6,\n    hostBindings: function IgxStepContentDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"aria-labelledby\", ctx.stepId)(\"id\", ctx.id)(\"tabindex\", ctx.tabIndex);\n        i0.ɵɵclassProp(\"igx-stepper__step-content\", ctx.defaultClass);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      tabIndex: \"tabIndex\"\n    }\n  });\n  return IgxStepContentDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID$1 = 0;\n/**\n * The IgxStepComponent is used within the `igx-stepper` element and it holds the content of each step.\n * It also supports custom indicators, title and subtitle.\n *\n * @igxModule IgxStepperModule\n *\n * @igxKeywords step\n *\n * @example\n * ```html\n *  <igx-stepper>\n *  ...\n *    <igx-step [active]=\"true\" [completed]=\"true\">\n *      ...\n *    </igx-step>\n *  ...\n *  </igx-stepper>\n * ```\n */\n\nlet IgxStepComponent = /*#__PURE__*/(() => {\n  class IgxStepComponent extends ToggleAnimationPlayer {\n    constructor(stepper, cdr, renderer, platform, stepperService, builder, element, dir) {\n      super(builder);\n      this.stepper = stepper;\n      this.cdr = cdr;\n      this.renderer = renderer;\n      this.platform = platform;\n      this.stepperService = stepperService;\n      this.builder = builder;\n      this.element = element;\n      this.dir = dir;\n      /**\n       * Get/Set the `id` of the step component.\n       * Default value is `\"igx-step-0\"`;\n       * ```html\n       * <igx-step id=\"my-first-step\"></igx-step>\n       * ```\n       * ```typescript\n       * const stepId = this.step.id;\n       * ```\n       */\n\n      this.id = `igx-step-${NEXT_ID$1++}`;\n      /**\n       * Get/Set whether the step is completed.\n       *\n       * @remarks\n       * When set to `true` the following separator is styled `solid`.\n       *\n       * ```html\n       * <igx-stepper>\n       * ...\n       *     <igx-step [completed]=\"true\"></igx-step>\n       * ...\n       * </igx-stepper>\n       * ```\n       *\n       * ```typescript\n       * this.stepper.steps[1].completed = true;\n       * ```\n       */\n\n      this.completed = false;\n      /**\n       * Get/Set whether the step is optional.\n       *\n       * @remarks\n       * Optional steps validity does not affect the default behavior when the stepper is in linear mode i.e.\n       * if optional step is invalid the user could still move to the next step.\n       *\n       * ```html\n       * <igx-step [optional]=\"true\"></igx-step>\n       * ```\n       * ```typescript\n       * this.stepper.steps[1].optional = true;\n       * ```\n       */\n\n      this.optional = false;\n      /** @hidden @internal **/\n\n      this.role = 'tab';\n      /** @hidden @internal */\n\n      this.cssClass = true;\n      /**\n       * Emitted when the step's `active` property changes. Can be used for two-way binding.\n       *\n       * ```html\n       * <igx-step [(active)]=\"this.isActive\">\n       * </igx-step>\n       * ```\n       *\n       * ```typescript\n       * const step: IgxStepComponent = this.stepper.step[0];\n       * step.activeChange.subscribe((e: boolean) => console.log(\"Step active state change to \", e))\n       * ```\n       */\n\n      this.activeChange = new EventEmitter();\n      this._tabIndex = -1;\n      this._valid = true;\n      this._focused = false;\n      this._disabled = false;\n    }\n    /**\n     * Get/Set whether the step is interactable.\n     *\n     * ```html\n     * <igx-stepper>\n     * ...\n     *     <igx-step [disabled]=\"true\"></igx-step>\n     * ...\n     * </igx-stepper>\n     * ```\n     *\n     * ```typescript\n     * this.stepper.steps[1].disabled = true;\n     * ```\n     */\n\n\n    set disabled(value) {\n      this._disabled = value;\n\n      if (this.stepper.linear) {\n        this.stepperService.calculateLinearDisabledSteps();\n      }\n    }\n\n    get disabled() {\n      return this._disabled;\n    }\n    /**\n     * Get/Set whether the step is valid.\n     *```html\n     * <igx-step [isValid]=\"form.form.valid\">\n     *      ...\n     *      <div igxStepContent>\n     *          <form #form=\"ngForm\">\n     *              ...\n     *          </form>\n     *      </div>\n     * </igx-step>\n     * ```\n     */\n\n\n    get isValid() {\n      return this._valid;\n    }\n\n    set isValid(value) {\n      this._valid = value;\n\n      if (this.stepper.linear && this.index !== undefined) {\n        this.stepperService.calculateLinearDisabledSteps();\n      }\n    }\n    /**\n     * Get/Set the active state of the step\n     *\n     * ```html\n     * <igx-step [active]=\"true\"></igx-step>\n     * ```\n     *\n     * ```typescript\n     * this.stepper.steps[1].active = true;\n     * ```\n     *\n     * @param value: boolean\n     */\n\n\n    set active(value) {\n      if (value) {\n        this.stepperService.expandThroughApi(this);\n      } else {\n        this.stepperService.collapse(this);\n      }\n    }\n\n    get active() {\n      return this.stepperService.activeStep === this;\n    }\n    /** @hidden @internal */\n\n\n    set tabIndex(value) {\n      this._tabIndex = value;\n    }\n\n    get tabIndex() {\n      return this._tabIndex;\n    }\n    /** @hidden @internal */\n\n\n    get contentId() {\n      var _a;\n\n      return (_a = this.content) === null || _a === void 0 ? void 0 : _a.id;\n    }\n    /** @hidden @internal */\n\n\n    get generalDisabled() {\n      return this.disabled || this.linearDisabled;\n    }\n    /** @hidden @internal */\n\n\n    get titlePositionTop() {\n      if (this.stepper.stepType !== IgxStepType.Full) {\n        return 'igx-stepper__step--simple';\n      }\n\n      return `igx-stepper__step--${this.titlePosition}`;\n    }\n    /**\n     * Get the step index inside of the stepper.\n     *\n     * ```typescript\n     * const step = this.stepper.steps[1];\n     * const stepIndex: number = step.index;\n     * ```\n     */\n\n\n    get index() {\n      return this._index;\n    }\n    /** @hidden @internal */\n\n\n    get indicatorTemplate() {\n      if (this.active && this.stepper.activeIndicatorTemplate) {\n        return this.stepper.activeIndicatorTemplate;\n      }\n\n      if (!this.isValid && this.stepper.invalidIndicatorTemplate) {\n        return this.stepper.invalidIndicatorTemplate;\n      }\n\n      if (this.completed && this.stepper.completedIndicatorTemplate) {\n        return this.stepper.completedIndicatorTemplate;\n      }\n\n      if (this.indicator) {\n        return this.customIndicatorTemplate;\n      }\n\n      return null;\n    }\n    /** @hidden @internal */\n\n\n    get direction() {\n      return this.stepperService.previousActiveStep && this.stepperService.previousActiveStep.index > this.index ? Direction.PREV : Direction.NEXT;\n    }\n    /** @hidden @internal */\n\n\n    get isAccessible() {\n      return !this.disabled && !this.linearDisabled;\n    }\n    /** @hidden @internal */\n\n\n    get isHorizontal() {\n      return this.stepper.orientation === IgxStepperOrientation.Horizontal;\n    }\n    /** @hidden @internal */\n\n\n    get isTitleVisible() {\n      return this.stepper.stepType !== IgxStepType.Indicator;\n    }\n    /** @hidden @internal */\n\n\n    get isIndicatorVisible() {\n      return this.stepper.stepType !== IgxStepType.Title;\n    }\n    /** @hidden @internal */\n\n\n    get titlePosition() {\n      return this.stepper.titlePosition ? this.stepper.titlePosition : this.stepper._defaultTitlePosition;\n    }\n    /** @hidden @internal */\n\n\n    get linearDisabled() {\n      return this.stepperService.linearDisabledSteps.has(this);\n    }\n    /** @hidden @internal */\n\n\n    get collapsing() {\n      return this.stepperService.collapsingSteps.has(this);\n    }\n    /** @hidden @internal */\n\n\n    get animationSettings() {\n      return this.stepper.verticalAnimationSettings;\n    }\n    /** @hidden @internal */\n\n\n    get contentClasses() {\n      if (this.isHorizontal) {\n        return {\n          'igx-stepper__body-content': true,\n          'igx-stepper__body-content--active': this.active\n        };\n      } else {\n        return 'igx-stepper__step-content';\n      }\n    }\n    /** @hidden @internal */\n\n\n    get stepHeaderClasses() {\n      return {\n        'igx-stepper__step--optional': this.optional,\n        'igx-stepper__step-header--current': this.active,\n        'igx-stepper__step-header--invalid': !this.isValid && this.stepperService.visitedSteps.has(this) && !this.active && this.isAccessible\n      };\n    }\n    /** @hidden @internal */\n\n\n    get nativeElement() {\n      return this.element.nativeElement;\n    }\n    /** @hidden @internal */\n\n\n    onFocus() {\n      this._focused = true;\n      this.stepperService.focusedStep = this;\n\n      if (this.stepperService.focusedStep !== this.stepperService.activeStep) {\n        this.stepperService.activeStep.tabIndex = -1;\n      }\n    }\n    /** @hidden @internal */\n\n\n    onBlur() {\n      this._focused = false;\n      this.stepperService.activeStep.tabIndex = 0;\n    }\n    /** @hidden @internal */\n\n\n    handleKeydown(event) {\n      if (!this._focused) {\n        return;\n      }\n\n      const key = event.key;\n\n      if (this.stepper.orientation === IgxStepperOrientation.Horizontal) {\n        if (key === this.platform.KEYMAP.ARROW_UP || key === this.platform.KEYMAP.ARROW_DOWN) {\n          return;\n        }\n      }\n\n      if (!(this.platform.isNavigationKey(key) || this.platform.isActivationKey(event))) {\n        return;\n      }\n\n      event.preventDefault();\n      this.handleNavigation(key);\n    }\n    /** @hidden @internal */\n\n\n    ngAfterViewInit() {\n      this.openAnimationDone.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        if (this.stepperService.activeStep === this) {\n          this.stepper.activeStepChanged.emit({\n            owner: this.stepper,\n            index: this.index\n          });\n        }\n      });\n      this.closeAnimationDone.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        this.stepperService.collapse(this);\n        this.cdr.markForCheck();\n      });\n    }\n    /** @hidden @internal */\n\n\n    ngOnDestroy() {\n      super.ngOnDestroy();\n    }\n    /** @hidden @internal */\n\n\n    onPointerDown(event) {\n      event.stopPropagation();\n\n      if (this.isHorizontal) {\n        this.changeHorizontalActiveStep();\n      } else {\n        this.changeVerticalActiveStep();\n      }\n    }\n    /** @hidden @internal */\n\n\n    handleNavigation(key) {\n      var _a, _b, _c, _d, _e, _f, _g, _h;\n\n      switch (key) {\n        case this.platform.KEYMAP.HOME:\n          (_a = this.stepper.steps.filter(s => s.isAccessible)[0]) === null || _a === void 0 ? void 0 : _a.nativeElement.focus();\n          break;\n\n        case this.platform.KEYMAP.END:\n          (_b = this.stepper.steps.filter(s => s.isAccessible).pop()) === null || _b === void 0 ? void 0 : _b.nativeElement.focus();\n          break;\n\n        case this.platform.KEYMAP.ARROW_UP:\n          (_c = this.previousStep) === null || _c === void 0 ? void 0 : _c.nativeElement.focus();\n          break;\n\n        case this.platform.KEYMAP.ARROW_LEFT:\n          if (this.dir.rtl && this.stepper.orientation === IgxStepperOrientation.Horizontal) {\n            (_d = this.nextStep) === null || _d === void 0 ? void 0 : _d.nativeElement.focus();\n          } else {\n            (_e = this.previousStep) === null || _e === void 0 ? void 0 : _e.nativeElement.focus();\n          }\n\n          break;\n\n        case this.platform.KEYMAP.ARROW_DOWN:\n          (_f = this.nextStep) === null || _f === void 0 ? void 0 : _f.nativeElement.focus();\n          break;\n\n        case this.platform.KEYMAP.ARROW_RIGHT:\n          if (this.dir.rtl && this.stepper.orientation === IgxStepperOrientation.Horizontal) {\n            (_g = this.previousStep) === null || _g === void 0 ? void 0 : _g.nativeElement.focus();\n          } else {\n            (_h = this.nextStep) === null || _h === void 0 ? void 0 : _h.nativeElement.focus();\n          }\n\n          break;\n\n        case this.platform.KEYMAP.SPACE:\n        case this.platform.KEYMAP.ENTER:\n          if (this.isHorizontal) {\n            this.changeHorizontalActiveStep();\n          } else {\n            this.changeVerticalActiveStep();\n          }\n\n          break;\n\n        default:\n          return;\n      }\n    }\n    /** @hidden @internal */\n\n\n    changeHorizontalActiveStep() {\n      if (this.stepper.animationType === HorizontalAnimationType.none && this.stepperService.activeStep !== this) {\n        const argsCanceled = this.stepperService.emitActivatingEvent(this);\n\n        if (argsCanceled) {\n          return;\n        }\n\n        this.active = true;\n        this.stepper.activeStepChanged.emit({\n          owner: this.stepper,\n          index: this.index\n        });\n        return;\n      }\n\n      this.stepperService.expand(this);\n\n      if (this.stepper.animationType === HorizontalAnimationType.fade) {\n        if (this.stepperService.collapsingSteps.has(this.stepperService.previousActiveStep)) {\n          this.stepperService.previousActiveStep.active = false;\n        }\n      }\n    }\n\n    get nextStep() {\n      const focusedStep = this.stepperService.focusedStep;\n\n      if (focusedStep) {\n        if (focusedStep.index === this.stepper.steps.length - 1) {\n          return this.stepper.steps.find(s => s.isAccessible);\n        }\n\n        const nextAccessible = this.stepper.steps.find((s, i) => i > focusedStep.index && s.isAccessible);\n        return nextAccessible ? nextAccessible : this.stepper.steps.find(s => s.isAccessible);\n      }\n\n      return null;\n    }\n\n    get previousStep() {\n      const focusedStep = this.stepperService.focusedStep;\n\n      if (focusedStep) {\n        if (focusedStep.index === 0) {\n          return this.stepper.steps.filter(s => s.isAccessible).pop();\n        }\n\n        let prevStep;\n\n        for (let i = focusedStep.index - 1; i >= 0; i--) {\n          const step = this.stepper.steps[i];\n\n          if (step.isAccessible) {\n            prevStep = step;\n            break;\n          }\n        }\n\n        return prevStep ? prevStep : this.stepper.steps.filter(s => s.isAccessible).pop();\n      }\n\n      return null;\n    }\n\n    changeVerticalActiveStep() {\n      var _a, _b;\n\n      this.stepperService.expand(this);\n\n      if (!this.animationSettings.closeAnimation) {\n        (_a = this.stepperService.previousActiveStep.openAnimationPlayer) === null || _a === void 0 ? void 0 : _a.finish();\n      }\n\n      if (!this.animationSettings.openAnimation) {\n        (_b = this.stepperService.activeStep.closeAnimationPlayer) === null || _b === void 0 ? void 0 : _b.finish();\n      }\n    }\n\n  }\n\n  IgxStepComponent.ɵfac = function IgxStepComponent_Factory(t) {\n    return new (t || IgxStepComponent)(i0.ɵɵdirectiveInject(IGX_STEPPER_COMPONENT), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(PlatformUtil), i0.ɵɵdirectiveInject(IgxStepperService), i0.ɵɵdirectiveInject(i1.AnimationBuilder), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(IgxDirectionality));\n  };\n\n  IgxStepComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxStepComponent,\n    selectors: [[\"igx-step\"]],\n    contentQueries: function IgxStepComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxStepIndicatorDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, IgxStepContentDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.indicator = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.content = _t.first);\n      }\n    },\n    viewQuery: function IgxStepComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c273, 7);\n        i0.ɵɵviewQuery(_c274, 7);\n        i0.ɵɵviewQuery(_c275, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.customIndicatorTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentContainer = _t.first);\n      }\n    },\n    hostVars: 13,\n    hostBindings: function IgxStepComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focus\", function IgxStepComponent_focus_HostBindingHandler() {\n          return ctx.onFocus();\n        })(\"blur\", function IgxStepComponent_blur_HostBindingHandler() {\n          return ctx.onBlur();\n        })(\"keydown\", function IgxStepComponent_keydown_HostBindingHandler($event) {\n          return ctx.handleKeydown($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id)(\"aria-selected\", ctx.active)(\"tabindex\", ctx.tabIndex)(\"role\", ctx.role)(\"aria-controls\", ctx.contentId);\n        i0.ɵɵclassMap(ctx.titlePositionTop);\n        i0.ɵɵclassProp(\"igx-stepper__step--completed\", ctx.completed)(\"igx-stepper__step\", ctx.cssClass)(\"igx-stepper__step--disabled\", ctx.generalDisabled);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      disabled: \"disabled\",\n      completed: \"completed\",\n      isValid: \"isValid\",\n      optional: \"optional\",\n      active: \"active\",\n      tabIndex: \"tabIndex\"\n    },\n    outputs: {\n      activeChange: \"activeChange\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IGX_STEP_COMPONENT,\n      useExisting: IgxStepComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c277,\n    decls: 13,\n    vars: 4,\n    consts: [[\"defaultTitle\", \"\"], [\"contentTemplate\", \"\"], [\"defaultIndicator\", \"\"], [\"customIndicator\", \"\"], [\"igxRipple\", \"\", 1, \"igx-stepper__step-header\", 3, \"ngClass\", \"keydown\", \"click\"], [\"class\", \"igx-stepper__step-indicator\", 4, \"ngIf\"], [1, \"igx-stepper__step-title-wrapper\"], [4, \"ngTemplateOutlet\"], [4, \"ngIf\"], [3, \"ngClass\"], [\"contentContainer\", \"\"], [1, \"igx-stepper__step-indicator\"], [1, \"igx-stepper__step-content-wrapper\"]],\n    template: function IgxStepComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c276);\n        i0.ɵɵtemplate(0, IgxStepComponent_ng_template_0_Template, 2, 2, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, IgxStepComponent_ng_template_2_Template, 3, 2, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(4, IgxStepComponent_ng_template_4_Template, 2, 1, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(6, IgxStepComponent_ng_template_6_Template, 1, 0, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementStart(8, \"div\", 4);\n        i0.ɵɵlistener(\"keydown\", function IgxStepComponent_Template_div_keydown_8_listener($event) {\n          return ctx.handleKeydown($event);\n        })(\"click\", function IgxStepComponent_Template_div_click_8_listener($event) {\n          return ctx.onPointerDown($event);\n        });\n        i0.ɵɵtemplate(9, IgxStepComponent_div_9_Template, 2, 1, \"div\", 5);\n        i0.ɵɵelementStart(10, \"div\", 6);\n        i0.ɵɵtemplate(11, IgxStepComponent_ng_container_11_Template, 1, 0, \"ng-container\", 7);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵtemplate(12, IgxStepComponent_ng_container_12_Template, 3, 1, \"ng-container\", 8);\n      }\n\n      if (rf & 2) {\n        const _r0 = i0.ɵɵreference(1);\n\n        i0.ɵɵadvance(8);\n        i0.ɵɵproperty(\"ngClass\", ctx.stepHeaderClasses);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isIndicatorVisible);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", _r0);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.isHorizontal);\n      }\n    },\n    directives: [i4.NgIf, i4.NgClass, IgxRippleDirective, i4.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return IgxStepComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // TODO: common interface between IgxCarouselComponentBase and ToggleAnimationPlayer?\n\n/**\n * IgxStepper provides a wizard-like workflow by dividing content into logical steps.\n *\n * @igxModule IgxStepperModule\n *\n * @igxKeywords stepper\n *\n * @igxGroup Layouts\n *\n * @remarks\n * The Ignite UI for Angular Stepper component allows the user to navigate between multiple steps.\n * It supports horizontal and vertical orientation as well as keyboard navigation and provides API methods to control the active step.\n * The component offers keyboard navigation and API to control the active step.\n *\n * @example\n * ```html\n * <igx-stepper>\n *  <igx-step [active]=\"true\">\n *      <igx-icon igxStepIndicator>home</igx-icon>\n *      <p igxStepTitle>Home</p>\n *      <div igxStepContent>\n *         ...\n *      </div>\n *  </igx-step>\n *  <igx-step [optional]=\"true\">\n *      <div igxStepContent>\n *          ...\n *      </div>\n *  </igx-step>\n *  <igx-step>\n *      <div igxStepContent>\n *          ...\n *      </div>\n *  </igx-step>\n * </igx-stepper>\n * ```\n */\n\n\nlet IgxStepperComponent = /*#__PURE__*/(() => {\n  class IgxStepperComponent extends IgxCarouselComponentBase {\n    constructor(cdr, animBuilder, stepperService, element) {\n      super(animBuilder, cdr);\n      this.animBuilder = animBuilder;\n      this.stepperService = stepperService;\n      this.element = element;\n      /**\n       * Get/Set the type of the steps.\n       *\n       * ```typescript\n       * this.stepper.stepType = IgxStepType.Indicator;\n       * ```\n       */\n\n      this.stepType = IgxStepType.Full;\n      /**\n       * Get/Set whether the content is displayed above the steps.\n       *\n       * @remarks\n       * Default value is `false` and the content is below the steps.\n       *\n       * ```typescript\n       * this.stepper.contentTop = true;\n       * ```\n       */\n\n      this.contentTop = false;\n      /**\n       * Get/Set the position of the steps title.\n       *\n       * @remarks\n       * The default value when the stepper is horizontally orientated is `bottom`.\n       * In vertical layout the default title position is `end`.\n       *\n       * ```typescript\n       * this.stepper.titlePosition = IgxStepperTitlePosition.Top;\n       * ```\n       */\n\n      this.titlePosition = null;\n      /** @hidden @internal **/\n\n      this.cssClass = 'igx-stepper';\n      /** @hidden @internal **/\n\n      this.role = 'tablist';\n      /**\n       * Emitted when the stepper's active step is changing.\n       *\n       *```html\n       * <igx-stepper (activeStepChanging)=\"handleActiveStepChanging($event)\">\n       * </igx-stepper>\n       * ```\n       *\n       *```typescript\n       * public handleActiveStepChanging(event: IStepChangingEventArgs) {\n       *  if (event.newIndex < event.oldIndex) {\n       *      event.cancel = true;\n       *  }\n       * }\n       *```\n       */\n\n      this.activeStepChanging = new EventEmitter();\n      /**\n       * Emitted when the active step is changed.\n       *\n       * @example\n       * ```\n       * <igx-stepper (activeStepChanged)=\"handleActiveStepChanged($event)\"></igx-stepper>\n       * ```\n       */\n\n      this.activeStepChanged = new EventEmitter();\n      /** @hidden @internal */\n\n      this.verticalAnimationSettings = {\n        openAnimation: growVerIn,\n        closeAnimation: growVerOut\n      };\n      /** @hidden @internal */\n\n      this._defaultTitlePosition = IgxStepperTitlePosition.Bottom;\n      this.destroy$ = new Subject();\n      this._orientation = IgxStepperOrientation.Horizontal;\n      this._verticalAnimationType = VerticalAnimationType.Grow;\n      this._linear = false;\n      this._defaultAnimationDuration = 350;\n      this.stepperService.stepper = this;\n    }\n    /**\n     * Get/Set the animation type of the stepper when the orientation direction is vertical.\n     *\n     * @remarks\n     * Default value is `grow`. Other possible values are `fade` and `none`.\n     *\n     * ```html\n     * <igx-stepper verticalAnimationType=\"none\">\n     * <igx-stepper>\n     * ```\n     */\n\n\n    get verticalAnimationType() {\n      return this._verticalAnimationType;\n    }\n\n    set verticalAnimationType(value) {\n      // TODO: activeChange event is not emitted for the collapsing steps (loop through collapsing steps and emit)\n      this.stepperService.collapsingSteps.clear();\n      this._verticalAnimationType = value;\n\n      switch (value) {\n        case 'grow':\n          this.verticalAnimationSettings = this.updateVerticalAnimationSettings(growVerIn, growVerOut);\n          break;\n\n        case 'fade':\n          this.verticalAnimationSettings = this.updateVerticalAnimationSettings(fadeIn, null);\n          break;\n\n        case 'none':\n          this.verticalAnimationSettings = this.updateVerticalAnimationSettings(null, null);\n          break;\n      }\n    }\n    /**\n     * Get/Set the animation type of the stepper when the orientation direction is horizontal.\n     *\n     * @remarks\n     * Default value is `grow`. Other possible values are `fade` and `none`.\n     *\n     * ```html\n     * <igx-stepper animationType=\"none\">\n     * <igx-stepper>\n     * ```\n     */\n\n\n    get horizontalAnimationType() {\n      return this.animationType;\n    }\n\n    set horizontalAnimationType(value) {\n      // TODO: activeChange event is not emitted for the collapsing steps (loop through collapsing steps and emit)\n      this.stepperService.collapsingSteps.clear();\n      this.animationType = value;\n    }\n    /**\n     * Get/Set the animation duration.\n     * ```html\n     * <igx-stepper [animationDuration]=\"500\">\n     * <igx-stepper>\n     * ```\n     */\n\n\n    get animationDuration() {\n      return this.defaultAnimationDuration;\n    }\n\n    set animationDuration(value) {\n      if (value && value > 0) {\n        this.defaultAnimationDuration = value;\n        return;\n      }\n\n      this.defaultAnimationDuration = this._defaultAnimationDuration;\n    }\n    /**\n     * Get/Set whether the stepper is linear.\n     *\n     * @remarks\n     * If the stepper is in linear mode and if the active step is valid only then the user is able to move forward.\n     *\n     * ```html\n     * <igx-stepper [linear]=\"true\"></igx-stepper>\n     * ```\n     */\n\n\n    get linear() {\n      return this._linear;\n    }\n\n    set linear(value) {\n      this._linear = value;\n\n      if (this._linear && this.steps.length > 0) {\n        // when the stepper is in linear mode we should calculate which steps should be disabled\n        // and which are visited i.e. their validity should be correctly displayed.\n        this.stepperService.calculateVisitedSteps();\n        this.stepperService.calculateLinearDisabledSteps();\n      } else {\n        this.stepperService.linearDisabledSteps.clear();\n      }\n    }\n    /**\n     * Get/Set the stepper orientation.\n     *\n     * ```typescript\n     * this.stepper.orientation = IgxStepperOrientation.Vertical;\n     * ```\n     */\n\n\n    get orientation() {\n      return this._orientation;\n    }\n\n    set orientation(value) {\n      if (this._orientation === value) {\n        return;\n      } // TODO: activeChange event is not emitted for the collapsing steps\n\n\n      this.stepperService.collapsingSteps.clear();\n      this._orientation = value;\n      this._defaultTitlePosition = this._orientation === IgxStepperOrientation.Horizontal ? IgxStepperTitlePosition.Bottom : IgxStepperTitlePosition.End;\n    }\n    /** @hidden @internal **/\n\n\n    get directionClass() {\n      return this.orientation === IgxStepperOrientation.Horizontal;\n    }\n    /**\n     * Get all steps.\n     *\n     * ```typescript\n     * const steps: IgxStepComponent[] = this.stepper.steps;\n     * ```\n     */\n\n\n    get steps() {\n      var _a;\n\n      return ((_a = this._steps) === null || _a === void 0 ? void 0 : _a.toArray()) || [];\n    }\n    /** @hidden @internal */\n\n\n    get nativeElement() {\n      return this.element.nativeElement;\n    }\n    /** @hidden @internal */\n\n\n    ngOnChanges(changes) {\n      if (changes['animationDuration']) {\n        this.verticalAnimationType = this._verticalAnimationType;\n      }\n    }\n    /** @hidden @internal */\n\n\n    ngOnInit() {\n      this.enterAnimationDone.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        this.activeStepChanged.emit({\n          owner: this,\n          index: this.stepperService.activeStep.index\n        });\n      });\n      this.leaveAnimationDone.pipe(takeUntil(this.destroy$)).subscribe(() => {\n        if (this.stepperService.collapsingSteps.size === 1) {\n          this.stepperService.collapse(this.stepperService.previousActiveStep);\n        } else {\n          Array.from(this.stepperService.collapsingSteps).slice(0, this.stepperService.collapsingSteps.size - 1).forEach(step => this.stepperService.collapse(step));\n        }\n      });\n    }\n    /** @hidden @internal */\n\n\n    ngAfterContentInit() {\n      let activeStep;\n      this.steps.forEach((step, index) => {\n        this.updateStepAria(step, index);\n\n        if (!activeStep && step.active) {\n          activeStep = step;\n        }\n      });\n\n      if (!activeStep) {\n        this.activateFirstStep(true);\n      }\n\n      this.handleStepChanges();\n    }\n    /** @hidden @internal */\n\n\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n    /**\n     * Activates the step at a given index.\n     *\n     *```typescript\n     * this.stepper.navigateTo(1);\n     *```\n     */\n\n\n    navigateTo(index) {\n      const step = this.steps[index];\n\n      if (!step || this.stepperService.activeStep === step) {\n        return;\n      }\n\n      this.activateStep(step);\n    }\n    /**\n     * Activates the next enabled step.\n     *\n     *```typescript\n     * this.stepper.next();\n     *```\n     */\n\n\n    next() {\n      this.moveToNextStep();\n    }\n    /**\n     * Activates the previous enabled step.\n     *\n     *```typescript\n     * this.stepper.prev();\n     *```\n     */\n\n\n    prev() {\n      this.moveToNextStep(false);\n    }\n    /**\n     * Resets the stepper to its initial state i.e. activates the first step.\n     *\n     * @remarks\n     * The steps' content will not be automatically reset.\n     *```typescript\n     * this.stepper.reset();\n     *```\n     */\n\n\n    reset() {\n      this.stepperService.visitedSteps.clear();\n      const activeStep = this.steps.find(s => !s.disabled);\n\n      if (activeStep) {\n        this.activateStep(activeStep);\n      }\n    }\n    /** @hidden @internal */\n\n\n    playHorizontalAnimations() {\n      this.previousItem = this.stepperService.previousActiveStep;\n      this.currentItem = this.stepperService.activeStep;\n      this.triggerAnimations();\n    }\n\n    getPreviousElement() {\n      var _a;\n\n      return (_a = this.stepperService.previousActiveStep) === null || _a === void 0 ? void 0 : _a.contentContainer.nativeElement;\n    }\n\n    getCurrentElement() {\n      return this.stepperService.activeStep.contentContainer.nativeElement;\n    }\n\n    updateVerticalAnimationSettings(openAnimation, closeAnimation) {\n      const customCloseAnimation = useAnimation(closeAnimation, {\n        params: {\n          duration: this.animationDuration + 'ms'\n        }\n      });\n      const customOpenAnimation = useAnimation(openAnimation, {\n        params: {\n          duration: this.animationDuration + 'ms'\n        }\n      });\n      return {\n        openAnimation: openAnimation ? customOpenAnimation : null,\n        closeAnimation: closeAnimation ? customCloseAnimation : null\n      };\n    }\n\n    updateStepAria(step, index) {\n      step._index = index;\n      step.renderer.setAttribute(step.nativeElement, 'aria-setsize', this.steps.length.toString());\n      step.renderer.setAttribute(step.nativeElement, 'aria-posinset', (index + 1).toString());\n    }\n\n    handleStepChanges() {\n      this._steps.changes.pipe(takeUntil(this.destroy$)).subscribe(steps => {\n        Promise.resolve().then(() => {\n          steps.forEach((step, index) => {\n            this.updateStepAria(step, index);\n          }); // when the active step is removed\n\n          const hasActiveStep = this.steps.find(s => s === this.stepperService.activeStep);\n\n          if (!hasActiveStep) {\n            this.activateFirstStep();\n          } // TO DO: mark step added before the active as visited?\n\n\n          if (this.linear) {\n            this.stepperService.calculateLinearDisabledSteps();\n          }\n        });\n      });\n    }\n\n    activateFirstStep(activateInitially = false) {\n      const firstEnabledStep = this.steps.find(s => !s.disabled);\n\n      if (firstEnabledStep) {\n        firstEnabledStep.active = true;\n\n        if (activateInitially) {\n          firstEnabledStep.activeChange.emit(true);\n          this.activeStepChanged.emit({\n            owner: this,\n            index: firstEnabledStep.index\n          });\n        }\n      }\n    }\n\n    activateStep(step) {\n      if (this.orientation === IgxStepperOrientation.Horizontal) {\n        step.changeHorizontalActiveStep();\n      } else {\n        this.stepperService.expand(step);\n      }\n    }\n\n    moveToNextStep(next = true) {\n      let steps = this.steps;\n      let activeStepIndex = this.stepperService.activeStep.index;\n\n      if (!next) {\n        steps = this.steps.reverse();\n        activeStepIndex = steps.findIndex(s => s === this.stepperService.activeStep);\n      }\n\n      const nextStep = steps.find((s, i) => i > activeStepIndex && s.isAccessible);\n\n      if (nextStep) {\n        this.activateStep(nextStep);\n      }\n    }\n\n  }\n\n  IgxStepperComponent.ɵfac = function IgxStepperComponent_Factory(t) {\n    return new (t || IgxStepperComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.AnimationBuilder), i0.ɵɵdirectiveInject(IgxStepperService), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxStepperComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxStepperComponent,\n    selectors: [[\"igx-stepper\"]],\n    contentQueries: function IgxStepperComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxStepInvalidIndicatorDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxStepCompletedIndicatorDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxStepActiveIndicatorDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxStepComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.invalidIndicatorTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.completedIndicatorTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.activeIndicatorTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._steps = _t);\n      }\n    },\n    hostVars: 6,\n    hostBindings: function IgxStepperComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-orientation\", ctx.orientation)(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"igx-stepper\", ctx.cssClass)(\"igx-stepper--horizontal\", ctx.directionClass);\n      }\n    },\n    inputs: {\n      verticalAnimationType: \"verticalAnimationType\",\n      horizontalAnimationType: \"horizontalAnimationType\",\n      animationDuration: \"animationDuration\",\n      linear: \"linear\",\n      orientation: \"orientation\",\n      stepType: \"stepType\",\n      contentTop: \"contentTop\",\n      titlePosition: \"titlePosition\"\n    },\n    outputs: {\n      activeStepChanging: \"activeStepChanging\",\n      activeStepChanged: \"activeStepChanged\"\n    },\n    features: [i0.ɵɵProvidersFeature([IgxStepperService, {\n      provide: IGX_STEPPER_COMPONENT,\n      useExisting: IgxStepperComponent\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c279,\n    decls: 5,\n    vars: 3,\n    consts: [[\"class\", \"igx-stepper__header\", 4, \"ngIf\"], [\"class\", \"igx-stepper__body\", 4, \"ngIf\"], [\"stepTemplate\", \"\"], [1, \"igx-stepper__header\"], [4, \"ngTemplateOutlet\"], [1, \"igx-stepper__body\"], [4, \"ngFor\", \"ngForOf\"]],\n    template: function IgxStepperComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c278);\n        i0.ɵɵtemplate(0, IgxStepperComponent_div_0_Template, 2, 1, \"div\", 0);\n        i0.ɵɵtemplate(1, IgxStepperComponent_div_1_Template, 2, 1, \"div\", 1);\n        i0.ɵɵtemplate(2, IgxStepperComponent_div_2_Template, 2, 1, \"div\", 0);\n        i0.ɵɵtemplate(3, IgxStepperComponent_ng_template_3_Template, 1, 0, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.contentTop || ctx.orientation !== \"horizontal\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.orientation === \"horizontal\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.contentTop && ctx.orientation === \"horizontal\");\n      }\n    },\n    directives: [i4.NgIf, i4.NgTemplateOutlet, i4.NgForOf],\n    encapsulation: 2\n  });\n  return IgxStepperComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxStepperModule = /*#__PURE__*/(() => {\n  class IgxStepperModule {}\n\n  IgxStepperModule.ɵfac = function IgxStepperModule_Factory(t) {\n    return new (t || IgxStepperModule)();\n  };\n\n  IgxStepperModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxStepperModule\n  });\n  IgxStepperModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, IgxRippleModule]]\n  });\n  return IgxStepperModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden @internal */\n\n\nlet DateRangePickerFormatPipe = /*#__PURE__*/(() => {\n  class DateRangePickerFormatPipe {\n    transform(values, appliedFormat, locale, formatter) {\n      if (!values || !values.start && !values.end) {\n        return '';\n      }\n\n      if (formatter) {\n        return formatter(values);\n      }\n\n      let {\n        start,\n        end\n      } = values;\n\n      if (!isDate(start)) {\n        start = DateTimeUtil.parseIsoDate(start);\n      }\n\n      if (!isDate(end)) {\n        end = DateTimeUtil.parseIsoDate(end);\n      }\n\n      const startDate = appliedFormat ? DateTimeUtil.formatDate(start, appliedFormat, locale || 'en') : start === null || start === void 0 ? void 0 : start.toLocaleDateString();\n      const endDate = appliedFormat ? DateTimeUtil.formatDate(end, appliedFormat, locale || 'en') : end === null || end === void 0 ? void 0 : end.toLocaleDateString();\n      let formatted;\n\n      if (start) {\n        formatted = `${startDate} - `;\n\n        if (end) {\n          formatted += endDate;\n        }\n      }\n\n      return formatted ? formatted : '';\n    }\n\n  }\n\n  DateRangePickerFormatPipe.ɵfac = function DateRangePickerFormatPipe_Factory(t) {\n    return new (t || DateRangePickerFormatPipe)();\n  };\n\n  DateRangePickerFormatPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"dateRange\",\n    type: DateRangePickerFormatPipe,\n    pure: true\n  });\n  return DateRangePickerFormatPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden @internal */\n\n\nlet IgxDateRangeInputsBaseComponent = /*#__PURE__*/(() => {\n  class IgxDateRangeInputsBaseComponent extends IgxInputGroupComponent {\n    /** @hidden @internal */\n    get nativeElement() {\n      return this.element.nativeElement;\n    }\n    /** @hidden @internal */\n\n\n    setFocus() {\n      this.input.focus();\n    }\n    /** @hidden @internal */\n\n\n    updateInputValue(value) {\n      if (this.ngControl) {\n        this.ngControl.control.setValue(value);\n      } else {\n        this.dateTimeEditor.value = value;\n      }\n    }\n    /** @hidden @internal */\n\n\n    updateInputValidity(state) {\n      this.inputDirective.valid = state;\n    }\n\n  }\n\n  IgxDateRangeInputsBaseComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxDateRangeInputsBaseComponent_BaseFactory;\n    return function IgxDateRangeInputsBaseComponent_Factory(t) {\n      return (ɵIgxDateRangeInputsBaseComponent_BaseFactory || (ɵIgxDateRangeInputsBaseComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxDateRangeInputsBaseComponent)))(t || IgxDateRangeInputsBaseComponent);\n    };\n  }();\n\n  IgxDateRangeInputsBaseComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxDateRangeInputsBaseComponent,\n    selectors: [[\"igx-date-range-base\"]],\n    contentQueries: function IgxDateRangeInputsBaseComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxDateTimeEditorDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, IgxInputDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, NgControl, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dateTimeEditor = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputDirective = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.ngControl = _t.first);\n      }\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxInputGroupBase,\n      useExisting: IgxDateRangeInputsBaseComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function IgxDateRangeInputsBaseComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return IgxDateRangeInputsBaseComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Defines the start input for a date range picker\n *\n * @igxModule IgxDateRangePickerModule\n *\n * @igxTheme igx-input-group-theme, igx-calendar-theme, igx-date-range-picker-theme\n *\n * @igxKeywords date, range, date range, date picker\n *\n * @igxGroup scheduling\n *\n * @remarks\n * When templating, start input has to be templated separately\n *\n * @example\n * ```html\n * <igx-date-range-picker mode=\"dropdown\">\n *      <igx-date-range-start>\n *          <input igxInput igxDateTimeEditor type=\"text\">\n *      </igx-date-range-start>\n *      ...\n * </igx-date-range-picker>\n * ```\n */\n\n\nlet IgxDateRangeStartComponent = /*#__PURE__*/(() => {\n  class IgxDateRangeStartComponent extends IgxDateRangeInputsBaseComponent {}\n\n  IgxDateRangeStartComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxDateRangeStartComponent_BaseFactory;\n    return function IgxDateRangeStartComponent_Factory(t) {\n      return (ɵIgxDateRangeStartComponent_BaseFactory || (ɵIgxDateRangeStartComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxDateRangeStartComponent)))(t || IgxDateRangeStartComponent);\n    };\n  }();\n\n  IgxDateRangeStartComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxDateRangeStartComponent,\n    selectors: [[\"igx-date-range-start\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxInputGroupBase,\n      useExisting: IgxDateRangeStartComponent\n    }, {\n      provide: IgxDateRangeInputsBaseComponent,\n      useExisting: IgxDateRangeStartComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c14,\n    decls: 26,\n    vars: 3,\n    consts: [[\"class\", \"igx-input-group__wrapper\", 4, \"ngIf\", \"ngIfElse\"], [\"class\", \"igx-input-group__border\", 4, \"ngIf\"], [1, \"igx-input-group__hint\", 3, \"click\"], [\"label\", \"\"], [\"input\", \"\"], [\"prefix\", \"\"], [\"uploadButton\", \"\"], [\"files\", \"\"], [\"clear\", \"\"], [\"suffix\", \"\"], [\"materialBundle\", \"\"], [\"fluentBundle\", \"\"], [\"bootstrapBundle\", \"\"], [\"bundle\", \"\"], [1, \"igx-input-group__wrapper\"], [4, \"ngTemplateOutlet\"], [1, \"igx-input-group__border\"], [\"class\", \"igx-prefix--upload\", 4, \"ngIf\"], [1, \"igx-prefix--upload\"], [\"igxButton\", \"raised\", 3, \"displayDensity\", \"disabled\", \"ngClass\", \"click\"], [\"class\", \"igx-input-group__file-input\", 3, \"title\", 4, \"ngIf\"], [1, \"igx-input-group__file-input\", 3, \"title\"], [\"class\", \"igx-input-group__clear-icon\", \"title\", \"clear files\", \"tabindex\", \"0\", 3, \"click\", \"keydown.Enter\", 4, \"ngIf\"], [\"title\", \"clear files\", \"tabindex\", \"0\", 1, \"igx-input-group__clear-icon\", 3, \"click\", \"keydown.Enter\"], [1, \"igx-input-group__bundle\"], [1, \"igx-input-group__bundle-main\"], [3, \"ngSwitch\"], [4, \"ngSwitchCase\"], [4, \"ngSwitchDefault\"]],\n    template: function IgxDateRangeStartComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c13);\n        i0.ɵɵtemplate(0, IgxDateRangeStartComponent_div_0_Template, 2, 1, \"div\", 0);\n        i0.ɵɵtemplate(1, IgxDateRangeStartComponent_div_1_Template, 1, 0, \"div\", 1);\n        i0.ɵɵelementStart(2, \"div\", 2);\n        i0.ɵɵlistener(\"click\", function IgxDateRangeStartComponent_Template_div_click_2_listener($event) {\n          return ctx.hintClickHandler($event);\n        });\n        i0.ɵɵprojection(3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(4, IgxDateRangeStartComponent_ng_template_4_Template, 1, 0, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(6, IgxDateRangeStartComponent_ng_template_6_Template, 1, 0, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(8, IgxDateRangeStartComponent_ng_template_8_Template, 1, 0, \"ng-template\", null, 5, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(10, IgxDateRangeStartComponent_ng_template_10_Template, 1, 1, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(12, IgxDateRangeStartComponent_ng_template_12_Template, 1, 1, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(14, IgxDateRangeStartComponent_ng_template_14_Template, 1, 1, \"ng-template\", null, 8, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(16, IgxDateRangeStartComponent_ng_template_16_Template, 1, 0, \"ng-template\", null, 9, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(18, IgxDateRangeStartComponent_ng_template_18_Template, 9, 7, \"ng-template\", null, 10, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(20, IgxDateRangeStartComponent_ng_template_20_Template, 9, 7, \"ng-template\", null, 11, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(22, IgxDateRangeStartComponent_ng_template_22_Template, 8, 7, \"ng-template\", null, 12, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(24, IgxDateRangeStartComponent_ng_template_24_Template, 5, 4, \"ng-template\", null, 13, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        const _r22 = i0.ɵɵreference(25);\n\n        i0.ɵɵproperty(\"ngIf\", ctx.isTypeBox)(\"ngIfElse\", _r22);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasBorder);\n      }\n    },\n    directives: [IgxIconComponent, i4.NgIf, i4.NgTemplateOutlet, IgxPrefixDirective, IgxButtonDirective, i4.NgClass, IgxSuffixDirective, i4.NgSwitch, i4.NgSwitchCase, i4.NgSwitchDefault],\n    encapsulation: 2\n  });\n  return IgxDateRangeStartComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Defines the end input for a date range picker\n *\n * @igxModule IgxDateRangeModule\n *\n * @igxTheme igx-input-group-theme, igx-calendar-theme, igx-date-range-picker-theme\n *\n * @igxKeywords date, range, date range, date picker\n *\n * @igxGroup scheduling\n *\n * @remarks\n * When templating, end input has to be template separately\n *\n * @example\n * ```html\n * <igx-date-range-picker mode=\"dropdown\">\n *      <igx-date-range-end>\n *          <input igxInput igxDateTimeEditor type=\"text\">\n *      </igx-date-range-end>\n *      ...\n * </igx-date-range-picker>\n * ```\n */\n\n\nlet IgxDateRangeEndComponent = /*#__PURE__*/(() => {\n  class IgxDateRangeEndComponent extends IgxDateRangeInputsBaseComponent {}\n\n  IgxDateRangeEndComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxDateRangeEndComponent_BaseFactory;\n    return function IgxDateRangeEndComponent_Factory(t) {\n      return (ɵIgxDateRangeEndComponent_BaseFactory || (ɵIgxDateRangeEndComponent_BaseFactory = i0.ɵɵgetInheritedFactory(IgxDateRangeEndComponent)))(t || IgxDateRangeEndComponent);\n    };\n  }();\n\n  IgxDateRangeEndComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxDateRangeEndComponent,\n    selectors: [[\"igx-date-range-end\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxInputGroupBase,\n      useExisting: IgxDateRangeEndComponent\n    }, {\n      provide: IgxDateRangeInputsBaseComponent,\n      useExisting: IgxDateRangeEndComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c14,\n    decls: 26,\n    vars: 3,\n    consts: [[\"class\", \"igx-input-group__wrapper\", 4, \"ngIf\", \"ngIfElse\"], [\"class\", \"igx-input-group__border\", 4, \"ngIf\"], [1, \"igx-input-group__hint\", 3, \"click\"], [\"label\", \"\"], [\"input\", \"\"], [\"prefix\", \"\"], [\"uploadButton\", \"\"], [\"files\", \"\"], [\"clear\", \"\"], [\"suffix\", \"\"], [\"materialBundle\", \"\"], [\"fluentBundle\", \"\"], [\"bootstrapBundle\", \"\"], [\"bundle\", \"\"], [1, \"igx-input-group__wrapper\"], [4, \"ngTemplateOutlet\"], [1, \"igx-input-group__border\"], [\"class\", \"igx-prefix--upload\", 4, \"ngIf\"], [1, \"igx-prefix--upload\"], [\"igxButton\", \"raised\", 3, \"displayDensity\", \"disabled\", \"ngClass\", \"click\"], [\"class\", \"igx-input-group__file-input\", 3, \"title\", 4, \"ngIf\"], [1, \"igx-input-group__file-input\", 3, \"title\"], [\"class\", \"igx-input-group__clear-icon\", \"title\", \"clear files\", \"tabindex\", \"0\", 3, \"click\", \"keydown.Enter\", 4, \"ngIf\"], [\"title\", \"clear files\", \"tabindex\", \"0\", 1, \"igx-input-group__clear-icon\", 3, \"click\", \"keydown.Enter\"], [1, \"igx-input-group__bundle\"], [1, \"igx-input-group__bundle-main\"], [3, \"ngSwitch\"], [4, \"ngSwitchCase\"], [4, \"ngSwitchDefault\"]],\n    template: function IgxDateRangeEndComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c13);\n        i0.ɵɵtemplate(0, IgxDateRangeEndComponent_div_0_Template, 2, 1, \"div\", 0);\n        i0.ɵɵtemplate(1, IgxDateRangeEndComponent_div_1_Template, 1, 0, \"div\", 1);\n        i0.ɵɵelementStart(2, \"div\", 2);\n        i0.ɵɵlistener(\"click\", function IgxDateRangeEndComponent_Template_div_click_2_listener($event) {\n          return ctx.hintClickHandler($event);\n        });\n        i0.ɵɵprojection(3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(4, IgxDateRangeEndComponent_ng_template_4_Template, 1, 0, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(6, IgxDateRangeEndComponent_ng_template_6_Template, 1, 0, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(8, IgxDateRangeEndComponent_ng_template_8_Template, 1, 0, \"ng-template\", null, 5, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(10, IgxDateRangeEndComponent_ng_template_10_Template, 1, 1, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(12, IgxDateRangeEndComponent_ng_template_12_Template, 1, 1, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(14, IgxDateRangeEndComponent_ng_template_14_Template, 1, 1, \"ng-template\", null, 8, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(16, IgxDateRangeEndComponent_ng_template_16_Template, 1, 0, \"ng-template\", null, 9, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(18, IgxDateRangeEndComponent_ng_template_18_Template, 9, 7, \"ng-template\", null, 10, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(20, IgxDateRangeEndComponent_ng_template_20_Template, 9, 7, \"ng-template\", null, 11, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(22, IgxDateRangeEndComponent_ng_template_22_Template, 8, 7, \"ng-template\", null, 12, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(24, IgxDateRangeEndComponent_ng_template_24_Template, 5, 4, \"ng-template\", null, 13, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        const _r22 = i0.ɵɵreference(25);\n\n        i0.ɵɵproperty(\"ngIf\", ctx.isTypeBox)(\"ngIfElse\", _r22);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasBorder);\n      }\n    },\n    directives: [IgxIconComponent, i4.NgIf, i4.NgTemplateOutlet, IgxPrefixDirective, IgxButtonDirective, i4.NgClass, IgxSuffixDirective, i4.NgSwitch, i4.NgSwitchCase, i4.NgSwitchDefault],\n    encapsulation: 2\n  });\n  return IgxDateRangeEndComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxDateRangeSeparatorDirective = /*#__PURE__*/(() => {\n  class IgxDateRangeSeparatorDirective {}\n\n  IgxDateRangeSeparatorDirective.ɵfac = function IgxDateRangeSeparatorDirective_Factory(t) {\n    return new (t || IgxDateRangeSeparatorDirective)();\n  };\n\n  IgxDateRangeSeparatorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgxDateRangeSeparatorDirective,\n    selectors: [[\"\", \"igxDateRangeSeparator\", \"\"]]\n  });\n  return IgxDateRangeSeparatorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst SingleInputDatesConcatenationString = ' - ';\n/**\n * Provides the ability to select a range of dates from a calendar UI or editable inputs.\n *\n * @igxModule IgxDateRangeModule\n *\n * @igxTheme igx-input-group-theme, igx-calendar-theme, igx-date-range-picker-theme\n *\n * @igxKeywords date, range, date range, date picker\n *\n * @igxGroup scheduling\n *\n * @remarks\n * It displays the range selection in a single or two input fields.\n * The default template displays a single *readonly* input field\n * while projecting `igx-date-range-start` and `igx-date-range-end`\n * displays two *editable* input fields.\n *\n * @example\n * ```html\n * <igx-date-range-picker mode=\"dropdown\"></igx-date-range-picker>\n * ```\n */\n\nlet IgxDateRangePickerComponent = /*#__PURE__*/(() => {\n  class IgxDateRangePickerComponent extends PickerBaseDirective {\n    constructor(element, _localeId, platform, _injector, _moduleRef, _cdr, _overlayService, _displayDensityOptions, _inputGroupType) {\n      super(element, _localeId, _displayDensityOptions, _inputGroupType);\n      this.element = element;\n      this._localeId = _localeId;\n      this.platform = platform;\n      this._injector = _injector;\n      this._moduleRef = _moduleRef;\n      this._cdr = _cdr;\n      this._overlayService = _overlayService;\n      this._displayDensityOptions = _displayDensityOptions;\n      this._inputGroupType = _inputGroupType;\n      /**\n       * The number of displayed month views.\n       *\n       * @remarks\n       * Default is `2`.\n       *\n       * @example\n       * ```html\n       * <igx-date-range-picker [displayMonthsCount]=\"3\"></igx-date-range-picker>\n       * ```\n       */\n\n      this.displayMonthsCount = 2;\n      /**\n       * The start day of the week.\n       *\n       * @remarks\n       * Can be assigned to a numeric value or to `WEEKDAYS` enum value.\n       *\n       * @example\n       * ```html\n       * <igx-date-range-picker [weekStart]=\"1\"></igx-date-range-picker>\n       * ```\n       */\n\n      this.weekStart = WEEKDAYS.SUNDAY;\n      /**\n       * Sets the `placeholder` for single-input `IgxDateRangePickerComponent`.\n       *\n       *   @example\n       * ```html\n       * <igx-date-range-picker [placeholder]=\"'Choose your dates'\"></igx-date-range-picker>\n       * ```\n       */\n\n      this.placeholder = '';\n      /**\n       * Emitted when the picker's value changes. Used for two-way binding.\n       *\n       * @example\n       * ```html\n       * <igx-date-range-picker [(value)]=\"date\"></igx-date-range-picker>\n       * ```\n       */\n\n      this.valueChange = new EventEmitter();\n      /** @hidden @internal */\n\n      this.cssClass = 'igx-date-range-picker';\n      this._resourceStrings = CurrentResourceStrings.DateRangePickerResStrings;\n      this._doneButtonText = null;\n      this._dateSeparator = null;\n      this._overlaySubFilter = [filter(x => x.id === this._overlayId), takeUntil(merge(this._destroy$, this.closed))];\n      this._dialogOverlaySettings = {\n        closeOnOutsideClick: true,\n        modal: true,\n        closeOnEscape: true\n      };\n      this._dropDownOverlaySettings = {\n        closeOnOutsideClick: true,\n        modal: false,\n        closeOnEscape: true\n      };\n      this.onChangeCallback = noop;\n      this.onTouchCallback = noop;\n      this.onValidatorChange = noop;\n\n      this.onStatusChanged = () => {\n        if (this.inputGroup) {\n          this.inputDirective.valid = this.isTouchedOrDirty ? this.getInputState(this.inputGroup.isFocused) : IgxInputState.INITIAL;\n        } else if (this.hasProjectedInputs) {\n          this.projectedInputs.forEach(i => {\n            i.inputDirective.valid = this.isTouchedOrDirty ? this.getInputState(i.isFocused) : IgxInputState.INITIAL;\n            ;\n          });\n        }\n\n        this.setRequiredToInputs();\n      };\n    }\n    /**\n     * The default text of the calendar dialog `done` button.\n     *\n     * @remarks\n     * Default value is `Done`.\n     * An @Input property that renders Done button with custom text. By default `doneButtonText` is set to Done.\n     * The button will only show up in `dialog` mode.\n     *\n     * @example\n     * ```html\n     * <igx-date-range-picker doneButtonText=\"完了\"></igx-date-range-picker>\n     * ```\n     */\n\n\n    set doneButtonText(value) {\n      this._doneButtonText = value;\n    }\n\n    get doneButtonText() {\n      if (this._doneButtonText === null) {\n        return this.resourceStrings.igx_date_range_picker_done_button;\n      }\n\n      return this._doneButtonText;\n    }\n    /**\n     * The minimum value in a valid range.\n     *\n     * @example\n     * <igx-date-range-picker [minValue]=\"minDate\"></igx-date-range-picker>\n     */\n\n\n    set minValue(value) {\n      this._minValue = value;\n      this.onValidatorChange();\n    }\n\n    get minValue() {\n      return this._minValue;\n    }\n    /**\n     * The maximum value in a valid range.\n     *\n     * @example\n     * <igx-date-range-picker [maxValue]=\"maxDate\"></igx-date-range-picker>\n     */\n\n\n    set maxValue(value) {\n      this._maxValue = value;\n      this.onValidatorChange();\n    }\n\n    get maxValue() {\n      return this._maxValue;\n    }\n    /**\n     * An accessor that sets the resource strings.\n     * By default it uses EN resources.\n     */\n\n\n    set resourceStrings(value) {\n      this._resourceStrings = Object.assign({}, this._resourceStrings, value);\n    }\n    /**\n     * An accessor that returns the resource strings.\n     */\n\n\n    get resourceStrings() {\n      return this._resourceStrings;\n    }\n    /** @hidden @internal */\n\n\n    get dateSeparator() {\n      if (this._dateSeparator === null) {\n        return this.resourceStrings.igx_date_range_picker_date_separator;\n      }\n\n      return this._dateSeparator;\n    }\n    /** @hidden @internal */\n\n\n    get appliedFormat() {\n      return DateTimeUtil.getLocaleDateFormat(this.locale, this.displayFormat) || DateTimeUtil.DEFAULT_INPUT_FORMAT;\n    }\n    /** @hidden @internal */\n\n\n    get singleInputFormat() {\n      if (this.placeholder !== '') {\n        return this.placeholder;\n      }\n\n      const format = this.appliedFormat;\n      return `${format}${SingleInputDatesConcatenationString}${format}`;\n    }\n    /**\n     * Gets calendar state.\n     *\n     * ```typescript\n     * let state = this.dateRange.collapsed;\n     * ```\n     */\n\n\n    get collapsed() {\n      return this._collapsed;\n    }\n    /**\n     * The currently selected value / range from the calendar\n     *\n     * @remarks\n     * The current value is of type `DateRange`\n     *\n     * @example\n     * ```typescript\n     * const newValue: DateRange = { start: new Date(\"2/2/2012\"), end: new Date(\"3/3/2013\")};\n     * this.dateRangePicker.value = newValue;\n     * ```\n     */\n\n\n    get value() {\n      return this._value;\n    }\n\n    set value(value) {\n      this.updateValue(value);\n      this.onChangeCallback(value);\n      this.valueChange.emit(value);\n    }\n    /** @hidden @internal */\n\n\n    get hasProjectedInputs() {\n      var _a;\n\n      return ((_a = this.projectedInputs) === null || _a === void 0 ? void 0 : _a.length) > 0;\n    }\n    /** @hidden @internal */\n\n\n    get separatorClass() {\n      return this.getComponentDensityClass('igx-date-range-picker__label');\n    }\n\n    get required() {\n      if (this._ngControl && this._ngControl.control && this._ngControl.control.validator) {\n        const error = this._ngControl.control.validator({});\n\n        return error && error.required ? true : false;\n      }\n\n      return false;\n    }\n\n    get calendar() {\n      return this._calendar;\n    }\n\n    get dropdownOverlaySettings() {\n      return Object.assign({}, this._dropDownOverlaySettings, this.overlaySettings);\n    }\n\n    get dialogOverlaySettings() {\n      return Object.assign({}, this._dialogOverlaySettings, this.overlaySettings);\n    }\n    /** @hidden @internal */\n\n\n    onKeyDown(event) {\n      switch (event.key) {\n        case this.platform.KEYMAP.ARROW_UP:\n          if (event.altKey) {\n            this.close();\n          }\n\n          break;\n\n        case this.platform.KEYMAP.ARROW_DOWN:\n          if (event.altKey) {\n            this.open();\n          }\n\n          break;\n      }\n    }\n    /**\n     * Opens the date range picker's dropdown or dialog.\n     *\n     * @example\n     * ```html\n     * <igx-date-range-picker #dateRange></igx-date-range-picker>\n     *\n     * <button (click)=\"dateRange.open()\">Open Dialog</button\n     * ```\n     */\n\n\n    open(overlaySettings) {\n      if (!this.collapsed || this.disabled) {\n        return;\n      }\n\n      const settings = Object.assign({}, this.isDropdown ? this.dropdownOverlaySettings : this.dialogOverlaySettings, overlaySettings);\n      this._overlayId = this._overlayService.attach(IgxCalendarContainerComponent, settings, this._moduleRef);\n      this.subscribeToOverlayEvents();\n\n      this._overlayService.show(this._overlayId);\n    }\n    /**\n     * Closes the date range picker's dropdown or dialog.\n     *\n     * @example\n     * ```html\n     * <igx-date-range-picker #dateRange></igx-date-range-picker>\n     *\n     * <button (click)=\"dateRange.close()\">Close Dialog</button>\n     * ```\n     */\n\n\n    close() {\n      if (!this.collapsed) {\n        this._overlayService.hide(this._overlayId);\n      }\n    }\n    /**\n     * Toggles the date range picker's dropdown or dialog\n     *\n     * @example\n     * ```html\n     * <igx-date-range-picker #dateRange></igx-date-range-picker>\n     *\n     * <button (click)=\"dateRange.toggle()\">Toggle Dialog</button>\n     * ```\n     */\n\n\n    toggle(overlaySettings) {\n      if (!this.collapsed) {\n        this.close();\n      } else {\n        this.open(overlaySettings);\n      }\n    }\n    /**\n     * Selects a range of dates. If no `endDate` is passed, range is 1 day (only `startDate`)\n     *\n     * @example\n     * ```typescript\n     * public selectFiveDayRange() {\n     *  const today = new Date();\n     *  const inFiveDays = new Date(new Date().setDate(today.getDate() + 5));\n     *  this.dateRange.select(today, inFiveDays);\n     * }\n     * ```\n     */\n\n\n    select(startDate, endDate) {\n      endDate = endDate !== null && endDate !== void 0 ? endDate : startDate;\n      const dateRange = [startDate, endDate];\n      this.handleSelection(dateRange);\n    }\n    /** @hidden @internal */\n\n\n    writeValue(value) {\n      this.updateValue(value);\n    }\n    /** @hidden @internal */\n\n\n    registerOnChange(fn) {\n      this.onChangeCallback = fn;\n    }\n    /** @hidden @internal */\n\n\n    registerOnTouched(fn) {\n      this.onTouchCallback = fn;\n    }\n    /** @hidden @internal */\n\n\n    validate(control) {\n      const value = control.value;\n      const errors = {};\n\n      if (value) {\n        if (this.hasProjectedInputs) {\n          const startInput = this.projectedInputs.find(i => i instanceof IgxDateRangeStartComponent);\n          const endInput = this.projectedInputs.find(i => i instanceof IgxDateRangeEndComponent);\n\n          if (!startInput.dateTimeEditor.value) {\n            Object.assign(errors, {\n              startValue: true\n            });\n          }\n\n          if (!endInput.dateTimeEditor.value) {\n            Object.assign(errors, {\n              endValue: true\n            });\n          }\n        }\n\n        const min = parseDate(this.minValue);\n        const max = parseDate(this.maxValue);\n        const start = parseDate(value.start);\n        const end = parseDate(value.end);\n\n        if (min && start && DateTimeUtil.lessThanMinValue(start, min, false) || min && end && DateTimeUtil.lessThanMinValue(end, min, false)) {\n          Object.assign(errors, {\n            minValue: true\n          });\n        }\n\n        if (max && start && DateTimeUtil.greaterThanMaxValue(start, max, false) || max && end && DateTimeUtil.greaterThanMaxValue(end, max, false)) {\n          Object.assign(errors, {\n            maxValue: true\n          });\n        }\n      }\n\n      return Object.keys(errors).length > 0 ? errors : null;\n    }\n    /** @hidden @internal */\n\n\n    registerOnValidatorChange(fn) {\n      this.onValidatorChange = fn;\n    }\n    /** @hidden @internal */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n    /** @hidden */\n\n\n    ngOnInit() {\n      this._ngControl = this._injector.get(NgControl, null);\n    }\n    /** @hidden */\n\n\n    ngAfterViewInit() {\n      super.ngAfterViewInit();\n      this.subscribeToDateEditorEvents();\n      this.configPositionStrategy();\n      this.configOverlaySettings();\n      this.cacheFocusedInput();\n      this.attachOnTouched();\n      this.setRequiredToInputs();\n\n      if (this._ngControl) {\n        this._statusChanges$ = this._ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));\n      } // delay invocations until the current change detection cycle has completed\n\n\n      Promise.resolve().then(() => {\n        this.updateDisabledState();\n        this.initialSetValue();\n        this.updateInputs(); // B.P. 07 July 2021 - IgxDateRangePicker not showing initial disabled state with ChangeDetectionStrategy.OnPush #9776\n\n        /**\n         * if disabled is placed on the range picker element and there are projected inputs\n         * run change detection since igxInput will initially set the projected inputs' disabled to false\n         */\n\n        if (this.hasProjectedInputs && this.disabled) {\n          this._cdr.markForCheck();\n        }\n      });\n      this.updateDisplayFormat();\n      this.updateInputFormat();\n    }\n    /** @hidden @internal */\n\n\n    ngOnChanges(changes) {\n      if (changes['displayFormat'] && this.hasProjectedInputs) {\n        this.updateDisplayFormat();\n      }\n\n      if (changes['inputFormat'] && this.hasProjectedInputs) {\n        this.updateInputFormat();\n      }\n\n      if (changes['disabled']) {\n        this.updateDisabledState();\n      }\n    }\n    /** @hidden @internal */\n\n\n    ngOnDestroy() {\n      super.ngOnDestroy();\n\n      if (this._statusChanges$) {\n        this._statusChanges$.unsubscribe();\n      }\n\n      if (this._overlayId) {\n        this._overlayService.detach(this._overlayId);\n      }\n    }\n    /** @hidden @internal */\n\n\n    getEditElement() {\n      return this.inputDirective.nativeElement;\n    }\n\n    get isTouchedOrDirty() {\n      return (this._ngControl.control.touched || this._ngControl.control.dirty) && (!!this._ngControl.control.validator || !!this._ngControl.control.asyncValidator);\n    }\n\n    handleSelection(selectionData) {\n      let newValue = this.extractRange(selectionData);\n\n      if (!newValue.start && !newValue.end) {\n        newValue = null;\n      }\n\n      this.value = newValue;\n\n      if (this.isDropdown && (selectionData === null || selectionData === void 0 ? void 0 : selectionData.length) > 1) {\n        this.close();\n      }\n    }\n\n    handleClosing(e) {\n      const args = {\n        owner: this,\n        cancel: e === null || e === void 0 ? void 0 : e.cancel,\n        event: e === null || e === void 0 ? void 0 : e.event\n      };\n      this.closing.emit(args);\n      e.cancel = args.cancel;\n\n      if (args.cancel) {\n        return;\n      }\n\n      if (this.isDropdown && (e === null || e === void 0 ? void 0 : e.event) && !this.element.nativeElement.contains(e.event.target)) {\n        // outside click\n        this.updateValidityOnBlur();\n      } else {\n        this.onTouchCallback(); // input click\n\n        if (this.hasProjectedInputs && this._focusedInput) {\n          this._focusedInput.setFocus();\n\n          this._focusedInput = null;\n        }\n\n        if (this.inputDirective) {\n          this.inputDirective.focus();\n        }\n      }\n    }\n\n    subscribeToOverlayEvents() {\n      this._overlayService.opening.pipe(...this._overlaySubFilter).subscribe(e => {\n        const overlayEvent = e;\n        const args = {\n          owner: this,\n          cancel: overlayEvent === null || overlayEvent === void 0 ? void 0 : overlayEvent.cancel,\n          event: e.event\n        };\n        this.opening.emit(args);\n\n        if (args.cancel) {\n          this._overlayService.detach(this._overlayId);\n\n          overlayEvent.cancel = true;\n          return;\n        }\n\n        this._initializeCalendarContainer(e.componentRef.instance);\n\n        this._collapsed = false;\n        this.updateCalendar();\n      });\n\n      this._overlayService.opened.pipe(...this._overlaySubFilter).subscribe(() => {\n        var _a, _b;\n\n        (_b = (_a = this.calendar) === null || _a === void 0 ? void 0 : _a.daysView) === null || _b === void 0 ? void 0 : _b.focusActiveDate();\n        this.opened.emit({\n          owner: this\n        });\n      });\n\n      this._overlayService.closing.pipe(...this._overlaySubFilter).subscribe(e => {\n        this.handleClosing(e);\n      });\n\n      this._overlayService.closed.pipe(...this._overlaySubFilter).subscribe(() => {\n        this._overlayService.detach(this._overlayId);\n\n        this._collapsed = true;\n        this._overlayId = null;\n        this.closed.emit({\n          owner: this\n        });\n      });\n    }\n\n    updateValue(value) {\n      this._value = value ? value : null;\n      this.updateInputs();\n      this.updateCalendar();\n    }\n\n    updateValidityOnBlur() {\n      this.onTouchCallback();\n\n      if (this._ngControl) {\n        if (this.hasProjectedInputs) {\n          this.projectedInputs.forEach(i => {\n            if (!this._ngControl.valid) {\n              i.updateInputValidity(IgxInputState.INVALID);\n            } else {\n              i.updateInputValidity(IgxInputState.INITIAL);\n            }\n          });\n        }\n\n        if (this.inputDirective) {\n          if (!this._ngControl.valid) {\n            this.inputDirective.valid = IgxInputState.INVALID;\n          } else {\n            this.inputDirective.valid = IgxInputState.INITIAL;\n          }\n        }\n      }\n    }\n\n    updateDisabledState() {\n      if (this.hasProjectedInputs) {\n        const start = this.projectedInputs.find(i => i instanceof IgxDateRangeStartComponent);\n        const end = this.projectedInputs.find(i => i instanceof IgxDateRangeEndComponent);\n        start.inputDirective.disabled = this.disabled;\n        end.inputDirective.disabled = this.disabled;\n        return;\n      }\n    }\n\n    getInputState(focused) {\n      if (focused) {\n        return this._ngControl.valid ? IgxInputState.VALID : IgxInputState.INVALID;\n      } else {\n        return this._ngControl.valid ? IgxInputState.INITIAL : IgxInputState.INVALID;\n      }\n    }\n\n    setRequiredToInputs() {\n      // workaround for igxInput setting required\n      Promise.resolve().then(() => {\n        const isRequired = this.required;\n\n        if (this.inputGroup && this.inputGroup.isRequired !== isRequired) {\n          this.inputGroup.isRequired = isRequired;\n        } else if (this.hasProjectedInputs && this._ngControl) {\n          this.projectedInputs.forEach(i => i.isRequired = isRequired);\n        }\n      });\n    }\n\n    parseMinValue(value) {\n      let minValue = parseDate(value);\n\n      if (!minValue && this.hasProjectedInputs) {\n        const start = this.projectedInputs.filter(i => i instanceof IgxDateRangeStartComponent)[0];\n\n        if (start) {\n          minValue = parseDate(start.dateTimeEditor.minValue);\n        }\n      }\n\n      return minValue;\n    }\n\n    parseMaxValue(value) {\n      let maxValue = parseDate(value);\n\n      if (!maxValue && this.projectedInputs) {\n        const end = this.projectedInputs.filter(i => i instanceof IgxDateRangeEndComponent)[0];\n\n        if (end) {\n          maxValue = parseDate(end.dateTimeEditor.maxValue);\n        }\n      }\n\n      return maxValue;\n    }\n\n    updateCalendar() {\n      var _a, _b;\n\n      if (!this.calendar) {\n        return;\n      }\n\n      this.calendar.disabledDates = [];\n      const minValue = this.parseMinValue(this.minValue);\n\n      if (minValue) {\n        this.calendar.disabledDates.push({\n          type: DateRangeType.Before,\n          dateRange: [minValue]\n        });\n      }\n\n      const maxValue = this.parseMaxValue(this.maxValue);\n\n      if (maxValue) {\n        this.calendar.disabledDates.push({\n          type: DateRangeType.After,\n          dateRange: [maxValue]\n        });\n      }\n\n      const range = [];\n\n      if (((_a = this.value) === null || _a === void 0 ? void 0 : _a.start) && ((_b = this.value) === null || _b === void 0 ? void 0 : _b.end)) {\n        const _value = this.toRangeOfDates(this.value);\n\n        if (DateTimeUtil.greaterThanMaxValue(_value.start, _value.end)) {\n          this.swapEditorDates();\n        }\n\n        if (this.valueInRange(this.value, minValue, maxValue)) {\n          range.push(_value.start, _value.end);\n        }\n      }\n\n      if (range.length > 0) {\n        this.calendar.selectDate(range);\n      } else if (range.length === 0 && this.calendar.monthViews) {\n        this.calendar.deselectDate();\n      }\n\n      this.calendar.viewDate = range[0] || new Date();\n    }\n\n    swapEditorDates() {\n      if (this.hasProjectedInputs) {\n        const start = this.projectedInputs.find(i => i instanceof IgxDateRangeStartComponent);\n        const end = this.projectedInputs.find(i => i instanceof IgxDateRangeEndComponent);\n        [start.dateTimeEditor.value, end.dateTimeEditor.value] = [end.dateTimeEditor.value, start.dateTimeEditor.value];\n        [this.value.start, this.value.end] = [this.value.end, this.value.start];\n      }\n    }\n\n    valueInRange(value, minValue, maxValue) {\n      const _value = this.toRangeOfDates(value);\n\n      if (minValue && DateTimeUtil.lessThanMinValue(_value.start, minValue, false)) {\n        return false;\n      }\n\n      if (maxValue && DateTimeUtil.greaterThanMaxValue(_value.end, maxValue, false)) {\n        return false;\n      }\n\n      return true;\n    }\n\n    extractRange(selection) {\n      return {\n        start: selection[0] || null,\n        end: selection.length > 0 ? selection[selection.length - 1] : null\n      };\n    }\n\n    toRangeOfDates(range) {\n      let start;\n      let end;\n\n      if (!isDate(range.start)) {\n        start = DateTimeUtil.parseIsoDate(range.start);\n      }\n\n      if (!isDate(range.end)) {\n        end = DateTimeUtil.parseIsoDate(range.end);\n      }\n\n      if (start || end) {\n        return {\n          start,\n          end\n        };\n      }\n\n      return {\n        start: range.start,\n        end: range.end\n      };\n    }\n\n    subscribeToDateEditorEvents() {\n      if (this.hasProjectedInputs) {\n        const start = this.projectedInputs.find(i => i instanceof IgxDateRangeStartComponent);\n        const end = this.projectedInputs.find(i => i instanceof IgxDateRangeEndComponent);\n\n        if (start && end) {\n          start.dateTimeEditor.valueChange.pipe(takeUntil(this._destroy$)).subscribe(value => {\n            if (this.value) {\n              this.value = {\n                start: value,\n                end: this.value.end\n              };\n            } else {\n              this.value = {\n                start: value,\n                end: null\n              };\n            }\n          });\n          end.dateTimeEditor.valueChange.pipe(takeUntil(this._destroy$)).subscribe(value => {\n            if (this.value) {\n              this.value = {\n                start: this.value.start,\n                end: value\n              };\n            } else {\n              this.value = {\n                start: null,\n                end: value\n              };\n            }\n          });\n        }\n      }\n    }\n\n    attachOnTouched() {\n      if (this.hasProjectedInputs) {\n        this.projectedInputs.forEach(i => {\n          fromEvent(i.dateTimeEditor.nativeElement, 'blur').pipe(takeUntil(this._destroy$)).subscribe(() => {\n            if (this.collapsed) {\n              this.updateValidityOnBlur();\n            }\n          });\n        });\n      } else {\n        fromEvent(this.inputDirective.nativeElement, 'blur').pipe(takeUntil(this._destroy$)).subscribe(() => {\n          if (this.collapsed) {\n            this.updateValidityOnBlur();\n          }\n        });\n      }\n    }\n\n    cacheFocusedInput() {\n      if (this.hasProjectedInputs) {\n        this.projectedInputs.forEach(i => {\n          fromEvent(i.dateTimeEditor.nativeElement, 'focus').pipe(takeUntil(this._destroy$)).subscribe(() => this._focusedInput = i);\n        });\n      }\n    }\n\n    configPositionStrategy() {\n      this._positionSettings = {\n        openAnimation: fadeIn,\n        closeAnimation: fadeOut\n      };\n      this._dropDownOverlaySettings.positionStrategy = new AutoPositionStrategy(this._positionSettings);\n      this._dropDownOverlaySettings.target = this.element.nativeElement;\n    }\n\n    configOverlaySettings() {\n      if (this.overlaySettings !== null) {\n        this._dropDownOverlaySettings = Object.assign({}, this._dropDownOverlaySettings, this.overlaySettings);\n        this._dialogOverlaySettings = Object.assign({}, this._dialogOverlaySettings, this.overlaySettings);\n      }\n    }\n\n    initialSetValue() {\n      // if there is no value and no ngControl on the picker but we have inputs we may have value set through\n      // their ngModels - we should generate our initial control value\n      if ((!this.value || !this.value.start && !this.value.end) && this.hasProjectedInputs && !this._ngControl) {\n        const start = this.projectedInputs.find(i => i instanceof IgxDateRangeStartComponent);\n        const end = this.projectedInputs.find(i => i instanceof IgxDateRangeEndComponent);\n        this._value = {\n          start: start.dateTimeEditor.value,\n          end: end.dateTimeEditor.value\n        };\n      }\n    }\n\n    updateInputs() {\n      var _a, _b;\n\n      const start = (_a = this.projectedInputs) === null || _a === void 0 ? void 0 : _a.find(i => i instanceof IgxDateRangeStartComponent);\n      const end = (_b = this.projectedInputs) === null || _b === void 0 ? void 0 : _b.find(i => i instanceof IgxDateRangeEndComponent);\n\n      if (start && end) {\n        const _value = this.value ? this.toRangeOfDates(this.value) : null;\n\n        start.updateInputValue((_value === null || _value === void 0 ? void 0 : _value.start) || null);\n        end.updateInputValue((_value === null || _value === void 0 ? void 0 : _value.end) || null);\n      }\n    }\n\n    updateDisplayFormat() {\n      this.projectedInputs.forEach(i => {\n        const input = i;\n        input.dateTimeEditor.displayFormat = this.displayFormat;\n      });\n    }\n\n    updateInputFormat() {\n      this.projectedInputs.forEach(i => {\n        const input = i;\n\n        if (input.dateTimeEditor.inputFormat !== this.inputFormat) {\n          input.dateTimeEditor.inputFormat = this.inputFormat;\n        }\n      });\n    }\n\n    _initializeCalendarContainer(componentInstance) {\n      this._calendar = componentInstance.calendar;\n      this.calendar.hasHeader = false;\n      this.calendar.locale = this.locale;\n      this.calendar.selection = CalendarSelection.RANGE;\n      this.calendar.weekStart = this.weekStart;\n      this.calendar.hideOutsideDays = this.hideOutsideDays;\n      this.calendar.monthsViewNumber = this.displayMonthsCount;\n      this.calendar.selected.pipe(takeUntil(this._destroy$)).subscribe(ev => this.handleSelection(ev));\n      componentInstance.mode = this.mode;\n      componentInstance.closeButtonLabel = !this.isDropdown ? this.doneButtonText : null;\n      componentInstance.pickerActions = this.pickerActions;\n      componentInstance.calendarClose.pipe(takeUntil(this._destroy$)).subscribe(() => this.close());\n    }\n\n  }\n\n  IgxDateRangePickerComponent.ɵfac = function IgxDateRangePickerComponent_Factory(t) {\n    return new (t || IgxDateRangePickerComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(LOCALE_ID), i0.ɵɵdirectiveInject(PlatformUtil), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.NgModuleRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(IgxOverlayService), i0.ɵɵdirectiveInject(DisplayDensityToken, 8), i0.ɵɵdirectiveInject(IGX_INPUT_GROUP_TYPE, 8));\n  };\n\n  IgxDateRangePickerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxDateRangePickerComponent,\n    selectors: [[\"igx-date-range-picker\"]],\n    contentQueries: function IgxDateRangePickerComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, IgxLabelDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, IgxPickerActionsDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, IgxDateRangeSeparatorDirective, 5, TemplateRef);\n        i0.ɵɵcontentQuery(dirIndex, IgxDateRangeInputsBaseComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.label = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.pickerActions = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dateSeparatorTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.projectedInputs = _t);\n      }\n    },\n    viewQuery: function IgxDateRangePickerComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxInputGroupComponent, 5);\n        i0.ɵɵviewQuery(IgxInputDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputGroup = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputDirective = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function IgxDateRangePickerComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function IgxDateRangePickerComponent_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-date-range-picker\", ctx.cssClass);\n      }\n    },\n    inputs: {\n      displayMonthsCount: \"displayMonthsCount\",\n      hideOutsideDays: \"hideOutsideDays\",\n      weekStart: \"weekStart\",\n      locale: \"locale\",\n      formatter: \"formatter\",\n      doneButtonText: \"doneButtonText\",\n      overlaySettings: \"overlaySettings\",\n      displayFormat: \"displayFormat\",\n      inputFormat: \"inputFormat\",\n      minValue: \"minValue\",\n      maxValue: \"maxValue\",\n      resourceStrings: \"resourceStrings\",\n      placeholder: \"placeholder\",\n      outlet: \"outlet\",\n      value: \"value\"\n    },\n    outputs: {\n      valueChange: \"valueChange\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: IgxDateRangePickerComponent,\n      multi: true\n    }, {\n      provide: NG_VALIDATORS,\n      useExisting: IgxDateRangePickerComponent,\n      multi: true\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c281,\n    decls: 11,\n    vars: 1,\n    consts: [[4, \"ngTemplateOutlet\"], [\"singleTemplate\", \"\"], [\"startEndTemplate\", \"\"], [\"defIcon\", \"\"], [\"defDateSeparatorTemplate\", \"\"], [\"defTemplate\", \"\"], [1, \"content-wrap\", 3, \"click\"], [3, \"className\"], [3, \"type\", \"displayDensity\", \"click\"], [\"igxInput\", \"\", \"type\", \"text\", \"readonly\", \"\", \"role\", \"combobox\", \"aria-haspopup\", \"grid\", 3, \"disabled\", \"placeholder\", \"value\"], [\"singleInput\", \"\"], [4, \"ngIf\"], [\"ngProjectAs\", \"[igxLabel]\", 5, [\"\", \"igxLabel\", \"\"]], [\"ngProjectAs\", \"igx-prefix\", 5, [\"igx-prefix\"]], [\"ngProjectAs\", \"igx-suffix\", 5, [\"igx-suffix\"]], [\"ngProjectAs\", \"igx-hint\", 5, [\"igx-hint\"]]],\n    template: function IgxDateRangePickerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c280);\n        i0.ɵɵtemplate(0, IgxDateRangePickerComponent_ng_container_0_Template, 1, 0, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, IgxDateRangePickerComponent_ng_template_1_Template, 2, 0, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(3, IgxDateRangePickerComponent_ng_template_3_Template, 4, 2, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(5, IgxDateRangePickerComponent_ng_template_5_Template, 2, 0, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(7, IgxDateRangePickerComponent_ng_template_7_Template, 1, 1, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(9, IgxDateRangePickerComponent_ng_template_9_Template, 13, 13, \"ng-template\", null, 5, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        const _r3 = i0.ɵɵreference(4);\n\n        const _r9 = i0.ɵɵreference(10);\n\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.hasProjectedInputs ? _r3 : _r9);\n      }\n    },\n    directives: [IgxIconComponent, IgxInputGroupComponent, i4.NgTemplateOutlet, IgxInputDirective, i4.NgIf, IgxPrefixDirective],\n    pipes: [DateRangePickerFormatPipe],\n    encapsulation: 2\n  });\n  return IgxDateRangePickerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @hidden */\n\n\nlet IgxDateRangePickerModule = /*#__PURE__*/(() => {\n  class IgxDateRangePickerModule {}\n\n  IgxDateRangePickerModule.ɵfac = function IgxDateRangePickerModule_Factory(t) {\n    return new (t || IgxDateRangePickerModule)();\n  };\n\n  IgxDateRangePickerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxDateRangePickerModule\n  });\n  IgxDateRangePickerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, IgxIconModule, IgxButtonModule, IgxToggleModule, IgxCalendarModule, IgxInputGroupModule, IgxPickersCommonModule, IgxDateTimeEditorModule, IgxCalendarContainerModule], IgxDateTimeEditorModule, IgxPickersCommonModule, IgxInputGroupModule]\n  });\n  return IgxDateRangePickerModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n *\n * For all intents & purposes treat this component as what a <thead> usually is in the default <table> element.\n *\n * This container holds the pivot grid header elements and their behavior/interactions.\n *\n * @hidden @internal\n */\n\n\nlet IgxPivotHeaderRowComponent = /*#__PURE__*/(() => {\n  class IgxPivotHeaderRowComponent extends IgxGridHeaderRowComponent {\n    constructor(grid, ref, cdr, renderer) {\n      super(ref, cdr);\n      this.grid = grid;\n      this.ref = ref;\n      this.cdr = cdr;\n      this.renderer = renderer;\n      this.aggregateList = [];\n      this.filterDropdownDimensions = new Set();\n      this.filterAreaDimensions = new Set();\n      this._dropPos = DropPosition.AfterDropTarget;\n      this._subMenuPositionSettings = {\n        verticalStartPoint: VerticalAlignment.Bottom,\n        closeAnimation: undefined\n      };\n      this._subMenuOverlaySettings = {\n        closeOnOutsideClick: true,\n        modal: false,\n        positionStrategy: new AutoPositionStrategy(this._subMenuPositionSettings),\n        scrollStrategy: new AbsoluteScrollStrategy()\n      };\n      /**\n      * @hidden\n      * @internal\n      * Default is a single empty level since default depth is 1\n      */\n\n      this.columnDimensionsByLevel = [[]];\n    }\n\n    get headerForOf() {\n      return this.headerContainers.last;\n    }\n    /**\n    * @hidden @internal\n    */\n\n\n    get isFiltersButton() {\n      var _a, _b;\n\n      let chipsWidth = 0;\n      this.filterDropdownDimensions.clear();\n      this.filterAreaDimensions.clear();\n\n      if (((_a = this.filterArea) === null || _a === void 0 ? void 0 : _a.chipsList) && this.filterArea.chipsList.length !== 0) {\n        const styles = getComputedStyle(this.pivotFilterContainer.nativeElement);\n        const containerPaddings = parseFloat(styles.paddingLeft) + parseFloat(styles.paddingRight);\n        chipsWidth += containerPaddings + (this.filtersButton && ((_b = this.filterArea) === null || _b === void 0 ? void 0 : _b.chipsList.length) > 1 ? this.filtersButton.el.nativeElement.getBoundingClientRect().width : 0);\n        this.filterArea.chipsList.forEach(chip => {\n          const dim = this.grid.filterDimensions.find(x => x.memberName === chip.id);\n\n          if (dim) {\n            // 8 px margin between chips\n            const currentChipWidth = chip.nativeElement.getBoundingClientRect().width + 8;\n\n            if (chipsWidth + currentChipWidth < this.grid.pivotRowWidths) {\n              this.filterAreaDimensions.add(dim);\n            } else {\n              this.filterDropdownDimensions.add(dim);\n            }\n\n            chipsWidth += currentChipWidth;\n          }\n        });\n        return this.filterDropdownDimensions.size > 0;\n      }\n\n      return false;\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    get totalDepth() {\n      const columnDimensions = this.grid.columnDimensions;\n\n      if (columnDimensions.length === 0) {\n        return 1;\n      }\n\n      let totalDepth = columnDimensions.map(x => PivotUtil.getDimensionDepth(x) + 1).reduce((acc, val) => acc + val);\n\n      if (this.grid.hasMultipleValues) {\n        totalDepth += 1;\n      }\n\n      return totalDepth;\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    get maxContainerHeight() {\n      return this.totalDepth * this.grid.renderedRowHeight;\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    calcHeight(col, index) {\n      return !col.columnGroup && col.level < this.totalDepth && col.level === index ? (this.totalDepth - col.level) * this.grid.rowHeight : this.grid.rowHeight;\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    isDuplicateOfExistingParent(col, lvl) {\n      const parentCollection = lvl > 0 ? this.columnDimensionsByLevel[lvl - 1] : [];\n      const duplicate = parentCollection.indexOf(col) !== -1;\n      return duplicate;\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    isMultiRow(col, lvl) {\n      const isLeaf = !col.columnGroup;\n      return isLeaf && lvl !== this.totalDepth - 1;\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    populateColumnDimensionsByLevel() {\n      const res = [];\n\n      for (let i = 0; i < this.totalDepth; i++) {\n        res[i] = [];\n      }\n\n      const cols = this.unpinnedColumnCollection; // populate column dimension matrix recursively\n\n      this.populateDimensionRecursively(cols.filter(x => x.level === 0), 0, res);\n      this.columnDimensionsByLevel = res;\n    }\n\n    populateDimensionRecursively(currentLevelColumns, level = 0, res) {\n      currentLevelColumns.forEach(col => {\n        if (res[level]) {\n          res[level].push(col);\n\n          if (col.columnGroup && col.children.length > 0) {\n            const visibleColumns = col.children.toArray().filter(x => !x.hidden);\n            this.populateDimensionRecursively(visibleColumns, level + 1, res);\n          } else if (level < this.totalDepth - 1) {\n            for (let i = level + 1; i <= this.totalDepth - 1; i++) {\n              res[i].push(col);\n            }\n          }\n        }\n      });\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    ngOnChanges(changes) {\n      if (changes.unpinnedColumnCollection) {\n        this.populateColumnDimensionsByLevel();\n      }\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    onDimDragStart(event, area) {\n      this.cdr.detectChanges();\n\n      for (let chip of this.notificationChips) {\n        const parent = chip.nativeElement.parentElement;\n\n        if (area.chipsList.toArray().indexOf(chip) === -1 && parent.children.length > 0 && parent.children.item(0).id !== 'empty') {\n          chip.nativeElement.hidden = false;\n          parent.parentElement.scrollTo({\n            left: chip.nativeElement.offsetLeft\n          });\n        }\n      }\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    onDimDragEnd() {\n      for (let chip of this.notificationChips) {\n        chip.nativeElement.hidden = true;\n      }\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    getAreaHeight(area) {\n      const chips = area.chipsList;\n      return chips && chips.length > 0 ? chips.first.nativeElement.offsetHeight : 0;\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    rowRemoved(event) {\n      const row = this.grid.pivotConfiguration.rows.find(x => x.memberName === event.owner.id);\n      this.grid.toggleDimension(row);\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    columnRemoved(event) {\n      const col = this.grid.pivotConfiguration.columns.find(x => x.memberName === event.owner.id);\n      this.grid.toggleDimension(col);\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    valueRemoved(event) {\n      const value = this.grid.pivotConfiguration.values.find(x => x.member === event.owner.id || x.displayName === event.owner.id);\n      this.grid.toggleValue(value);\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    filterRemoved(event) {\n      const filter = this.grid.pivotConfiguration.filters.find(x => x.memberName === event.owner.id);\n      this.grid.toggleDimension(filter);\n\n      if (this.filterDropdownDimensions.size > 0) {\n        this.onFiltersAreaDropdownClick({\n          target: this.filtersButton.el.nativeElement\n        }, undefined, false);\n      } else {\n        this.grid.filteringService.hideESF();\n      }\n    }\n\n    onFiltersSelectionChanged(event) {\n      this.dropdownChips.chipsList.forEach(chip => {\n        if (chip.id !== event.owner.id) {\n          chip.selected = false;\n        }\n      });\n      this.onFiltersAreaDropdownClick({\n        target: this.filtersButton.el.nativeElement\n      }, this.grid.filterDimensions.find(dim => dim.memberName === event.owner.id), false);\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    onFilteringIconPointerDown(event) {\n      event.stopPropagation();\n      event.preventDefault();\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    onFilteringIconClick(event, dimension) {\n      event.stopPropagation();\n      event.preventDefault();\n      let dim = dimension;\n      const col = this.grid.dimensionDataColumns.find(x => x.field === dim.memberName || x.field === dim.member);\n      this.grid.filteringService.toggleFilterDropdown(event.target, col);\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    onSummaryClick(eventArgs, value, dropdown, chip) {\n      this._subMenuOverlaySettings.target = eventArgs.currentTarget;\n      this.updateDropDown(value, dropdown, chip);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onFiltersAreaDropdownClick(event, dimension, shouldReattach = true) {\n      let dim = dimension || this.filterDropdownDimensions.values().next().value;\n      const col = this.grid.dimensionDataColumns.find(x => x.field === dim.memberName || x.field === dim.member);\n\n      if (shouldReattach) {\n        this.dropdownChips.chipsList.forEach(chip => {\n          chip.selected = false;\n        });\n        this.dropdownChips.chipsList.first.selected = true;\n      }\n\n      this.grid.filteringService.toggleFiltersESF(this.esf, event.target, col, shouldReattach);\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    onAggregationChange(event) {\n      if (!this.isSelected(event.newSelection.value)) {\n        this.value.aggregate = event.newSelection.value;\n        this.grid.pipeTrigger++;\n      }\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    isSelected(val) {\n      return this.value.aggregate.key === val.key;\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    onChipSort(_event, dimension) {\n      const startDirection = dimension.sortDirection || SortingDirection.None;\n      const direction = startDirection + 1 > SortingDirection.Desc ? SortingDirection.None : startDirection + 1;\n      this.grid.sortDimension(dimension, direction);\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    onDimDragOver(event, dimension) {\n      var _a;\n\n      if (!event.dragChip || !((_a = event.dragChip.data) === null || _a === void 0 ? void 0 : _a.pivotArea)) return;\n      const typeMismatch = dimension !== undefined ? this.grid.pivotConfiguration.values.find(x => x.member === event.dragChip.id || x.displayName === event.dragChip.id) : !this.grid.pivotConfiguration.values.find(x => x.member === event.dragChip.id || x.displayName === event.dragChip.id);\n\n      if (typeMismatch) {\n        // cannot drag between dimensions and value\n        return;\n      } // if we are in the left half of the chip, drop on the left\n      // else drop on the right of the chip\n\n\n      const clientRect = event.owner.nativeElement.getBoundingClientRect();\n      const pos = clientRect.width / 2;\n      this._dropPos = event.originalEvent.offsetX > pos ? DropPosition.AfterDropTarget : DropPosition.BeforeDropTarget;\n\n      if (this._dropPos === DropPosition.AfterDropTarget) {\n        event.owner.nativeElement.previousElementSibling.style.visibility = 'hidden';\n        event.owner.nativeElement.nextElementSibling.style.visibility = '';\n      } else {\n        event.owner.nativeElement.nextElementSibling.style.visibility = 'hidden';\n        event.owner.nativeElement.previousElementSibling.style.visibility = '';\n      }\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    onDimDragLeave(event) {\n      event.owner.nativeElement.previousElementSibling.style.visibility = 'hidden';\n      event.owner.nativeElement.nextElementSibling.style.visibility = 'hidden';\n      this._dropPos = DropPosition.AfterDropTarget;\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    onAreaDragLeave(event, area) {\n      const dataChips = area.chipsList.toArray().filter(x => this.notificationChips.toArray().indexOf(x) === -1);\n      dataChips.forEach(element => {\n        if (element.nativeElement.previousElementSibling) {\n          element.nativeElement.previousElementSibling.style.visibility = 'hidden';\n        }\n\n        if (element.nativeElement.nextElementSibling) {\n          element.nativeElement.nextElementSibling.style.visibility = 'hidden';\n        }\n      });\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    onValueDrop(event, area) {\n      var _a, _b, _c, _d;\n\n      if (!(event.dragChip && ((_a = event.dragChip.data) === null || _a === void 0 ? void 0 : _a.pivotArea)) && !(((_b = event.dragData) === null || _b === void 0 ? void 0 : _b.chip) && !!event.dragData.chip.data.pivotArea)) return; //values can only be reordered\n\n      const values = this.grid.pivotConfiguration.values;\n      const dragId = ((_c = event.dragChip) === null || _c === void 0 ? void 0 : _c.id) || ((_d = event.dragData) === null || _d === void 0 ? void 0 : _d.chip.id);\n      const chipsArray = area.chipsList.toArray();\n      let chipIndex = chipsArray.indexOf(event.owner) !== -1 ? chipsArray.indexOf(event.owner) : chipsArray.length;\n      chipIndex = this._dropPos === DropPosition.AfterDropTarget ? chipIndex + 1 : chipIndex;\n      const value = values.find(x => x.member === dragId || x.displayName === dragId);\n\n      if (value) {\n        const dragChipIndex = chipsArray.indexOf(event.dragChip || event.dragData.chip);\n        this.grid.moveValue(value, dragChipIndex >= chipIndex ? chipIndex : chipIndex - 1);\n      }\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    onDimDrop(event, area, dimensionType) {\n      var _a, _b, _c, _d;\n\n      if (!(event.dragChip && ((_a = event.dragChip.data) === null || _a === void 0 ? void 0 : _a.pivotArea)) && !(((_b = event.dragData) === null || _b === void 0 ? void 0 : _b.chip) && !!event.dragData.chip.data.pivotArea)) return;\n      const dragId = ((_c = event.dragChip) === null || _c === void 0 ? void 0 : _c.id) || ((_d = event.dragData) === null || _d === void 0 ? void 0 : _d.chip.id);\n      const currentDim = this.grid.getDimensionsByType(dimensionType);\n      const chipsArray = area.chipsList.toArray();\n      const chip = chipsArray.find(x => x.id === dragId);\n      const isNewChip = chip === undefined;\n      const isReorder = event.owner.id !== undefined; //const chipIndex = chipsArray.indexOf(event.owner) !== -1 ? chipsArray.indexOf(event.owner) : chipsArray.length;\n\n      const chipIndex = currentDim.findIndex(x => x.memberName === event.owner.id) !== -1 ? currentDim.findIndex(x => x.memberName === event.owner.id) : currentDim.length;\n      const targetIndex = this._dropPos === DropPosition.AfterDropTarget ? chipIndex + 1 : chipIndex;\n\n      if (isNewChip) {\n        // chip moved from an external collection\n        const dim = this.grid.allDimensions.find(x => x && x.memberName === dragId);\n\n        if (!dim) {\n          // you have dragged something that is not a dimension\n          return;\n        }\n\n        this.grid.moveDimension(dim, dimensionType, targetIndex);\n      } else if (isReorder) {\n        // chip from same collection, reordered.\n        const newDim = currentDim.find(x => x.memberName === dragId);\n        const dragChipIndex = currentDim.findIndex(x => x.memberName === dragId);\n        this.grid.moveDimension(newDim, dimensionType, dragChipIndex > chipIndex ? targetIndex : targetIndex - 1);\n      }\n\n      this.grid.pipeTrigger++;\n      this.grid.dimensionsChange.emit({\n        dimensions: currentDim,\n        dimensionCollectionType: dimensionType\n      }); // clean states\n\n      this.onDimDragEnd();\n      this.onAreaDragLeave(event, area);\n    }\n\n    updateDropDown(value, dropdown, chip) {\n      this.value = value;\n      dropdown.width = chip.nativeElement.clientWidth + 'px';\n      this.aggregateList = PivotUtil.getAggregateList(value, this.grid);\n      this.cdr.detectChanges();\n      dropdown.open(this._subMenuOverlaySettings);\n    }\n\n  }\n\n  IgxPivotHeaderRowComponent.ɵfac = function IgxPivotHeaderRowComponent_Factory(t) {\n    return new (t || IgxPivotHeaderRowComponent)(i0.ɵɵdirectiveInject(IGX_GRID_BASE), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  IgxPivotHeaderRowComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxPivotHeaderRowComponent,\n    selectors: [[\"igx-pivot-header-row\"]],\n    viewQuery: function IgxPivotHeaderRowComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c282, 5);\n        i0.ɵɵviewQuery(_c283, 5);\n        i0.ɵɵviewQuery(_c284, 5);\n        i0.ɵɵviewQuery(_c285, 5);\n        i0.ɵɵviewQuery(_c286, 5);\n        i0.ɵɵviewQuery(_c287, 5);\n        i0.ɵɵviewQuery(_c171, 5, IgxGridForOfDirective);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.esf = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.filterArea = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.filtersButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropdownChips = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.pivotFilterContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.notificationChips = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerContainers = _t);\n      }\n    },\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature],\n    decls: 37,\n    vars: 31,\n    consts: [[\"role\", \"row\", 1, \"igx-grid-thead__wrapper\", \"igx-grid-thead__wrapper--pivot\"], [\"role\", \"row\", 1, \"igx-grid__tr\"], [1, \"igx-grid__tr-pivot--filter-container\"], [\"class\", \"igx-grid__tr-pivot igx-grid__tr-pivot--filter\", \"igxDrop\", \"\", 3, \"min-width\", \"max-width\", \"igxDragLeave\", \"dropped\", \"pointerdown\", 4, \"ngIf\"], [\"igxDrop\", \"\", 1, \"igx-grid__tr-pivot--drop-row-area\", 3, \"igxDragLeave\", \"dropped\"], [1, \"igx-grid__tr-pivot-group\"], [\"class\", \"igx-grid__tr-pivot\", \"igxDrop\", \"\", 3, \"dropped\", \"igxDragLeave\", 4, \"ngIf\"], [\"class\", \"igx-grid__tr-pivot\", \"igxDrop\", \"\", 3, \"pointerdown\", \"dropped\", \"igxDragLeave\", 4, \"ngIf\"], [\"role\", \"rowgroup\", 1, \"igx-grid-thead__wrapper\"], [\"igxDrop\", \"\", 1, \"igx-grid__tr-pivot\", \"igx-grid__tr-pivot--row-area\", 3, \"igxDragLeave\", \"dropped\", \"pointerdown\"], [\"pivotContainer\", \"\"], [\"droppable\", \"true\"], [\"rowArea\", \"\"], [4, \"ngIf\"], [1, \"igx-grid-thead--virtualizationWrapper\"], [\"class\", \"igx-grid-thead__group igx-grid-thead--virtualizationContainer\", 3, \"height\", \"width\", 4, \"ngFor\", \"ngForOf\"], [1, \"igx-grid-thead__thumb\", 3, \"hidden\"], [3, \"selectionChanging\"], [\"dropdown\", \"\"], [3, \"selected\", \"value\", 4, \"ngFor\", \"ngForOf\"], [3, \"hidden\"], [3, \"maxHeight\", \"minHeight\"], [\"esf\", \"\"], [\"igxExcelStyleColumnOperations\", \"\"], [\"dropdownChips\", \"\"], [3, \"id\", \"displayDensity\", \"removable\", \"selectable\", \"selected\", \"remove\", \"chipClick\", 4, \"ngFor\", \"ngForOf\"], [2, \"visibility\", \"hidden\", \"position\", \"absolute\", \"top\", \"-10000px\"], [\"filterAreaHidden\", \"\"], [3, \"id\", \"draggable\", \"displayDensity\", \"removable\", \"remove\", 4, \"ngFor\", \"ngForOf\"], [\"igxDrop\", \"\", 1, \"igx-grid__tr-pivot\", \"igx-grid__tr-pivot--filter\", 3, \"igxDragLeave\", \"dropped\", \"pointerdown\"], [\"pivotFilterContainer\", \"\"], [\"filterArea\", \"\"], [\"id\", \"empty\", \"igxDrop\", \"\", \"class\", \"igx-grid__pivot-empty-chip-area\", 3, \"dropped\", 4, \"ngIf\"], [4, \"ngFor\", \"ngForOf\"], [\"igxDrop\", \"\", 3, \"hidden\", \"displayDensity\", \"dragDrop\"], [\"notifyChip\", \"\"], [\"class\", \"igx-grid__pivot-filter-toggle\", 4, \"ngIf\"], [\"id\", \"empty\", \"igxDrop\", \"\", 1, \"igx-grid__pivot-empty-chip-area\", 3, \"dropped\"], [1, \"igx-grid__tr-pivot--chip_drop_indicator\"], [3, \"id\", \"draggable\", \"displayDensity\", \"data\", \"removable\", \"remove\", \"dragOver\", \"dragLeave\", \"dragDrop\", \"moveStart\", \"moveEnd\"], [\"igxPrefix\", \"\", 3, \"pointerdown\", \"click\"], [1, \"igx-grid__pivot-filter-toggle\"], [3, \"pointerdown\", \"click\"], [\"filterIcon\", \"\"], [3, \"value\"], [\"igxDrop\", \"\", 1, \"igx-grid__tr-pivot\", 3, \"dropped\", \"igxDragLeave\"], [\"pivotColumnContainer\", \"\"], [\"colArea\", \"\"], [3, \"draggable\", \"id\", \"displayDensity\", \"data\", \"removable\", \"remove\", \"dragOver\", \"dragLeave\", \"dragDrop\", \"moveStart\", \"moveEnd\", \"click\"], [\"igxPrefix\", \"\"], [\"igxSuffix\", \"\", 4, \"ngIf\"], [\"igxSuffix\", \"\"], [\"igxDrop\", \"\", 1, \"igx-grid__tr-pivot\", 3, \"pointerdown\", \"dropped\", \"igxDragLeave\"], [\"pivotValueContainer\", \"\"], [\"valueArea\", \"\"], [\"notifyValueChip\", \"\"], [3, \"draggable\", \"id\", \"data\", \"displayDensity\", \"removable\", \"remove\", \"dragLeave\", \"dragOver\", \"dragDrop\"], [\"currChip\", \"\"], [\"igxPrefix\", \"\", 1, \"igx-grid__tr-pivot-toggle-icons\", 3, \"igxDropDownItemNavigation\", \"click\", \"pointerdown\"], [3, \"draggable\", \"id\", \"displayDensity\", \"data\", \"removable\", \"remove\", \"dragLeave\", \"dragDrop\", \"dragOver\", \"moveStart\", \"moveEnd\", \"click\"], [3, \"ngClass\", \"ngStyle\", \"column\", \"pointerdown\"], [1, \"igx-grid-thead__group\", \"igx-grid-thead--virtualizationContainer\"], [\"igxGridFor\", \"\", 3, \"igxGridForOf\", \"igxGridForOfUniqueSizeCache\", \"igxForScrollContainer\", \"igxForContainerSize\", \"igxForTrackBy\", \"igxForSizePropName\", \"igxForScrollOrientation\"], [\"headerVirtualContainer\", \"\"], [3, \"ngClass\", \"ngStyle\", \"column\"], [3, \"selected\", \"value\"], [3, \"id\", \"displayDensity\", \"removable\", \"selectable\", \"selected\", \"remove\", \"chipClick\"], [3, \"id\", \"draggable\", \"displayDensity\", \"removable\", \"remove\"]],\n    template: function IgxPivotHeaderRowComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        const _r138 = i0.ɵɵgetCurrentView();\n\n        i0.ɵɵelementStart(0, \"div\")(1, \"div\", 0)(2, \"div\", 1)(3, \"div\", 2);\n        i0.ɵɵtemplate(4, IgxPivotHeaderRowComponent_div_4_Template, 10, 10, \"div\", 3);\n        i0.ɵɵelementStart(5, \"div\", 4);\n        i0.ɵɵlistener(\"igxDragLeave\", function IgxPivotHeaderRowComponent_Template_div_igxDragLeave_5_listener($event) {\n          i0.ɵɵrestoreView(_r138);\n\n          const _r4 = i0.ɵɵreference(14);\n\n          return ctx.onAreaDragLeave($event, _r4);\n        })(\"dropped\", function IgxPivotHeaderRowComponent_Template_div_dropped_5_listener($event) {\n          i0.ɵɵrestoreView(_r138);\n\n          const _r4 = i0.ɵɵreference(14);\n\n          return ctx.onDimDrop($event, _r4, 0);\n        });\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(6, \"div\", 5);\n        i0.ɵɵtemplate(7, IgxPivotHeaderRowComponent_div_7_Template, 9, 5, \"div\", 6);\n        i0.ɵɵtemplate(8, IgxPivotHeaderRowComponent_div_8_Template, 9, 5, \"div\", 7);\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵelementStart(9, \"div\", 8)(10, \"div\", 1)(11, \"div\", 9, 10);\n        i0.ɵɵlistener(\"igxDragLeave\", function IgxPivotHeaderRowComponent_Template_div_igxDragLeave_11_listener($event) {\n          i0.ɵɵrestoreView(_r138);\n\n          const _r4 = i0.ɵɵreference(14);\n\n          return ctx.onAreaDragLeave($event, _r4);\n        })(\"dropped\", function IgxPivotHeaderRowComponent_Template_div_dropped_11_listener($event) {\n          i0.ɵɵrestoreView(_r138);\n\n          const _r4 = i0.ɵɵreference(14);\n\n          return ctx.onDimDrop($event, _r4, 0);\n        })(\"pointerdown\", function IgxPivotHeaderRowComponent_Template_div_pointerdown_11_listener($event) {\n          return $event.preventDefault();\n        });\n        i0.ɵɵelementStart(13, \"igx-chips-area\", 11, 12);\n        i0.ɵɵtemplate(15, IgxPivotHeaderRowComponent_ng_container_15_Template, 6, 5, \"ng-container\", 13);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵtemplate(16, IgxPivotHeaderRowComponent_ng_container_16_Template, 3, 3, \"ng-container\", 13);\n        i0.ɵɵelementStart(17, \"div\", 14);\n        i0.ɵɵtemplate(18, IgxPivotHeaderRowComponent_div_18_Template, 3, 11, \"div\", 15);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(19, IgxPivotHeaderRowComponent_ng_container_19_Template, 3, 3, \"ng-container\", 13);\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵelement(20, \"div\", 16);\n        i0.ɵɵelementStart(21, \"igx-drop-down\", 17, 18);\n        i0.ɵɵlistener(\"selectionChanging\", function IgxPivotHeaderRowComponent_Template_igx_drop_down_selectionChanging_21_listener($event) {\n          return ctx.onAggregationChange($event);\n        });\n        i0.ɵɵtemplate(23, IgxPivotHeaderRowComponent_igx_drop_down_item_23_Template, 2, 3, \"igx-drop-down-item\", 19);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(24, \"div\", 20)(25, \"igx-grid-excel-style-filtering\", 21, 22)(27, \"div\", 23)(28, \"igx-chips-area\", null, 24);\n        i0.ɵɵtemplate(30, IgxPivotHeaderRowComponent_igx_chip_30_Template, 2, 6, \"igx-chip\", 25);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(31, \"igx-excel-style-filter-operations\");\n        i0.ɵɵelement(32, \"igx-excel-style-search\");\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵelementStart(33, \"div\", 26)(34, \"igx-chips-area\", 11, 27);\n        i0.ɵɵtemplate(36, IgxPivotHeaderRowComponent_igx_chip_36_Template, 4, 5, \"igx-chip\", 28);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.width, \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.width, \"px\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.grid.showPivotConfigurationUI);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.grid.showPivotConfigurationUI);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.grid.showPivotConfigurationUI);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.width, \"px\");\n        i0.ɵɵclassProp(\"igx-grid__tr--mrl\", ctx.hasMRL);\n        i0.ɵɵattribute(\"aria-activedescendant\", ctx.activeDescendant);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.width, \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.grid.pivotRowWidths - 1, \"px\");\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"ngIf\", ctx.grid.showPivotConfigurationUI);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.pinnedColumnCollection.length && ctx.grid.isPinningToStart);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"max-height\", ctx.maxContainerHeight, \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.columnDimensionsByLevel);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.pinnedColumnCollection.length && !ctx.grid.isPinningToStart);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.grid.scrollSize, \"px\");\n        i0.ɵɵproperty(\"hidden\", !ctx.grid.hasVerticalScroll());\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngForOf\", ctx.aggregateList);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"hidden\", true);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"maxHeight\", ctx.grid.excelStyleFilterMaxHeight)(\"minHeight\", ctx.grid.excelStyleFilterMinHeight);\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"ngForOf\", ctx.filterDropdownDimensions);\n        i0.ɵɵadvance(6);\n        i0.ɵɵproperty(\"ngForOf\", ctx.grid.filterDimensions);\n      }\n    },\n    directives: [IgxChipsAreaComponent, IgxChipComponent, IgxIconComponent, IgxBadgeComponent, IgxGridHeaderGroupComponent, IgxDropDownComponent, IgxDropDownItemComponent, IgxGridExcelStyleFilteringComponent, IgxExcelStyleSearchComponent, i4.NgIf, IgxDropDirective, i4.NgForOf, IgxPrefixDirective, IgxSuffixDirective, IgxDropDownItemNavigationDirective, i4.NgClass, i4.NgStyle, IgxGridForOfDirective, IgxExcelStyleColumnOperationsTemplateDirective, IgxExcelStyleFilterOperationsTemplateDirective],\n    pipes: [IgxGridTopLevelColumns, IgxHeaderGroupStylePipe, IgxHeaderGroupWidthPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxPivotHeaderRowComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxPivotGridNavigationService = /*#__PURE__*/(() => {\n  class IgxPivotGridNavigationService extends IgxGridNavigationService {\n    get lastRowDimensionsIndex() {\n      return this.grid.rowDimensions.length - 1;\n    }\n\n    focusOutRowHeader() {\n      this.isRowHeaderActive = false;\n    }\n\n    handleNavigation(event) {\n      if (this.isRowHeaderActive) {\n        const key = event.key.toLowerCase();\n        const ctrl = event.ctrlKey;\n\n        if (!HEADER_KEYS.has(key)) {\n          return;\n        }\n\n        event.preventDefault();\n        const newActiveNode = {\n          row: this.activeNode.row,\n          column: this.activeNode.column,\n          level: null,\n          mchCache: null,\n          layout: null\n        };\n\n        if ((key.includes('left') || key === 'home') && this.activeNode.column > 0) {\n          newActiveNode.column = ctrl || key === 'home' ? 0 : this.activeNode.column - 1;\n        }\n\n        if ((key.includes('right') || key === 'end') && this.activeNode.column < this.lastRowDimensionsIndex) {\n          newActiveNode.column = ctrl || key === 'end' ? this.lastRowDimensionsIndex : this.activeNode.column + 1;\n        }\n\n        const verticalContainer = this.grid.verticalRowDimScrollContainers.toArray()[newActiveNode.column];\n\n        if (key.includes('up') && this.activeNode.row > 0) {\n          newActiveNode.row = ctrl ? 0 : this.activeNode.row - 1;\n        }\n\n        if (key.includes('down') && this.activeNode.row < this.findLastDataRowIndex()) {\n          newActiveNode.row = ctrl ? verticalContainer.igxForOf.length - 1 : Math.min(this.activeNode.row + 1, verticalContainer.igxForOf.length - 1);\n        }\n\n        if (key.includes('left') || key.includes('right')) {\n          const prevRIndex = this.activeNode.row;\n          const prevScrContainer = this.grid.verticalRowDimScrollContainers.toArray()[this.activeNode.column];\n          const src = prevScrContainer.getScrollForIndex(prevRIndex);\n          newActiveNode.row = this.activeNode.mchCache && this.activeNode.mchCache.level === newActiveNode.column ? this.activeNode.mchCache.visibleIndex : verticalContainer.getIndexAtScroll(src);\n          newActiveNode.mchCache = {\n            visibleIndex: this.activeNode.row,\n            level: this.activeNode.column\n          };\n        }\n\n        this.setActiveNode(newActiveNode);\n\n        if (verticalContainer.isIndexOutsideView(newActiveNode.row)) {\n          verticalContainer.scrollTo(newActiveNode.row);\n        }\n      } else {\n        super.handleNavigation(event);\n      }\n    }\n\n    focusTbody(event) {\n      if (!this.activeNode || this.activeNode.row === null || this.activeNode.row === undefined) {\n        this.activeNode = this.lastActiveNode;\n      } else {\n        super.focusTbody(event);\n      }\n    }\n\n  }\n\n  IgxPivotGridNavigationService.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxPivotGridNavigationService_BaseFactory;\n    return function IgxPivotGridNavigationService_Factory(t) {\n      return (ɵIgxPivotGridNavigationService_BaseFactory || (ɵIgxPivotGridNavigationService_BaseFactory = i0.ɵɵgetInheritedFactory(IgxPivotGridNavigationService)))(t || IgxPivotGridNavigationService);\n    };\n  }();\n\n  IgxPivotGridNavigationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxPivotGridNavigationService,\n    factory: IgxPivotGridNavigationService.ɵfac\n  });\n  return IgxPivotGridNavigationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IgxPivotFilteringService = /*#__PURE__*/(() => {\n  class IgxPivotFilteringService extends IgxFilteringService {\n    clearFilter(field) {\n      this.clear_filter(field);\n    }\n\n    clear_filter(fieldName) {\n      super.clear_filter(fieldName);\n      const grid = this.grid;\n      const allDimensions = grid.allDimensions;\n      const allDimensionsFlat = PivotUtil.flatten(allDimensions);\n      const dim = allDimensionsFlat.find(x => x.memberName === fieldName);\n      dim.filter = undefined;\n      grid.filteringPipeTrigger++;\n\n      if (allDimensions.indexOf(dim) !== -1) {\n        // update columns\n        grid.setupColumns();\n      }\n    }\n\n    filter_internal(fieldName, term, conditionOrExpressionsTree, ignoreCase) {\n      var _a;\n\n      super.filter_internal(fieldName, term, conditionOrExpressionsTree, ignoreCase);\n      const grid = this.grid;\n      const config = grid.pivotConfiguration;\n      const allDimensions = PivotUtil.flatten(config.rows.concat(config.columns).concat(config.filters).filter(x => x !== null && x !== undefined));\n      const enabledDimensions = allDimensions.filter(x => x && x.enabled);\n      const dim = enabledDimensions.find(x => x.memberName === fieldName || x.member === fieldName);\n      const filteringTree = dim.filter || new FilteringExpressionsTree(FilteringLogic.And);\n      const fieldFilterIndex = filteringTree.findIndex(fieldName);\n\n      if (fieldFilterIndex > -1) {\n        filteringTree.filteringOperands.splice(fieldFilterIndex, 1);\n      }\n\n      this.prepare_filtering_expression(filteringTree, fieldName, term, conditionOrExpressionsTree, ignoreCase, fieldFilterIndex);\n      dim.filter = filteringTree;\n      grid.filteringPipeTrigger++;\n      grid.filterStrategy = (_a = grid.filterStrategy) !== null && _a !== void 0 ? _a : new DimensionValuesFilteringStrategy();\n\n      if (allDimensions.indexOf(dim) !== -1) {\n        // update columns\n        grid.setupColumns();\n      }\n    }\n\n    toggleFiltersESF(dropdown, element, column, shouldReattach) {\n      const filterIcon = column.filteringExpressionsTree ? 'igx-excel-filter__icon--filtered' : 'igx-excel-filter__icon';\n      const filterIconTarget = element.querySelector(`.${filterIcon}`) || element;\n      const {\n        id,\n        ref\n      } = this.grid.createFilterESF(dropdown, column, Object.assign(Object.assign({}, this._filterMenuOverlaySettings), {\n        target: filterIconTarget\n      }), shouldReattach);\n      this.filtersESFId = id;\n\n      if (shouldReattach) {\n        this._overlayService.opening.pipe(first$1(overlay => overlay.id === id), takeUntil(this.destroy$)).subscribe(() => this.lastActiveNode = this.grid.navigation.activeNode);\n\n        this._overlayService.closed.pipe(first$1(overlay => overlay.id === id), takeUntil(this.destroy$)).subscribe(() => {\n          this._overlayService.detach(id);\n\n          ref === null || ref === void 0 ? void 0 : ref.destroy();\n          this.grid.navigation.activeNode = this.lastActiveNode;\n          this.grid.theadRow.nativeElement.focus();\n        });\n\n        this.grid.columnPinned.pipe(first$1()).subscribe(() => ref === null || ref === void 0 ? void 0 : ref.destroy());\n\n        this._overlayService.show(id);\n      }\n    }\n\n    hideESF() {\n      this._overlayService.hide(this.filtersESFId);\n    }\n\n  }\n\n  IgxPivotFilteringService.ɵfac = /* @__PURE__ */function () {\n    let ɵIgxPivotFilteringService_BaseFactory;\n    return function IgxPivotFilteringService_Factory(t) {\n      return (ɵIgxPivotFilteringService_BaseFactory || (ɵIgxPivotFilteringService_BaseFactory = i0.ɵɵgetInheritedFactory(IgxPivotFilteringService)))(t || IgxPivotFilteringService);\n    };\n  }();\n\n  IgxPivotFilteringService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IgxPivotFilteringService,\n    factory: IgxPivotFilteringService.ɵfac\n  });\n  return IgxPivotFilteringService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxPivotRowDimensionHeaderComponent = /*#__PURE__*/(() => {\n  class IgxPivotRowDimensionHeaderComponent extends IgxGridHeaderComponent {\n    constructor(grid, colResizingService, cdr, refInstance) {\n      super(grid, colResizingService, cdr, refInstance);\n      this.grid = grid;\n      this.colResizingService = colResizingService;\n      this.cdr = cdr;\n      this.refInstance = refInstance;\n    }\n\n    onClick(event) {\n      event.preventDefault();\n    }\n\n    get selectable() {\n      return false;\n    }\n\n  }\n\n  IgxPivotRowDimensionHeaderComponent.ɵfac = function IgxPivotRowDimensionHeaderComponent_Factory(t) {\n    return new (t || IgxPivotRowDimensionHeaderComponent)(i0.ɵɵdirectiveInject(IGX_GRID_BASE), i0.ɵɵdirectiveInject(IgxPivotColumnResizingService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  IgxPivotRowDimensionHeaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxPivotRowDimensionHeaderComponent,\n    selectors: [[\"igx-pivot-row-dimension-header\"]],\n    hostBindings: function IgxPivotRowDimensionHeaderComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function IgxPivotRowDimensionHeaderComponent_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 9,\n    vars: 6,\n    consts: [[\"defaultColumn\", \"\"], [\"defaultESFHeaderIconTemplate\", \"\"], [\"defaultSortHeaderIconTemplate\", \"\"], [1, \"igx-grid-th__title\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [4, \"ngIf\"], [3, \"title\"], [1, \"igx-grid-th__icons\"], [1, \"sort-icon\", 3, \"click\", \"pointerdown\"], [3, \"ngClass\", \"click\", \"pointerdown\"]],\n    template: function IgxPivotRowDimensionHeaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxPivotRowDimensionHeaderComponent_ng_template_0_Template, 2, 2, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, IgxPivotRowDimensionHeaderComponent_ng_template_2_Template, 2, 0, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(4, IgxPivotRowDimensionHeaderComponent_ng_template_4_Template, 2, 1, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementStart(6, \"span\", 3);\n        i0.ɵɵtemplate(7, IgxPivotRowDimensionHeaderComponent_ng_container_7_Template, 1, 0, \"ng-container\", 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(8, IgxPivotRowDimensionHeaderComponent_ng_container_8_Template, 4, 2, \"ng-container\", 5);\n      }\n\n      if (rf & 2) {\n        const _r0 = i0.ɵɵreference(1);\n\n        i0.ɵɵadvance(7);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.column.headerTemplate ? ctx.column.headerTemplate : _r0)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(3, _c161, ctx.column, ctx.column));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.column.columnGroup);\n      }\n    },\n    directives: [IgxIconComponent, i4.NgTemplateOutlet, i4.NgIf, i4.NgClass],\n    pipes: [SortingIndexPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxPivotRowDimensionHeaderComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxPivotRowDimensionHeaderGroupComponent = /*#__PURE__*/(() => {\n  class IgxPivotRowDimensionHeaderGroupComponent extends IgxGridHeaderGroupComponent {\n    constructor(cdRef, grid, elementRef, colResizingService, filteringService, platform, zone) {\n      super(cdRef, grid, elementRef, colResizingService, filteringService, platform);\n      this.cdRef = cdRef;\n      this.grid = grid;\n      this.elementRef = elementRef;\n      this.colResizingService = colResizingService;\n      this.filteringService = filteringService;\n      this.platform = platform;\n      this.zone = zone;\n      /**\n       * @hidden\n       */\n\n      this.userSelect = 'none';\n    }\n\n    get headerID() {\n      return `${this.grid.id}_-2_${this.rowIndex}_${this.visibleIndex}`;\n    }\n\n    get title() {\n      return this.column.header;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onClick(event) {\n      if (this.grid.rowSelection === 'none') {\n        return;\n      }\n\n      event === null || event === void 0 ? void 0 : event.stopPropagation();\n      const key = this.parent.getRowDimensionKey(this.column);\n\n      if (this.grid.selectionService.isRowSelected(key)) {\n        this.grid.selectionService.deselectRow(key, event);\n      } else {\n        this.grid.selectionService.selectRowById(key, true, event);\n      }\n\n      this.zone.run(() => {});\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get visibleIndex() {\n      const field = this.column.field;\n      const rows = this.grid.rowDimensions;\n      const rootDimension = this.findRootDimension(field);\n      return rows.indexOf(rootDimension);\n    }\n\n    get active() {\n      const nav = this.grid.navigation;\n      const node = nav.activeNode;\n      return node && !this.column.columnGroup ? nav.isRowHeaderActive && node.row === this.rowIndex && node.column === this.visibleIndex : false;\n    }\n\n    get activeNode() {\n      this.grid.navigation.isRowHeaderActive = true;\n      return {\n        row: this.rowIndex,\n        column: this.visibleIndex,\n        level: null,\n        mchCache: null,\n        layout: null\n      };\n    }\n\n    findRootDimension(field) {\n      const rows = this.grid.rowDimensions;\n      let tempRow;\n      let result = null;\n      rows.forEach(row => {\n        tempRow = row;\n\n        do {\n          if (tempRow.memberName === field) {\n            result = row;\n          }\n\n          tempRow = tempRow.childLevel;\n        } while (tempRow);\n      });\n      return result;\n    }\n\n    activate() {\n      this.grid.navigation.isRowHeader = true;\n      this.grid.navigation.setActiveNode(this.activeNode);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    pointerdown(_event) {\n      this.activate();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    onMouseDown(_event) {\n      this.activate();\n    }\n\n    get selectable() {\n      return false;\n    }\n\n  }\n\n  IgxPivotRowDimensionHeaderGroupComponent.ɵfac = function IgxPivotRowDimensionHeaderGroupComponent_Factory(t) {\n    return new (t || IgxPivotRowDimensionHeaderGroupComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(IGX_GRID_BASE), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(IgxPivotColumnResizingService), i0.ɵɵdirectiveInject(IgxFilteringService), i0.ɵɵdirectiveInject(PlatformUtil), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  IgxPivotRowDimensionHeaderGroupComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxPivotRowDimensionHeaderGroupComponent,\n    selectors: [[\"igx-pivot-row-dimension-header-group\"]],\n    viewQuery: function IgxPivotRowDimensionHeaderGroupComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxPivotRowDimensionHeaderComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.header = _t.first);\n      }\n    },\n    hostVars: 6,\n    hostBindings: function IgxPivotRowDimensionHeaderGroupComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function IgxPivotRowDimensionHeaderGroupComponent_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.headerID)(\"title\", ctx.title);\n        i0.ɵɵstyleProp(\"user-select\", ctx.userSelect);\n        i0.ɵɵclassProp(\"igx-grid-th--active\", ctx.active);\n      }\n    },\n    inputs: {\n      rowIndex: \"rowIndex\",\n      parent: \"parent\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 5,\n    vars: 1,\n    consts: [[\"defaultColumn\", \"\"], [\"defaultCollapseIndicator\", \"\"], [4, \"ngIf\"], [1, \"igx-grid-th__group-title\", 3, \"title\"], [\"class\", \"igx-grid-th__drop-indicator-left\", 4, \"ngIf\"], [\"role\", \"columnheader\", 1, \"igx-grid-th--fw\", 3, \"id\", \"ngClass\", \"ngStyle\", \"igxColumnMovingDrag\", \"ghostHost\", \"igxColumnMovingDrop\", \"column\", \"density\", \"pointerdown\"], [3, \"column\", 4, \"ngIf\"], [\"class\", \"igx-grid-th__resize-handle\", 3, \"igxPivotResizeHandle\", \"igxPivotResizeHandleHeader\", \"cursor\", 4, \"ngIf\"], [\"class\", \"igx-grid-th__drop-indicator-right\", 4, \"ngIf\"], [1, \"igx-grid-th__drop-indicator-left\"], [3, \"column\"], [1, \"igx-grid-th__resize-handle\", 3, \"igxPivotResizeHandle\", \"igxPivotResizeHandleHeader\"], [1, \"igx-grid-th__drop-indicator-right\"]],\n    template: function IgxPivotRowDimensionHeaderGroupComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxPivotRowDimensionHeaderGroupComponent_ng_template_0_Template, 2, 2, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, IgxPivotRowDimensionHeaderGroupComponent_ng_template_2_Template, 2, 2, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(4, IgxPivotRowDimensionHeaderGroupComponent_ng_container_4_Template, 7, 17, \"ng-container\", 2);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"ngIf\", !ctx.column.columnGroup);\n      }\n    },\n    directives: [IgxIconComponent, IgxPivotRowDimensionHeaderComponent, IgxGridFilteringCellComponent, i4.NgIf, i4.NgClass, i4.NgStyle, IgxColumnMovingDragDirective, IgxColumnMovingDropDirective, IgxPivotResizeHandleDirective],\n    pipes: [IgxHeaderGroupStylePipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxPivotRowDimensionHeaderGroupComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n *\n * For all intents & purposes treat this component as what a <thead> usually is in the default <table> element.\n *\n * This container holds the pivot grid header elements and their behavior/interactions.\n *\n * @hidden @internal\n */\n\n\nlet IgxPivotRowDimensionContentComponent = /*#__PURE__*/(() => {\n  class IgxPivotRowDimensionContentComponent extends IgxGridHeaderRowComponent {\n    constructor(grid, ref, cdr, resolver, viewRef) {\n      super(ref, cdr);\n      this.grid = grid;\n      this.ref = ref;\n      this.cdr = cdr;\n      this.resolver = resolver;\n      this.viewRef = viewRef;\n    }\n\n    get rowDimensionColumn() {\n      var _a;\n\n      return (_a = this.rowDimensionData) === null || _a === void 0 ? void 0 : _a.column;\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    ngOnChanges(changes) {\n      if (changes.rowData) {\n        // generate new rowDimension on row data change\n        this.rowDimensionData = null;\n        this.viewRef.clear();\n        this.extractFromDimensions();\n        this.viewRef.clear();\n      }\n\n      if (changes.width && this.rowDimensionData) {\n        const data = this.rowDimensionData;\n        data.column.width = this.grid.rowDimensionWidthToPixels(this.rootDimension) + 'px';\n      }\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    toggleRowDimension(event) {\n      this.grid.toggleRow(this.getRowDimensionKey());\n      event === null || event === void 0 ? void 0 : event.stopPropagation();\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    getRowDimensionKey() {\n      const dimData = this.rowDimensionData;\n      const key = PivotUtil.getRecordKey(this.rowData, dimData.dimension);\n      return key;\n    }\n\n    getExpandState() {\n      return this.grid.gridAPI.get_row_expansion_state(this.getRowDimensionKey());\n    }\n\n    getLevel() {\n      return this.dimension.level;\n    }\n\n    extractFromDimensions() {\n      const col = this.extractFromDimension(this.dimension, this.rowData);\n      const prevDims = [];\n      this.rowDimensionData = {\n        column: col,\n        dimension: this.dimension,\n        prevDimensions: prevDims\n      };\n    }\n\n    extractFromDimension(dim, rowData) {\n      const field = dim.memberName;\n      const header = rowData.dimensionValues.get(field);\n\n      const col = this._createColComponent(field, header, dim);\n\n      return col;\n    }\n\n    _createColComponent(field, header, dim) {\n      const ref = this.viewRef.createComponent(IgxColumnComponent);\n      ref.instance.field = field;\n      ref.instance.header = header;\n      ref.instance.width = this.grid.rowDimensionWidthToPixels(this.rootDimension) + 'px';\n      ref.instance.resizable = this.grid.rowDimensionResizing;\n      ref.instance._vIndex = this.grid.columns.length + this.rowIndex + this.rowIndex * this.grid.pivotConfiguration.rows.length;\n\n      if (dim.childLevel) {\n        ref.instance.headerTemplate = this.headerTemplate;\n      } else {\n        ref.instance.headerTemplate = this.headerTemplateDefault;\n      }\n\n      return ref.instance;\n    }\n\n  }\n\n  IgxPivotRowDimensionContentComponent.ɵfac = function IgxPivotRowDimensionContentComponent_Factory(t) {\n    return new (t || IgxPivotRowDimensionContentComponent)(i0.ɵɵdirectiveInject(IGX_GRID_BASE), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  };\n\n  IgxPivotRowDimensionContentComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxPivotRowDimensionContentComponent,\n    selectors: [[\"igx-pivot-row-dimension-content\"]],\n    viewQuery: function IgxPivotRowDimensionContentComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c258, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c292, 7, TemplateRef);\n        i0.ɵɵviewQuery(IgxPivotRowDimensionHeaderGroupComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplateDefault = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerGroups = _t);\n      }\n    },\n    inputs: {\n      rowIndex: \"rowIndex\",\n      dimension: \"dimension\",\n      rootDimension: \"rootDimension\",\n      rowData: \"rowData\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature],\n    decls: 10,\n    vars: 27,\n    consts: [[\"role\", \"rowgroup\", 1, \"igx-grid-thead__wrapper\"], [\"role\", \"row\", 1, \"igx-grid__tr\", \"igx-grid__tr-header-row\"], [3, \"ngClass\", \"ngStyle\", \"column\", \"rowIndex\", \"parent\"], [\"headerTemplate\", \"\"], [\"headerDefaultTemplate\", \"\"], [3, \"click\"], [2, \"flex-shrink\", \"0\"]],\n    template: function IgxPivotRowDimensionContentComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1)(2, \"igx-pivot-row-dimension-header-group\", 2);\n        i0.ɵɵpipe(3, \"igxHeaderGroupWidth\");\n        i0.ɵɵpipe(4, \"igxHeaderGroupWidth\");\n        i0.ɵɵpipe(5, \"igxHeaderGroupStyle\");\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵtemplate(6, IgxPivotRowDimensionContentComponent_ng_template_6_Template, 4, 6, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(8, IgxPivotRowDimensionContentComponent_ng_template_8_Template, 3, 5, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"width\", ctx.width, \"px\");\n        i0.ɵɵclassProp(\"igx-grid__tr--mrl\", ctx.hasMRL);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.width, \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"min-width\", i0.ɵɵpipeBind3(3, 15, ctx.grid.rowDimensionWidthToPixels(ctx.rootDimension), ctx.grid.defaultHeaderGroupMinWidth, ctx.hasMRL))(\"flex-basis\", i0.ɵɵpipeBind3(4, 19, ctx.grid.rowDimensionWidthToPixels(ctx.rootDimension), ctx.grid.defaultHeaderGroupMinWidth, ctx.hasMRL));\n        i0.ɵɵproperty(\"ngClass\", ctx.rowDimensionColumn.headerGroupClasses)(\"ngStyle\", i0.ɵɵpipeBind3(5, 23, ctx.rowDimensionColumn.headerGroupStyles, ctx.rowDimensionColumn, ctx.grid.pipeTrigger))(\"column\", ctx.rowDimensionColumn)(\"rowIndex\", ctx.rowIndex)(\"parent\", ctx);\n      }\n    },\n    directives: [IgxPivotRowDimensionHeaderGroupComponent, IgxIconComponent, i4.NgClass, i4.NgStyle],\n    pipes: [IgxHeaderGroupStylePipe, IgxHeaderGroupWidthPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxPivotRowDimensionContentComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass PivotSortUtil {\n  static generateDimensionSortingExpressions(dimensions) {\n    const expressions = [];\n    PivotUtil.flatten(dimensions).forEach(x => {\n      if (x.sortDirection) {\n        expressions.push({\n          dir: x.sortDirection,\n          fieldName: x.memberName,\n          strategy: DefaultPivotSortingStrategy.instance()\n        });\n      } else {\n        expressions.push({\n          dir: SortingDirection.None,\n          fieldName: x.memberName,\n          strategy: DefaultPivotSortingStrategy.instance()\n        });\n      }\n    });\n    return expressions;\n  }\n\n}\n\nconst MINIMUM_COLUMN_WIDTH$1 = 200;\nlet IgxPivotRowComponent = /*#__PURE__*/(() => {\n  class IgxPivotRowComponent extends IgxRowDirective {\n    constructor(grid, selectionService, element, cdr, resolver, viewRef) {\n      super(grid, selectionService, element, cdr);\n      this.grid = grid;\n      this.selectionService = selectionService;\n      this.element = element;\n      this.cdr = cdr;\n      this.resolver = resolver;\n      this.viewRef = viewRef;\n      /**\n       * @hidden\n       * @internal\n       */\n\n      this.disabled = false;\n    }\n    /**\n     * @hidden\n     */\n\n\n    get selected() {\n      let isSelected = false;\n\n      for (let rowDim of this.data.dimensions) {\n        const key = PivotUtil.getRecordKey(this.data, rowDim);\n\n        if (this.selectionService.isPivotRowSelected(key)) {\n          isSelected = true;\n        }\n      }\n\n      return isSelected;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get viewIndex() {\n      return this.index;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get addRowUI() {\n      return false;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get inEditMode() {\n      return false;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    set pinned(_value) {}\n\n    get pinned() {\n      return false;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    delete() {}\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    beginAddRow() {}\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    update(_value) {}\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    pin() {\n      return false;\n    }\n    /**\n    * @hidden\n    * @internal\n    */\n\n\n    unpin() {\n      return false;\n    }\n    /**\n    *  The pivot record data passed to the row component.\n    *\n    * ```typescript\n    * // get the pivot row data for the first selected row\n    * let selectedRowData = this.grid.selectedRows[0].data;\n    * ```\n    */\n\n\n    get data() {\n      return this._data;\n    }\n\n    set data(v) {\n      this._data = v;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    get pivotAggregationData() {\n      const aggregations = this.data.aggregationValues;\n      const obj = {};\n      aggregations.forEach((value, key) => {\n        obj[key] = value;\n      });\n      return obj;\n    }\n\n    getCellClass(col) {\n      var _a;\n\n      const values = this.grid.values;\n\n      if (values.length === 1) {\n        return values[0].styles;\n      }\n\n      const colName = col.field.split(this.grid.pivotKeys.columnDimensionSeparator);\n      const measureName = colName[colName.length - 1];\n      return (_a = values.find(v => v.member === measureName)) === null || _a === void 0 ? void 0 : _a.styles;\n    }\n\n    isCellActive(visibleColumnIndex) {\n      const nav = this.grid.navigation;\n      const node = nav.activeNode;\n      return node && Object.keys(node).length !== 0 ? !nav.isRowHeaderActive && super.isCellActive(visibleColumnIndex) : false;\n    }\n\n  }\n\n  IgxPivotRowComponent.ɵfac = function IgxPivotRowComponent_Factory(t) {\n    return new (t || IgxPivotRowComponent)(i0.ɵɵdirectiveInject(IGX_GRID_BASE), i0.ɵɵdirectiveInject(IgxGridSelectionService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  };\n\n  IgxPivotRowComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxPivotRowComponent,\n    selectors: [[\"igx-pivot-row\"]],\n    hostVars: 1,\n    hostBindings: function IgxPivotRowComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-selected\", ctx.selected);\n      }\n    },\n    inputs: {\n      selected: \"selected\",\n      data: \"data\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgxRowDirective,\n      useExisting: forwardRef(() => IgxPivotRowComponent)\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 5,\n    vars: 8,\n    consts: [[\"igxGridFor\", \"\", 3, \"igxGridForOf\", \"igxForScrollContainer\", \"igxForSizePropName\", \"igxForScrollOrientation\", \"igxForContainerSize\", \"igxForTrackBy\"], [\"igxDirRef\", \"\"], [\"rowSelectorBaseTemplate\", \"\"], [1, \"igx-grid__td\", \"igx-grid__td--fw\", 3, \"ngClass\", \"ngStyle\", \"editMode\", \"column\", \"formatter\", \"intRow\", \"active\", \"rowData\", \"width\", \"visibleColumnIndex\", \"value\", \"cellTemplate\", \"lastSearchInfo\", \"cellSelectionMode\", \"displayPinnedChip\", \"pointerdown\"], [\"cell\", \"\"], [1, \"igx-grid__cbx-padding\"], [3, \"tabindex\", \"readonly\", \"checked\", \"disableRipple\", \"disabled\", \"disableTransitions\", \"aria-label\"]],\n    template: function IgxPivotRowComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, IgxPivotRowComponent_ng_template_0_Template, 7, 90, \"ng-template\", 0, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵpipe(2, \"igxNotGrouped\");\n        i0.ɵɵtemplate(3, IgxPivotRowComponent_ng_template_3_Template, 2, 7, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"igxGridForOf\", i0.ɵɵpipeBind1(2, 6, ctx.unpinnedColumns))(\"igxForScrollContainer\", ctx.grid.parentVirtDir)(\"igxForSizePropName\", \"calcPixelWidth\")(\"igxForScrollOrientation\", \"horizontal\")(\"igxForContainerSize\", ctx.grid.unpinnedWidth)(\"igxForTrackBy\", ctx.grid.trackColumnChanges);\n      }\n    },\n    directives: [IgxGridCellComponent, IgxCheckboxComponent, IgxGridForOfDirective, i4.NgClass, i4.NgStyle],\n    pipes: [IgxGridNotGroupedPipe, IgxGridTransactionStatePipe, IgxStringReplacePipe, IgxGridCellStyleClassesPipe, IgxGridCellStylesPipe, IgxGridDataMapperPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IgxPivotRowComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxPivotRowPipe = /*#__PURE__*/(() => {\n  class IgxPivotRowPipe {\n    constructor() {}\n\n    transform(collection, config, _, _pipeTrigger, __) {\n      var _a, _b, _c;\n\n      const pivotKeys = config.pivotKeys || DEFAULT_PIVOT_KEYS;\n      const enabledRows = ((_a = config.rows) === null || _a === void 0 ? void 0 : _a.filter(x => x.enabled)) || [];\n      const enabledColumns = ((_b = config.columns) === null || _b === void 0 ? void 0 : _b.filter(x => x.enabled)) || [];\n      const enabledValues = ((_c = config.values) === null || _c === void 0 ? void 0 : _c.filter(x => x.enabled)) || [];\n\n      if (enabledRows.length === 0 && enabledColumns.length === 0 && enabledValues.length === 0) {\n        // nothing to group and aggregate by ...\n        return [];\n      }\n\n      const rowStrategy = config.rowStrategy || PivotRowDimensionsStrategy.instance();\n      const data = cloneArray(collection, true);\n      return rowStrategy.process(data, enabledRows, config.values, pivotKeys);\n    }\n\n  }\n\n  IgxPivotRowPipe.ɵfac = function IgxPivotRowPipe_Factory(t) {\n    return new (t || IgxPivotRowPipe)();\n  };\n\n  IgxPivotRowPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"pivotGridRow\",\n    type: IgxPivotRowPipe,\n    pure: true\n  });\n  return IgxPivotRowPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n * Transforms generic array data into IPivotGridRecord[]\n */\n\n\nlet IgxPivotAutoTransform = /*#__PURE__*/(() => {\n  class IgxPivotAutoTransform {\n    transform(collection, config, _pipeTrigger, __) {\n      let needsTransformation = false;\n\n      if (collection.length > 0) {\n        needsTransformation = !this.isPivotRecord(collection[0]);\n      }\n\n      if (!needsTransformation) return collection;\n      const res = this.processCollectionToPivotRecord(config, collection);\n      return res;\n    }\n\n    isPivotRecord(arg) {\n      return !!arg.aggregationValues;\n    }\n\n    processCollectionToPivotRecord(config, collection) {\n      const pivotKeys = config.pivotKeys || DEFAULT_PIVOT_KEYS;\n      const enabledRows = config.rows.filter(x => x.enabled);\n      const allFlat = PivotUtil.flatten(enabledRows);\n      const result = [];\n\n      for (const rec of collection) {\n        const pivotRec = {\n          dimensionValues: new Map(),\n          aggregationValues: new Map(),\n          children: new Map(),\n          dimensions: []\n        };\n        const keys = Object.keys(rec);\n\n        for (const key of keys) {\n          const dim = allFlat.find(x => x.memberName === key);\n\n          if (dim) {\n            //field has matching dimension\n            pivotRec.dimensions.push(dim);\n            pivotRec.dimensionValues.set(key, rec[key]);\n          } else if (key.indexOf(pivotKeys.rowDimensionSeparator + pivotKeys.records) !== -1) {\n            // field that contains child collection\n            const dimKey = key.slice(0, key.indexOf(pivotKeys.rowDimensionSeparator + pivotKeys.records));\n            const childData = rec[key];\n            const childPivotData = this.processCollectionToPivotRecord(config, childData);\n            pivotRec.children.set(dimKey, childPivotData);\n          } else {\n            // an aggregation\n            pivotRec.aggregationValues.set(key, rec[key]);\n          }\n        }\n\n        const flattened = PivotUtil.flatten(config.rows);\n        pivotRec.dimensions.sort((x, y) => flattened.indexOf(x) - flattened.indexOf(y));\n        result.push(pivotRec);\n      }\n\n      return result;\n    }\n\n  }\n\n  IgxPivotAutoTransform.ɵfac = function IgxPivotAutoTransform_Factory(t) {\n    return new (t || IgxPivotAutoTransform)();\n  };\n\n  IgxPivotAutoTransform.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"pivotGridAutoTransform\",\n    type: IgxPivotAutoTransform,\n    pure: true\n  });\n  return IgxPivotAutoTransform;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxPivotRowExpansionPipe = /*#__PURE__*/(() => {\n  class IgxPivotRowExpansionPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(collection, config, expansionStates, defaultExpand, _pipeTrigger, __) {\n      var _a;\n\n      const enabledRows = ((_a = config.rows) === null || _a === void 0 ? void 0 : _a.filter(x => x.enabled)) || [];\n      const data = collection ? cloneArray(collection, true) : [];\n\n      for (const row of enabledRows) {\n        PivotUtil.flattenGroups(data, row, expansionStates, defaultExpand);\n      }\n\n      const finalData = enabledRows.length > 0 ? data.filter(x => x.dimensions.length === enabledRows.length) : data;\n\n      if (this.grid) {\n        this.grid.setFilteredSortedData(finalData, false);\n      }\n\n      return finalData;\n    }\n\n  }\n\n  IgxPivotRowExpansionPipe.ɵfac = function IgxPivotRowExpansionPipe_Factory(t) {\n    return new (t || IgxPivotRowExpansionPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxPivotRowExpansionPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"pivotGridRowExpansion\",\n    type: IgxPivotRowExpansionPipe,\n    pure: true\n  });\n  return IgxPivotRowExpansionPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxPivotCellMergingPipe = /*#__PURE__*/(() => {\n  class IgxPivotCellMergingPipe {\n    constructor(grid) {\n      this.grid = grid;\n    }\n\n    transform(collection, config, dim, _pipeTrigger) {\n      var _a;\n\n      if (collection.length === 0 || config.rows.length === 0) return collection;\n      const data = collection ? cloneArray(collection, true) : [];\n      const res = [];\n      const enabledRows = (_a = config.rows) === null || _a === void 0 ? void 0 : _a.filter(x => x.enabled);\n      let groupData = [];\n      let prevId;\n      const index = enabledRows.indexOf(dim);\n\n      for (let rec of data) {\n        const currentDim = rec.dimensions[index];\n        const id = PivotUtil.getRecordKey(rec, currentDim);\n\n        if (groupData.length > 0 && prevId !== id) {\n          const h = groupData.length > 1 ? groupData.length * this.grid.renderedRowHeight : undefined;\n          groupData[0].height = h;\n          groupData[0].rowSpan = groupData.length;\n          res.push(groupData[0]);\n          groupData = [];\n        }\n\n        groupData.push(rec);\n        prevId = id;\n      }\n\n      if (groupData.length > 0) {\n        const h = groupData.length > 1 ? groupData.length * this.grid.rowHeight + (groupData.length - 1) + 1 : undefined;\n        groupData[0].height = h;\n        groupData[0].rowSpan = groupData.length;\n        res.push(groupData[0]);\n      }\n\n      return res;\n    }\n\n  }\n\n  IgxPivotCellMergingPipe.ɵfac = function IgxPivotCellMergingPipe_Factory(t) {\n    return new (t || IgxPivotCellMergingPipe)(i0.ɵɵdirectiveInject(IGX_GRID_BASE, 16));\n  };\n\n  IgxPivotCellMergingPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"pivotGridCellMerging\",\n    type: IgxPivotCellMergingPipe,\n    pure: true\n  });\n  return IgxPivotCellMergingPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxPivotColumnPipe = /*#__PURE__*/(() => {\n  class IgxPivotColumnPipe {\n    transform(collection, config, _, _pipeTrigger, __) {\n      var _a, _b;\n\n      const pivotKeys = config.pivotKeys || DEFAULT_PIVOT_KEYS;\n      const enabledColumns = ((_a = config.columns) === null || _a === void 0 ? void 0 : _a.filter(x => x.enabled)) || [];\n      const enabledValues = ((_b = config.values) === null || _b === void 0 ? void 0 : _b.filter(x => x.enabled)) || [];\n      const colStrategy = config.columnStrategy || PivotColumnDimensionsStrategy.instance();\n      const data = cloneArray(collection, true);\n      return colStrategy.process(data, enabledColumns, enabledValues, pivotKeys);\n    }\n\n  }\n\n  IgxPivotColumnPipe.ɵfac = function IgxPivotColumnPipe_Factory(t) {\n    return new (t || IgxPivotColumnPipe)();\n  };\n\n  IgxPivotColumnPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"pivotGridColumn\",\n    type: IgxPivotColumnPipe,\n    pure: true\n  });\n  return IgxPivotColumnPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxPivotGridFilterPipe = /*#__PURE__*/(() => {\n  class IgxPivotGridFilterPipe {\n    constructor(gridAPI) {\n      this.gridAPI = gridAPI;\n    }\n\n    transform(collection, config, filterStrategy, advancedExpressionsTree, _filterPipeTrigger, _pipeTrigger) {\n      const expressionsTree = PivotUtil.buildExpressionTree(config);\n      const state = {\n        expressionsTree,\n        strategy: filterStrategy || new DimensionValuesFilteringStrategy(),\n        advancedExpressionsTree\n      };\n\n      if (FilteringExpressionsTree.empty(state.expressionsTree) && FilteringExpressionsTree.empty(state.advancedExpressionsTree)) {\n        return collection;\n      }\n\n      const result = FilterUtil.filter(cloneArray(collection, true), state, this.gridAPI.grid);\n      return result;\n    }\n\n  }\n\n  IgxPivotGridFilterPipe.ɵfac = function IgxPivotGridFilterPipe_Factory(t) {\n    return new (t || IgxPivotGridFilterPipe)(i0.ɵɵdirectiveInject(GridBaseAPIService, 16));\n  };\n\n  IgxPivotGridFilterPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"pivotGridFilter\",\n    type: IgxPivotGridFilterPipe,\n    pure: true\n  });\n  return IgxPivotGridFilterPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxPivotGridColumnSortingPipe = /*#__PURE__*/(() => {\n  class IgxPivotGridColumnSortingPipe {\n    transform(collection, expressions, sorting, _pipeTrigger) {\n      let result;\n\n      if (!expressions.length) {\n        result = collection;\n      } else {\n        for (const expr of expressions) {\n          expr.strategy = DefaultPivotGridRecordSortingStrategy.instance();\n        }\n\n        result = PivotUtil.sort(cloneArray(collection, true), expressions, sorting);\n      }\n\n      return result;\n    }\n\n  }\n\n  IgxPivotGridColumnSortingPipe.ɵfac = function IgxPivotGridColumnSortingPipe_Factory(t) {\n    return new (t || IgxPivotGridColumnSortingPipe)();\n  };\n\n  IgxPivotGridColumnSortingPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"pivotGridColumnSort\",\n    type: IgxPivotGridColumnSortingPipe,\n    pure: true\n  });\n  return IgxPivotGridColumnSortingPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxPivotGridSortingPipe = /*#__PURE__*/(() => {\n  class IgxPivotGridSortingPipe {\n    constructor(gridAPI) {\n      this.gridAPI = gridAPI;\n    }\n\n    transform(collection, config, sorting, _pipeTrigger) {\n      let result;\n      const allDimensions = config.rows || [];\n      const enabledDimensions = allDimensions.filter(x => x && x.enabled);\n      const expressions = PivotSortUtil.generateDimensionSortingExpressions(enabledDimensions);\n\n      if (!expressions.length) {\n        result = collection;\n      } else {\n        result = DataUtil.sort(cloneArray(collection, true), expressions, sorting, this.gridAPI.grid);\n      }\n\n      return result;\n    }\n\n  }\n\n  IgxPivotGridSortingPipe.ɵfac = function IgxPivotGridSortingPipe_Factory(t) {\n    return new (t || IgxPivotGridSortingPipe)(i0.ɵɵdirectiveInject(GridBaseAPIService, 16));\n  };\n\n  IgxPivotGridSortingPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"pivotGridSort\",\n    type: IgxPivotGridSortingPipe,\n    pure: true\n  });\n  return IgxPivotGridSortingPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxFilterPivotItemsPipe = /*#__PURE__*/(() => {\n  class IgxFilterPivotItemsPipe {\n    transform(collection, filterCriteria, _pipeTrigger) {\n      if (!collection) {\n        return collection;\n      }\n\n      let copy = collection.slice(0);\n\n      if (filterCriteria && filterCriteria.length > 0) {\n        const filterFunc = c => {\n          var _a, _b;\n\n          const filterText = c.member || c.memberName;\n\n          if (!filterText) {\n            return false;\n          }\n\n          return filterText.toLocaleLowerCase().indexOf(filterCriteria.toLocaleLowerCase()) >= 0 || ((_b = (_a = c.children) === null || _a === void 0 ? void 0 : _a.some(filterFunc)) !== null && _b !== void 0 ? _b : false);\n        };\n\n        copy = collection.filter(filterFunc);\n      }\n\n      return copy;\n    }\n\n  }\n\n  IgxFilterPivotItemsPipe.ɵfac = function IgxFilterPivotItemsPipe_Factory(t) {\n    return new (t || IgxFilterPivotItemsPipe)();\n  };\n\n  IgxFilterPivotItemsPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"filterPivotItems\",\n    type: IgxFilterPivotItemsPipe,\n    pure: true\n  });\n  return IgxFilterPivotItemsPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NEXT_ID = 0;\nconst MINIMUM_COLUMN_WIDTH = 200;\nconst MINIMUM_COLUMN_WIDTH_SUPER_COMPACT = 104;\n/**\n * Pivot Grid provides a way to present and manipulate data in a pivot table view.\n *\n * @igxModule IgxPivotGridModule\n * @igxGroup Grids & Lists\n * @igxKeywords pivot, grid, table\n * @igxTheme igx-grid-theme\n * @remarks\n * The Ignite UI Pivot Grid is used for grouping and aggregating simple flat data into a pivot table.  Once data\n * has been bound and the dimensions and values configured it can be manipulated via sorting and filtering.\n * @example\n * ```html\n * <igx-pivot-grid [data]=\"data\" [pivotConfiguration]=\"configuration\">\n * </igx-pivot-grid>\n * ```\n */\n\nlet IgxPivotGridComponent = /*#__PURE__*/(() => {\n  class IgxPivotGridComponent extends IgxGridBaseDirective {\n    constructor(selectionService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, appRef, moduleRef, injector, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, localeId, platform, _diTransactions) {\n      super(selectionService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, appRef, moduleRef, injector, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, localeId, platform);\n      this.selectionService = selectionService;\n      this.colResizingService = colResizingService;\n      this.transactionFactory = transactionFactory;\n      this.document = document;\n      this.overlayService = overlayService;\n      this.summaryService = summaryService;\n      this._displayDensityOptions = _displayDensityOptions;\n      this.platform = platform;\n      this._diTransactions = _diTransactions;\n      /**\n       * Emitted when the dimension collection is changed via the grid chip area.\n       *\n       * @remarks\n       * Returns the new dimension collection and its type:\n       * @example\n       * ```html\n       * <igx-pivot-grid #grid [data]=\"localData\" [height]=\"'305px'\"\n       *              (dimensionsChange)=\"dimensionsChange($event)\"></igx-grid>\n       * ```\n       */\n\n      this.dimensionsChange = new EventEmitter();\n      /**\n       * Emitted when a dimension is sorted.\n       *\n       * @example\n       * ```html\n       * <igx-pivot-grid #grid [data]=\"localData\" [height]=\"'305px'\"\n       *              (dimensionsSortingExpressionsChange)=\"dimensionsSortingExpressionsChange($event)\"></igx-pivot-grid>\n       * ```\n       */\n\n      this.dimensionsSortingExpressionsChange = new EventEmitter();\n      /**\n       * Emitted when the values collection is changed via the grid chip area.\n       *\n       * @remarks\n       * Returns the new dimension\n       * @example\n       * ```html\n       * <igx-pivot-grid #grid [data]=\"localData\" [height]=\"'305px'\"\n       *              (valuesChange)=\"valuesChange($event)\"></igx-grid>\n       * ```\n      */\n\n      this.valuesChange = new EventEmitter();\n      this.showPivotConfigurationUI = true;\n      /**\n       * @hidden @internal\n       */\n\n      this.role = 'grid';\n      /**\n       * @hidden @internal\n       */\n\n      this.snackbarDisplayTime = 6000;\n      /**\n       * @hidden @internal\n       */\n\n      this.cellEdit = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.cellEditDone = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.cellEditEnter = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.cellEditExit = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.columnMovingStart = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.columnMoving = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.columnMovingEnd = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.columnPin = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.columnPinned = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.rowAdd = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.rowAdded = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.rowDeleted = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.rowDelete = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.rowDragStart = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.rowDragEnd = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.rowEditEnter = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.rowEdit = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.rowEditDone = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.rowEditExit = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.rowPinning = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.rowPinned = new EventEmitter();\n      this.columnGroupStates = new Map();\n      this.isPivot = true;\n      /**\n       * @hidden @internal\n       */\n\n      this.dragRowID = null;\n      /**\n       * @hidden @internal\n       */\n\n      this.rowDimensionResizing = true;\n      /**\n       * @hidden @internal\n       */\n\n      this._emptyRowDimension = {\n        memberName: '',\n        enabled: true,\n        level: 0\n      };\n      this._defaultExpandState = false;\n      this._filterStrategy = new DimensionValuesFilteringStrategy();\n      this._pivotConfiguration = {\n        rows: null,\n        columns: null,\n        values: null,\n        filters: null\n      };\n      this.p_id = `igx-pivot-grid-${NEXT_ID++}`;\n      this._superCompactMode = false;\n      /**\n       * @hidden @internal\n       */\n\n      this.autoGenerate = true;\n      /**\n       * @hidden @internal\n       */\n\n      this.pageChange = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.pagingDone = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.perPageChange = new EventEmitter();\n      /**\n       * @hidden @internal\n       */\n\n      this.moving = false;\n      /**\n       * @hidden @internal\n       */\n\n      this.toolbarExporting = new EventEmitter();\n    }\n\n    set pivotConfiguration(value) {\n      this._pivotConfiguration = value;\n\n      if (!this._init) {\n        this.setupColumns();\n      }\n\n      this.notifyChanges(true);\n    }\n\n    get pivotConfiguration() {\n      return this._pivotConfiguration || {\n        rows: null,\n        columns: null,\n        values: null,\n        filters: null\n      };\n    }\n    /**\n     * Enables a super compact theme for the component.\n     * @remarks\n     * Overrides the displayDensity option if one is set.\n     * @example\n     * ```html\n     * <igx-pivot-grid [superCompactMode]=\"true\"></igx-pivot-grid>\n     * ```\n     */\n\n\n    get superCompactMode() {\n      return this._superCompactMode;\n    }\n\n    set superCompactMode(value) {\n      Promise.resolve().then(() => {\n        // wait for the current detection cycle to end before triggering a new one.\n        this._superCompactMode = value;\n        this.cdr.detectChanges();\n      });\n    }\n    /**\n    * Returns the theme of the component.\n    * The default theme is `comfortable`.\n    * Available options are `comfortable`, `cosy`, `compact`.\n    * @remarks\n    * If set while superCompactMode is enabled will have no affect.\n    * ```typescript\n    * let componentTheme = this.component.displayDensity;\n    * ```\n    */\n\n\n    get displayDensity() {\n      if (this.superCompactMode) {\n        return DisplayDensity.compact;\n      }\n\n      return super.displayDensity;\n    }\n    /**\n    * Sets the theme of the component.\n    */\n\n\n    set displayDensity(val) {\n      const currentDisplayDensity = this._displayDensity;\n      this._displayDensity = val;\n\n      if (currentDisplayDensity !== this._displayDensity) {\n        const densityChangedArgs = {\n          oldDensity: currentDisplayDensity,\n          newDensity: this._displayDensity\n        };\n        this.onDensityChanged.emit(densityChangedArgs);\n      }\n    }\n\n    get pivotKeys() {\n      return this.pivotConfiguration.pivotKeys || DEFAULT_PIVOT_KEYS;\n    }\n    /**\n    * @hidden @internal\n    */\n\n\n    get rootSummariesEnabled() {\n      return false;\n    }\n\n    get emptyRowDimension() {\n      return this._emptyRowDimension;\n    }\n    /**\n    * Gets/Sets the default expand state for all rows.\n    */\n\n\n    get defaultExpandState() {\n      return this._defaultExpandState;\n    }\n\n    set defaultExpandState(val) {\n      this._defaultExpandState = val;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get pagingMode() {\n      return;\n    }\n\n    set pagingMode(_val) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    get hideRowSelectors() {\n      return;\n    }\n\n    set hideRowSelectors(_value) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    get rowDraggable() {\n      return;\n    }\n\n    set rowDraggable(_val) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    get allowAdvancedFiltering() {\n      return false;\n    }\n\n    set allowAdvancedFiltering(_value) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    get filterMode() {\n      return FilterMode.quickFilter;\n    }\n\n    set filterMode(_value) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    get allowFiltering() {\n      return false;\n    }\n\n    set allowFiltering(_value) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    get isFirstPage() {\n      return true;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get isLastPage() {\n      return true;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get page() {\n      return 0;\n    }\n\n    set page(_val) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    get paging() {\n      return false;\n    }\n\n    set paging(_value) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    get perPage() {\n      return;\n    }\n\n    set perPage(_val) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    get pinnedColumns() {\n      return [];\n    }\n    /**\n    * @hidden @internal\n    */\n\n\n    get unpinnedColumns() {\n      return super.unpinnedColumns;\n    }\n    /**\n    * @hidden @internal\n    */\n\n\n    get unpinnedDataView() {\n      return super.unpinnedDataView;\n    }\n    /**\n    * @hidden @internal\n    */\n\n\n    get unpinnedWidth() {\n      return super.unpinnedWidth;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get pinnedWidth() {\n      return super.pinnedWidth;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    set summaryRowHeight(_value) {}\n\n    get summaryRowHeight() {\n      return 0;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get totalPages() {\n      return;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get transactions() {\n      return this._transactions;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get dragIndicatorIconTemplate() {\n      return;\n    }\n\n    set dragIndicatorIconTemplate(_val) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    get rowEditable() {\n      return;\n    }\n\n    set rowEditable(_val) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    get pinning() {\n      return {};\n    }\n\n    set pinning(_value) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    get summaryPosition() {\n      return;\n    }\n\n    set summaryPosition(_value) {}\n    /**\n     * @hidden @interal\n     */\n\n\n    get summaryCalculationMode() {\n      return;\n    }\n\n    set summaryCalculationMode(_value) {}\n    /**\n     * @hidden @interal\n     */\n\n\n    get showSummaryOnCollapse() {\n      return;\n    }\n\n    set showSummaryOnCollapse(_value) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    get hiddenColumnsCount() {\n      return null;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get pinnedColumnsCount() {\n      return null;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get batchEditing() {\n      return;\n    }\n\n    set batchEditing(_val) {}\n\n    get selectedRows() {\n      if (this.selectionService.getSelectedRows().length === 0) {\n        return [];\n      }\n\n      const selectedRowIds = [];\n      this.dataView.forEach(record => {\n        const prev = [];\n\n        for (const dim of this.rowDimensions) {\n          let currDim = dim;\n          let shouldBreak = false;\n\n          do {\n            const key = PivotUtil.getRecordKey(record, currDim);\n\n            if (this.selectionService.isPivotRowSelected(key) && !selectedRowIds.find(x => x === record)) {\n              selectedRowIds.push(record);\n              shouldBreak = true;\n              break;\n            }\n\n            currDim = currDim.childLevel;\n          } while (currDim);\n\n          prev.push(dim);\n\n          if (shouldBreak) {\n            break;\n          }\n        }\n      });\n      return selectedRowIds;\n    }\n    /**\n     * Gets the default row height.\n     *\n     * @example\n     * ```typescript\n     * const rowHeigh = this.grid.defaultRowHeight;\n     * ```\n     */\n\n\n    get defaultRowHeight() {\n      if (this.superCompactMode) {\n        return 24;\n      }\n\n      return super.defaultRowHeight;\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngOnInit() {\n      // pivot grid always generates columns automatically.\n      this.autoGenerate = true;\n      const config = this.pivotConfiguration;\n      this.filteringExpressionsTree = PivotUtil.buildExpressionTree(config);\n      super.ngOnInit();\n    }\n    /**\n     * @hidden\n     */\n\n\n    ngAfterContentInit() {\n      // ignore any user defined columns and auto-generate based on pivot config.\n      this.columnList.reset([]);\n      Promise.resolve().then(() => {\n        this.setupColumns();\n      });\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    ngAfterViewInit() {\n      Promise.resolve().then(() => {\n        super.ngAfterViewInit();\n      });\n    }\n    /**\n     * Notifies for dimension change.\n     */\n\n\n    notifyDimensionChange(regenerateColumns = false) {\n      if (regenerateColumns) {\n        this.setupColumns();\n      }\n\n      this.pipeTrigger++;\n      this.cdr.detectChanges();\n    }\n    /**\n     * Gets the full list of dimensions.\n     *\n     * @example\n     * ```typescript\n     * const dimensions = this.grid.allDimensions;\n     * ```\n     */\n\n\n    get allDimensions() {\n      const config = this.pivotConfiguration;\n      return (config.rows || []).concat(config.columns || []).concat(config.filters || []).filter(x => x !== null && x !== undefined);\n    }\n    /** @hidden @internal */\n\n\n    createFilterESF(dropdown, column, options, shouldReatach) {\n      options.outlet = this.outlet;\n\n      if (dropdown) {\n        dropdown.initialize(column, this.overlayService);\n\n        if (shouldReatach) {\n          const id = this.overlayService.attach(dropdown.element, options);\n          dropdown.overlayComponentId = id;\n          return {\n            id,\n            ref: undefined\n          };\n        }\n\n        return {\n          id: dropdown.overlayComponentId,\n          ref: undefined\n        };\n      }\n    }\n    /** @hidden */\n\n\n    featureColumnsWidth() {\n      return this.pivotRowWidths;\n    }\n    /**\n     * Gets/Sets the value of the `id` attribute.\n     *\n     * @remarks\n     * If not provided it will be automatically generated.\n     * @example\n     * ```html\n     * <igx-pivot-grid [id]=\"'igx-pivot-1'\" [data]=\"Data\"></igx-pivot-grid>\n     * ```\n     */\n\n\n    get id() {\n      return this.p_id;\n    }\n\n    set id(value) {\n      this.p_id = value;\n    }\n    /**\n     * An @Input property that lets you fill the `IgxPivotGridComponent` with an array of data.\n     * ```html\n     * <igx-pivot-grid [data]=\"Data\"></igx-pivot-grid>\n     * ```\n     */\n\n\n    set data(value) {\n      this._data = value || [];\n\n      if (!this._init) {\n        this.setupColumns();\n        this.reflow();\n      }\n\n      this.cdr.markForCheck();\n\n      if (this.height === null || this.height.indexOf('%') !== -1) {\n        // If the height will change based on how much data there is, recalculate sizes in igxForOf.\n        this.notifyChanges(true);\n      }\n    }\n    /**\n     * Returns an array of data set to the component.\n     * ```typescript\n     * let data = this.grid.data;\n     * ```\n     */\n\n\n    get data() {\n      return this._data;\n    }\n    /**\n     * Sets an array of objects containing the filtered data.\n     * ```typescript\n     * this.grid.filteredData = [{\n     *       ID: 1,\n     *       Name: \"A\"\n     * }];\n     * ```\n     */\n\n\n    set filteredData(value) {\n      this._filteredData = value;\n    }\n    /**\n     * Returns an array of objects containing the filtered data.\n     * ```typescript\n     * let filteredData = this.grid.filteredData;\n     * ```\n     *\n     * @memberof IgxHierarchicalGridComponent\n     */\n\n\n    get filteredData() {\n      return this._filteredData;\n    }\n    /**\n     * @hidden\n     */\n\n\n    getContext(rowData, rowIndex) {\n      return {\n        $implicit: rowData,\n        templateID: {\n          type: 'dataRow',\n          id: null\n        },\n        index: this.getDataViewIndex(rowIndex, false)\n      };\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get pivotRowWidths() {\n      return this.rowDimensions.length ? this.rowDimensions.reduce((accumulator, dim) => accumulator + this.rowDimensionWidthToPixels(dim), 0) : this.rowDimensionWidthToPixels(this.emptyRowDimension);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    rowDimensionWidthToPixels(dim) {\n      if (!dim.width) {\n        return MINIMUM_COLUMN_WIDTH;\n      }\n\n      const isPercent = dim.width && dim.width.indexOf('%') !== -1;\n\n      if (isPercent) {\n        return parseFloat(dim.width) / 100 * this.calcWidth;\n      } else {\n        return parseInt(dim.width, 10);\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    reverseDimensionWidthToPercent(width) {\n      return width * 100 / this.calcWidth;\n    }\n\n    get rowDimensions() {\n      var _a;\n\n      return ((_a = this.pivotConfiguration.rows) === null || _a === void 0 ? void 0 : _a.filter(x => x.enabled)) || [];\n    }\n\n    get columnDimensions() {\n      var _a;\n\n      return ((_a = this.pivotConfiguration.columns) === null || _a === void 0 ? void 0 : _a.filter(x => x.enabled)) || [];\n    }\n\n    get filterDimensions() {\n      var _a;\n\n      return ((_a = this.pivotConfiguration.filters) === null || _a === void 0 ? void 0 : _a.filter(x => x.enabled)) || [];\n    }\n\n    get values() {\n      var _a;\n\n      return ((_a = this.pivotConfiguration.values) === null || _a === void 0 ? void 0 : _a.filter(x => x.enabled)) || [];\n    }\n\n    toggleColumn(col) {\n      const state = this.columnGroupStates.get(col.field);\n      const newState = !state;\n      this.columnGroupStates.set(col.field, newState);\n      this.toggleRowGroup(col, newState);\n      this.reflow();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    isRecordPinnedByIndex(_rowIndex) {\n      return null;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    toggleColumnVisibility(_args) {\n      return;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    expandAll() {}\n    /**\n     * @hidden @internal\n     */\n\n\n    collapseAll() {}\n    /**\n     * @hidden @internal\n     */\n\n\n    expandRow(_rowID) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    collapseRow(_rowID) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    get pinnedRows() {\n      return;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get totalRecords() {\n      return;\n    }\n\n    set totalRecords(_total) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    moveColumn(_column, _target, _pos = DropPosition.AfterDropTarget) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    addRow(_data) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    deleteRow(_rowSelector) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    updateCell(_value, _rowSelector, _column) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    updateRow(_value, _rowSelector) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    enableSummaries(..._rest) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    disableSummaries(..._rest) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    pinColumn(_columnName, _index) {\n      return;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    unpinColumn(_columnName, _index) {\n      return;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    pinRow(_rowID, _index, _row) {\n      return;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    unpinRow(_rowID, _row) {\n      return;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get pinnedRowHeight() {\n      return;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get hasEditableColumns() {\n      return;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get hasSummarizedColumns() {\n      return;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get hasMovableColumns() {\n      return;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get pinnedDataView() {\n      return [];\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    openAdvancedFilteringDialog(_overlaySettings) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    closeAdvancedFilteringDialog(_applyChanges) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    endEdit(_commit = true, _event) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    beginAddRowById(_rowID, _asChild) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    beginAddRowByIndex(_index) {}\n    /**\n     * @hidden @internal\n     */\n\n\n    clearSearch() {}\n    /**\n     * @hidden @internal\n     */\n\n\n    paginate(_val) {}\n    /**\n    * @hidden @internal\n    */\n\n\n    nextPage() {}\n    /**\n    * @hidden @internal\n    */\n\n\n    previousPage() {}\n    /**\n    * @hidden @internal\n    */\n\n\n    refreshSearch(_updateActiveInfo, _endEdit = true) {\n      return 0;\n    }\n    /**\n    * @hidden @internal\n    */\n\n\n    findNext(_text, _caseSensitive, _exactMatch) {\n      return 0;\n    }\n    /**\n    * @hidden @internal\n    */\n\n\n    findPrev(_text, _caseSensitive, _exactMatch) {\n      return 0;\n    }\n    /**\n    * @hidden @internal\n    */\n\n\n    getNextCell(currRowIndex, curVisibleColIndex, callback = null) {\n      return super.getNextCell(currRowIndex, curVisibleColIndex, callback);\n    }\n    /**\n    * @hidden @internal\n    */\n\n\n    getPreviousCell(currRowIndex, curVisibleColIndex, callback = null) {\n      return super.getPreviousCell(currRowIndex, curVisibleColIndex, callback);\n    }\n    /**\n    * @hidden @internal\n    */\n\n\n    getPinnedWidth(takeHidden = false) {\n      return super.getPinnedWidth(takeHidden);\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    get totalHeight() {\n      return this.calcHeight;\n    }\n\n    getColumnGroupExpandState(col) {\n      const state = this.columnGroupStates.get(col.field); // columns are expanded by default?\n\n      return state !== undefined && state !== null ? state : false;\n    }\n\n    toggleRowGroup(col, newState) {\n      if (!col) return;\n\n      if (this.hasMultipleValues) {\n        const parentCols = col.parent ? col.parent.children.toArray() : this._autoGeneratedCols.filter(x => x.level === 0);\n        const siblingCol = parentCols.filter(x => x.header === col.header && x !== col)[0];\n        const currIndex = parentCols.indexOf(col);\n        const siblingIndex = parentCols.indexOf(siblingCol);\n\n        if (currIndex < siblingIndex) {\n          // clicked on the full hierarchy header\n          this.resolveToggle(col, newState);\n          siblingCol.headerTemplate = this.headerTemplate;\n        } else {\n          // clicked on summary parent column that contains just the measures\n          col.headerTemplate = undefined;\n          this.resolveToggle(siblingCol, newState);\n        }\n      } else {\n        const parentCols = col.parent ? col.parent.children : this._autoGeneratedCols.filter(x => x.level === 0);\n        const fieldColumn = parentCols.filter(x => x.header === col.header && !x.columnGroup)[0];\n        const groupColumn = parentCols.filter(x => x.header === col.header && x.columnGroup)[0];\n        this.resolveToggle(groupColumn, newState);\n\n        if (newState) {\n          fieldColumn.headerTemplate = this.headerTemplate;\n        } else {\n          fieldColumn.headerTemplate = undefined;\n        }\n      }\n    }\n    /**\n    * @hidden @internal\n    */\n\n\n    setupColumns() {\n      super.setupColumns();\n    }\n    /**\n     * Auto-sizes row dimension cells.\n     *\n     * @remarks\n     * Only sizes based on the dimension cells in view.\n     * @example\n     * ```typescript\n     * this.grid.autoSizeRowDimension(dimension);\n     * ```\n     * @param dimension The row dimension to size.\n     */\n\n\n    autoSizeRowDimension(dimension) {\n      if (this.getDimensionType(dimension) === PivotDimensionType.Row) {\n        const relatedDims = PivotUtil.flatten([dimension]).map(x => x.memberName);\n        const content = this.rowDimensionContentCollection.filter(x => relatedDims.indexOf(x.dimension.memberName) !== -1);\n        const headers = content.map(x => x.headerGroups.toArray()).flat().map(x => x.header && x.header.refInstance);\n        const autoWidth = this.getLargesContentWidth(headers);\n        dimension.width = autoWidth;\n        this.pipeTrigger++;\n        this.cdr.detectChanges();\n      }\n    }\n    /**\n     * Inserts dimension in target collection by type at specified index or at the collection's end.\n     *\n     * @example\n     * ```typescript\n     * this.grid.insertDimensionAt(dimension, PivotDimensionType.Row, 1);\n     * ```\n     * @param dimension The dimension that will be added.\n     * @param targetCollectionType The target collection type to add to. Can be Row, Column or Filter.\n     * @param index The index in the collection at which to add.\n     * This parameter is optional. If not set it will add it to the end of the collection.\n     */\n\n\n    insertDimensionAt(dimension, targetCollectionType, index) {\n      const targetCollection = this.getDimensionsByType(targetCollectionType);\n\n      if (index !== undefined) {\n        targetCollection.splice(index, 0, dimension);\n      } else {\n        targetCollection.push(dimension);\n      }\n\n      if (targetCollectionType === PivotDimensionType.Column) {\n        this.setupColumns();\n      }\n\n      this.pipeTrigger++;\n      this.dimensionsChange.emit({\n        dimensions: targetCollection,\n        dimensionCollectionType: targetCollectionType\n      });\n\n      if (targetCollectionType === PivotDimensionType.Filter) {\n        this.dimensionDataColumns = this.generateDimensionColumns();\n        this.reflow();\n      }\n    }\n    /**\n     * Move dimension from its currently collection to the specified target collection by type at specified index or at the collection's end.\n     *\n     * @example\n     * ```typescript\n     * this.grid.moveDimension(dimension, PivotDimensionType.Row, 1);\n     * ```\n     * @param dimension The dimension that will be moved.\n     * @param targetCollectionType The target collection type to move it to. Can be Row, Column or Filter.\n     * @param index The index in the collection at which to add.\n     * This parameter is optional. If not set it will add it to the end of the collection.\n     */\n\n\n    moveDimension(dimension, targetCollectionType, index) {\n      const prevCollectionType = this.getDimensionType(dimension);\n      if (prevCollectionType === null) return; // remove from old collection\n\n      this._removeDimensionInternal(dimension); // add to target\n\n\n      this.insertDimensionAt(dimension, targetCollectionType, index);\n\n      if (prevCollectionType === PivotDimensionType.Column) {\n        this.setupColumns();\n      }\n    }\n    /**\n     * Removes dimension from its currently collection.\n     * @remarks\n     * This is different than toggleDimension that enabled/disables the dimension.\n     * This completely removes the specified dimension from the collection.\n     * @example\n     * ```typescript\n     * this.grid.removeDimension(dimension);\n     * ```\n     * @param dimension The dimension to be removed.\n     */\n\n\n    removeDimension(dimension) {\n      const prevCollectionType = this.getDimensionType(dimension);\n\n      this._removeDimensionInternal(dimension);\n\n      if (prevCollectionType === PivotDimensionType.Column) {\n        this.setupColumns();\n      }\n\n      if (prevCollectionType === PivotDimensionType.Filter) {\n        this.reflow();\n      }\n\n      this.pipeTrigger++;\n      this.cdr.detectChanges();\n    }\n    /**\n     * Toggles the dimension's enabled state on or off.\n     * @remarks\n     * The dimension remains in its current collection. This just changes its enabled state.\n     * @example\n     * ```typescript\n     * this.grid.toggleDimension(dimension);\n     * ```\n     * @param dimension The dimension to be toggled.\n     */\n\n\n    toggleDimension(dimension) {\n      const dimType = this.getDimensionType(dimension);\n      if (dimType === null) return;\n      const collection = this.getDimensionsByType(dimType);\n      dimension.enabled = !dimension.enabled;\n\n      if (dimType === PivotDimensionType.Column) {\n        this.setupColumns();\n      }\n\n      if (!dimension.enabled && dimension.filter) {\n        this.filteringService.clearFilter(dimension.memberName);\n      }\n\n      this.pipeTrigger++;\n      this.dimensionsChange.emit({\n        dimensions: collection,\n        dimensionCollectionType: dimType\n      });\n      this.cdr.detectChanges();\n\n      if (dimType === PivotDimensionType.Filter) {\n        this.reflow();\n      }\n    }\n    /**\n     * Inserts value at specified index or at the end.\n     *\n     * @example\n     * ```typescript\n     * this.grid.insertValueAt(value, 1);\n     * ```\n     * @param value The value definition that will be added.\n     * @param index The index in the collection at which to add.\n     * This parameter is optional. If not set it will add it to the end of the collection.\n     */\n\n\n    insertValueAt(value, index) {\n      if (!this.pivotConfiguration.values) {\n        this.pivotConfiguration.values = [];\n      }\n\n      const values = this.pivotConfiguration.values;\n\n      if (index !== undefined) {\n        values.splice(index, 0, value);\n      } else {\n        values.push(value);\n      }\n\n      this.setupColumns();\n      this.pipeTrigger++;\n      this.cdr.detectChanges();\n      this.valuesChange.emit({\n        values\n      });\n    }\n    /**\n     * Move value from its currently at specified index or at the end.\n     *\n     * @example\n     * ```typescript\n     * this.grid.moveValue(value, 1);\n     * ```\n     * @param value The value that will be moved.\n     * @param index The index in the collection at which to add.\n     * This parameter is optional. If not set it will add it to the end of the collection.\n     */\n\n\n    moveValue(value, index) {\n      if (this.pivotConfiguration.values.indexOf(value) === -1) return; // remove from old index\n\n      this.removeValue(value); // add to new\n\n      this.insertValueAt(value, index);\n    }\n    /**\n     * Removes value from collection.\n     * @remarks\n     * This is different than toggleValue that enabled/disables the value.\n     * This completely removes the specified value from the collection.\n     * @example\n     * ```typescript\n     * this.grid.removeValue(dimension);\n     * ```\n     * @param value The value to be removed.\n     */\n\n\n    removeValue(value) {\n      const values = this.pivotConfiguration.values;\n      const currentIndex = values.indexOf(value);\n\n      if (currentIndex !== -1) {\n        values.splice(currentIndex, 1);\n        this.setupColumns();\n        this.pipeTrigger++;\n        this.valuesChange.emit({\n          values\n        });\n      }\n    }\n    /**\n     * Toggles the value's enabled state on or off.\n     * @remarks\n     * The value remains in its current collection. This just changes its enabled state.\n     * @example\n     * ```typescript\n     * this.grid.toggleValue(value);\n     * ```\n     * @param value The value to be toggled.\n     */\n\n\n    toggleValue(value) {\n      if (this.pivotConfiguration.values.indexOf(value) === -1) return;\n      value.enabled = !value.enabled;\n      this.setupColumns();\n      this.pipeTrigger++;\n      this.valuesChange.emit({\n        values: this.pivotConfiguration.values\n      });\n      this.reflow();\n    }\n    /**\n     * Sort the dimension and its children in the provided direction.\n     * @example\n     * ```typescript\n     * this.grid.sortDimension(dimension, SortingDirection.Asc);\n     * ```\n     * @param value The value to be toggled.\n     */\n\n\n    sortDimension(dimension, sortDirection) {\n      const dimensionType = this.getDimensionType(dimension);\n      dimension.sortDirection = sortDirection; // apply same sort direction to children.\n\n      let dim = dimension;\n\n      while (dim.childLevel) {\n        dim.childLevel.sortDirection = dimension.sortDirection;\n        dim = dim.childLevel;\n      }\n\n      const dimensionsSortingExpressions = PivotSortUtil.generateDimensionSortingExpressions(this.rowDimensions);\n      this.pipeTrigger++;\n      this.dimensionsSortingExpressionsChange.emit(dimensionsSortingExpressions);\n\n      if (dimensionType === PivotDimensionType.Column) {\n        this.setupColumns();\n      }\n\n      this.cdr.detectChanges();\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    getDimensionsByType(dimension) {\n      switch (dimension) {\n        case PivotDimensionType.Row:\n          if (!this.pivotConfiguration.rows) {\n            this.pivotConfiguration.rows = [];\n          }\n\n          return this.pivotConfiguration.rows;\n\n        case PivotDimensionType.Column:\n          if (!this.pivotConfiguration.columns) {\n            this.pivotConfiguration.columns = [];\n          }\n\n          return this.pivotConfiguration.columns;\n\n        case PivotDimensionType.Filter:\n          if (!this.pivotConfiguration.filters) {\n            this.pivotConfiguration.filters = [];\n          }\n\n          return this.pivotConfiguration.filters;\n\n        default:\n          return null;\n      }\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    resizeRowDimensionPixels(dimension, newWidth) {\n      const isPercentageWidth = dimension.width && typeof dimension.width === 'string' && dimension.width.indexOf('%') !== -1;\n\n      if (isPercentageWidth) {\n        dimension.width = this.reverseDimensionWidthToPercent(newWidth).toFixed(2) + '%';\n      } else {\n        dimension.width = newWidth + 'px';\n      } // Notify the grid to reflow, to update if horizontal scrollbar needs to be rendered/removed.\n\n\n      this.pipeTrigger++;\n      this.cdr.detectChanges();\n    }\n    /*\n    * @hidden\n    * @internal\n    */\n\n\n    _removeDimensionInternal(dimension) {\n      const prevCollectionType = this.getDimensionType(dimension);\n      if (prevCollectionType === null) return;\n      const prevCollection = this.getDimensionsByType(prevCollectionType);\n      const currentIndex = prevCollection.indexOf(dimension);\n      prevCollection.splice(currentIndex, 1);\n      this.pipeTrigger++;\n      this.cdr.detectChanges();\n    }\n\n    getDimensionType(dimension) {\n      return PivotUtil.flatten(this.pivotConfiguration.rows).indexOf(dimension) !== -1 ? PivotDimensionType.Row : PivotUtil.flatten(this.pivotConfiguration.columns).indexOf(dimension) !== -1 ? PivotDimensionType.Column : !!this.pivotConfiguration.filters && PivotUtil.flatten(this.pivotConfiguration.filters).indexOf(dimension) !== -1 ? PivotDimensionType.Filter : null;\n    }\n\n    getLargesContentWidth(contents) {\n      const largest = new Map();\n\n      if (contents.length > 0) {\n        const cellsContentWidths = [];\n        contents.forEach(elem => cellsContentWidths.push(this.getHeaderCellWidth(elem.nativeElement).width));\n        const index = cellsContentWidths.indexOf(Math.max(...cellsContentWidths));\n        const cellStyle = this.document.defaultView.getComputedStyle(contents[index].nativeElement);\n        const cellPadding = parseFloat(cellStyle.paddingLeft) + parseFloat(cellStyle.paddingRight) + parseFloat(cellStyle.borderLeftWidth) + parseFloat(cellStyle.borderRightWidth);\n        largest.set(Math.max(...cellsContentWidths), cellPadding);\n      }\n\n      const largestCell = Math.max(...Array.from(largest.keys()));\n      const width = Math.ceil(largestCell + largest.get(largestCell));\n\n      if (Number.isNaN(width)) {\n        return null;\n      } else {\n        return width + 'px';\n      }\n    }\n    /**\n    * @hidden\n    */\n\n\n    get hasMultipleValues() {\n      return this.values.length > 1;\n    }\n    /**\n    * @hidden\n    */\n\n\n    get excelStyleFilterMaxHeight() {\n      // max 10 rows, row size depends on density\n      const maxHeight = this.renderedRowHeight * 10;\n      return `${maxHeight}px`;\n    }\n    /**\n    * @hidden\n    */\n\n\n    get excelStyleFilterMinHeight() {\n      // min 5 rows, row size depends on density\n      const minHeight = this.renderedRowHeight * 5;\n      return `${minHeight}px`;\n    }\n\n    resolveToggle(groupColumn, state) {\n      if (!groupColumn) return;\n      groupColumn.hidden = state;\n      this.columnGroupStates.set(groupColumn.field, state);\n      const childrenTotal = this.hasMultipleValues ? groupColumn.children.filter(x => x.columnGroup && x.children.filter(y => !y.columnGroup).length === this.values.length) : groupColumn.children.filter(x => !x.columnGroup);\n      const childrenSubgroups = this.hasMultipleValues ? groupColumn.children.filter(x => x.columnGroup && x.children.filter(y => !y.columnGroup).length === 0) : groupColumn.children.filter(x => x.columnGroup);\n      childrenTotal.forEach(group => {\n        const newState = this.columnGroupStates.get(group.field) || state;\n\n        if (newState) {\n          group.headerTemplate = this.headerTemplate;\n        } else {\n          group.headerTemplate = undefined;\n        }\n      });\n\n      if (!groupColumn.hidden && childrenSubgroups.length > 0) {\n        childrenSubgroups.forEach(group => {\n          const newState = this.columnGroupStates.get(group.field) || state;\n          this.resolveToggle(group, newState);\n        });\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    calcGridHeadRow() {}\n\n    buildDataView(data) {\n      this._dataView = data;\n    }\n    /**\n     * @hidden @internal\n     */\n\n\n    getDataBasedBodyHeight() {\n      var _a;\n\n      const dvl = ((_a = this.dataView) === null || _a === void 0 ? void 0 : _a.length) || 0;\n      return dvl < this._defaultTargetRecordNumber ? 0 : this.defaultTargetBodyHeight;\n    }\n\n    horizontalScrollHandler(event) {\n      const scrollLeft = event.target.scrollLeft;\n      this.theadRow.headerContainers.forEach(headerForOf => {\n        headerForOf.onHScroll(scrollLeft);\n      });\n      super.horizontalScrollHandler(event);\n    }\n\n    verticalScrollHandler(event) {\n      this.verticalRowDimScrollContainers.forEach(x => {\n        x.onScroll(event);\n      });\n      super.verticalScrollHandler(event);\n    }\n    /**\n     * @hidden\n     */\n\n\n    autogenerateColumns() {\n      let columns = [];\n      const data = this.gridAPI.filterDataByExpressions(this.filteringExpressionsTree);\n      this.dimensionDataColumns = this.generateDimensionColumns();\n      let fieldsMap;\n\n      if (this.pivotConfiguration.columnStrategy && this.pivotConfiguration.columnStrategy instanceof NoopPivotDimensionsStrategy) {\n        const fields = this.generateDataFields(data);\n        if (fields.length === 0) return;\n        const rowFields = PivotUtil.flatten(this.pivotConfiguration.rows).map(x => x.memberName);\n        const keyFields = Object.values(this.pivotKeys);\n        const filteredFields = fields.filter(x => rowFields.indexOf(x) === -1 && keyFields.indexOf(x) === -1 && x.indexOf(this.pivotKeys.rowDimensionSeparator + this.pivotKeys.level) === -1 && x.indexOf(this.pivotKeys.rowDimensionSeparator + this.pivotKeys.records) === -1);\n        fieldsMap = this.generateFromData(filteredFields);\n      } else {\n        fieldsMap = PivotUtil.getFieldsHierarchy(data, this.columnDimensions, PivotDimensionType.Column, this.pivotKeys);\n      }\n\n      columns = this.generateColumnHierarchy(fieldsMap, data);\n      this._autoGeneratedCols = columns; // reset expansion states if any are stored.\n\n      this.columnGroupStates.forEach((value, key) => {\n        if (value) {\n          const primaryColumn = columns.find(x => x.field === key && x.headerTemplate === this.headerTemplate);\n          const groupSummaryColumn = columns.find(x => x.field === key && x.headerTemplate !== this.headerTemplate);\n          this.toggleRowGroup(primaryColumn, value);\n\n          if (groupSummaryColumn) {\n            groupSummaryColumn.headerTemplate = this.headerTemplate;\n          }\n        }\n      });\n      this.reflow();\n      this.columnList.reset(columns);\n\n      if (data && data.length > 0) {\n        this.shouldGenerate = false;\n      }\n    }\n\n    getComponentDensityClass(baseStyleClass) {\n      if (this.superCompactMode) {\n        return `${baseStyleClass}--${DisplayDensity.compact} igx-grid__pivot--super-compact`;\n      }\n\n      return super.getComponentDensityClass(baseStyleClass);\n    }\n\n    generateDimensionColumns() {\n      const rootFields = this.allDimensions.map(x => x.memberName);\n      const columns = [];\n      const factory = this.resolver.resolveComponentFactory(IgxColumnComponent);\n      rootFields.forEach(field => {\n        const ref = factory.create(this.viewRef.injector);\n        ref.instance.field = field;\n        ref.changeDetectorRef.detectChanges();\n        columns.push(ref.instance);\n      });\n      return columns;\n    }\n\n    generateFromData(fields) {\n      const separator = this.pivotKeys.columnDimensionSeparator;\n      const dataArr = fields.map(x => x.split(separator)).sort(x => x.length);\n      const hierarchy = new Map();\n      dataArr.forEach(arr => {\n        let currentHierarchy = hierarchy;\n        const path = [];\n\n        for (const val of arr) {\n          path.push(val);\n          const newPath = path.join(separator);\n          let targetHierarchy = currentHierarchy.get(newPath);\n\n          if (!targetHierarchy) {\n            currentHierarchy.set(newPath, {\n              value: newPath,\n              expandable: true,\n              children: new Map(),\n              dimension: this.columnDimensions[0]\n            });\n            targetHierarchy = currentHierarchy.get(newPath);\n          }\n\n          currentHierarchy = targetHierarchy.children;\n        }\n      });\n      return hierarchy;\n    }\n\n    generateColumnHierarchy(fields, data, parent = null) {\n      const factoryColumn = this.resolver.resolveComponentFactory(IgxColumnComponent);\n      let columns = [];\n\n      if (fields.size === 0) {\n        this.values.forEach(value => {\n          const ref = factoryColumn.create(this.viewRef.injector);\n          ref.instance.header = value.displayName;\n          ref.instance.field = value.member;\n          ref.instance.parent = parent;\n          ref.instance.width = MINIMUM_COLUMN_WIDTH + 'px';\n          ref.instance.sortable = true;\n          ref.instance.dataType = value.dataType || this.resolveDataTypes(data[0][value.member]);\n          ref.instance.formatter = value.formatter;\n          columns.push(ref.instance);\n        });\n        return columns;\n      }\n\n      const first = fields.keys().next().value;\n      const dim = fields.get(first).dimension;\n      let currentFields = fields;\n\n      if (dim && dim.sortDirection) {\n        const entries = Array.from(fields.entries());\n        const expressions = [{\n          dir: dim.sortDirection,\n          fieldName: dim.memberName,\n          strategy: DefaultPivotSortingStrategy.instance()\n        }];\n        const sorted = DataUtil.sort(cloneArray(entries, true), expressions, this.sortStrategy, this.gridAPI.grid);\n        currentFields = new Map(sorted);\n      }\n\n      currentFields.forEach(value => {\n        var _a;\n\n        let shouldGenerate = true;\n\n        if (data.length === 0) {\n          shouldGenerate = false;\n        }\n\n        if (shouldGenerate && (value.children == null || value.children.length === 0 || value.children.size === 0)) {\n          const col = this.createColumnForDimension(value, data, parent, this.hasMultipleValues);\n          columns.push(col);\n\n          if (this.hasMultipleValues) {\n            const measureChildren = this.getMeasureChildren(factoryColumn, data, col, false, value.dimension.width);\n            col.children.reset(measureChildren);\n            columns = columns.concat(measureChildren);\n          }\n        } else if (shouldGenerate) {\n          const col = this.createColumnForDimension(value, data, parent, true);\n\n          if (value.expandable) {\n            col.headerTemplate = this.headerTemplate;\n          }\n\n          const children = this.generateColumnHierarchy(value.children, data, col);\n          const filteredChildren = children.filter(x => x.level === col.level + 1);\n          columns.push(col);\n\n          if (this.hasMultipleValues) {\n            let measureChildren = this.getMeasureChildren(factoryColumn, data, col, true, value.dimension.width);\n            const nestedChildren = filteredChildren; //const allChildren = children.concat(measureChildren);\n\n            col.children.reset(nestedChildren);\n            columns = columns.concat(children);\n\n            if (value.dimension.childLevel) {\n              const sibling = this.createColumnForDimension(value, data, parent, true);\n              columns.push(sibling);\n              measureChildren = this.getMeasureChildren(factoryColumn, data, sibling, false, (_a = value.dimension) === null || _a === void 0 ? void 0 : _a.width);\n              sibling.children.reset(measureChildren);\n              columns = columns.concat(measureChildren);\n            }\n          } else {\n            col.children.reset(filteredChildren);\n            columns = columns.concat(children);\n\n            if (value.dimension.childLevel) {\n              const sibling = this.createColumnForDimension(value, data, parent, false);\n              columns.push(sibling);\n            }\n          }\n        }\n      });\n      return columns;\n    }\n\n    createColumnForDimension(value, data, parent, isGroup) {\n      const factoryColumn = this.resolver.resolveComponentFactory(IgxColumnComponent);\n      const factoryColumnGroup = this.resolver.resolveComponentFactory(IgxColumnGroupComponent);\n      const key = value.value;\n      const ref = isGroup ? factoryColumnGroup.create(this.viewRef.injector) : factoryColumn.create(this.viewRef.injector);\n      ref.instance.header = parent != null ? key.split(parent.header + this.pivotKeys.columnDimensionSeparator)[1] : key;\n      ref.instance.field = key;\n      ref.instance.parent = parent;\n      ref.instance.width = this.resolveColumnDimensionWidth(value.dimension);\n      const valueDefinition = this.values[0];\n      ref.instance.dataType = (valueDefinition === null || valueDefinition === void 0 ? void 0 : valueDefinition.dataType) || this.resolveDataTypes(data[0][valueDefinition === null || valueDefinition === void 0 ? void 0 : valueDefinition.member]);\n      ref.instance.formatter = valueDefinition === null || valueDefinition === void 0 ? void 0 : valueDefinition.formatter;\n      ref.instance.sortable = true;\n      ref.changeDetectorRef.detectChanges();\n      return ref.instance;\n    }\n\n    resolveColumnDimensionWidth(dim) {\n      if (dim.width) {\n        return dim.width;\n      }\n\n      return this.superCompactMode ? MINIMUM_COLUMN_WIDTH_SUPER_COMPACT + 'px' : MINIMUM_COLUMN_WIDTH + 'px';\n    }\n\n    getMeasureChildren(colFactory, data, parent, hidden, parentWidth) {\n      const cols = [];\n      const count = this.values.length;\n      const width = parentWidth ? parseInt(parentWidth, 10) / count : this.superCompactMode ? MINIMUM_COLUMN_WIDTH_SUPER_COMPACT : MINIMUM_COLUMN_WIDTH;\n      const isPercent = parentWidth && parentWidth.indexOf('%') !== -1;\n      this.values.forEach(val => {\n        const ref = colFactory.create(this.viewRef.injector);\n        ref.instance.header = val.displayName || val.member;\n        ref.instance.field = parent.field + this.pivotKeys.columnDimensionSeparator + val.member;\n        ref.instance.parent = parent;\n        ref.instance.width = isPercent ? width + '%' : width + 'px';\n        ref.instance.hidden = hidden;\n        ref.instance.sortable = true;\n        ref.instance.dataType = val.dataType || this.resolveDataTypes(data[0][val.member]);\n        ref.instance.formatter = val.formatter;\n        ref.changeDetectorRef.detectChanges();\n        cols.push(ref.instance);\n      });\n      return cols;\n    }\n    /**\n    * @hidden @internal\n    */\n\n\n    get template() {\n      const allEnabledDimensions = this.rowDimensions.concat(this.columnDimensions);\n\n      if (allEnabledDimensions.length === 0 && this.values.length === 0) {\n        // no enabled values and dimensions\n        return this.emptyPivotGridTemplate || this.defaultEmptyPivotGridTemplate;\n      }\n\n      super.template;\n    }\n\n  }\n\n  IgxPivotGridComponent.ɵfac = function IgxPivotGridComponent_Factory(t) {\n    return new (t || IgxPivotGridComponent)(i0.ɵɵdirectiveInject(IgxGridSelectionService), i0.ɵɵdirectiveInject(IgxPivotColumnResizingService), i0.ɵɵdirectiveInject(GridBaseAPIService), i0.ɵɵdirectiveInject(IgxFlatTransactionFactory), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ApplicationRef), i0.ɵɵdirectiveInject(i0.NgModuleRef), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(IgxPivotGridNavigationService), i0.ɵɵdirectiveInject(IgxFilteringService), i0.ɵɵdirectiveInject(IgxOverlayService), i0.ɵɵdirectiveInject(IgxGridSummaryService), i0.ɵɵdirectiveInject(DisplayDensityToken, 8), i0.ɵɵdirectiveInject(LOCALE_ID), i0.ɵɵdirectiveInject(PlatformUtil), i0.ɵɵdirectiveInject(IgxGridTransaction, 8));\n  };\n\n  IgxPivotGridComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxPivotGridComponent,\n    selectors: [[\"igx-pivot-grid\"]],\n    viewQuery: function IgxPivotGridComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(IgxPivotHeaderRowComponent, 7);\n        i0.ɵɵviewQuery(_c216, 7, TemplateRef);\n        i0.ɵɵviewQuery(_c258, 7, TemplateRef);\n        i0.ɵɵviewQuery(IgxPivotGridColumnResizerComponent, 5);\n        i0.ɵɵviewQuery(_c293, 7, TemplateRef);\n        i0.ɵɵviewQuery(IgxGridExcelStyleFilteringComponent, 5, IgxGridExcelStyleFilteringComponent);\n        i0.ɵɵviewQuery(IgxPivotRowDimensionContentComponent, 5);\n        i0.ɵɵviewQuery(_c294, 5, IgxGridForOfDirective);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.theadRow = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.recordTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.resizeLine = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultEmptyPivotGridTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.excelStyleFilteringComponents = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.rowDimensionContentCollection = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.verticalRowDimScrollContainers = _t);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function IgxPivotGridComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"id\", ctx.id);\n        i0.ɵɵclassProp(\"igx-grid__pivot--super-compact\", ctx.superCompactMode);\n      }\n    },\n    inputs: {\n      pivotConfiguration: \"pivotConfiguration\",\n      showPivotConfigurationUI: \"showPivotConfigurationUI\",\n      superCompactMode: \"superCompactMode\",\n      displayDensity: \"displayDensity\",\n      addRowEmptyTemplate: \"addRowEmptyTemplate\",\n      snackbarDisplayTime: \"snackbarDisplayTime\",\n      defaultExpandState: \"defaultExpandState\",\n      pagingMode: \"pagingMode\",\n      hideRowSelectors: \"hideRowSelectors\",\n      rowDraggable: \"rowDraggable\",\n      allowAdvancedFiltering: \"allowAdvancedFiltering\",\n      filterMode: \"filterMode\",\n      allowFiltering: \"allowFiltering\",\n      page: \"page\",\n      paging: \"paging\",\n      perPage: \"perPage\",\n      summaryRowHeight: \"summaryRowHeight\",\n      rowEditable: \"rowEditable\",\n      pinning: \"pinning\",\n      summaryPosition: \"summaryPosition\",\n      summaryCalculationMode: \"summaryCalculationMode\",\n      showSummaryOnCollapse: \"showSummaryOnCollapse\",\n      batchEditing: \"batchEditing\",\n      id: \"id\",\n      data: \"data\",\n      totalRecords: \"totalRecords\",\n      emptyPivotGridTemplate: \"emptyPivotGridTemplate\"\n    },\n    outputs: {\n      dimensionsChange: \"dimensionsChange\",\n      dimensionsSortingExpressionsChange: \"dimensionsSortingExpressionsChange\",\n      valuesChange: \"valuesChange\",\n      cellEdit: \"cellEdit\",\n      cellEditDone: \"cellEditDone\",\n      cellEditEnter: \"cellEditEnter\",\n      cellEditExit: \"cellEditExit\",\n      columnMovingStart: \"columnMovingStart\",\n      columnMoving: \"columnMoving\",\n      columnMovingEnd: \"columnMovingEnd\",\n      columnPin: \"columnPin\",\n      columnPinned: \"columnPinned\",\n      rowAdd: \"rowAdd\",\n      rowAdded: \"rowAdded\",\n      rowDeleted: \"rowDeleted\",\n      rowDelete: \"rowDelete\",\n      rowDragStart: \"rowDragStart\",\n      rowDragEnd: \"rowDragEnd\",\n      rowEditEnter: \"rowEditEnter\",\n      rowEdit: \"rowEdit\",\n      rowEditDone: \"rowEditDone\",\n      rowEditExit: \"rowEditExit\",\n      rowPinning: \"rowPinning\",\n      rowPinned: \"rowPinned\"\n    },\n    features: [i0.ɵɵProvidersFeature([IgxGridCRUDService, IgxGridSummaryService, IgxGridSelectionService, GridBaseAPIService, {\n      provide: IGX_GRID_BASE,\n      useExisting: IgxPivotGridComponent\n    }, {\n      provide: IgxFilteringService,\n      useClass: IgxPivotFilteringService\n    }, IgxPivotGridNavigationService, IgxPivotColumnResizingService, IgxForOfSyncService, IgxForOfScrollSyncService]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c296,\n    decls: 73,\n    vars: 128,\n    consts: [[\"tabindex\", \"0\", 1, \"igx-grid-thead\", \"igx-grid-thead--pivot\", 3, \"grid\", \"hasMRL\", \"density\", \"activeDescendant\", \"width\", \"pinnedColumnCollection\", \"unpinnedColumnCollection\", \"keydown.meta.c\", \"keydown.control.c\", \"copy\", \"keydown\", \"scroll\"], [\"igxGridBody\", \"\", \"role\", \"rowgroup\", 1, \"igx-grid__tbody\", 3, \"keydown.control.c\", \"copy\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"tabindex\", \"0\", 1, \"igx-grid__tbody-content\", 3, \"igxGridDragSelect\", \"keydown\", \"focus\", \"dragStop\", \"scroll\", \"dragScroll\"], [\"tbody\", \"\"], [\"id\", \"left\", \"class\", \"igx-grid__scroll-on-drag-left\", 3, \"igxColumnMovingDrop\", 4, \"ngIf\"], [\"id\", \"left\", \"class\", \"igx-grid__scroll-on-drag-pinned\", 3, \"igxColumnMovingDrop\", \"left\", 4, \"ngIf\"], [\"igxGridFor\", \"\", 3, \"igxGridForOf\", \"igxForScrollOrientation\", \"igxForScrollContainer\", \"igxForContainerSize\", \"igxForItemSize\", \"igxGridForOfVariableSizes\"], [\"verticalScrollContainer\", \"\"], [\"record_template\", \"\"], [4, \"ngTemplateOutlet\"], [\"igxToggle\", \"\"], [\"loadingOverlay\", \"\"], [3, \"indeterminate\", 4, \"ngIf\"], [\"id\", \"right\", \"class\", \"igx-grid__scroll-on-drag-right\", 3, \"igxColumnMovingDrop\", 4, \"ngIf\"], [1, \"igx-grid__tbody-scrollbar\", 3, \"hidden\", \"pointerdown\"], [1, \"igx-grid__tbody-scrollbar-start\"], [1, \"igx-grid__tbody-scrollbar-main\"], [\"igxGridFor\", \"\", 3, \"igxGridForOf\"], [\"verticalScrollHolder\", \"\"], [1, \"igx-grid__tbody-scrollbar-end\"], [1, \"igx-grid__addrow-snackbar\"], [3, \"outlet\", \"actionText\", \"displayTime\"], [\"addRowSnackbar\", \"\"], [\"igxOverlayOutlet\", \"\"], [\"igxBodyOverlayOutlet\", \"overlay-outlet\"], [1, \"igx-grid__scroll\", 3, \"hidden\", \"pointerdown\"], [\"scr\", \"\"], [1, \"igx-grid__scroll-start\"], [1, \"igx-grid__scroll-main\"], [\"scrollContainer\", \"\"], [1, \"igx-grid__scroll-end\", 3, \"hidden\"], [\"role\", \"rowgroup\", 1, \"igx-grid__tfoot\"], [\"tfoot\", \"\"], [1, \"igx-grid__footer\"], [\"footer\", \"\"], [\"emptyFilteredGrid\", \"\"], [\"defaultEmptyGrid\", \"\"], [\"defaultLoadingGrid\", \"\"], [3, \"restrictResizerTop\", 4, \"ngIf\"], [\"igxOverlayOutlet\", \"\", 1, \"igx-grid__loading-outlet\"], [\"igxLoadingOverlayOutlet\", \"\"], [\"igxOverlayOutlet\", \"\", 1, \"igx-grid__outlet\"], [\"igxFilteringOverlayOutlet\", \"\"], [\"headerTemplate\", \"\"], [\"defaultRowDimensionsTemplate\", \"\"], [\"emptyRowDimensionsTemplate\", \"\"], [\"emptyPivotGridTemplate\", \"\"], [3, \"hidden\"], [3, \"maxHeight\", \"minHeight\"], [\"igxExcelStyleColumnOperations\", \"\", 3, \"hidden\"], [\"id\", \"left\", 1, \"igx-grid__scroll-on-drag-left\", 3, \"igxColumnMovingDrop\"], [\"id\", \"left\", 1, \"igx-grid__scroll-on-drag-pinned\", 3, \"igxColumnMovingDrop\"], [3, \"igxTemplateOutlet\", \"igxTemplateOutletContext\", \"cachedViewLoaded\"], [3, \"gridID\", \"index\", \"data\", \"ngClass\", \"ngStyle\"], [\"row\", \"\"], [3, \"indeterminate\"], [\"id\", \"right\", 1, \"igx-grid__scroll-on-drag-right\", 3, \"igxColumnMovingDrop\"], [\"role\", \"cell\", 1, \"igx-grid__tbody-message\"], [1, \"igx-grid__loading\"], [3, \"restrictResizerTop\"], [1, \"igx-grid__tr--header\"], [3, \"click\"], [\"tabindex\", \"0\", \"role\", \"rowgroup\", \"class\", \"igx-grid__tbody-pivot-dimension\", 3, \"height\", \"focus\", \"keydown\", 4, \"ngFor\", \"ngForOf\"], [\"tabindex\", \"0\", \"role\", \"rowgroup\", 1, \"igx-grid__tbody-pivot-dimension\", 3, \"focus\", \"keydown\"], [\"rowDimensionContainer\", \"\"], [\"igxGridFor\", \"\", 3, \"igxGridForOf\", \"igxForScrollOrientation\", \"igxForScrollContainer\", \"igxForContainerSize\", \"igxForItemSize\", \"igxForSizePropName\"], [\"verticalRowDimScrollContainer\", \"\"], [\"role\", \"row\", 1, \"igx-grid-thead\", 3, \"grid\", \"dimension\", \"rootDimension\", \"rowIndex\", \"rowData\", \"density\", \"width\"], [\"tabindex\", \"0\", \"role\", \"rowgroup\", \"class\", \"igx-grid__tbody-pivot-dimension\", 3, \"focus\", \"keydown\", 4, \"ngIf\"]],\n    template: function IgxPivotGridComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c295);\n        i0.ɵɵprojection(0);\n        i0.ɵɵelementStart(1, \"igx-pivot-header-row\", 0);\n        i0.ɵɵlistener(\"keydown.meta.c\", function IgxPivotGridComponent_Template_igx_pivot_header_row_keydown_meta_c_1_listener($event) {\n          return ctx.copyHandler($event);\n        })(\"keydown.control.c\", function IgxPivotGridComponent_Template_igx_pivot_header_row_keydown_control_c_1_listener($event) {\n          return ctx.copyHandler($event);\n        })(\"copy\", function IgxPivotGridComponent_Template_igx_pivot_header_row_copy_1_listener($event) {\n          return ctx.copyHandler($event);\n        })(\"keydown\", function IgxPivotGridComponent_Template_igx_pivot_header_row_keydown_1_listener($event) {\n          return ctx.navigation.headerNavigation($event);\n        })(\"scroll\", function IgxPivotGridComponent_Template_igx_pivot_header_row_scroll_1_listener($event) {\n          return ctx.preventHeaderScroll($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(2, \"div\", 1);\n        i0.ɵɵlistener(\"keydown.control.c\", function IgxPivotGridComponent_Template_div_keydown_control_c_2_listener($event) {\n          return ctx.copyHandler($event);\n        })(\"copy\", function IgxPivotGridComponent_Template_div_copy_2_listener($event) {\n          return ctx.copyHandler($event);\n        });\n        i0.ɵɵtemplate(3, IgxPivotGridComponent_ng_container_3_Template, 1, 0, \"ng-container\", 2);\n        i0.ɵɵelementStart(4, \"div\", 3, 4);\n        i0.ɵɵlistener(\"keydown\", function IgxPivotGridComponent_Template_div_keydown_4_listener($event) {\n          return ctx.navigation.handleNavigation($event);\n        })(\"focus\", function IgxPivotGridComponent_Template_div_focus_4_listener($event) {\n          return ctx.navigation.focusTbody($event);\n        })(\"dragStop\", function IgxPivotGridComponent_Template_div_dragStop_4_listener($event) {\n          return ctx.selectionService.dragMode = $event;\n        })(\"scroll\", function IgxPivotGridComponent_Template_div_scroll_4_listener($event) {\n          return ctx.preventContainerScroll($event);\n        })(\"dragScroll\", function IgxPivotGridComponent_Template_div_dragScroll_4_listener($event) {\n          return ctx.dragScroll($event);\n        });\n        i0.ɵɵtemplate(6, IgxPivotGridComponent_span_6_Template, 1, 2, \"span\", 5);\n        i0.ɵɵtemplate(7, IgxPivotGridComponent_span_7_Template, 1, 4, \"span\", 6);\n        i0.ɵɵtemplate(8, IgxPivotGridComponent_ng_template_8_Template, 1, 2, \"ng-template\", 7, 8, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵpipe(10, \"pivotGridRowExpansion\");\n        i0.ɵɵpipe(11, \"pivotGridColumnSort\");\n        i0.ɵɵpipe(12, \"pivotGridAutoTransform\");\n        i0.ɵɵpipe(13, \"pivotGridColumn\");\n        i0.ɵɵpipe(14, \"pivotGridRow\");\n        i0.ɵɵpipe(15, \"pivotGridSort\");\n        i0.ɵɵpipe(16, \"pivotGridFilter\");\n        i0.ɵɵtemplate(17, IgxPivotGridComponent_ng_template_17_Template, 4, 37, \"ng-template\", null, 9, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(19, IgxPivotGridComponent_ng_container_19_Template, 1, 0, \"ng-container\", 10);\n        i0.ɵɵelement(20, \"igc-trial-watermark\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(21, \"div\", 11, 12);\n        i0.ɵɵtemplate(23, IgxPivotGridComponent_igx_circular_bar_23_Template, 1, 1, \"igx-circular-bar\", 13);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(24, IgxPivotGridComponent_span_24_Template, 1, 2, \"span\", 14);\n        i0.ɵɵelementStart(25, \"div\", 15);\n        i0.ɵɵlistener(\"pointerdown\", function IgxPivotGridComponent_Template_div_pointerdown_25_listener($event) {\n          return $event.preventDefault();\n        });\n        i0.ɵɵelement(26, \"div\", 16);\n        i0.ɵɵelementStart(27, \"div\", 17);\n        i0.ɵɵtemplate(28, IgxPivotGridComponent_ng_template_28_Template, 0, 0, \"ng-template\", 18, 19, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(30, \"div\", 20);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(31, \"div\", 21)(32, \"igx-snackbar\", 22, 23);\n        i0.ɵɵtext(34);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelement(35, \"div\", 24, 25);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(37, \"div\", 26, 27);\n        i0.ɵɵlistener(\"pointerdown\", function IgxPivotGridComponent_Template_div_pointerdown_37_listener($event) {\n          return $event.preventDefault();\n        });\n        i0.ɵɵelement(39, \"div\", 28);\n        i0.ɵɵelementStart(40, \"div\", 29);\n        i0.ɵɵtemplate(41, IgxPivotGridComponent_ng_template_41_Template, 0, 0, \"ng-template\", 18, 30, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(43, \"div\", 31);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(44, \"div\", 32, 33);\n        i0.ɵɵelementStart(46, \"div\", 34, 35);\n        i0.ɵɵprojection(48, 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(49, IgxPivotGridComponent_ng_template_49_Template, 3, 1, \"ng-template\", null, 36, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(51, IgxPivotGridComponent_ng_template_51_Template, 3, 1, \"ng-template\", null, 37, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(53, IgxPivotGridComponent_ng_template_53_Template, 2, 1, \"ng-template\", null, 38, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(55, IgxPivotGridComponent_igx_pivot_grid_column_resizer_55_Template, 1, 1, \"igx-pivot-grid-column-resizer\", 39);\n        i0.ɵɵelement(56, \"div\", 40, 41)(58, \"div\", 42, 43);\n        i0.ɵɵtemplate(60, IgxPivotGridComponent_ng_template_60_Template, 4, 3, \"ng-template\", null, 44, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(62, IgxPivotGridComponent_ng_template_62_Template, 1, 1, \"ng-template\", null, 45, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(64, IgxPivotGridComponent_ng_template_64_Template, 1, 1, \"ng-template\", null, 46, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(66, IgxPivotGridComponent_ng_template_66_Template, 3, 1, \"ng-template\", null, 47, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵelementStart(68, \"div\", 48)(69, \"igx-grid-excel-style-filtering\", 49);\n        i0.ɵɵelement(70, \"div\", 50);\n        i0.ɵɵelementStart(71, \"igx-excel-style-filter-operations\");\n        i0.ɵɵelement(72, \"igx-excel-style-search\");\n        i0.ɵɵelementEnd()()();\n      }\n\n      if (rf & 2) {\n        const _r15 = i0.ɵɵreference(36);\n\n        const _r32 = i0.ɵɵreference(63);\n\n        const _r34 = i0.ɵɵreference(65);\n\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"grid\", ctx)(\"hasMRL\", ctx.hasColumnLayouts)(\"density\", ctx.displayDensity)(\"activeDescendant\", ctx.activeDescendant)(\"width\", ctx.calcWidth)(\"pinnedColumnCollection\", ctx.pinnedColumns)(\"unpinnedColumnCollection\", ctx.unpinnedColumns);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.rowDimensions.length ? _r32 : _r34)(\"ngTemplateOutletContext\", ctx);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"height\", ctx.totalHeight, \"px\")(\"width\", ctx.calcWidth || null, \"px\");\n        i0.ɵɵproperty(\"igxGridDragSelect\", ctx.selectionService.dragMode);\n        i0.ɵɵattribute(\"role\", ctx.dataView.length ? null : \"row\")(\"aria-activedescendant\", ctx.activeDescendant);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasMovableColumns && ctx.columnInDrag && ctx.pinnedColumns.length <= 0);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasMovableColumns && ctx.columnInDrag && ctx.pinnedColumns.length > 0);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"igxGridForOf\", i0.ɵɵpipeBindV(10, 63, i0.ɵɵpureFunction5(121, _c71, i0.ɵɵpipeBind4(11, 69, i0.ɵɵpipeBind3(12, 74, i0.ɵɵpipeBindV(13, 78, i0.ɵɵpureFunction5(115, _c71, i0.ɵɵpipeBindV(14, 84, i0.ɵɵpureFunction5(109, _c71, i0.ɵɵpipeBind4(15, 90, i0.ɵɵpipeBindV(16, 95, i0.ɵɵpureFunction6(102, _c215, ctx.data, ctx.pivotConfiguration, ctx.filterStrategy, ctx.advancedFilteringExpressionsTree, ctx.filteringPipeTrigger, ctx.pipeTrigger)), ctx.pivotConfiguration, ctx.sortStrategy, ctx.pipeTrigger), ctx.pivotConfiguration, ctx.expansionStates, ctx.pipeTrigger, ctx.sortingExpressions)), ctx.pivotConfiguration, ctx.expansionStates, ctx.pipeTrigger, ctx.sortingExpressions)), ctx.pivotConfiguration, ctx.pipeTrigger), ctx.sortingExpressions, ctx.sortStrategy, ctx.pipeTrigger), ctx.pivotConfiguration, ctx.expansionStates, ctx.defaultExpandState, ctx.pipeTrigger)))(\"igxForScrollOrientation\", \"vertical\")(\"igxForScrollContainer\", ctx.verticalScroll)(\"igxForContainerSize\", ctx.calcHeight)(\"igxForItemSize\", ctx.hasColumnLayouts ? ctx.rowHeight * ctx.multiRowLayoutRowSize + 1 : ctx.renderedRowHeight)(\"igxGridForOfVariableSizes\", false);\n        i0.ɵɵadvance(11);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template);\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"ngIf\", ctx.shouldOverlayLoading);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.hasMovableColumns && ctx.columnInDrag);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.scrollSize, \"px\");\n        i0.ɵɵproperty(\"hidden\", !ctx.hasVerticalScroll());\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"height\", ctx.isRowPinningToTop ? ctx.pinnedRowHeight : 0, \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"height\", ctx.calcHeight, \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"igxGridForOf\", i0.ɵɵpureFunction0(127, _c115));\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"height\", !ctx.isRowPinningToTop ? ctx.pinnedRowHeight : 0, \"px\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"outlet\", _r15)(\"actionText\", ctx.resourceStrings.igx_grid_snackbar_addrow_actiontext)(\"displayTime\", ctx.snackbarDisplayTime);\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate(ctx.resourceStrings.igx_grid_snackbar_addrow_label);\n        i0.ɵɵadvance(3);\n        i0.ɵɵstyleProp(\"height\", ctx.scrollSize, \"px\");\n        i0.ɵɵproperty(\"hidden\", ctx.isHorizontalScrollHidden);\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"width\", ctx.isPinningToStart ? ctx.pinnedWidth : ctx.headerFeaturesWidth, \"px\")(\"min-width\", ctx.isPinningToStart ? ctx.pinnedWidth : ctx.headerFeaturesWidth, \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.unpinnedWidth, \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"igxGridForOf\", ctx.EMPTY_DATA);\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"float\", \"right\")(\"width\", ctx.pinnedWidth, \"px\")(\"min-width\", ctx.pinnedWidth, \"px\");\n        i0.ɵɵproperty(\"hidden\", ctx.pinnedWidth === 0 || ctx.isPinningToStart);\n        i0.ɵɵadvance(12);\n        i0.ɵɵproperty(\"ngIf\", ctx.colResizingService.showResizer);\n        i0.ɵɵadvance(13);\n        i0.ɵɵproperty(\"hidden\", true);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"maxHeight\", ctx.excelStyleFilterMaxHeight)(\"minHeight\", ctx.excelStyleFilterMinHeight);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"hidden\", true);\n      }\n    },\n    directives: [IgxPivotHeaderRowComponent, IgxPivotRowComponent, IgxCircularProgressBarComponent, IgxSnackbarComponent, IgxPivotGridColumnResizerComponent, IgxIconComponent, IgxPivotRowDimensionContentComponent, IgxGridExcelStyleFilteringComponent, IgxExcelStyleSearchComponent, IgxGridBodyDirective, i4.NgTemplateOutlet, IgxGridDragSelectDirective, i4.NgIf, IgxColumnMovingDropDirective, IgxGridForOfDirective, IgxTemplateOutletDirective, i4.NgClass, i4.NgStyle, IgxToggleDirective, IgxOverlayOutletDirective, i4.NgForOf, IgxExcelStyleColumnOperationsTemplateDirective, IgxExcelStyleFilterOperationsTemplateDirective],\n    pipes: [IgxPivotRowExpansionPipe, IgxPivotGridColumnSortingPipe, IgxPivotAutoTransform, IgxPivotColumnPipe, IgxPivotRowPipe, IgxPivotGridSortingPipe, IgxPivotGridFilterPipe, IgxGridRowClassesPipe, IgxGridRowStylesPipe, IgxPivotCellMergingPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  __decorate([WatchChanges()], IgxPivotGridComponent.prototype, \"hideRowSelectors\", null);\n\n  __decorate([WatchChanges()], IgxPivotGridComponent.prototype, \"rowEditable\", null);\n\n  return IgxPivotGridComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // Equals to pretty much this configuration:\n// {\n//     member: () => 'All Periods',\n//     enabled: true,\n//     fieldName: 'AllPeriods',\n//     childLevel: {\n//         fieldName: 'Years',\n//         member: (rec) => {\n//             const recordValue = rec['Date'];\n//             return recordValue ? (new Date(recordValue)).getFullYear().toString() : rec['Years'];\n//         },\n//         enabled: true,\n//         childLevel: {\n//                 member: (rec) => {\n//                     const recordValue = rec['Date'];\n//                     return recordValue ? new Date(recordValue).toLocaleString('default', { month: 'long' }) : rec['Months'];\n//                 },\n//                 enabled: true,\n//                 fieldName: 'Months',\n//                 childLevel: {\n//                         member: 'Date',\n//                         fieldName:'Date',\n//                         enabled: true\n//                     }\n//             }\n//     }\n// },\n\n\nclass IgxPivotDateDimension {\n  /**\n   * Creates additional pivot date dimensions based on a provided dimension describing date data:\n   *\n   * @param inDateDimension Base dimension that is used by this class to determine the other dimensions and their values.\n   * @param inOptions Options for the predefined date dimensions whether to show quarter, years and etc.\n   * @example\n   * ```typescript\n   * // Displays only years as parent dimension to the base dimension provided.\n   * new IgxPivotDateDimension({ memberName: 'Date', enabled: true }, { total: false, months: false });\n   * ```\n   */\n  constructor(inBaseDimension, inOptions = {}) {\n    this.inBaseDimension = inBaseDimension;\n    this.inOptions = inOptions;\n    /** Enables/Disables a particular dimension from pivot structure. */\n\n    this.enabled = true;\n    /** Default options used for initialization. */\n\n    this.defaultOptions = {\n      total: true,\n      years: true,\n      months: true,\n      fullDate: true\n    };\n    /** @hidden @internal */\n\n    this.memberName = 'AllPeriods';\n    this._resourceStrings = CurrentResourceStrings.GridResStrings;\n    /** @hidden @internal */\n\n    this.memberFunction = _data => this.resourceStrings.igx_grid_pivot_date_dimension_total;\n\n    const options = Object.assign(Object.assign({}, this.defaultOptions), inOptions);\n\n    if (!inBaseDimension) {\n      console.warn(`Please provide data child level to the pivot dimension.`);\n      return;\n    }\n\n    const baseDimension = options.fullDate ? inBaseDimension : null;\n    const monthDimensionDef = {\n      memberName: 'Months',\n      memberFunction: rec => {\n        const recordValue = PivotUtil.extractValueFromDimension(inBaseDimension, rec);\n        return recordValue ? new Date(recordValue).toLocaleString('default', {\n          month: 'long'\n        }) : rec['Months'];\n      },\n      enabled: true,\n      childLevel: baseDimension\n    };\n    const monthDimension = options.months ? monthDimensionDef : baseDimension;\n    const quarterDimensionDef = {\n      memberName: 'Quarters',\n      memberFunction: rec => {\n        const recordValue = PivotUtil.extractValueFromDimension(inBaseDimension, rec);\n        return recordValue ? `Q` + Math.ceil((new Date(recordValue).getMonth() + 1) / 3) : rec['Quarters'];\n      },\n      enabled: true,\n      childLevel: monthDimension\n    };\n    const quarterDimension = options.quarters ? quarterDimensionDef : monthDimension;\n    const yearsDimensionDef = {\n      memberName: 'Years',\n      memberFunction: rec => {\n        const recordValue = PivotUtil.extractValueFromDimension(inBaseDimension, rec);\n        return recordValue ? new Date(recordValue).getFullYear().toString() : rec['Years'];\n      },\n      enabled: true,\n      childLevel: quarterDimension\n    };\n    const yearsDimension = options.years ? yearsDimensionDef : quarterDimension;\n    this.childLevel = yearsDimension;\n\n    if (!options.total) {\n      this.memberName = yearsDimension.memberName;\n      this.memberFunction = yearsDimension.memberFunction;\n      this.childLevel = yearsDimension.childLevel;\n    }\n  }\n  /**\n   * Gets/Sets the resource strings.\n   *\n   * @remarks\n   * By default it uses EN resources.\n   */\n\n\n  set resourceStrings(value) {\n    this._resourceStrings = Object.assign({}, this._resourceStrings, value);\n  }\n\n  get resourceStrings() {\n    return this._resourceStrings;\n  }\n\n}\n/**\n * Pivot Data Selector provides means to configure the pivot state of the Pivot Grid via a vertical panel UI\n *\n * @igxModule IgxPivotGridModule\n * @igxGroup Grids & Lists\n * @igxKeywords data selector, pivot, grid\n * @igxTheme pivot-data-selector-theme\n * @remarks\n * The Ignite UI Data Selector has a searchable list with the grid data columns,\n * there are also four expandable areas underneath for filters, rows, columns, and values\n * is used for grouping and aggregating simple flat data into a pivot table.\n * @example\n * ```html\n * <igx-pivot-grid #grid1 [data]=\"data\" [pivotConfiguration]=\"configuration\">\n * </igx-pivot-grid>\n * <igx-pivot-data-selector [grid]=\"grid1\"></igx-pivot-data-selector>\n * ```\n */\n\n\nlet IgxPivotDataSelectorComponent = /*#__PURE__*/(() => {\n  class IgxPivotDataSelectorComponent {\n    constructor(renderer, cdr) {\n      this.renderer = renderer;\n      this.cdr = cdr;\n      /**\n       * Gets/sets whether the columns panel is expanded\n       * Get\n       * ```typescript\n       *  const columnsPanelState: boolean = this.dataSelector.columnsExpanded;\n       * ```\n       * Set\n       * ```html\n       * <igx-pivot-data-selector [grid]=\"grid1\" [columnsExpanded]=\"columnsPanelState\"></igx-pivot-data-selector>\n       * ```\n       *\n       * Two-way data binding:\n       * ```html\n       * <igx-pivot-data-selector [grid]=\"grid1\" [(columnsExpanded)]=\"columnsPanelState\"></igx-pivot-data-selector>\n       * ```\n       */\n\n      this.columnsExpanded = true;\n      /**\n       * @hidden\n       */\n\n      this.columnsExpandedChange = new EventEmitter();\n      /**\n       * Gets/sets whether the rows panel is expanded\n       * Get\n       * ```typescript\n       *  const rowsPanelState: boolean = this.dataSelector.rowsExpanded;\n       * ```\n       * Set\n       * ```html\n       * <igx-pivot-data-selector [grid]=\"grid1\" [rowsExpanded]=\"rowsPanelState\"></igx-pivot-data-selector>\n       * ```\n       *\n       * Two-way data binding:\n       * ```html\n       * <igx-pivot-data-selector [grid]=\"grid1\" [(rowsExpanded)]=\"rowsPanelState\"></igx-pivot-data-selector>\n       * ```\n       */\n\n      this.rowsExpanded = true;\n      /**\n       * @hidden\n       */\n\n      this.rowsExpandedChange = new EventEmitter();\n      /**\n       * Gets/sets whether the filters panel is expanded\n       * Get\n       * ```typescript\n       *  const filtersPanelState: boolean = this.dataSelector.filtersExpanded;\n       * ```\n       * Set\n       * ```html\n       * <igx-pivot-data-selector [grid]=\"grid1\" [filtersExpanded]=\"filtersPanelState\"></igx-pivot-data-selector>\n       * ```\n       *\n       * Two-way data binding:\n       * ```html\n       * <igx-pivot-data-selector [grid]=\"grid1\" [(filtersExpanded)]=\"filtersPanelState\"></igx-pivot-data-selector>\n       * ```\n       */\n\n      this.filtersExpanded = true;\n      /**\n       * @hidden\n       */\n\n      this.filtersExpandedChange = new EventEmitter();\n      /**\n       * Gets/sets whether the values panel is expanded\n       * Get\n       * ```typescript\n       *  const valuesPanelState: boolean = this.dataSelector.valuesExpanded;\n       * ```\n       * Set\n       * ```html\n       * <igx-pivot-data-selector [grid]=\"grid1\" [valuesExpanded]=\"valuesPanelState\"></igx-pivot-data-selector>\n       * ```\n       *\n       * Two-way data binding:\n       * ```html\n       * <igx-pivot-data-selector [grid]=\"grid1\" [(valuesExpanded)]=\"valuesPanelState\"></igx-pivot-data-selector>\n       * ```\n       */\n\n      this.valuesExpanded = true;\n      /**\n       * @hidden\n       */\n\n      this.valuesExpandedChange = new EventEmitter();\n      this._dropDelta = 0;\n      /** @hidden @internal **/\n\n      this.cssClass = \"igx-pivot-data-selector\";\n      this._subMenuPositionSettings = {\n        verticalStartPoint: VerticalAlignment.Bottom,\n        closeAnimation: undefined\n      };\n      this._subMenuOverlaySettings = {\n        closeOnOutsideClick: true,\n        modal: false,\n        positionStrategy: new AutoPositionStrategy(this._subMenuPositionSettings),\n        scrollStrategy: new AbsoluteScrollStrategy()\n      };\n      this.animationSettings = {\n        closeAnimation: useAnimation(fadeOut, {\n          params: {\n            duration: \"0ms\"\n          }\n        }),\n        openAnimation: useAnimation(fadeIn, {\n          params: {\n            duration: \"0ms\"\n          }\n        })\n      };\n      /** @hidden @internal */\n\n      this.aggregateList = [];\n      /**\n       * @hidden @internal\n       */\n\n      this._panels = [{\n        name: \"Filters\",\n        i18n: 'igx_grid_pivot_selector_filters',\n        type: PivotDimensionType.Filter,\n        dataKey: \"filterDimensions\",\n        icon: \"filter_list\",\n        itemKey: \"memberName\",\n        sortable: false,\n        dragChannels: [\"Filters\", \"Columns\", \"Rows\"]\n      }, {\n        name: \"Columns\",\n        i18n: 'igx_grid_pivot_selector_columns',\n        type: PivotDimensionType.Column,\n        dataKey: \"columnDimensions\",\n        icon: \"view_column\",\n        itemKey: \"memberName\",\n        sortable: true,\n        dragChannels: [\"Filters\", \"Columns\", \"Rows\"]\n      }, {\n        name: \"Rows\",\n        i18n: 'igx_grid_pivot_selector_rows',\n        type: PivotDimensionType.Row,\n        dataKey: \"rowDimensions\",\n        icon: \"table_rows\",\n        itemKey: \"memberName\",\n        sortable: true,\n        dragChannels: [\"Filters\", \"Columns\", \"Rows\"]\n      }, {\n        name: \"Values\",\n        i18n: 'igx_grid_pivot_selector_values',\n        type: null,\n        dataKey: \"values\",\n        icon: \"functions\",\n        itemKey: \"member\",\n        displayKey: 'displayName',\n        sortable: false,\n        dragChannels: [\"Values\"]\n      }];\n    }\n    /** @hidden @internal */\n\n\n    get dims() {\n      return this._grid.allDimensions;\n    }\n\n    /** @hidden @internal */\n    get values() {\n      return this._grid.pivotConfiguration.values;\n    }\n\n    /**\n     * @hidden @internal\n     */\n    get displayDensity() {\n      var _a;\n\n      return (_a = this.grid) === null || _a === void 0 ? void 0 : _a.displayDensity;\n    }\n    /**\n     * An @Input property that sets the grid.\n     */\n\n\n    set grid(value) {\n      this._grid = value;\n    }\n    /**\n     * Returns the grid.\n     */\n\n\n    get grid() {\n      return this._grid;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onItemSort(_, dimension, dimensionType) {\n      if (!this._panels.find(panel => panel.type === dimensionType).sortable) return;\n      const startDirection = dimension.sortDirection || SortingDirection.None;\n      const direction = startDirection + 1 > SortingDirection.Desc ? SortingDirection.None : startDirection + 1;\n      this.grid.sortDimension(dimension, direction);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onFilteringIconPointerDown(event) {\n      event.stopPropagation();\n      event.preventDefault();\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onFilteringIconClick(event, dimension) {\n      event.stopPropagation();\n      event.preventDefault();\n      let dim = dimension;\n      let col;\n\n      while (dim) {\n        col = this.grid.dimensionDataColumns.find(x => x.field === dim.memberName);\n\n        if (col) {\n          break;\n        } else {\n          dim = dim.childLevel;\n        }\n      }\n\n      this.grid.filteringService.toggleFilterDropdown(event.target, col);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    getDimensionState(dimensionType) {\n      switch (dimensionType) {\n        case PivotDimensionType.Row:\n          return this.grid.rowDimensions;\n\n        case PivotDimensionType.Column:\n          return this.grid.columnDimensions;\n\n        case PivotDimensionType.Filter:\n          return this.grid.filterDimensions;\n\n        default:\n          return null;\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    moveValueItem(itemId) {\n      const aggregation = this.grid.pivotConfiguration.values;\n      const valueIndex = aggregation.findIndex(x => x.member === itemId) !== -1 ? aggregation === null || aggregation === void 0 ? void 0 : aggregation.findIndex(x => x.member === itemId) : aggregation.length;\n      const newValueIndex = valueIndex + this._dropDelta < 0 ? 0 : valueIndex + this._dropDelta;\n      const aggregationItem = aggregation.find(x => x.member === itemId || x.displayName === itemId);\n\n      if (aggregationItem) {\n        this.grid.moveValue(aggregationItem, newValueIndex);\n        this.grid.valuesChange.emit({\n          values: this.grid.pivotConfiguration.values\n        });\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onItemDropped(event, dimensionType) {\n      if (!this.dropAllowed) {\n        return;\n      }\n\n      const dimension = this.grid.getDimensionsByType(dimensionType);\n      const dimensionState = this.getDimensionState(dimensionType);\n      const itemId = event.drag.element.nativeElement.id;\n      const targetId = event.owner.element.nativeElement.id;\n      const dimensionItem = dimension === null || dimension === void 0 ? void 0 : dimension.find(x => x.memberName === itemId);\n      const itemIndex = (dimension === null || dimension === void 0 ? void 0 : dimension.findIndex(x => (x === null || x === void 0 ? void 0 : x.memberName) === itemId)) !== -1 ? dimension === null || dimension === void 0 ? void 0 : dimension.findIndex(x => x.memberName === itemId) : dimension === null || dimension === void 0 ? void 0 : dimension.length;\n      const dimensions = this.grid.allDimensions.filter(x => x && x.memberName === itemId);\n      const reorder = (dimensionState === null || dimensionState === void 0 ? void 0 : dimensionState.findIndex(item => item.memberName === itemId)) !== -1;\n      let targetIndex = targetId !== \"\" ? dimension === null || dimension === void 0 ? void 0 : dimension.findIndex(x => x.memberName === targetId) : dimension === null || dimension === void 0 ? void 0 : dimension.length;\n\n      if (!dimension) {\n        this.moveValueItem(itemId);\n      }\n\n      if (reorder) {\n        targetIndex = itemIndex + this._dropDelta < 0 ? 0 : itemIndex + this._dropDelta;\n      }\n\n      if (dimensionItem) {\n        this.grid.moveDimension(dimensionItem, dimensionType, targetIndex);\n      } else {\n        const newDim = dimensions.find(x => x.memberName === itemId);\n        this.grid.moveDimension(newDim, dimensionType, targetIndex);\n      }\n\n      this.grid.dimensionsChange.emit({\n        dimensions: dimension,\n        dimensionCollectionType: dimensionType\n      });\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    updateDropDown(value, dropdown) {\n      this.value = value;\n      dropdown.width = \"200px\";\n      this.aggregateList = PivotUtil.getAggregateList(value, this.grid);\n      this.cdr.detectChanges();\n      dropdown.open(this._subMenuOverlaySettings);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onSummaryClick(event, value, dropdown) {\n      this._subMenuOverlaySettings.target = event.currentTarget;\n\n      if (dropdown.collapsed) {\n        this.updateDropDown(value, dropdown);\n      } else {\n        // close for previous chip\n        dropdown.close();\n        dropdown.closed.pipe(first$1()).subscribe(() => {\n          this.updateDropDown(value, dropdown);\n        });\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onAggregationChange(event) {\n      if (!this.isSelected(event.newSelection.value)) {\n        this.value.aggregate = event.newSelection.value;\n        this.grid.pipeTrigger++;\n        this.grid.cdr.markForCheck();\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    isSelected(val) {\n      return this.value.aggregate.key === val.key;\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    ghostCreated(event, value) {\n      const {\n        width: itemWidth\n      } = event.owner.element.nativeElement.getBoundingClientRect();\n      this.ghostWidth = itemWidth;\n      this.ghostText = value;\n      this.renderer.setStyle(event.owner.element.nativeElement, \"position\", \"absolute\");\n      this.renderer.setStyle(event.owner.element.nativeElement, \"visibility\", \"hidden\");\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    toggleItem(item) {\n      if (item) {\n        this.grid.toggleValue(item);\n      }\n\n      if (item) {\n        this.grid.toggleDimension(item);\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onPanelEntry(event, panel) {\n      var _a;\n\n      this.dropAllowed = event.dragData.gridID === this.grid.id && ((_a = event.dragData.selectorChannels) === null || _a === void 0 ? void 0 : _a.some(channel => channel === panel));\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onItemDragMove(event) {\n      const clientRect = event.owner.element.nativeElement.getBoundingClientRect();\n      this._dropDelta = Math.round((event.nextPageY - event.startY) / clientRect.height);\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onItemDragEnd(event) {\n      this.renderer.setStyle(event.owner.element.nativeElement, \"position\", \"static\");\n      this.renderer.setStyle(event.owner.element.nativeElement, \"visibility\", \"visible\");\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onItemDragOver(event) {\n      if (this.dropAllowed) {\n        this.renderer.addClass(event.owner.element.nativeElement, \"igx-drag--push\");\n      }\n    }\n    /**\n     * @hidden\n     * @internal\n     */\n\n\n    onItemDragLeave(event) {\n      if (this.dropAllowed) {\n        this.renderer.removeClass(event.owner.element.nativeElement, \"igx-drag--push\");\n      }\n    }\n\n    getPanelCollapsed(panelType) {\n      switch (panelType) {\n        case PivotDimensionType.Column:\n          return !this.columnsExpanded;\n\n        case PivotDimensionType.Filter:\n          return !this.filtersExpanded;\n\n        case PivotDimensionType.Row:\n          return !this.rowsExpanded;\n\n        default:\n          return !this.valuesExpanded;\n      }\n    }\n\n    onCollapseChange(value, panelType) {\n      switch (panelType) {\n        case PivotDimensionType.Column:\n          this.columnsExpanded = !value;\n          this.columnsExpandedChange.emit(this.columnsExpanded);\n          break;\n\n        case PivotDimensionType.Filter:\n          this.filtersExpanded = !value;\n          this.filtersExpandedChange.emit(this.filtersExpanded);\n          break;\n\n        case PivotDimensionType.Row:\n          this.rowsExpanded = !value;\n          this.rowsExpandedChange.emit(this.rowsExpanded);\n          break;\n\n        default:\n          this.valuesExpanded = !value;\n          this.valuesExpandedChange.emit(this.valuesExpanded);\n      }\n    }\n\n  }\n\n  IgxPivotDataSelectorComponent.ɵfac = function IgxPivotDataSelectorComponent_Factory(t) {\n    return new (t || IgxPivotDataSelectorComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  IgxPivotDataSelectorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: IgxPivotDataSelectorComponent,\n    selectors: [[\"igx-pivot-data-selector\"]],\n    hostVars: 2,\n    hostBindings: function IgxPivotDataSelectorComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"igx-pivot-data-selector\", ctx.cssClass);\n      }\n    },\n    inputs: {\n      columnsExpanded: \"columnsExpanded\",\n      rowsExpanded: \"rowsExpanded\",\n      filtersExpanded: \"filtersExpanded\",\n      valuesExpanded: \"valuesExpanded\",\n      grid: \"grid\"\n    },\n    outputs: {\n      columnsExpandedChange: \"columnsExpandedChange\",\n      rowsExpandedChange: \"rowsExpandedChange\",\n      filtersExpandedChange: \"filtersExpandedChange\",\n      valuesExpandedChange: \"valuesExpandedChange\"\n    },\n    decls: 18,\n    vars: 14,\n    consts: [[1, \"igx-pivot-data-selector__filter\"], [\"type\", \"box\", 3, \"displayDensity\"], [\"igxPrefix\", \"\"], [\"igxInput\", \"\", \"tabindex\", \"0\", \"placeholder\", \"Search\", \"autocomplete\", \"off\"], [\"input\", \"\"], [3, \"displayDensity\"], [3, \"id\", 4, \"ngFor\", \"ngForOf\"], [3, \"animationSettings\", \"collapsed\", \"collapsedChange\", 4, \"ngFor\", \"ngForOf\"], [3, \"selectionChanging\"], [\"dropdown\", \"\"], [3, \"selected\", \"value\", 4, \"ngFor\", \"ngForOf\"], [\"itemGhost\", \"\"], [3, \"id\"], [3, \"aria-labelledby\", \"disableRipple\", \"checked\", \"click\"], [3, \"animationSettings\", \"collapsed\", \"collapsedChange\"], [\"iconPosition\", \"left\", \"igxDrop\", \"\", 3, \"disabled\", \"enter\", \"dropped\"], [1, \"igx-pivot-data-selector__header\"], [1, \"igx-pivot-data-selector__header-title\"], [1, \"igx-pivot-data-selector__header-extra\"], [\"igxDrop\", \"\", 3, \"enter\", \"dropped\"], [3, \"displayDensity\", 4, \"ngIf\"], [\"class\", \"igx-pivot-data-selector__empty\", 4, \"ngIf\"], [\"igxDrop\", \"\", 3, \"igxDrag\", \"ghostTemplate\", \"id\", \"ghostCreate\", \"over\", \"leave\", \"dragMove\", \"dragEnd\", \"dropped\", 4, \"ngFor\", \"ngForOf\"], [\"igxDrop\", \"\", 3, \"igxDrag\", \"ghostTemplate\", \"id\", \"ghostCreate\", \"over\", \"leave\", \"dragMove\", \"dragEnd\", \"dropped\"], [1, \"igx-pivot-data-selector__item\"], [1, \"igx-pivot-data-selector__item-start\", 3, \"click\"], [1, \"igx-pivot-data-selector__item-text\"], [4, \"ngIf\"], [\"class\", \"igx-pivot-data-selector__action-sort\", 4, \"ngIf\"], [1, \"igx-pivot-data-selector__item-end\"], [\"class\", \"igx-pivot-data-selector__action-filter\", 3, \"pointerdown\", \"click\", 4, \"ngIf\"], [\"class\", \"igx-pivot-data-selector__action-summary\", 3, \"igxDropDownItemNavigation\", \"click\", 4, \"ngIf\"], [\"igxDragHandle\", \"\", \"class\", \"igx-pivot-data-selector__action-move\", 4, \"ngIf\"], [1, \"igx-pivot-data-selector__action-sort\"], [1, \"igx-pivot-data-selector__action-filter\", 3, \"pointerdown\", \"click\"], [1, \"igx-pivot-data-selector__action-summary\", 3, \"igxDropDownItemNavigation\", \"click\"], [\"igxDragHandle\", \"\", 1, \"igx-pivot-data-selector__action-move\"], [1, \"igx-pivot-data-selector__empty\"], [3, \"selected\", \"value\"], [1, \"igx-pivot-data-selector__item-ghost\"], [1, \"igx-pivot-data-selector__item-ghost-text\"]],\n    template: function IgxPivotDataSelectorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"igx-input-group\", 1)(2, \"igx-icon\", 2);\n        i0.ɵɵtext(3, \"search\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(4, \"input\", 3, 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(6, \"igx-list\", 5);\n        i0.ɵɵtemplate(7, IgxPivotDataSelectorComponent_igx_list_item_7_Template, 4, 5, \"igx-list-item\", 6);\n        i0.ɵɵpipe(8, \"filterPivotItems\");\n        i0.ɵɵtemplate(9, IgxPivotDataSelectorComponent_igx_list_item_9_Template, 4, 5, \"igx-list-item\", 6);\n        i0.ɵɵpipe(10, \"filterPivotItems\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(11, \"igx-accordion\");\n        i0.ɵɵtemplate(12, IgxPivotDataSelectorComponent_igx_expansion_panel_12_Template, 13, 8, \"igx-expansion-panel\", 7);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(13, \"igx-drop-down\", 8, 9);\n        i0.ɵɵlistener(\"selectionChanging\", function IgxPivotDataSelectorComponent_Template_igx_drop_down_selectionChanging_13_listener($event) {\n          return ctx.onAggregationChange($event);\n        });\n        i0.ɵɵtemplate(15, IgxPivotDataSelectorComponent_igx_drop_down_item_15_Template, 2, 3, \"igx-drop-down-item\", 10);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(16, IgxPivotDataSelectorComponent_ng_template_16_Template, 8, 5, \"ng-template\", null, 11, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        const _r0 = i0.ɵɵreference(5);\n\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"displayDensity\", ctx.displayDensity);\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"displayDensity\", ctx.displayDensity);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBind3(8, 6, ctx.dims, _r0.value, ctx.grid.pipeTrigger));\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBind3(10, 10, ctx.values, _r0.value, ctx.grid.pipeTrigger));\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngForOf\", ctx._panels);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngForOf\", ctx.aggregateList);\n      }\n    },\n    directives: [IgxInputGroupComponent, IgxIconComponent, IgxListComponent, IgxListItemComponent, IgxCheckboxComponent, IgxAccordionComponent, IgxExpansionPanelComponent, IgxExpansionPanelHeaderComponent, IgxChipComponent, IgxExpansionPanelBodyComponent, IgxDropDownComponent, IgxDropDownItemComponent, IgxPrefixDirective, IgxInputDirective, i4.NgForOf, IgxDropDirective, IgxExpansionPanelTitleDirective, i4.NgIf, IgxDragDirective, IgxDropDownItemNavigationDirective, IgxDragHandleDirective],\n    pipes: [IgxFilterPivotItemsPipe],\n    encapsulation: 2\n  });\n  return IgxPivotDataSelectorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @hidden\n */\n\n\nlet IgxPivotGridModule = /*#__PURE__*/(() => {\n  class IgxPivotGridModule {}\n\n  IgxPivotGridModule.ɵfac = function IgxPivotGridModule_Factory(t) {\n    return new (t || IgxPivotGridModule)();\n  };\n\n  IgxPivotGridModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgxPivotGridModule\n  });\n  IgxPivotGridModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[IgxGridModule, IgxExpansionPanelModule, IgxDragDropModule, IgxListModule, IgxAccordionModule], IgxGridModule]\n  });\n  return IgxPivotGridModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of igniteui-angular\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AbsolutePosition, AbsoluteScrollStrategy, AutoPositionStrategy, BaseFilteringStrategy, BaseProgressDirective, BlockScrollStrategy, ButtonGroupAlignment, Calendar, CalendarHammerConfig, CalendarSelection, CalendarView, CarouselHammerConfig, CarouselIndicatorsOrientation, CloseScrollStrategy, ColumnDisplayOrder, ColumnPinningPosition, ConnectedPositioningStrategy, ContainerPositionStrategy, CsvFileTypes, DEFAULT_OWNER, DEFAULT_PIVOT_KEYS, DataUtil, DatePart, DateRangePickerFormatPipe, DateRangeType, DefaultDataCloneStrategy, DefaultPivotGridRecordSortingStrategy, DefaultPivotSortingStrategy, DefaultSortingStrategy, DimensionValuesFilteringStrategy, Direction, DisplayDensity, DisplayDensityBase, DisplayDensityToken, DragDirection, ElasticPositionStrategy, ExpansionPanelHeaderIconPosition, ExportRecordType, FilterMode, FilterUtil, FilteringExpressionsTree, FilteringExpressionsTreeType, FilteringLogic, FilteringStrategy, FormattedValuesFilteringStrategy, GlobalPositionStrategy, GridBaseAPIService, GridColumnDataType, GridInstanceType, GridPagingMode, GridSelectionMode, GridSummaryCalculationMode, GridSummaryPosition, GroupedRecords, HeaderType, HorizontalAlignment, HorizontalAnimationType, IGX_CHECKBOX_REQUIRED_VALIDATOR, IGX_GRID_BASE, IGX_INPUT_GROUP_TYPE, IGX_STEPPER_COMPONENT, IGX_STEP_COMPONENT, IGX_SWITCH_REQUIRED_VALIDATOR, ITreeGridAggregation, IgxAccordionComponent, IgxAccordionModule, IgxActionStripComponent, IgxActionStripMenuItemDirective, IgxActionStripModule, IgxAdvancedFilteringDialogComponent, IgxAppendDropStrategy, IgxAutocompleteDirective, IgxAutocompleteModule, IgxAvatarComponent, IgxAvatarModule, IgxAvatarSize, IgxAvatarType, IgxBadgeComponent, IgxBadgeModule, IgxBadgeType, IgxBannerActionsDirective, IgxBannerComponent, IgxBannerModule, IgxBaseExporter, IgxBaseTransactionService, IgxBooleanFilteringOperand, IgxBottomNavComponent, IgxBottomNavContentComponent, IgxBottomNavHeaderComponent, IgxBottomNavHeaderIconDirective, IgxBottomNavHeaderLabelDirective, IgxBottomNavItemComponent, IgxBottomNavModule, IgxButtonDirective, IgxButtonGroupComponent, IgxButtonGroupModule, IgxButtonModule, IgxCSVTextDirective, IgxCalendarBaseDirective, IgxCalendarComponent, IgxCalendarHeaderTemplateDirective, IgxCalendarModule, IgxCalendarMonthDirective, IgxCalendarScrollMonthDirective, IgxCalendarSubheaderTemplateDirective, IgxCalendarView, IgxCalendarYearDirective, IgxCardActionsComponent, IgxCardActionsLayout, IgxCardComponent, IgxCardContentDirective, IgxCardFooterDirective, IgxCardHeaderComponent, IgxCardHeaderSubtitleDirective, IgxCardHeaderTitleDirective, IgxCardMediaDirective, IgxCardModule, IgxCardThumbnailDirective, IgxCardType, IgxCarouselComponent, IgxCarouselComponentBase, IgxCarouselIndicatorDirective, IgxCarouselModule, IgxCarouselNextButtonDirective, IgxCarouselPrevButtonDirective, IgxCellEditorTemplateDirective, IgxCellFooterTemplateDirective, IgxCellHeaderTemplateDirective, IgxCellTemplateDirective, IgxCheckboxComponent, IgxCheckboxModule, IgxCheckboxRequiredDirective, IgxChildGridRowComponent, IgxChipComponent, IgxChipsAreaComponent, IgxChipsModule, IgxCircularProgressBarComponent, IgxCollapsibleIndicatorTemplateDirective, IgxColumnActionEnabledPipe, IgxColumnActionsBaseDirective, IgxColumnActionsComponent, IgxColumnActionsModule, IgxColumnComponent, IgxColumnFormatterPipe, IgxColumnGroupComponent, IgxColumnHidingDirective, IgxColumnLayoutComponent, IgxColumnMovingDragDirective, IgxColumnMovingDropDirective, IgxColumnMovingModule, IgxColumnPinningDirective, IgxColumnResizerDirective, IgxComboAddItemComponent, IgxComboAddItemDirective, IgxComboCleanPipe, IgxComboClearIconDirective, IgxComboComponent, IgxComboDropDownComponent, IgxComboEmptyDirective, IgxComboFilteringPipe, IgxComboFooterDirective, IgxComboGroupingPipe, IgxComboHeaderDirective, IgxComboHeaderItemDirective, IgxComboItemComponent, IgxComboItemDirective, IgxComboModule, IgxComboToggleIconDirective, IgxCsvExporterOptions, IgxCsvExporterService, IgxDataLoadingTemplateDirective, IgxDataRecordSorting, IgxDateFilteringOperand, IgxDatePickerComponent, IgxDatePickerModule, IgxDateRangeEndComponent, IgxDateRangeInputsBaseComponent, IgxDateRangePickerComponent, IgxDateRangePickerModule, IgxDateRangeSeparatorDirective, IgxDateRangeStartComponent, IgxDateSummaryOperand, IgxDateTimeEditorDirective, IgxDateTimeEditorModule, IgxDateTimeFilteringOperand, IgxDaysViewComponent, IgxDefaultDropStrategy, IgxDialogActionsDirective, IgxDialogComponent, IgxDialogModule, IgxDialogTitleDirective, IgxDisplayDensityModule, IgxDividerDirective, IgxDividerModule, IgxDividerType, IgxDragDirective, IgxDragDropModule, IgxDragHandleDirective, IgxDragIgnoreDirective, IgxDragIndicatorIconDirective, IgxDragLocation, IgxDropDirective, IgxDropDownBaseDirective, IgxDropDownComponent, IgxDropDownGroupComponent, IgxDropDownItemBaseDirective, IgxDropDownItemComponent, IgxDropDownItemNavigationDirective, IgxDropDownModule, IgxEmptyListTemplateDirective, IgxExcelExporterOptions, IgxExcelExporterService, IgxExcelStyleClearFiltersComponent, IgxExcelStyleColumnOperationsTemplateDirective, IgxExcelStyleConditionalFilterComponent, IgxExcelStyleDateExpressionComponent, IgxExcelStyleFilterOperationsTemplateDirective, IgxExcelStyleHeaderComponent, IgxExcelStyleHeaderIconDirective, IgxExcelStyleHidingComponent, IgxExcelStyleLoadingValuesTemplateDirective, IgxExcelStyleMovingComponent, IgxExcelStylePinningComponent, IgxExcelStyleSearchComponent, IgxExcelStyleSelectingComponent, IgxExcelStyleSortingComponent, IgxExcelTextDirective, IgxExpansionPanelBodyComponent, IgxExpansionPanelComponent, IgxExpansionPanelDescriptionDirective, IgxExpansionPanelHeaderComponent, IgxExpansionPanelIconDirective, IgxExpansionPanelModule, IgxExpansionPanelTitleDirective, IgxExporterOptionsBase, IgxFilterActionColumnsPipe, IgxFilterCellTemplateDirective, IgxFilterDirective, IgxFilterModule, IgxFilterOptions, IgxFilterPipe, IgxFilterPivotItemsPipe, IgxFilteringOperand, IgxFlatTransactionFactory, IgxFlexDirective, IgxFocusDirective, IgxFocusModule, IgxFocusTrapDirective, IgxFocusTrapModule, IgxForOfContext, IgxForOfDirective, IgxForOfModule, IgxGridAPIService, IgxGridActionButtonComponent, IgxGridActionsBaseDirective, IgxGridAddRowPipe, IgxGridBaseDirective, IgxGridBodyDirective, IgxGridCell, IgxGridCellStyleClassesPipe, IgxGridCellStylesPipe, IgxGridColumnModule, IgxGridColumnResizerComponent, IgxGridCommonModule, IgxGridComponent, IgxGridDataMapperPipe, IgxGridDetailTemplateDirective, IgxGridDetailsPipe, IgxGridDragSelectDirective, IgxGridEditingActionsComponent, IgxGridExcelStyleFilteringComponent, IgxGridExcelStyleFilteringModule, IgxGridExpandableCellComponent, IgxGridFilterConditionPipe, IgxGridFilteringModule, IgxGridFilteringPipe, IgxGridFooterComponent, IgxGridForOfDirective, IgxGridGroupByAreaComponent, IgxGridGroupByRowComponent, IgxGridGroupingPipe, IgxGridHeaderComponent, IgxGridHeaderGroupComponent, IgxGridHeaderRowComponent, IgxGridHeadersModule, IgxGridHierarchicalPagingPipe, IgxGridHierarchicalPipe, IgxGridModule, IgxGridNotGroupedPipe, IgxGridPaginatorOptionsPipe, IgxGridPagingPipe, IgxGridPinningActionsComponent, IgxGridPipesModule, IgxGridResizingModule, IgxGridRow, IgxGridRowClassesPipe, IgxGridRowPinningPipe, IgxGridRowStylesPipe, IgxGridSelectionModule, IgxGridSharedModules, IgxGridSortingPipe, IgxGridStateDirective, IgxGridStateModule, IgxGridSummaryModule, IgxGridSummaryPipe, IgxGridToolbarActionsDirective, IgxGridToolbarAdvancedFilteringComponent, IgxGridToolbarComponent, IgxGridToolbarDirective, IgxGridToolbarExporterComponent, IgxGridToolbarHidingComponent, IgxGridToolbarModule, IgxGridToolbarPinningComponent, IgxGridToolbarTitleDirective, IgxGridTopLevelColumns, IgxGridTransactionPipe, IgxGridTransactionStatePipe, IgxGroupAreaDropDirective, IgxGroupByAreaDirective, IgxGroupByMetaPipe, IgxGroupByRow, IgxGroupByRowSelectorDirective, IgxGroupByRowTemplateDirective, IgxGroupedTreeGridSorting, IgxGrouping, IgxHasVisibleColumnsPipe, IgxHeadSelectorDirective, IgxHeaderCollapseIndicatorDirective, IgxHeaderExpandIndicatorDirective, IgxHeaderGroupStylePipe, IgxHeaderGroupWidthPipe, IgxHierarchicalGridAPIService, IgxHierarchicalGridBaseDirective, IgxHierarchicalGridComponent, IgxHierarchicalGridModule, IgxHierarchicalGridRow, IgxHierarchicalRowComponent, IgxHierarchicalTransactionFactory, IgxHierarchicalTransactionService, IgxHierarchicalTransactionServiceFactory, IgxHintDirective, IgxIconComponent, IgxIconModule, IgxIconService, IgxInputDirective, IgxInputGroupComponent, IgxInputGroupModule, IgxInputState, IgxInsertDropStrategy, IgxItemListDirective, IgxLabelDirective, IgxLayoutDirective, IgxLayoutModule, IgxLinearProgressBarComponent, IgxListActionDirective, IgxListBaseDirective, IgxListComponent, IgxListItemComponent, IgxListItemLeftPanningTemplateDirective, IgxListItemRightPanningTemplateDirective, IgxListLineDirective, IgxListLineSubTitleDirective, IgxListLineTitleDirective, IgxListModule, IgxListPanState, IgxListThumbnailDirective, IgxMaskDirective, IgxMaskModule, IgxMonthPickerBaseDirective, IgxMonthPickerComponent, IgxMonthsViewComponent, IgxNavDrawerItemDirective, IgxNavDrawerMiniTemplateDirective, IgxNavDrawerTemplateDirective, IgxNavbarActionDirective, IgxNavbarComponent, IgxNavbarModule, IgxNavbarTitleDirective, IgxNavigationCloseDirective, IgxNavigationDrawerComponent, IgxNavigationDrawerModule, IgxNavigationModule, IgxNavigationService, IgxNavigationToggleDirective, IgxNumberFilteringOperand, IgxNumberSummaryOperand, IgxOverlayOutletDirective, IgxOverlayService, IgxPageNavigationComponent, IgxPageSizeSelectorComponent, IgxPaginatorComponent, IgxPaginatorDirective, IgxPaginatorModule, IgxPaginatorTemplateDirective, IgxPickerActionsDirective, IgxPickerClearComponent, IgxPickerToggleComponent, IgxPickersCommonModule, IgxPivotAggregate, IgxPivotAutoTransform, IgxPivotCellMergingPipe, IgxPivotColumnPipe, IgxPivotDataSelectorComponent, IgxPivotDateAggregate, IgxPivotDateDimension, IgxPivotGridColumnResizerComponent, IgxPivotGridColumnSortingPipe, IgxPivotGridComponent, IgxPivotGridFilterPipe, IgxPivotGridModule, IgxPivotGridSortingPipe, IgxPivotHeaderRowComponent, IgxPivotNumericAggregate, IgxPivotResizeHandleDirective, IgxPivotRowComponent, IgxPivotRowDimensionContentComponent, IgxPivotRowDimensionHeaderComponent, IgxPivotRowDimensionHeaderGroupComponent, IgxPivotRowExpansionPipe, IgxPivotRowPipe, IgxPivotTimeAggregate, IgxPrefixDirective, IgxPrefixModule, IgxPrependDropStrategy, IgxProcessBarTextTemplateDirective, IgxProgressBarGradientDirective, IgxProgressBarModule, IgxProgressType, IgxRadioComponent, IgxRadioGroupDirective, IgxRadioModule, IgxResizeHandleDirective, IgxRippleDirective, IgxRippleModule, IgxRowAddTextDirective, IgxRowCollapsedIndicatorDirective, IgxRowDragDirective, IgxRowDragGhostDirective, IgxRowDragModule, IgxRowEditActionsDirective, IgxRowEditTabStopDirective, IgxRowEditTemplateDirective, IgxRowEditTextDirective, IgxRowExpandedIndicatorDirective, IgxRowIslandAPIService, IgxRowIslandComponent, IgxRowLoadingIndicatorTemplateDirective, IgxRowSelectorDirective, IgxSelectComponent, IgxSelectFooterDirective, IgxSelectGroupComponent, IgxSelectHeaderDirective, IgxSelectItemComponent, IgxSelectItemNavigationDirective, IgxSelectModule, IgxSelectToggleIconDirective, IgxSimpleComboComponent, IgxSimpleComboModule, IgxSlideComponent, IgxSliderComponent, IgxSliderModule, IgxSliderType, IgxSnackbarComponent, IgxSnackbarModule, IgxSortActionColumnsPipe, IgxSortAscendingHeaderIconDirective, IgxSortDescendingHeaderIconDirective, IgxSortHeaderIconDirective, IgxSorting, IgxSplitBarComponent, IgxSplitterComponent, IgxSplitterModule, IgxSplitterPaneComponent, IgxStepActiveIndicatorDirective, IgxStepCompletedIndicatorDirective, IgxStepComponent, IgxStepContentDirective, IgxStepIndicatorDirective, IgxStepInvalidIndicatorDirective, IgxStepSubTitleDirective, IgxStepTitleDirective, IgxStepType, IgxStepperComponent, IgxStepperModule, IgxStepperOrientation, IgxStepperTitlePosition, IgxStringFilteringOperand, IgxStringReplacePipe, IgxSuffixDirective, IgxSuffixModule, IgxSummaryCellComponent, IgxSummaryDataPipe, IgxSummaryFormatterPipe, IgxSummaryOperand, IgxSummaryRow, IgxSummaryRowComponent, IgxSummaryTemplateDirective, IgxSwitchComponent, IgxSwitchModule, IgxSwitchRequiredDirective, IgxTabContentComponent, IgxTabContentDirective, IgxTabHeaderComponent, IgxTabHeaderDirective, IgxTabHeaderIconDirective, IgxTabHeaderLabelDirective, IgxTabItemComponent, IgxTabItemDirective, IgxTabsAlignment, IgxTabsComponent, IgxTabsDirective, IgxTabsModule, IgxTemplateOutletDirective, IgxTemplateOutletModule, IgxTextAlign, IgxTextHighlightDirective, IgxTextHighlightModule, IgxTextSelectionDirective, IgxTextSelectionModule, IgxThumbFromTemplateDirective, IgxThumbToTemplateDirective, IgxTickLabelTemplateDirective, IgxTimeFilteringOperand, IgxTimeItemDirective, IgxTimePickerActionsDirective, IgxTimePickerComponent, IgxTimePickerModule, IgxTimePickerTemplateDirective, IgxTimeSummaryOperand, IgxToastComponent, IgxToastModule, IgxToggleActionDirective, IgxToggleDirective, IgxToggleModule, IgxTooltipDirective, IgxTooltipModule, IgxTooltipTargetDirective, IgxTransactionService, IgxTreeComponent, IgxTreeExpandIndicatorDirective, IgxTreeGridAPIService, IgxTreeGridAddRowPipe, IgxTreeGridComponent, IgxTreeGridGroupByAreaComponent, IgxTreeGridGroupingPipe, IgxTreeGridModule, IgxTreeGridRow, IgxTreeModule, IgxTreeNodeComponent, IgxTreeNodeLinkDirective, IgxTreeSelectMarkerDirective, IgxTreeSelectionType, IgxYearsViewComponent, LabelPosition, NoOpScrollStrategy, NoopFilteringStrategy, NoopPivotDimensionsStrategy, NoopSortingStrategy, PagingError, PickerInteractionMode, PivotColumnDimensionsStrategy, PivotDimensionType, PivotRowDimensionsStrategy, Point, RadioGroupAlignment, RadioLabelPosition, RelativePosition, RelativePositionStrategy, RowEditPositionStrategy, RowPinningPosition, SPLITTER_INTERACTION_KEYS, ScrollMonth, ScrollStrategy, SliderHandle, SortingDirection, SortingIndexPipe, SplitterType, SwitchLabelPosition, TickLabelsOrientation, TicksOrientation, TransactionEventOrigin, TransactionType, TreeGridFilteringStrategy, TreeGridFormattedValuesFilteringStrategy, TreeGridMatchingRecordsOnlyFilteringStrategy, VerticalAlignment, VerticalAnimationType, WEEKDAYS, blink, changei18n, fadeIn, fadeOut, filteringStateDefaults, flipBottom, flipHorBck, flipHorFwd, flipLeft, flipRight, flipTop, flipVerBck, flipVerFwd, getCurrentResourceStrings, getTypeNameForDebugging, growVerIn, growVerOut, heartbeat, hierarchicalTransactionServiceFactory, isDateInRanges, isLeap, monthRange, pulsateBck, pulsateFwd, range, rotateInBl, rotateInBottom, rotateInBr, rotateInCenter, rotateInDiagonal1, rotateInDiagonal2, rotateInHor, rotateInLeft, rotateInRight, rotateInTl, rotateInTop, rotateInTr, rotateInVer, rotateOutBl, rotateOutBottom, rotateOutBr, rotateOutCenter, rotateOutDiagonal1, rotateOutDiagonal2, rotateOutHor, rotateOutLeft, rotateOutRight, rotateOutTl, rotateOutTop, rotateOutTr, rotateOutVer, scaleInBl, scaleInBottom, scaleInBr, scaleInCenter, scaleInHorCenter, scaleInHorLeft, scaleInHorRight, scaleInLeft, scaleInRight, scaleInTl, scaleInTop, scaleInTr, scaleInVerBottom, scaleInVerCenter, scaleInVerTop, scaleOutBl, scaleOutBottom, scaleOutBr, scaleOutCenter, scaleOutHorCenter, scaleOutHorLeft, scaleOutHorRight, scaleOutLeft, scaleOutRight, scaleOutTl, scaleOutTop, scaleOutTr, scaleOutVerBottom, scaleOutVerCenter, scaleOutVerTop, shakeBl, shakeBottom, shakeBr, shakeCenter, shakeHor, shakeLeft, shakeRight, shakeTl, shakeTop, shakeTr, shakeVer, slideInBl, slideInBottom, slideInBr, slideInLeft, slideInRight, slideInTl, slideInTop, slideInTr, slideOutBl, slideOutBottom, slideOutBr, slideOutLeft, slideOutRight, slideOutTl, slideOutTop, slideOutTr, swingInBottomBck, swingInBottomFwd, swingInLeftBck, swingInLeftFwd, swingInRightBck, swingInRightFwd, swingInTopBck, swingInTopFwd, swingOutBottomBck, swingOutBottomFwd, swingOutLeftBck, swingOutLefttFwd, swingOutRightBck, swingOutRightFwd, swingOutTopBck, swingOutTopFwd, toPercent, toValue, valueInRange, weekDay, IgxGridFilteringCellComponent as θIgxGridFilteringCellComponent, IgxGridFilteringRowComponent as θIgxGridFilteringRowComponent, IgxHierarchicalGridCellComponent as θIgxHierarchicalGridCellComponent, IgxTreeGridCellComponent as θIgxTreeGridCellComponent, IgxTreeGridRowComponent as θIgxTreeGridRowComponent, IgxGridCellComponent as ϴIgxGridCellComponent, IgxGridRowComponent as ϴIgxGridRowComponent }; //# sourceMappingURL=igniteui-angular.mjs.map","map":null,"metadata":{},"sourceType":"module"}